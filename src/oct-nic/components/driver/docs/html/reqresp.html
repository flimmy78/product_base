<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Octeon PCI Driver: Request processing using the OCTEON PCI driver</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1><a class="anchor" name="reqresp">Request processing using the OCTEON PCI driver</a></h1>This section describes the steps involved in sending a request to OCTEON.<p>
<br>
 <br>
 <h2><a class="anchor" name="rr-sec1">
OCTEON Input queue initialization.</a></h2>
The OCTEON PCI host driver (provided as a linux kernel module in the OCTEON-PCI-BASE package) is responsible for the initialization of all OCTEON devices in the system.<p>
During initialization, the driver would allocate memory for the instruction queue used for OCTEON PCI input. For each instruction queue (also referred to as input queues), the driver allocates a contiguous memory in host memory that can accomodate a fixed number of instructions. The starting address of each queue and the number of instructions it accomodates are programmed into OCTEON by the driver. OCTEON supports instructions that are 32 or 64 bytes in size.<p>
<br>
 <br>
 <h2><a class="anchor" name="rr-sec2">
OCTEON PCI driver application interfaces</a></h2>
The driver provides ioctl's that can be used by user-space applications to send requests to OCTEON. A user-space library provides a set of API's that act as wrappers around these ioctls. User-space applications are encouraged to use the API's rather than ioctl. This will allow the applications to be independent of any low-level changes in the ioctl interface of the driver. The driver also exports API's usable by kernel-space applications. Both set of API's are explained in more detail later on in this chapter.<p>
<br>
 <br>
 <h2><a class="anchor" name="rr-sec3">
Driver interaction with OCTEON for request processing</a></h2>
To send a request to OCTEON, applications in user-space call the user-space library API (which in turn calls the OCTEON driver ioctl). Kernel applications use a different set of API exported by the driver. In all cases, the request has to be sent to the driver in a format defined by the OCTEON_soft_request_t structure.<p>
All requests get converted to a instruction format that is understood by the OCTEON PCI input queues. Each such instruction is copied into the next available location in the instruction queue. The driver notifies availability of new instructions to OCTEON by writing to a doorbell register.<p>
The OCTEON PCI input queue hardware gets the data pointer from the instruction and fetches all data and buffers it internally in a work queue entry. OCTEON IPD would schedule the work to one of the cores when the core software requests work from the hardware. The core gets the data (and instruction contents if it was a RAW packet) for the instruction, processes it locally and send a response back to host. If a response is required, the instruction would also have a return pointer which gives the physical address in host memory where the response should be returned.<p>
<a class="anchor" name="PCIcmd32"></a> <h2><a class="anchor" name="rr-cmd32">
PCI Input Queue command format</a></h2>
The driver uses a 32-byte command for the Input Queues by default. The first 16 bytes of the command are defined by the hardware. The PCI instruction format is explained in section 10.3.1. in the CN38XX/CN58XX hardware manual and in section 9.4.1 in CN56XX Hardware manual.The contents of the remaining 16 bytes is setup under the driver's control. The 32-byte command format is as shown below:<p>
<div class="fragment"><pre class="fragment">  -----------------------------
 |    Data Pointer       (64-bit) |   Hardware defined
  --------------------------------
 | Instruction Header    (64-bit) |   Hardware defined
  --------------------------------
 | Return Data Pointer   (64-bit) |   Driver defined
  --------------------------------
 | Input Response Header (64-bit) |   Driver defined
  --------------------------------
</pre></div><p>
<b> Figure 1: 32-byte PCI Input Queue Command format </b><p>
The data pointer points to a buffer or a gather list of buffers in host memory where the input data is located. The instruction header (IH) format can be found in the hardware manual.<p>
The return data pointer (rptr) points to a buffer or a scatter list of buffers in host memory where the application running on OCTEON is expected to send the response data.<p>
The Input Response Header (IRH) is specified by the driver and has the following format:<p>
<div class="fragment"><pre class="fragment">   63      48 47      40 39       34 33     20  19   18       16 15           0
   ----------------------------------------------------------------------------
  | Opcode   |  Param   | Dest Port | rlenssz |  S  | pcie_port | Request ID   |
   ----------------------------------------------------------------------------
</pre></div><p>
<b> Figure 2: Input Response Header format </b><p>
Field Description:<ul>
<li>opcode &amp; param : application defined values to identify the payload type.</li><li>Destport : application defined value to identify the destination; usually an OCTEON I/O port.</li><li>rlenssz : data length if rptr is a single buffer; count of buffers in gather list if rptr points to a scatter list.</li><li>S : indicates if rptr points to a scatter list.</li><li>pcie_port - indicates which PCIe interface should be used to send the response back to host.</li><li>Request ID : index in the driver data structure to identify the request.</li></ul>
<p>
<br>
 <br>
 <br>
<h2><a class="anchor" name="rr-sec4">
OCTEON Request format</a></h2>
As mentioned before, to send a request to OCTEON, the application should fill a OCTEON_soft_request_t structure and call the kernel/user-space api to send the request. The structure definition can be found in <a class="el" href="cavium__defs_8h.html">components/driver/host/include/cavium_defs.h</a>.<p>
The following fields must be filled by the caller:<p>
1. inbuf - set the number of input buffers, address and size of each buffer. It is legal to have 0 input buffers.<p>
2. outbuf - set the number of output buffers, address and size of each buffer. It is legal to have 0 output buffers if no response is expected. Output buffers must be allocated if a response is expected. Kernel applications must allocate an additional 16 bytes to accomodate the response header and status of a response. For user-space applications, driver will allocate the extra bytes.<p>
3. ih - instruction header bits. Refer to the OCTEON Hardware Manual (section 10.3.1) for the format and usage.<p>
4. irh - The opcode field should be set. Optionally the param and dport fields can also be set. All other fields are set by the driver and should not be set by the application. See driver/common/OCTEON-opcodes.h for opcodes reserved for use by driver and applications released by Cavium.<p>
5. exhdr - upto 4 additional 64-bit values can be passed which will be added to the front of the request data bytes.<p>
6. exhdr_info - Just the exhdr_count field needs to be set.<p>
7. req_info - The following field needs to be set by application. <ul>
<li>OCTEON_id - OCTEON device id. </li>
<li>req_mask - Set the response order, response mode, dma mode and instruction queue to use. </li>
<li>timeout - time in millisecs to wait for response. </li>
<li>callback - should not be set by user space application. Kernel applications can set it to a function pointer. </li>
<li>callback_arg - additional argument to be passed to callback by driver. Should not be set by user application. </li>
<li>status - Should not be set by any application. Driver will return status in this field. </li>
<li>request_id - Should not be set by any application. Driver will return request id after request is posted to OCTEON.</li>
</ul>
If the call returns success, the current state of the request will be in the req_info.status field of the request.<p>
<a class="anchor" name="octsoftreqformat"></a> Note: There are some changes to OCTEON_soft_request_t in the 1.0 release. To continue using the old format, recompile the driver after enabling the CVM_SUPPORT_DEPRECATED_API flag in <a class="el" href="cavium__defs_8h.html">components/driver/host/include/cavium_defs.h</a>. The changes in 1.0 were made to enable support for 32-bit user-space apps to communicate with the driver in a 64-bit kernel. The changes are listed below:<p>
<ul>
<li>The OCTEON_request_info_t structure does not have the callback and callback_arg fields when used in user-space applications.</li><li>The datatype for req_info field in OCTEON_soft_request_t and for ptr field in OCTEON_buffer_t have changed from a pointer type to a union which includes a pointer and a uint64_t value.</li></ul>
<p>
The following macros allow application to transparently access the modified fields:<ul>
<li>SOFT_REQ_INBUF(sr, idx)</li><li>SOFT_REQ_OUTBUF(sr, idx)</li><li>SOFT_REQ_INFO(sr)</li></ul>
<p>
where sr is a pointer to a OCTEON_soft_request_t structure.<p>
The response sent by the core application to any request is expected in the following format:<p>
<div class="fragment"><pre class="fragment"> -----------------------------
 | Response Header (8 bytes) |
 -----------------------------
 | Response Data             |
 -----------------------------
 | Status word     (8 bytes) |
 -----------------------------
</pre></div> <b> Figure 3: Response buffer format </b><p>
Kernel applications should take care that the response (output) buffer is created in the above format. For user-space application, the driver builds the buffer in the required format.<p>
<div class="fragment"><pre class="fragment">   63    48 47         42 41              20     19     18              0
  -----------------------------------------------------------------------
  | Opcode | Source Port | Destination Port | Reserved |   Request ID   |
  -----------------------------------------------------------------------
</pre></div> <b> Figure 4: Response Header format </b><p>
<div class="fragment"><pre class="fragment">   63        32 31                    16 15              8 7            0
  -----------------------------------------------------------------------
  | Reserved   | Application Identifier | Request Status  | DMA status  |
  -----------------------------------------------------------------------
</pre></div> <b> Figure 5: Status word format </b><p>
Only the lower 4 bytes of the status word currently hold the completion status. The upper 4 bytes are reserved. Of the lower 2 bytes, the most significant 2 bytes is used as an application identifier. The least significant 2 bytes hold a 16-bit status value.<p>
<b> NOTE:</b> The last 8 bits of status word is used as a DMA completion indicator by the driver. Applications have the 24-bits as shown above for their use. If more than 255 error conditions can occur in an application, it can reserve multiple application identifiers. The application identifier value 0 is reserved for the driver.<p>
The OCTEON host driver looks at the 8 byte status word for completion of a request. When a request is sent, the driver initializes it to all f's. The driver keeps checking that byte[0] of status word changes from 0xff to any other value to consider the request completed.<p>
<b>NOTE:</b> It is illegal for core applications to set byte[0] of the status word to 0xff.<p>
The next sections describe the response mode, dma mode and response order that can be used with requests sent to the driver.<p>
<br>
 <br>
 <h3><a class="anchor" name="rr-subsec4-1">
RESPONSE ORDER</a></h3>
The driver supports the following response ordering mechanisms:<p>
1. <b>ORDERED:</b> An ordered request's response is delivered to the caller only after all previous ORDERED requests have received their responses. This is true even if the timeout values for a ordered request is less than the previous ordered requests. This is the recommended mode to use for kernel-level applications.<p>
2. <b>UNORDERED:</b> Unordered requests can complete in any order. UNORDERED mode requests are the preferred mode for user-space applications. A user-space application can specify blocking (the function call will not return till a response is received or its times-out) or non-blocking (the function call returns immediately). For non-blocking mode, the user-space application is expected to query for the status of the request at frequent intervals till the status for the request returned indicates that the request completed or timed-out.<p>
3. <b>NORESPONSE:</b> These requests don't expect a response. The driver buffers them internally only as long as it takes OCTEON to read them in. These type of requests can be sent from kernel and user space applications.<p>
<br>
 <br>
 <h3><a class="anchor" name="rr-subsec4-2">
RESPONSE MODE</a></h3>
The driver supports the following response modes for UNORDERED requests:<p>
1. <b>BLOCKING:</b> The driver will not return from the ioctl till the requests completes (or times-out).<p>
2. <b>NON-BLOCKING:</b> The driver returns as soon as the request is submitted to OCTEON. The user application is required to poll for completion of the request using a query api function.<p>
For kernel-space applications, all requests are considered NON-BLOCKING operations by the driver.<p>
<br>
 <br>
 <h3><a class="anchor" name="rr-subsec4-3">
DMA MODES</a></h3>
The driver supports the following DMA modes:<p>
1. <b>DIRECT:</b> In this mode, there is a single input buffer pointer (dptr) in the instruction and a single output buffer pointer (rptr).<p>
2. <b>GATHER:</b> In this mode, there can be multiple input buffer pointers. Driver creates a gather list with these pointers and passes address of gather list in the instruction. There is only one output buffer.<p>
3. <b>SCATTER:</b> There is only one input buffer. There can be multiple output buffer pointers. Driver creates a scatter list with these pointers and passes address of scatter list in the instruction.<p>
4. <b>SCATTER_GATHER:</b> There can be multiple input and output buffers. Driver creates a gather and scatter list and passes the address of these lists in the instrcution.<p>
<br>
 <br>
 <br>
 <h2><a class="anchor" name="user_space_support">
Supported Modes for user-space applications.</a></h2>
For user-space applications, the supported modes are described below. All constants used below are defined in <a class="el" href="cavium__defs_8h.html">components/driver/host/include/cavium_defs.h</a>.<p>
1. <b>DIRECT DMA:</b> Multiple Input or Output buffers are allowed. Multiple input buffers are coalesced internally by the driver. Multiple output buffers are also supported. Driver gets response in a single response buffer and splits it among the multiple user-space output buffers. Maximum Input data size is OCT_MAX_DIRECT_INPUT_DATA_SIZE. Maximum Output data size is OCT_MAX_DIRECT_OUTPUT_DATA_SIZE.<p>
2. <b>GATHER DMA:</b> Multiple Input or Output buffers are allowed. Multiple input buffers are put into a gather list. Maximum gather input data cannot exceed OCT_MAX_GATHER_DATA_SIZE. Multiple output buffers are also supported. Driver gets response in a single response buffer and splits it among the multiple user-space output buffers. Maximum output data size cannot exceed OCT_MAX_DIRECT_OUTPUT_DATA_SIZE.<p>
3. <b>SCATTER DMA:</b> Multiple Input or Output buffers are allowed. Multiple input buffers are coalesced internally by the driver. Maximum input data cannot exceed OCT_MAX_DIRECT_INPUT_DATA_SIZE. Multiple output buffers are put into a scatter list. Driver splits the response from internal scatter buffers among the multiple user-space output buffers. Maximum output data size cannot exceed OCT_MAX_SCATTER_DATA_SIZE.<p>
4. <b>SCATTER_GATHER DMA:</b> Multiple Input or Output buffers are allowed. Multiple input buffers are put into a gather list. Maximum gather input data cannot exceed OCT_MAX_GATHER_DATA_SIZE. Multiple output buffers are put into a scatter list. Driver splits the response from internal scatter buffers among the multiple user-space output buffers. Maximum output data size cannot exceed OCT_MAX_SCATTER_DATA_SIZE.<p>
The following response mode and response orders are supported:<p>
<div class="fragment"><pre class="fragment">    Response Order  |  Response mode
 ---------------------------------------
 1. UNORDERED       |  BLOCKING

 2. UNORDERED       |  NON-BLOCKING

 3. NORESPONSE      |  NON-BLOCKING
</pre></div><p>
<b>IMPORTANT</b> ORDERED response order is not supported for user-space applications.<p>
<br>
 <br>
 <br>
 <h2><a class="anchor" name="kernel_space_support">
Supported Modes for kernel-space applications.</a></h2>
For kernel-space applications, the supported modes are described below. All constants used below are defined in <a class="el" href="cavium__defs_8h.html">components/driver/host/include/cavium_defs.h</a>.<p>
1. <b>DIRECT DMA:</b> Multiple Input buffers are allowed. Multiple input buffers are coalesced internally by the driver. Multiple output buffers are not supported. Maximum Input data size is OCT_MAX_DIRECT_INPUT_DATA_SIZE. Maximum Output data size is OCT_MAX_DIRECT_OUTPUT_DATA_SIZE.<p>
2. <b>GATHER DMA:</b> Multiple Input buffers are allowed. Multiple input buffers are put into a gather list. Maximum gather input data cannot exceed OCT_MAX_GATHER_DATA_SIZE. Multiple output buffers are not supported. Maximum output data size cannot exceed OCT_MAX_DIRECT_OUTPUT_DATA_SIZE.<p>
3. <b>SCATTER DMA:</b> Multiple Input buffers are not allowed. Maximum input data cannot exceed OCT_MAX_DIRECT_INPUT_DATA_SIZE. Multiple output buffers are put into a scatter list. Maximum output data size cannot exceed OCT_MAX_SCATTER_DATA_SIZE.<p>
4. <b>SCATTER_GATHER DMA:</b> Multiple Input or Output buffers are allowed. Multiple input buffers are put into a gather list. Maximum gather input data cannot exceed OCT_MAX_GATHER_DATA_SIZE. Multiple output buffers are put into a scatter list. The core driver has the responsibility to DMA the response data into the buffers pointed by the scatter list. Maximum output data size cannot exceed OCT_MAX_SCATTER_DATA_SIZE.<p>
<b>NOTE: </b> Kernel applications are required to reserve 8 bytes at the start of the output buffer for Response Header and 8 bytes at the end of the output buffer for status bytes. Thus, the actual output buffer size constraints is the maximum data size mentioned in the above paragraphs + 16 bytes. For e.g., to receive the maximum DIRECT DMA data size of OCT_MAX_DIRECT_OUTPUT_DATA_SIZE (16367 bytes) the application should allocate a buffer of size 16383 bytes.<p>
<b>IMPORTANT</b>: The driver supports ORDERED and NORESPONSE type requests for kernel applications. UNORDERED response order is supported, but is not recommended.<p>
For kernel-space applications, all requests are considered NON-BLOCKING operations by the driver.<p>
<br>
 <br>
 <br>
 <h2><a class="anchor" name="driver_kernel_api">
Request processing from kernel applications</a></h2>
The OCTEON host driver provides two functions as entry points for kernel applications into the driver to support request/response with the OCTEON device. The driver allows kernel level requests to specify a callback which will be called by the driver on request completion. A request can send data in a single buffer, in multiple buffers (in which case the driver coalesces the buffers into one big buffer) or a gather list of data buffers. The application can use multiple buffers to get the response if SCATTER dma mode is used, in which case the driver would create a scatter list which would be used by the core driver to copy the response to host.<p>
<br>
 <h3><a class="anchor" name="kernel_api">
API for kernel space applications</a></h3>
1. OCTEON_process_request() - Kernel space applications use this API to send a request to OCTEON. All 3 response modes described above are supported. ORDERED and NORESPONSE mode requests are recommended for kernel space applications. The required information for a request is filled in a OCTEON_soft_request_t structure and passed along with the OCTEON device id as parameters to this function. When this function returns success, the request has been queued successfully by the driver though it may not have been sent yet to OCTEON. A callback may be specified with the request. The callback function will be called by the driver when, <ul>
<li>for ORDERED/UNORDERED: response is received or the request timed-out. </li>
<li>for NORESPONSE mode: request is sent to OCTEON or if it times-out.</li>
</ul>
In case of a time out, the driver returns a status value of OCTEON_REQUEST_TIMEOUT (decimal 3). A response from the core could also give an error value, but it should never be 3 as that value is reserved for the driver.<p>
2. OCTEON_query_request_status() - Kernel space applications call this function to determine the status of a previously posted UNORDERED request. The request id is presented to the driver in a OCTEON_query_request_t structure. The current status of the request is returned by the driver in the same structure. The status returned can be one of <ul>
<li>OCTEON_REQUEST_PENDING - the request has not yet completed </li>
<li>OCTEON_REQUEST_TIMEOUT - the request timed-out before completion </li>
<li>32-bit value - which is returned by the application on the core that processed the request. Its value is application dependent.</li>
</ul>
<br>
 <h3><a class="anchor" name="kern_samp">
Kernel-space application example sources</a></h3>
The kernel-space application example under components/driver/host/test/kernel/req_resp demonstrates request processing using the OCTEON PCI driver. It requires the <b>cvmcs</b> core application which can be found at applications/pci-core-app/base.<p>
<br>
 <br>
 <br>
 <h2><a class="anchor" name="driver_user_api">
Request processing from user space  applications</a></h2>
ORDERED mode requests are not supported for user space requests. For NORESPONSE type of requests, blocking mode is not supported. User mode requests cannot specify a callback. Requests can be blocking or non-blocking. User space applications can send requests with the input in multiple buffers. The driver would copy all the input data into one buffer. The driver does not support zero-copy gather/scatter with multiple user-space buffers but supports a 1-copy operation for all user-space input data buffers. User-space applications can give multiple user-space buffers to receive the output data. If multiple buffers are specified, the driver scatters the output data into the user-space output buffers appropriately.<p>
<br>
 <h3><a class="anchor" name="dev_file_sec">
OCTEON device file.</a></h3>
Before any user applications can start using the OCTEON driver, a device file should be created. The OCTEON device file is a character device with major number 127 named /dev/OCTEON_device. The OCTEON user api library (liboctapi.a) looks for this device file. Note that there is only one device file even when there are multiple OCTEON devices in the system. The device file should be considered as a entry point to the driver. Each of the ioctls supported by the driver has a field identifying the OCTEON device at which the operation is directed.<p>
<br>
 <h3><a class="anchor" name="ioctl_sec">
OCTEON driver ioctls and user level API.</a></h3>
Once the file has been opened, there are several ioctl's that enable access to the OCTEON device. They provide read/write access to the OCTEON registers and to send requests. The octapi library provides wrappers for all ioctls. The ioctls are defined in OCTEON_SDK/components/driver/host/include/OCTEON_ioctl.h. The preferred method though is to use the octapi library. Check out OCTEON_SDK/components/driver/api/OCTEON_user.h for all the api functions available.<p>
A request from user space can send the data in multiple input buffers and the result can arrive in multiple output buffers as desired by the user.<h3><a class="anchor" name="user_api">
API for user space applications.</a></h3>
1. OCTEON_initialize() - This function opens the OCTEON device file and enables a channel of communication with the OCTEON device driver.<p>
2. OCTEON_send_request() - User space applications can send a request by filling up a OCTEON_soft_request_t structure and calling this function with the OCTEON device id. User-space applications can send UNORDERED (blocking or non-blocking) and NORESPONSE mode requests. For non-blocking UNORDERED requests, the caller is expected to query the request's status. For UNORDERED BLOCKING mode, the status is available in the soft request structure when the call returns. For all modes, if the request was queued successfully, the function returns success, else it returns a errno value describing the error encountered.<p>
3. OCTEON_query_request() - User space applications use this function to query the status of a previously posted UNORDERED non-blocking request. The mechanism used and the return values are the same as for a kernel space OCTEON_query_request_status() call. See above.<p>
4. OCTEON_shutdown() - This function closes the OCTEON device file and stops the channel of communication to the OCTEON driver.<p>
<br>
 <h3><a class="anchor" name="cmd64">
Using Input Queues with 64-byte commands.</a></h3>
By default, all the Input Queues are configured to use the 32-byte PCI command format. To use the 64-byte format, edit the configuration data in <a class="el" href="oct__config__data_8h.html">components/driver/host/include/oct_config_data.h</a> to change the instr_type field in the input queue configuration from 32 to 64.<p>
Refer to <a class="el" href="host-main.html#Octdevconf">Section: OCTEON device configuration</a> to learn more about editing OCTEON configuration.<p>
When using a input queue with 64-byte command, the first 32 bytes in the command generated by the driver are identical to the 32-byte command described in <a class="el" href="reqresp.html#rr-cmd32">PCI command format</a>. The remaining 32 bytes are read from the 4 64-bit exhdr fields in the OCTEON_soft_request_t structure.<p>
The setting of the Input queue is transparent to the host application and the data bytes from the exhdr and from the input data buffer appear in the same way in the WQE received by the application running on the OCTEON cores irrespective of the command type set for the Input queues.<p>
<br>
 <h3><a class="anchor" name="user_samp">
user-space application example sources</a></h3>
The user-space application example (oct_req) under components/driver/host/test demonstrates request processing using the OCTEON PCI driver. It requires the <b>cvmcs</b> core application which can be found at applications/pci-core-app/base. <hr size="1"><address style="align: right;"><small>Generated on Tue Nov 22 15:41:00 2011 for Octeon PCI Driver by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
