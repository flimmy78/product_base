<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Octeon PCI Driver: OCTEON core driver</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1><a class="anchor" name="core-main">OCTEON core driver</a></h1><h2><a class="anchor" name="cm-sec1">
Introduction</a></h2>
The core component of the OCTEON PCI driver provides a set of API's for OCTEON core applications <ul>
<li>to send responses for requests received from the host </li>
<li>to send unsolicited data packets to the OCTEON host using OCTEON output queues. </li>
<li>to transfer data between host memory and OCTEON local memory using DMA engines.</li>
</ul>
The core driver sources can be found at components/driver/core. The core driver gets compiled as a library which is linked with the core application.<p>
For an example core application that uses the PCI input, output and DMA engines, go to applications/pci-core-app/base. The core application is called <b>cvmcs</b>. It uses the files in pci-core-app/common for initialization and the files in pci-core-app/test to demonstrate request/response, packet data transfer via PCI output queue and DMA transfer via the PCI DMA engines.<p>
<br>
<br>
 <h2><a class="anchor" name="cm-sec2">
Input processing in OCTEON cores</a></h2>
<b>Files:</b> cvm-drv.c<p>
The core component of OCTEON PCI driver does not have any API's for input processing. This is because OCTEON treats data arriving from the PCI input rings in the same way as from any of the other ports. The only exception is that RAW mode packets include information about the instruction in the work queue entry.<p>
OCTEON input ports receive packets from PCI and send it to the cores for processing in a work queue entry (WQE). The PCI data can be in RAW mode or packet mode (identified by the WQE structure's 2nd 64-bit word and by the Instruction Header).<p>
The PCI Instruction Header (IH) is converted into a Packet Instruction Header which retain all the fields of the PCI IH except the dlengsz (data length) and fsz (front data size) fields. In place of these two fields, the Packet IH has a skip length and Parse Mode fields. Refer to the OCTEON Hardware Manual for more info on the packet IH format and conversion. The driver currently uses fixed size front data (16 bytes) and the length field of the WQE structure gives the total length of packet (including headers).<p>
A core application that wishes to receive data from the PCI input ports requests work from OCTEON POW in the same way as it would for other ports. It can identify data received from the PCI ports by looking at the ipprt field in WORD1 of the WQE. This field should have a value between 32 and 35 for OCTEON processors up to CN63xx and 0x100 to 0x11F on OCTEON CN68xx.<p>
<br>
<br>
 <h2><a class="anchor" name="cm-sec3">
Using Output rings from OCTEON cores</a></h2>
<b>Files:</b> cvm-pci-pko.c; <a class="el" href="cvm-pci-pko_8h.html">cvm-pci-pko.h</a><p>
There are up to 32 PCI output rings available for Core applications to send data to the host. Each of these rings is implemented as a descriptor ring in the host memory. Data is sent out via the PCI Output rings by writing commands to PKO ports corresponding to the PCI block. When a command is written to one of the PKO PCI ports the OCTEON hardware takes care of transferring the data from the OCTEON memory to the output ring buffers in host memory using PCI operations. The core driver provides API's that allow core applications to send data to the PCI output queues. The API's are discussed in detail later in this chapter.<p>
<br>
<br>
 <h2><a class="anchor" name="cm-sec4">
Sending instruction response from OCTEON cores</a></h2>
<b>Files:</b> cvm-drv-reqresp.c; <a class="el" href="cvm-drv-reqresp_8h.html">cvm-drv-reqresp.h</a>; <a class="el" href="cvm-pci-dma_8h.html">cvm-pci-dma.h</a>; <a class="el" href="cvm-driver-defs_8h.html">cvm-driver-defs.h</a><p>
Core applications can send responses via the DMA queues for instructions received from the host. The response can be send to a single or multiple locations in the host memory. The core component of the PCI driver provides several API's that allow core applications to send the response in several different ways. The API's are discussed in detail later in this chapter.<p>
<br>
<br>
 <h2><a class="anchor" name="cm-sec5">
Data transfer from OCTEON cores</a></h2>
<b>Files: </b> cvm-pci-dma.c; <a class="el" href="cvm-pci-dma_8h.html">cvm-pci-dma.h</a><p>
Core applications can transfer data between host memory and OCTEON L2/DRAM using API's provided by the core PCI driver. The API's takes local buffer pointers and remote host addresses and uses the PCI DMA engines to transfer data between the local OCTEON memory and remote host memory.<p>
<br>
<br>
 <h2><a class="anchor" name="pci_init_sec">
Initialization of the core driver component.</a></h2>
<b>Files: </b> cvm-drv.c; <a class="el" href="cvm-driver-defs_8h.html">cvm-driver-defs.h</a><p>
This section describes the steps a simple executive application should take when it needs to use the PCI interface. It also describes the API's available for use by a core application. Every simple executive application goes through the following steps:<p>
<ul>
<li>a) Allocate memory resources for the application globally i.e. one of the cores does the allocation on behalf of all cores. This includes setting up of FPA pools, arena allocation and configuring the IO interfaces. </li>
<li>b) Each core then allocates resources it requires like scratchpad location and memory allocation for local structures. </li>
<li>c) Finally, it starts its application specific chores in a loop.</li>
</ul>
During step (a), the application should call <a class="el" href="cvm-drv_8h.html#59a51ac9c6dffe2a64697b8a8cddefe5">cvm_drv_init()</a>. This will do initialization of the PCI ports and also allocate resources for the PCI input and output interfaces. This actions is done globally by one of the cores in the application.<p>
During step (b), the application should call <a class="el" href="cvm-drv_8h.html#ef39aa57411854884f335cb9f1633429">cvm_drv_local_init()</a>. This reserves scratchpad locations for use by the core driver. These scratchpad locations serve as storage for memory pointers for driver async allocation routines. This is done on all the cores which run the application.<p>
After step (b) and before entering the data processing part in step (c), the application should call <a class="el" href="cvm-drv_8h.html#e95174649a7301c225b94c8a4f3226d8">cvm_drv_start()</a>. This routine sends a packet on PCI output queue that tells the host that core initialization is complete and PCI packet transfer can begin. This step is also performed by only one of the cores running the application.<p>
<div class="fragment"><pre class="fragment">   ----------------------------- IMPORTANT -------------------------------
   The host driver will NOT send requests to OCTEON until it receives an
   indication from the  OCTEON cores. All core applications that want to
   use  PCI input ports should call  cvm_drv_start() as the last step in
   initialization.
</pre></div><p>
<br>
<br>
<br>
<br>
 <h2><a class="anchor" name="pci_use_sec">
PCI core driver API</a></h2>
<br>
<br>
 <b> Sending response to a request from host </b><p>
<b> Important: </b> The OCTEON DMA engine limits each local buffer size to 8184 bytes. This is documented in OCTEON CN38XX PASS3 Errata as PCI-500.<p>
<b> Important: </b>: For each DMA command, OCTEON limits the maximum number of local buffers to 14 and remote pointers to 13.<p>
<ul>
<li><a class="el" href="cvm-drv-reqresp_8h.html#1c7a3963410a0b2c3ef012fb76a0eb0a">cvm_drv_pci_instr_response()</a> Use this API if the response header, status and data are in separate locations in OCTEON memory. The host memory location is retrieved by the core driver from the instruction front data (in parameter "front"). Note that this API will reserve 2 local and 2 remote pointers for the response header &amp; status respectively.</li>
</ul>
<ul>
<li><a class="el" href="cvm-drv-reqresp_8h.html#09b04b4ec27595fc3cca9c7f7f929cc5">cvm_drv_pci_instr_response_direct()</a> - Use this API if the the response header, status and data are in a single buffer in OCTEON memory. The host memory location is retrieved by the core driver from the instruction front data (in parameter "front").</li>
</ul>
<ul>
<li><a class="el" href="cvm-drv-reqresp_8h.html#a39d8274ebc2aa1f7772f542f7b8dce3">cvm_dma_send_scatter_response()</a> - Use this API if the response pointer is a scatter list and not a direct host memory address. Read the scatter list first by calling cvm_pci_dma_read_scatter_list() and pass the scatter list along with the local response buffers, response header and status to this function. The status and response header are passed as arguments to this function. Note that this API will reserve 2 local and 2 remote pointers for the response header &amp; status respectively.</li>
</ul>
<ul>
<li><a class="el" href="cvm-drv-reqresp_8h.html#2cccd6a8e87bad2c7ef08e691ec5d17b">cvm_dma_send_scatter_response_direct()</a> - Use this API if the response pointer is a scatter list and not a direct host memory address. Read the scatter list first by calling cvm_pci_dma_read_scatter_list() and pass the scatter list to this function. The status and response header are assumed to be part of the response data.</li>
</ul>
All the API's above support blocking and non-blocking calls. The DMA_ACTION parameter determines the type of call. If the action is DMA_BLOCKING, the function call does not return till the OCTEON PCI DMA engine indicates that the DMA is completed. If the action is DMA_NON_BLOCKING, the functions expects a pointer to a work queue entry (WQE). This WQE will be scheduled by the DMA engine when the DMA is completed. The application should complete all DMA post-processing when it receives this WQE.<p>
The above functions can be found in cvm-drv-reqresp.c &amp; <a class="el" href="cvm-drv-reqresp_8h.html">cvm-drv-reqresp.h</a>.<p>
<br>
<br>
 <b> Sending unsolicited data to OCTEON PCI host via Output queues</b><p>
<b> Important: </b>: OCTEON limits the maximum data transfer on the PCI output queue to 65528.<p>
<ul>
<li><a class="el" href="cvm-pci-pko_8h.html#0729a4a8ff43bc9e6ac868728aab1c94">cvm_pko_send_direct()</a> - This API supports local data buffers in a single buffer or multiple buffers in chained (linked) mode or gather mode. Use this when the data buffer includes the response header identifying the data contents.</li>
</ul>
<ul>
<li><a class="el" href="cvm-pci-pko_8h.html#c5e166689b1d4f886e5bee1bac37fffb">cvm_pko_send_data()</a> - This API supports all the data buffer modes in <a class="el" href="cvm-pci-pko_8h.html#0729a4a8ff43bc9e6ac868728aab1c94">cvm_pko_send_direct()</a> but allows the response header to be sent separately from the data.</li>
</ul>
The above functions can be found in cvm-pci-pko.c &amp; <a class="el" href="cvm-pci-pko_8h.html">cvm-pci-pko.h</a>.<p>
<br>
<br>
 <b> Sending data to host memory via DMA engines </b><p>
<ul>
<li><a class="el" href="cvm-pci-dma_8h.html#06a3a35352277e1f4735eea19d79c1a1">cvm_pci_dma_send_direct()</a> - This API provides a low level interface where the caller is required to specify the DMA command and the local and remote memory address pointers.</li>
</ul>
<ul>
<li><a class="el" href="cvm-pci-dma_8h.html#aedebf9d4cf969e2f017e822461a44e0">cvm_pci_dma_send_data()</a> - Use this API to send data to the host memory via DMA. The DMA command is built by the core driver.</li>
</ul>
The above functions do not have intrinsic support for blocking or non-blocking operations, though the application can specify a work queue entry or memory location in the <a class="el" href="unioncvm__pci__dma__cmd__t.html">cvm_pci_dma_cmd_t</a> parameters passed to these routines for PCI DMA completion indication.<p>
The above functions can be found in cvm-pci-dma.c<p>
<br>
<br>
 <b> Receiving data from host memory via DMA engines </b><p>
<ul>
<li><a class="el" href="cvm-pci-dma_8h.html#4ebbf8a86fefe0238ae2a57c830cf09d">cvm_pci_dma_recv_data()</a> - Use this API to read data from host memory via DMA. The DMA command is built by the core driver.</li>
</ul>
<ul>
<li>cvm_pci_dma_read_scatter_list() - Use this API to read a scatter list from host memory. The bus address of host memory is passed as a parameter along with the address of a local buffer where the scatter list is copied by the DMA engine. This requests supports BLOCKING mode where the function does not return till the scatter list is retrieved, and a NON-BLOCKING mode where the function schedules a WQE after completion of DMA. The application must provide a WQE when using the NON-BLOCKING mode and be capable of processing the WQE when it is becomes available after completion of DMA.</li>
</ul>
The above functions do not have intrinsic support for blocking or non-blocking operations, though the application can specify a work queue entry or memory location in the <a class="el" href="unioncvm__pci__dma__cmd__t.html">cvm_pci_dma_cmd_t</a> parameters passed to these routines for PCI DMA completion indication.<p>
The above functions can be found in cvm-pci-dma.c<p>
<b>NOTE:</b> Please refer to the README.txt at OCTEON-SDK/components/driver for compilation instructions. <hr size="1"><address style="align: right;"><small>Generated on Tue Nov 22 15:41:00 2011 for Octeon PCI Driver by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
