/*******************************************************************************
*              (c), Copyright 2001, Marvell International Ltd.                 *
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL SEMICONDUCTOR, INC.   *
* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT  *
* OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE        *
* DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.     *
* THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESSED,       *
* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.   *
********************************************************************************
*  cpssDxChBrgFdbAu.c
*
* DESCRIPTION:
*       This file provides the CPSS DxCh FDB Address Update (AU) functionality
*
*
* FILE REVISION NUMBER:
*       $Revision: 1.1.1.1 $
*
*******************************************************************************/


/* get the device info and common info */
#include <cpss/dxCh/dxChxGen/config/private/prvCpssDxChInfo.h>
/* get DxCh FDB types */
#include <cpss/dxCh/dxChxGen/bridge/cpssDxChBrgFdb.h>

#include <cpss/generic/bridge/cpssGenBrgFdb.h>
/* check errata */
#include <cpss/dxCh/dxChxGen/config/private/prvCpssDxChErrataMng.h>


/* get driver level structs information */
#include <cpssDriver/pp/prvCpssDrvPpDefs.h>

/* check that mask enabled/not and application asked for the SW filtering  */
#define NON_SOURCE_PORT_GROUP_FILTER_CHECK_MAC(_devNum)             \
    (PRV_CPSS_FDB_AUQ_FROM_NON_SOURCE_PORT_GROUP_WA_E(_devNum) &&   \
     PRV_CPSS_FDB_AUQ_FROM_NON_SOURCE_PORT_GROUP_FILTER_ENABLED_WA_E(_devNum))

#define HW_FORMAT_2_CMD_MAC(hwData,macCmd)                                 \
    macCmd = (((hwData) == 0) ? CPSS_MAC_TABLE_FRWRD_E  :                  \
                    (((hwData) == 1) ? CPSS_MAC_TABLE_MIRROR_TO_CPU_E :    \
                    (((hwData) == 2) ? CPSS_MAC_TABLE_CNTL_E :             \
                    (((hwData) == 3) ? CPSS_MAC_TABLE_DROP_E :             \
                    (((hwData) == 4) ? CPSS_MAC_TABLE_SOFT_DROP_E :        \
                                       CPSS_MAC_TABLE_FRWRD_E)))));


/*
 *  typedef: enum  MESSAGE_QUEUE_ENT
 *
 *  Description: hold the different types of message queues that cpss SW uses
 *
 *  Enumerations:
 *      MESSAGE_QUEUE_PRIMARY_AUQ_E - the primary AUQ
 *      MESSAGE_QUEUE_PRIMARY_FUQ_E - the primary FUQ
 *      MESSAGE_QUEUE_SECONDARY_AUQ_E - the secondary AUQ
*/
typedef enum
{
    MESSAGE_QUEUE_PRIMARY_AUQ_E,
    MESSAGE_QUEUE_PRIMARY_FUQ_E,
    MESSAGE_QUEUE_SECONDARY_AUQ_E
}MESSAGE_QUEUE_ENT;


/* the number of AU messages to */
GT_U32  prvCpssDxChPerPortGroupNumOfAu  = 1;/* <-- allow to modify from test in order to check performances*/

/*******************************************************************************
* auDescMultiPortGroupNonSourceFilterCheck
*
* DESCRIPTION:
*       This function check if need to filter message from the AUQ/FUQ due to
*       'non source port group'
*
*       When Enabled - AU/FU messages are filtered by CPSS if the MAC entry
*       does NOT reside on the local port group, i.e. the entry port[5:4] != port group
*
* APPLICABLE DEVICES:
*        Lion.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; xCat2.
*                      --ONLY for multi-Port Group device
*
* INPUTS:
*       devNum             - device number
*       portGroupId        - the portGroupId - for multi-port-groups support
*       swapedAuDescPtr    - (pointer) to the AU descriptor filled by PP.
*                   this is pointer to 'swapped' auDesc
*
* OUTPUTS:
*       none
*
* RETURNS:
*       GT_TRUE - need to filter the message
*       GT_FALSE - NO need to filter the message
*
* COMMENTS:
*
*
*******************************************************************************/
static GT_BOOL auDescMultiPortGroupNonSourceFilterCheck
(
    IN  GT_U8                         devNum,
    IN  GT_U32                        portGroupId,
    IN  PRV_CPSS_AU_DESC_STC          *swapedAuDescPtr
)
{
     /* When Enabled - AU/FU messages are filtered by CPSS if the MAC entry
       does NOT reside on the local port group, i.e. the entry port[5:4] != port group */

    switch(U32_GET_FIELD_MAC(swapedAuDescPtr->word0, 4, 3))
    {
        case CPSS_AA_E:
        case CPSS_TA_E:
        case CPSS_FU_E:
             /*Only messages that generated by the 'Aging deamon'
               (auto/triggered action ) , apply to the filter */
            break;
        default:
            /* those messages are not filtered by the device .*/
            return GT_FALSE;
    }
    /* check that the entry associated with current device */
    if(PRV_CPSS_HW_DEV_NUM_MAC(devNum) != U32_GET_FIELD_MAC(swapedAuDescPtr->word3, 7, 5))
    {
        return GT_FALSE;
    }

    /* type must be CPSS_MAC_ENTRY_EXT_TYPE_MAC_ADDR_E */
    if(0 != U32_GET_FIELD_MAC(swapedAuDescPtr->word3,19, 3))
    {
        return GT_FALSE;
    }

    /* check multiple bit */
    if(1 == U32_GET_FIELD_MAC(swapedAuDescPtr->word2,15, 1))
    {
        return GT_FALSE;
    }

    /* check multicast bit (bit 40 in macAddr[])*/
    if(1 == U32_GET_FIELD_MAC(swapedAuDescPtr->word1,24, 1))
    {
        return GT_FALSE;
    }

    /* check isTrunk bit  */
    if(1 == U32_GET_FIELD_MAC(swapedAuDescPtr->word2,17, 1))
    {
        return GT_FALSE;
    }

    /* check portGroupId that is bits 4,5 in the portNum that is from bit 18 -> 6 bits */
    if(portGroupId == U32_GET_FIELD_MAC(swapedAuDescPtr->word2,22, 2))
    {
        return GT_FALSE;
    }

    /* need to filter the message */
    return GT_TRUE;
}

/*******************************************************************************
* auDesc2UpdMsg
*
* DESCRIPTION:
*       This function is called whenever an address update message is received.
*       It translates the descriptor into CPSS_MAC_UPDATE_MSG_EXT_STC format
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; Lion; xCat2.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum       - number of device whose descriptor queue is processed
*       portGroupId       - the portGroupId - for multi-port-groups support
*       auDescPtr    - (pointer) to the AU descriptor filled by PP.
*       auDescrFromDma - AU descriptor is from DMA queue
*                        GT_TRUE - AU descriptor is from DMA queue
*                        GT_FALSE - AU descriptor is from FIFO but not DMA queue
*
* OUTPUTS:
*       addrUpMsgPtr     - MAC format of entry
*
* RETURNS:
*       GT_OK if successful, or
*       GT_FAIL otherwise.
*
* COMMENTS:
*
*
*******************************************************************************/
static GT_STATUS auDesc2UpdMsg
(
    IN  GT_U8                         devNum,
    IN  GT_U32                        portGroupId,
    IN  PRV_CPSS_AU_DESC_STC          *auDescPtr,
    IN  GT_BOOL                       auDescrFromDma,
    OUT CPSS_MAC_UPDATE_MSG_EXT_STC   *addrUpMsgPtr
)
{
    PRV_CPSS_AU_DESC_STC    auDesc;   /* Holds the address update         */
                                      /* descriptor after byte-swapping.  */
    GT_U32  multiple;
    GT_BOOL fixFEr22;      /* GT_TRUE - handle errata 22 */
    CPSS_MAC_ENTRY_EXT_KEY_STC *macEntryExtKeyPtr; /* pointer to mac entry */
    GT_U16  vlanId;          /* vlan id */
    GT_U32  naFormatVersion; /* Address message format version       */
    GT_U32  oldPortTrunk;   /* old port or trunk number                    */

    if (auDescrFromDma == GT_TRUE)
    {
        /* AU descriptor from DMA queue must be handled by swap procedure. */
        auDesc.word0 = prvCpssDrvHwPpPortGroupByteSwap(devNum, portGroupId , auDescPtr->word0);
        auDesc.word1 = prvCpssDrvHwPpPortGroupByteSwap(devNum, portGroupId , auDescPtr->word1);
        auDesc.word2 = prvCpssDrvHwPpPortGroupByteSwap(devNum, portGroupId , auDescPtr->word2);
        auDesc.word3 = prvCpssDrvHwPpPortGroupByteSwap(devNum, portGroupId , auDescPtr->word3);
    }
    else
    {
        /* AU descriptor from FIFO already handled by swap procedure in the
           prvCpssDrvHwPpPortGroupReadRegister. */
        auDesc = *auDescPtr;
    }

    if(NON_SOURCE_PORT_GROUP_FILTER_CHECK_MAC(devNum))
    {
        /* check if need to 'filter' the message */

        /* function auDescMultiPortGroupNonSourceFilterCheck , must be called with
           'swapped' auDesc */
        if(GT_TRUE == auDescMultiPortGroupNonSourceFilterCheck(devNum,portGroupId,&auDesc))
        {
            /* need to filter the message */
            AU_DESC_RESET_MAC(auDescPtr);
            return GT_OK;
        }
    }

    if(PRV_CPSS_IS_MULTI_PORT_GROUPS_DEVICE_MAC(devNum))
    {
        /* multi port groups support . needed even in unified FDBs for the trunk
        entries*/
        addrUpMsgPtr->portGroupId = portGroupId;
    }
    else
    {
        /* other devices are 'unaware' */
        addrUpMsgPtr->portGroupId = CPSS_PORT_GROUP_UNAWARE_MODE_CNS;
    }

    addrUpMsgPtr->updType = (GT_U8)U32_GET_FIELD_MAC(auDesc.word0, 4, 3);

    /* The FDB message type 5 (CPSS_SA_E) is used only for Cheetah 2 devices
     for FDB Upload messages.*/
    if(addrUpMsgPtr->updType == 5)
        addrUpMsgPtr->updType = CPSS_FU_E;

    if ((PRV_CPSS_DXCH_XCAT2_FAMILY_CHECK_MAC(devNum))
        && (addrUpMsgPtr->updType == CPSS_NA_E))
    {
        naFormatVersion  = 1;
    }
    else
    {
        naFormatVersion  = 0;
    }

    addrUpMsgPtr->associatedDevNum = (GT_U8)U32_GET_FIELD_MAC(auDesc.word3, 7, 5);


    if(addrUpMsgPtr->updType == CPSS_AA_E)
    {
        fixFEr22 = PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                                PRV_CPSS_DXCH_FDB_AGING_WITH_REMOVAL_MODE_WA_E);

        if((fixFEr22 == GT_TRUE) &&
           (0 == (PRV_CPSS_DXCH_PP_MAC(devNum)->bridge.devTable &
                    (1 << addrUpMsgPtr->associatedDevNum))))
          {
            /* FEr #22:
               In Aging with removal mode, AA message is sent for entries
               removed due to an invalid device
            */

            /* Workaround :
               The CPU should ignore those messages,
               after ensuring that the DeviceId is invalid.
            */

            AU_DESC_RESET_MAC(auDescPtr);
            return GT_OK;

        }

    }

    macEntryExtKeyPtr = &(addrUpMsgPtr->macEntry.key);

    if (naFormatVersion == 0)
    {
        macEntryExtKeyPtr->entryType = (GT_U8)U32_GET_FIELD_MAC(auDesc.word3, 19, 3);
    }
    else
    {
        /* xCat2 use only MAC address NA message */
        macEntryExtKeyPtr->entryType = CPSS_MAC_ENTRY_EXT_TYPE_MAC_ADDR_E;
    }
    
    if(macEntryExtKeyPtr->entryType == CPSS_MAC_ENTRY_EXT_TYPE_MAC_ADDR_E)
    {
        macEntryExtKeyPtr->key.macVlan.vlanId =
                                     (GT_U16)U32_GET_FIELD_MAC(auDesc.word2, 0, 12);
        vlanId = macEntryExtKeyPtr->key.macVlan.vlanId;

        macEntryExtKeyPtr->key.macVlan.macAddr.arEther[5] =
                                      (GT_U8)U32_GET_FIELD_MAC(auDesc.word0, 16, 8);
        macEntryExtKeyPtr->key.macVlan.macAddr.arEther[4] =
                                      (GT_U8)U32_GET_FIELD_MAC(auDesc.word0, 24, 8);
        macEntryExtKeyPtr->key.macVlan.macAddr.arEther[3] =
                                       (GT_U8)U32_GET_FIELD_MAC(auDesc.word1, 0, 8);
        macEntryExtKeyPtr->key.macVlan.macAddr.arEther[2] =
                                       (GT_U8)U32_GET_FIELD_MAC(auDesc.word1, 8, 8);
        macEntryExtKeyPtr->key.macVlan.macAddr.arEther[1] =
                                      (GT_U8)U32_GET_FIELD_MAC(auDesc.word1, 16, 8);
        macEntryExtKeyPtr->key.macVlan.macAddr.arEther[0] =
                                      (GT_U8)U32_GET_FIELD_MAC(auDesc.word1, 24, 8);
    }
    else /* The entry is IPv4 or IPv6 Multicast */
    {
        macEntryExtKeyPtr->key.ipMcast.vlanId =
                                     (GT_U16)U32_GET_FIELD_MAC(auDesc.word2, 0, 12);
        vlanId = macEntryExtKeyPtr->key.ipMcast.vlanId;

        macEntryExtKeyPtr->key.ipMcast.dip[3] =
            (GT_U8)U32_GET_FIELD_MAC(auDesc.word0, 16, 8);
        macEntryExtKeyPtr->key.ipMcast.dip[2] =
            (GT_U8)U32_GET_FIELD_MAC(auDesc.word0, 24, 8);
        macEntryExtKeyPtr->key.ipMcast.dip[1] =
             (GT_U8)U32_GET_FIELD_MAC(auDesc.word1, 0, 8);
        macEntryExtKeyPtr->key.ipMcast.dip[0] =
             (GT_U8)U32_GET_FIELD_MAC(auDesc.word1, 8, 8);
        macEntryExtKeyPtr->key.ipMcast.sip[3] =
             (GT_U8)U32_GET_FIELD_MAC(auDesc.word1, 16, 8);
        macEntryExtKeyPtr->key.ipMcast.sip[2] =
            (GT_U8)U32_GET_FIELD_MAC(auDesc.word1, 24, 8);
        macEntryExtKeyPtr->key.ipMcast.sip[1] =
            (GT_U8)U32_GET_FIELD_MAC(auDesc.word3, 0, 8);
        macEntryExtKeyPtr->key.ipMcast.sip[0] =
             (GT_U8)(U32_GET_FIELD_MAC(auDesc.word3, 8, 4) |
             (U32_GET_FIELD_MAC(auDesc.word3, 27, 4) << 4));


    }


    if(PRV_CPSS_PP_MAC(devNum)->devFamily != CPSS_PP_FAMILY_CHEETAH_E)
    {
        if (naFormatVersion == 0)
        {
            addrUpMsgPtr->macEntry.daSecurityLevel =
                (GT_U8)U32_GET_FIELD_MAC(auDesc.word0, 1, 3);
            addrUpMsgPtr->macEntry.saSecurityLevel =
                (GT_U8)U32_GET_FIELD_MAC(auDesc.word0, 12, 3);
        }
        else
        {
            /* set default values */
            addrUpMsgPtr->macEntry.daSecurityLevel =
            addrUpMsgPtr->macEntry.saSecurityLevel = 0;
        }
        addrUpMsgPtr->macEntry.appSpecificCpuCode =
                                    (GT_U8)U32_GET_FIELD_MAC(auDesc.word2, 29, 1);
    }

    /* If this is a QR message copy entryFound */
    if (CPSS_QR_E == addrUpMsgPtr->updType)
    {
        addrUpMsgPtr->entryWasFound = (GT_U8)U32_GET_FIELD_MAC(auDesc.word0, 15, 1);
    }
    else
    {
        addrUpMsgPtr->entryWasFound = 0;
    }

    if (naFormatVersion == 0)
    {
        addrUpMsgPtr->skip =  (GT_U8)U32_GET_FIELD_MAC(auDesc.word2, 12, 1);
        addrUpMsgPtr->aging = (GT_U8)U32_GET_FIELD_MAC(auDesc.word2, 13, 1);
    }
    else
    {
        /* set default values */
        addrUpMsgPtr->skip  = GT_FALSE;
        addrUpMsgPtr->aging = GT_TRUE;
    }
    addrUpMsgPtr->macEntry.age = addrUpMsgPtr->aging;

    addrUpMsgPtr->macEntry.spUnknown =
        BIT2BOOL_MAC(((auDesc.word2 >> 14) & 1));

    if (naFormatVersion == 0)
    {
        multiple = U32_GET_FIELD_MAC(auDesc.word2,15, 1);
    }
    else
    {
        /* set default values */
        multiple = 0;
    }

    if((multiple == 1)|| U32_GET_FIELD_MAC(auDesc.word1, 24, 1) ||
       (macEntryExtKeyPtr->entryType  != CPSS_MAC_ENTRY_EXT_TYPE_MAC_ADDR_E))
    {
        addrUpMsgPtr->macEntry.dstInterface.vidx =
            (GT_U16)U32_GET_FIELD_MAC(auDesc.word2, 17, 12);

        /* multiple or multicast */
        if(addrUpMsgPtr->macEntry.dstInterface.vidx == 0xFFF)
        {
            addrUpMsgPtr->macEntry.dstInterface.type = CPSS_INTERFACE_VID_E;
            addrUpMsgPtr->macEntry.dstInterface.vlanId = vlanId;
        }
        else
        {
            addrUpMsgPtr->macEntry.dstInterface.type = CPSS_INTERFACE_VIDX_E;
        }

    }
    else
    {
        addrUpMsgPtr->macEntry.userDefined = U32_GET_FIELD_MAC(auDesc.word2, 25, 4);
        if((GT_U8)U32_GET_FIELD_MAC(auDesc.word2, 17, 1) == 1)
        {/* the message is associated with a trunk */
            addrUpMsgPtr->macEntry.dstInterface.trunkId =
                (GT_U8)U32_GET_FIELD_MAC(auDesc.word2, 18, 7);
            addrUpMsgPtr->macEntry.dstInterface.type = CPSS_INTERFACE_TRUNK_E;
        }
        else/* the message is associated with a port */
        {
            addrUpMsgPtr->macEntry.dstInterface.devPort.portNum =
                (GT_U8)U32_GET_FIELD_MAC(auDesc.word2, 18, 6);
            addrUpMsgPtr->macEntry.dstInterface.devPort.devNum =
                addrUpMsgPtr->associatedDevNum;
            addrUpMsgPtr->macEntry.dstInterface.type = CPSS_INTERFACE_PORT_E;
        }

    }

    if (naFormatVersion == 0)
    {
        addrUpMsgPtr->macEntry.isStatic = (GT_U8)U32_GET_FIELD_MAC(auDesc.word3, 18, 1);

        addrUpMsgPtr->macEntry.daQosIndex = (GT_U8)U32_GET_FIELD_MAC(auDesc.word3, 15, 3);
        addrUpMsgPtr->macEntry.saQosIndex = (GT_U8)U32_GET_FIELD_MAC(auDesc.word3, 12, 3);

        HW_FORMAT_2_CMD_MAC((GT_U8)U32_GET_FIELD_MAC(auDesc.word3, 21, 3),
                        addrUpMsgPtr->macEntry.daCommand);
        HW_FORMAT_2_CMD_MAC((GT_U8)U32_GET_FIELD_MAC(auDesc.word3, 24, 3),
                         addrUpMsgPtr->macEntry.saCommand);


        addrUpMsgPtr->macEntry.mirrorToRxAnalyzerPortEn =
                                        (GT_BOOL)U32_GET_FIELD_MAC(auDesc.word3, 31, 1);

        addrUpMsgPtr->macEntry.daRoute = (GT_BOOL)U32_GET_FIELD_MAC(auDesc.word2, 30, 1);
    }
    else
    {
        /* set default values */
        addrUpMsgPtr->macEntry.isStatic = GT_FALSE;
        addrUpMsgPtr->macEntry.daQosIndex = 
        addrUpMsgPtr->macEntry.saQosIndex = 0;
        addrUpMsgPtr->macEntry.daCommand = CPSS_MAC_TABLE_FRWRD_E;
        addrUpMsgPtr->macEntry.saCommand = CPSS_MAC_TABLE_FRWRD_E;
        addrUpMsgPtr->macEntry.mirrorToRxAnalyzerPortEn = GT_FALSE;
        addrUpMsgPtr->macEntry.daRoute = 0;
    }

    addrUpMsgPtr->macEntry.sourceID = (GT_U8)U32_GET_FIELD_MAC(auDesc.word3, 2, 5);

    addrUpMsgPtr->naChainIsTooLong = (GT_BOOL)U32_GET_FIELD_MAC(auDesc.word2, 31, 1);
    addrUpMsgPtr->queryDevNum = PRV_CPSS_HW_DEV_NUM_MAC(devNum);

    if((addrUpMsgPtr->updType == CPSS_NA_E) ||
       (addrUpMsgPtr->updType == CPSS_QR_E) ||
       (addrUpMsgPtr->updType == CPSS_QA_E))
    {
        addrUpMsgPtr->entryOffset = U32_GET_FIELD_MAC(auDesc.word0, 7, 5);
    }

    if((addrUpMsgPtr->updType == CPSS_AA_E) ||
        (addrUpMsgPtr->updType == CPSS_TA_E))
    {
        addrUpMsgPtr->macEntryIndex = U32_GET_FIELD_MAC(auDesc.word0, 7, 8);
        if(macEntryExtKeyPtr->entryType == CPSS_MAC_ENTRY_EXT_TYPE_MAC_ADDR_E)
        {
            addrUpMsgPtr->macEntryIndex |=
                ((U32_GET_FIELD_MAC(auDesc.word3, 27, 4) << 8) |
                 (U32_GET_FIELD_MAC(auDesc.word3, 0, 2) << 12));
        }

    }

    if (naFormatVersion == 1) 
    {
        /* vid1 */
        addrUpMsgPtr->vid1 = 
            (GT_U16)(U32_GET_FIELD_MAC(auDesc.word0, 1, 2) |            /* bits 1..2 */
                     (U32_GET_FIELD_MAC(auDesc.word0, 12, 3) << 2) |    /* bits 12..14 */
                     (U32_GET_FIELD_MAC(auDesc.word3, 27, 4) << 5) |    /* bits 123..126 */
                     (U32_GET_FIELD_MAC(auDesc.word3, 0, 2) << 9) |     /* bits 96..97 */
                     (U32_GET_FIELD_MAC(auDesc.word0, 15, 1) << 11));   /* bit 15 */

        /* up0 */
        addrUpMsgPtr->up0 = U32_GET_FIELD_MAC(auDesc.word3, 12, 3);

        /* check if the station was moved */
        addrUpMsgPtr->isMoved = (GT_BOOL)U32_GET_FIELD_MAC(auDesc.word2, 16, 1);

        if (addrUpMsgPtr->isMoved == GT_TRUE) 
        {
            addrUpMsgPtr->oldSrcId = 
                (U32_GET_FIELD_MAC(auDesc.word3, 31, 1) |           /* bit 127 */
                 (U32_GET_FIELD_MAC(auDesc.word3, 21, 3) << 1) |    /* bits 117..119 */
                 (U32_GET_FIELD_MAC(auDesc.word2, 30, 1) << 4));    /* bit 94   */

            addrUpMsgPtr->oldAssociatedDevNum = 
                (GT_U8)(U32_GET_FIELD_MAC(auDesc.word3, 19, 2) |           /* bit 115..116 */
                        (U32_GET_FIELD_MAC(auDesc.word3, 15, 3) << 2));    /* bit 111..113 */

            oldPortTrunk = (U32_GET_FIELD_MAC(auDesc.word0, 3, 1) |         /* bit 3 */
                            (U32_GET_FIELD_MAC(auDesc.word2, 15, 1) << 1) | /* bit 79 */
                            (U32_GET_FIELD_MAC(auDesc.word2, 13, 1) << 2) | /* bit 77 */
                            (U32_GET_FIELD_MAC(auDesc.word2, 12, 1) << 3) | /* bit 76 */
                            (U32_GET_FIELD_MAC(auDesc.word3, 24, 3) << 4)); /* bits 120..122 */

            /* check if old interface type is port or trunk */
            if((GT_U8)U32_GET_FIELD_MAC(auDesc.word3, 18, 1) == 1)
            {
                /* the old interface is associated with a trunk */
                addrUpMsgPtr->oldDstInterface.trunkId = (GT_TRUNK_ID)oldPortTrunk;
                addrUpMsgPtr->oldDstInterface.type = CPSS_INTERFACE_TRUNK_E;
            }
            else
            {
                /* the old interface is associated with a port */
                addrUpMsgPtr->oldDstInterface.devPort.portNum = 
                    (GT_U8)oldPortTrunk;
                addrUpMsgPtr->oldDstInterface.devPort.devNum =
                    (GT_U8)addrUpMsgPtr->oldAssociatedDevNum;
                addrUpMsgPtr->macEntry.dstInterface.type = CPSS_INTERFACE_PORT_E;
            }
        }
    }

    return GT_OK;
}

/*******************************************************************************
* auMsgFifoBlockDevGet
*
* DESCRIPTION:
*       Device specific get function for AU messages from FIFO -
*       from specific port group - for multi-port-groups support
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; Lion; xCat2.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum     - the device number from which AU are taken
*       portGroupId       - the portGroupId - for multi-port-groups support
*       numOfAuPtr - (pointer to)max number of AU messages to get
*
* OUTPUTS:
*       numOfAuPtr - (pointer to)actual number of AU messages that were received
*       auMessagesPtr - array that holds received AU messages
*                       pointer is allocated by the caller , with enough memory
*                       for *numOfAuPtr entries that was given as INPUT
*                       parameter.
*
* RETURNS:
*       GT_OK       - on success
*       GT_NO_MORE  - the action succeeded and there are no more waiting
*                     AU messages
*
*       GT_FAIL     - on failure
*       GT_BAD_PTR  - one of the parameters is NULL pointer
*
* COMMENTS:
*       None
*
*
*
*******************************************************************************/
static GT_STATUS auMsgFifoBlockGet
(
    IN     GT_U8                       devNum,
    IN     GT_U32                      portGroupId,
    INOUT  GT_U32                      *numOfAuPtr,
    OUT    CPSS_MAC_UPDATE_MSG_EXT_STC *auMessagesPtr

)
{
    GT_U32                  auCnt;          /* current AU count             */
    GT_U32                  auMaxCnt;       /* size of AU arr from user     */
    GT_U32                  auQBaseAddr;    /* register address             */
    PRV_CPSS_AU_DESC_STC    auDesc;         /* AU descriptor                */
    GT_U32                  *auWordPtr;     /* pointer to AU table          */
    GT_STATUS               retVal;         /* return value                 */
    GT_U32                  wordNum;        /* number of read words         */

    auQBaseAddr = PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.auQBaseAddr;

    auMaxCnt = *numOfAuPtr;

    *numOfAuPtr = 0;
    for (auCnt = 0; auCnt < auMaxCnt; auCnt++)
    {
        auWordPtr = (GT_U32*)&auDesc;

        /* get the AU message from HW */
        for (wordNum = 0; wordNum < 4; wordNum++, auWordPtr++)
        {
            retVal = prvCpssDrvHwPpPortGroupReadRegister(devNum, portGroupId,auQBaseAddr,auWordPtr);
            if (GT_OK != retVal)
            {
                return retVal;
            }

            if (0xFFFFFFFF == *auWordPtr)
            {
                if (0 == wordNum)
                {
                    /* no more addresses ! */
                    return GT_NO_MORE;
                }
            }
        }

        /* get the Address Update message from AU descriptor */
        retVal = auDesc2UpdMsg(devNum,portGroupId, &auDesc, GT_FALSE, &auMessagesPtr[(*numOfAuPtr)]);
        if(retVal != GT_OK)
            return retVal;

        /* check that the function auDesc2UpdMsg(...) does not reset the AU
          descriptor. An application should not get the message if
          auDesc2UpdMsg resets the descriptor. */
        if(AU_DESC_IS_NOT_VALID(&auDesc))
        {
                auCnt--;/* try to find other message to put for application */
        }
        else
        {
            /* increment the actual number of AU messages */
            (*numOfAuPtr)++;
        }
    }

    return GT_OK;
}


/*******************************************************************************
* prvDxChBrgFdbAuMsgFifoBlockDevGet
*
* DESCRIPTION:
*       Device specific get function for AU messages from FIFO
*
*       for multi-port groups device :
*           AU messages -
*           1. Unified FDB mode:
*              portGroup indication is required , for:
*                 a. Aging calculations of Trunks
*                 b. Aging calculations of regular entries when DA refresh is enabled.
*              In these 2 cases entries are considered as aged-out only if AA is
*              receives from all 4 portGroups.
*           2. In Unified-Linked FDB mode and Linked FDB 128K mode:
*              portGroup indication is required for these reasons:
*                 a. Aging calculations of Trunk and regular entries which have
*                    been written to multiple portGroups.
*                 b. New addresses (NA) source portGroup indication is required
*                    so application can add new entry to the exact portGroup
*                    which saw this station (especially on trunk entries).
*                 c. Indication on which portGroup has removed this address when
*                    AA of delete is fetched (relevant when same entry was written
*                    to multiple portGroups).
*                 d. Indication on which portGroup currently has this address
*                    when QR (query reply) is being fetched (relevant when same
*                    entry was written to multiple portGroups).
*
*           the function fetch AU messages from the queues in a round robin manner
*           (in steps of one entry).the function store which queue was last checked,
*           such that next message should be fetched from the next queue that
*           hold messages until the number of requested messages could be
*           supplied to application.
*           As one can understand, algorithm described above might create
*           undesired functional behaviors for the application:
*           1. Out-of-order messages -
*               since the fetching of messages from the 4 portGroups, is not
*               synchronized with messages' arrival order, possibly, application
*               would treat the updates not in the right order -
*               for example station X has been relocated to location A and then
*               location B - this will create 2 NA messages, NA with location A and
*               then NA with location B, if we'll treat these messages in wrong
*               order - we'll end up configuring station to location B and then A.
*               (specifically this example is not so bad cause even we do set station
*               with location A additional NA would be sent repeating location B
*               until rightly configured).
*               Note that there is no WA that can fix this undesired behavior.
*
*           FU messages -
*           since FU is triggered on all port groups , 'duplicated' messages may
*           appear on entries that reside on several/all port groups.
*
*           the function fetch FU messages from the queues in a round robin manner
*           (in steps of one entry).the function store which queue was last checked,
*           such that next message should be fetched from the next queue that
*           hold messages until the number of requested messages could be
*           supplied to application.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; Lion; xCat2.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum     - the device number from which AU are taken
*       numOfAuPtr - (pointer to)max number of AU messages to get
*
* OUTPUTS:
*       numOfAuPtr - (pointer to)actual number of AU messages that were received
*       auMessagesPtr - array that holds received AU messages
*                       pointer is allocated by the caller , with enough memory
*                       for *numOfAuPtr entries that was given as INPUT
*                       parameter.
*
* RETURNS:
*       GT_OK       - on success
*       GT_NO_MORE  - the action succeeded and there are no more waiting
*                     AU messages
*
*       GT_FAIL     - on failure
*       GT_BAD_PTR  - one of the parameters is NULL pointer
*
* COMMENTS:
*       None
*
*
*
*******************************************************************************/
static GT_STATUS prvDxChBrgFdbAuMsgFifoBlockDevGet
(
    IN     GT_U8                       devNum,
    INOUT  GT_U32                      *numOfAuPtr,
    OUT    CPSS_MAC_UPDATE_MSG_EXT_STC *auMessagesPtr

)
{
    GT_STATUS               rc = GT_OK;
    GT_U32                  auCnt;          /* current AU count             */
    GT_U32                  auMaxCnt;       /* size of AU arr from user     */
    GT_U32                  portGroupsBmp;/* port groups to query - support multi-port-groups device */
    GT_U32  portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32  perPortGroupNumOfAu = 1;/* number of AU to serve from each port group , before query other port groups */
    GT_U32  *lastPortGroupServedPtr;/* pointer to the last port group served */

    if(0 == PRV_CPSS_IS_MULTI_PORT_GROUPS_DEVICE_MAC(devNum))
    {
        /* non multi-port-groups device */
        return auMsgFifoBlockGet(devNum ,
                CPSS_NON_MULTI_PORT_GROUP_DEVICE_INDEX_CNS,
                numOfAuPtr ,
                auMessagesPtr);
    }

    lastPortGroupServedPtr = &PRV_CPSS_PP_MAC(devNum)->portGroupsInfo.auqPortGroupIdLastServed;

    auMaxCnt = *numOfAuPtr;

    /* start with bmp of all active port groups */
    portGroupsBmp = PRV_CPSS_PP_MAC(devNum)->portGroupsInfo.activePortGroupsBmp;

    /* we start we the next port group , from the last treated */
    portGroupId =  *lastPortGroupServedPtr;

    for (auCnt = 0; (auCnt < auMaxCnt); auCnt += perPortGroupNumOfAu)
    {
        do
        {
            portGroupId++;
            if(portGroupId > PRV_CPSS_PP_MAC(devNum)->portGroupsInfo.lastActivePortGroup)
            {
                portGroupId = PRV_CPSS_PP_MAC(devNum)->portGroupsInfo.firstActivePortGroup;
            }
        }
        while(0 == (portGroupsBmp & (1 << portGroupId)) );/* look for port group to query */

        perPortGroupNumOfAu = prvCpssDxChPerPortGroupNumOfAu;

        rc = auMsgFifoBlockGet(devNum ,portGroupId, &perPortGroupNumOfAu , &auMessagesPtr[auCnt]);
        if(rc == GT_OK)
        {
            /* this port group returned the messages */
            /* continue to other port groups         */
        }
        else if(rc == GT_NO_MORE)
        {
            /* this port group has no more messages */
            /* continue to other port groups , but remove this port group from the bmp to query */
            portGroupsBmp &= ~(1 << portGroupId);

            if(portGroupsBmp == 0)
            {
                /* update the number of messages returned */
                auCnt += perPortGroupNumOfAu;
                /* all port groups finished */
                break;
            }
        }
        else
        {
            /* error */
            return rc;
        }

    }

    *numOfAuPtr = auCnt;

    /* save the info about the last port group served */
    *lastPortGroupServedPtr = portGroupId;

    return rc;
}


/*******************************************************************************
* auFuMsgBlockGet
*
* DESCRIPTION:
*       The function return a block (array) of AU / FU messages , the max number
*       of elements defined by the caller
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; Lion; xCat2.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum         - the device number from which AU / FU are taken
*       portGroupId       - the portGroupId - for multi-port-groups support
*       queueType       - type of message queue to retrieve entries from
*       numOfAuFuPtr - (pointer to)actual number of AU / FU messages that
*                          were received
*
* OUTPUTS:
*       numOfAuFuPtr - (pointer to)actual number of AU / FU messages that
*                          were received
*       auFuMessagesPtr - array that holds received AU / FUmessages
*                       pointer is allocated by the caller , with enough memory
*                       for *numOfAuPtr entries that was given as INPUT
*                       parameter.
*
* RETURNS:
*       GT_OK           - on success
*       GT_NO_MORE      - the action succeeded and there are no more waiting
*                         AU messages
*
*       GT_FAIL         - on failure
*       GT_BAD_PTR      - one of the parameters is NULL pointer
*       GT_BAD_STATE    - not all results of the CNC block upload
*                         retrieved from the common used FU and CNC
*                         upload queue
*
* COMMENTS:
*       None
*
*
*
*******************************************************************************/
static GT_STATUS auFuMsgBlockGet
(
    IN     GT_U8                       devNum,
    IN     GT_U32                      portGroupId,
    IN     MESSAGE_QUEUE_ENT           queueType,
    INOUT  GT_U32                      *numOfAuFuPtr,
    OUT    CPSS_MAC_UPDATE_MSG_EXT_STC *auFuMessagesPtr
)
{
    PRV_CPSS_AU_DESC_STC        *descPtr;   /*pointer to the current descriptor*/
    PRV_CPSS_AU_DESC_CTRL_STC   *descCtrlPtr;  /* pointer to the descriptors DB
                                                 of the device */
    PRV_CPSS_AU_DESC_STC        *descBlockPtr; /* AU descriptors block */
    GT_U32                      ii;            /* iterator */
    GT_U32                      phyAddr;       /* phy address */
    GT_U32                      auMaxCnt;      /* number of AU / FU messages */
    GT_U32                      regAddr;       /* register address */
    GT_STATUS                   rc;            /* return code                */
    GT_U32                      numOfWaAu;/* get messages one by one from the secondary AUQ*/
    GT_U32                      regValue;

     switch(queueType)
    {
        case MESSAGE_QUEUE_PRIMARY_FUQ_E:
            /* check that the FUQ initialized */
            PRV_CPSS_FUQ_DESCRIPTORS_INIT_DONE_CHECK_MAC(devNum);

            /* use separate FU queue if enabled, otherwise use common AU queue */
            descCtrlPtr = &(PRV_CPSS_PP_MAC(devNum)->intCtrl.fuDescCtrl[portGroupId]);
            regAddr =  PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.fuQBaseAddr;

            /* not all upload CNC counter messages retrieved from the common */
            /* used queue                                                   */
            if (PRV_CPSS_DXCH3_FAMILY_CHECK_MAC(devNum)
                && (descCtrlPtr->unreadCncCounters != 0))
            {
                return GT_BAD_STATE;
            }

            break;

        case MESSAGE_QUEUE_SECONDARY_AUQ_E:
            descCtrlPtr = &(PRV_CPSS_PP_MAC(devNum)->intCtrl.secondaryAuDescCtrl[portGroupId]);
            regAddr =  PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.auQBaseAddr;
            break;
        case MESSAGE_QUEUE_PRIMARY_AUQ_E:
            /* check that the AUQ initialized */
            PRV_CPSS_AUQ_DESCRIPTORS_INIT_DONE_CHECK_MAC(devNum);

            descCtrlPtr = &(PRV_CPSS_PP_MAC(devNum)->intCtrl.auDescCtrl[portGroupId]);
            regAddr =  PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.auQBaseAddr;
            break;
        default:
            return GT_BAD_PARAM;/*should not happen*/
    }

    /* when the primary AUQ is called , and it's SW index is 0 , we need to
       check if there a reason to query the secondary AUQ , because those
       messages comes chronologically after the 'previous' primary auq messages
       and before the current messages in the primary AUQ */
    if((descCtrlPtr->currDescIdx == 0) &&
       (queueType == MESSAGE_QUEUE_PRIMARY_AUQ_E) &&
       (PRV_CPSS_PP_MAC(devNum)->intCtrl.auqDeadLockWa[portGroupId].needToCheckSecondaryAuQueue == GT_TRUE))
    {
        numOfWaAu = *numOfAuFuPtr;
        rc = auFuMsgBlockGet(devNum,portGroupId,MESSAGE_QUEUE_SECONDARY_AUQ_E,
                                  &numOfWaAu,auFuMessagesPtr);

        if(rc != GT_NO_MORE)
        {
            /* if we got the GT_OK it means that the buffer was filled with
            messages from the secondary queue , otherwise there was error and we
            exit the function anyway */

            return rc;
        }

        /* NOTE: meaning we got GT_NO_MORE , so we need to continue and getting
                messages from the primary AUQ */

        /* set ii to continue handling messages from the primary queue */
        ii = numOfWaAu;
    }
    else
    {
        /* initialize ii , to indicate that no messages already exist in the buffer */
        ii = 0;
        /* initialize rc - because function return rc */
        rc = GT_OK;
    }

    /* get address of AU descriptors block */
    descBlockPtr = (PRV_CPSS_AU_DESC_STC*)(descCtrlPtr->blockAddr);

    /* pointer to the current descriptor */
    descPtr = &(descBlockPtr[descCtrlPtr->currDescIdx]);

    auMaxCnt = *numOfAuFuPtr;

    *numOfAuFuPtr = ii;

    /* read number of AU descriptors */
    for (/*ii was already initialized*/; ii < auMaxCnt; ii++)
    {
        if(!AU_DESC_IS_NOT_VALID(descPtr))
        {
            rc = auDesc2UpdMsg(devNum, portGroupId ,descPtr , GT_TRUE, &auFuMessagesPtr[ii]);
            if(rc != GT_OK)
                return rc;
            if(AU_DESC_IS_NOT_VALID(descPtr))
            {
                /* the function auDesc2UpdMsg(...) reset the info */
                /* meaning that Application should not get the message */

                ii--;/* try to find other message to put for application */
            }
            else
            {
                AU_DESC_RESET_MAC(descPtr);
                /* increment the actual number of AU messages */
                (*numOfAuFuPtr)++;
            }
        }
        else
        {
            /* no more AU descriptors */
            return GT_NO_MORE;
        }

        descCtrlPtr->currDescIdx = ((descCtrlPtr->currDescIdx + 1) %
                                   descCtrlPtr->blockSize);

        /* point descPtr to the next AU descriptor in the queue */
        descPtr = &(descBlockPtr[descCtrlPtr->currDescIdx]);

        /* reached the end of AU block */
        if(descCtrlPtr->currDescIdx == 0)
        {
            if((PRV_CPSS_PP_MAC(devNum)->intCtrl.auqDeadLockWa[portGroupId].needToCheckSecondaryAuQueue  == GT_TRUE) &&
               queueType == MESSAGE_QUEUE_PRIMARY_AUQ_E)
            {
                /* get messages from the secondary AUQ , that was set by the WA
                in function cpssExMxPmBrgFdbTriggerAuQueueWa(...) */

                /* increment ii because the message in [ii] was already placed */
                /* and we not continuing the above loop on ii */
                ii++;

                for ( /*continue ii */  ; ii < auMaxCnt; ii++)
                {
                    /* get the messages one-by-one */
                    numOfWaAu = 1;
                    rc = auFuMsgBlockGet(devNum,portGroupId,MESSAGE_QUEUE_SECONDARY_AUQ_E,
                                    &numOfWaAu,&auFuMessagesPtr[ii]);
                    if(rc == GT_OK && numOfWaAu == 1)
                    {
                        /* increment the actual number of AU messages */
                        (*numOfAuFuPtr)++;
                    }
                    else
                    {
                        /* no more messages to pull from the secondary pool */
                        break;
                    }
                }
            }

            if(queueType == MESSAGE_QUEUE_PRIMARY_AUQ_E)
            {
                /* get a the value of the AUQ size */
                rc = prvCpssDrvHwPpPortGroupGetRegField(devNum,portGroupId,
                            PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.auQControl,
                            0, 29,
                            &regValue);
                if(rc != GT_OK)
                {
                    return rc;
                }

                if(regValue != descCtrlPtr->blockSize)
                {
                    /* set the 'primary' AUQ size */
                    rc = prvCpssDrvHwPpPortGroupSetRegField(devNum,portGroupId,
                                PRV_CPSS_DXCH_DEV_REGS_MAC(devNum)->globalRegs.auQControl,
                                0, 29,
                                descCtrlPtr->blockSize);/* 'primary' AUQ */
                    if (rc != GT_OK)
                    {
                        return rc;
                    }
                }

                /* now we will set the 'primary' AUQ base address*/
            }
            /* when this function called to 'get messages from the secondary AUQ
               we must not write to the PP it's base address again because
               we need to restore the primary base address , but the primary
               base address will be set on it's own code flow */
            else if(queueType == MESSAGE_QUEUE_SECONDARY_AUQ_E)
            {
                /* state that we finished reading the secondary AUQ till the end
                   of it , so no need to query it again */
                PRV_CPSS_PP_MAC(devNum)->intCtrl.
                    auqDeadLockWa[portGroupId].needToCheckSecondaryAuQueue = GT_FALSE;

                /* DO NOT write the secondary base address to the HW ,
                    only the function cpssExMxPmBrgFdbTriggerAuQueueWa do that
                    and the application must call it , ONLY when a deadlock is
                    detected by the application
                */

                /* this will exit the function with GT_OK */
                break;
            }

            /* reset the AU descriptors queue */
            cpssOsVirt2Phy(descCtrlPtr->blockAddr,&phyAddr);
            rc = prvCpssDrvHwPpPortGroupWriteRegister(devNum,portGroupId ,regAddr,phyAddr);
            if(rc != GT_OK)
                return rc;


            if(queueType == MESSAGE_QUEUE_PRIMARY_AUQ_E)
            {
                /* indicate the primary AUQ was rewind */
                PRV_CPSS_PP_MAC(devNum)->intCtrl.auqDeadLockWa[portGroupId].auqRewind = GT_TRUE;
            }

            break;
        }
    }

    return rc;
}

/*******************************************************************************
* prvDxChBrgFdbAuFuMsgBlockGet
*
* DESCRIPTION:
*       The function return a block (array) of AU / FU messages , the max number
*       of elements defined by the caller
*
*       for multi-port groups device :
*           AU messages -
*           1. Unified FDB mode:
*              portGroup indication is required , for:
*                 a. Aging calculations of Trunks
*                 b. Aging calculations of regular entries when DA refresh is enabled.
*              In these 2 cases entries are considered as aged-out only if AA is
*              receives from all 4 portGroups.
*           2. In Unified-Linked FDB mode and Linked FDB 128K mode:
*              portGroup indication is required for these reasons:
*                 a. Aging calculations of Trunk and regular entries which have
*                    been written to multiple portGroups.
*                 b. New addresses (NA) source portGroup indication is required
*                    so application can add new entry to the exact portGroup
*                    which saw this station (especially on trunk entries).
*                 c. Indication on which portGroup has removed this address when
*                    AA of delete is fetched (relevant when same entry was written
*                    to multiple portGroups).
*                 d. Indication on which portGroup currently has this address
*                    when QR (query reply) is being fetched (relevant when same
*                    entry was written to multiple portGroups).
*
*           the function fetch AU messages from the queues in a round robin manner
*           (in steps of one entry).the function store which queue was last checked,
*           such that next message should be fetched from the next queue that
*           hold messages until the number of requested messages could be
*           supplied to application.
*           As one can understand, algorithm described above might create
*           undesired functional behaviors for the application:
*           1. Out-of-order messages -
*               since the fetching of messages from the 4 portGroups, is not
*               synchronized with messages' arrival order, possibly, application
*               would treat the updates not in the right order -
*               for example station X has been relocated to location A and then
*               location B - this will create 2 NA messages, NA with location A and
*               then NA with location B, if we'll treat these messages in wrong
*               order - we'll end up configuring station to location B and then A.
*               (specifically this example is not so bad cause even we do set station
*               with location A additional NA would be sent repeating location B
*               until rightly configured).
*               Note that there is no WA that can fix this undesired behavior.
*
*           FU messages -
*           since FU is triggered on all port groups , 'duplicated' messages may
*           appear on entries that reside on several/all port groups.
*
*           the function fetch FU messages from the queues in a round robin manner
*           (in steps of one entry).the function store which queue was last checked,
*           such that next message should be fetched from the next queue that
*           hold messages until the number of requested messages could be
*           supplied to application.
*
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; Lion; xCat2.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum        - the device number from which AU / FU are taken
*       queueType     - AUQ or FUQ. FUQ valid for DxCh2 and above.
*       numOfAuFuPtr  - (pointer to)actual number of AU / FU messages that
*                          were received
*
* OUTPUTS:
*       numOfAuFuPtr - (pointer to)actual number of AU / FU messages that
*                          were received
*       auFuMessagesPtr - array that holds received AU / FUmessages
*                       pointer is allocated by the caller , with enough memory
*                       for *numOfAuPtr entries that was given as INPUT
*                       parameter.
*
* RETURNS:
*       GT_OK           - on success
*       GT_NO_MORE      - the action succeeded and there are no more waiting
*                         AU messages
*
*       GT_FAIL         - on failure
*       GT_BAD_PTR      - one of the parameters is NULL pointer
*       GT_BAD_STATE    - not all results of the CNC block upload
*                         retrieved from the common used FU and CNC
*                         upload queue
*
* COMMENTS:
*       None
*
*******************************************************************************/
static GT_STATUS prvDxChBrgFdbAuFuMsgBlockGet
(
    IN     GT_U8                       devNum,
    IN     MESSAGE_QUEUE_ENT           queueType,
    INOUT  GT_U32                      *numOfAuFuPtr,
    OUT    CPSS_MAC_UPDATE_MSG_EXT_STC *auFuMessagesPtr
)
{
    GT_STATUS               rc = GT_OK;
    GT_U32                  auCnt;          /* current AU count             */
    GT_U32                  auMaxCnt;       /* size of AU arr from user     */
    GT_U32                  portGroupsBmp;/* port groups to query - support multi-port-groups device */
    GT_U32  portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32  perPortGroupNumOfAu = prvCpssDxChPerPortGroupNumOfAu;/* number of AU to serve from each port group , before query other port groups */
    GT_U32  *lastPortGroupServedPtr;/* pointer to the last port group served */

    if(0 == PRV_CPSS_IS_MULTI_PORT_GROUPS_DEVICE_MAC(devNum))
    {
        /* non multi-port-groups device */
        return auFuMsgBlockGet(devNum ,
                CPSS_NON_MULTI_PORT_GROUP_DEVICE_INDEX_CNS,
                queueType,
                numOfAuFuPtr ,
                auFuMessagesPtr);
    }

    if(queueType != MESSAGE_QUEUE_PRIMARY_FUQ_E)
    {
        lastPortGroupServedPtr = &PRV_CPSS_PP_MAC(devNum)->portGroupsInfo.auqPortGroupIdLastServed;
    }
    else
    {
        lastPortGroupServedPtr = &PRV_CPSS_PP_MAC(devNum)->portGroupsInfo.fuqPortGroupIdLastServed;
    }


    auMaxCnt = *numOfAuFuPtr;

    /* start with bmp of all active port groups */
    portGroupsBmp = PRV_CPSS_PP_MAC(devNum)->portGroupsInfo.activePortGroupsBmp;

    /* we start we the next port group , from the last treated */
    portGroupId =  *lastPortGroupServedPtr;

    for (auCnt = 0; (auCnt < auMaxCnt); auCnt += perPortGroupNumOfAu)
    {
        do
        {
            portGroupId++;
            if(portGroupId > PRV_CPSS_PP_MAC(devNum)->portGroupsInfo.lastActivePortGroup)
            {
                portGroupId = PRV_CPSS_PP_MAC(devNum)->portGroupsInfo.firstActivePortGroup;
            }
        }
        while(0 == (portGroupsBmp & (1 << portGroupId)) );/* look for port group to query */

        perPortGroupNumOfAu = prvCpssDxChPerPortGroupNumOfAu;

        rc = auFuMsgBlockGet(devNum ,portGroupId, queueType, &perPortGroupNumOfAu , &auFuMessagesPtr[auCnt]);
        if(rc == GT_OK)
        {
            /* this port group returned the messages */
            /* continue to other port groups */
        }
        else if(rc == GT_NO_MORE)
        {
            /* this port group has no more messages */
            /* continue to other port groups , but remove this port group from the bmp to query */
            portGroupsBmp &= ~(1 << portGroupId);

            if(portGroupsBmp == 0)
            {
                /* update the number of messages returned */
                auCnt += perPortGroupNumOfAu;
                /* all port groups finished */
                break;
            }
        }
        else
        {
            /* error */
            return rc;
        }

    }

    *numOfAuFuPtr = auCnt;

    /* save the info about the last port group served */
    *lastPortGroupServedPtr = portGroupId;

    return rc;
}

/*******************************************************************************
* cpssDxChBrgFdbFuMsgBlockGet
*
* DESCRIPTION:
*       The function return a block (array) of FDB Address Update (AU) messages,
*       the max number of elements defined by the caller.
*       The PP may place FU messages in common FDB Address Update (AU) messages
*       queue or in separate queue only for FU messages. The function
*       cpssDxChHwPpPhase2Init configures queue for FU messages by the
*       fuqUseSeparate parameter. If common AU queue is used then function
*       returns all AU messages in the queue including FU ones.
*       If separate FU queue is used then function returns only FU messages.
*
* APPLICABLE DEVICES:
*        DxCh2; DxCh3; xCat; Lion; xCat2.
*
* NOT APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond.
*
* INPUTS:
*       devNum     - the device number from which FU are taken
*       numOfFuPtr - (pointer to)max number of FU messages to get
*
* OUTPUTS:
*       numOfFuPtr - (pointer to)actual number of FU messages that were received
*       fuMessagesPtr - array that holds received FU messages
*                       pointer is allocated by the caller , with enough memory
*                       for *numOfFuPtr entries that was given as INPUT
*                       parameter.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_NO_MORE       - the action succeeded and there are no more waiting
*                          AU messages
*
*       GT_FAIL                  - on failure
*       GT_BAD_PARAM             - wrong devNum
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_BAD_STATE             - not all results of the CNC block upload
*                          retrieved from the common used FU and CNC
*                          upload queue
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       for multi-port groups device :
*           since FU is triggered on all port groups , 'duplicated' messages may
*           appear on entries that reside on several/all port groups.
*
*******************************************************************************/
GT_STATUS cpssDxChBrgFdbFuMsgBlockGet
(
    IN     GT_U8                       devNum,
    INOUT  GT_U32                      *numOfFuPtr,
    OUT    CPSS_MAC_UPDATE_MSG_EXT_STC *fuMessagesPtr
)
{

    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);
    PRV_CPSS_NOT_APPLICABLE_DEV_CHECK_MAC(devNum, CPSS_CH1_E | CPSS_CH1_DIAMOND_E);


    CPSS_NULL_PTR_CHECK_MAC(numOfFuPtr);
    CPSS_NULL_PTR_CHECK_MAC(fuMessagesPtr);

    if((PRV_CPSS_HW_IF_PCI_COMPATIBLE_MAC(devNum)) &&
        (PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                    info_PRV_CPSS_DXCH_XCAT_FDB_AU_FIFO_CORRUPT_WA_E.
                        enabled == GT_FALSE))
    {
       if(PRV_CPSS_DXCH_PP_MAC(devNum)->moduleCfg.fuqUseSeparate == GT_TRUE)
       {
            return prvDxChBrgFdbAuFuMsgBlockGet(devNum,MESSAGE_QUEUE_PRIMARY_FUQ_E,numOfFuPtr,fuMessagesPtr);
       }
       else
       {
            return prvDxChBrgFdbAuFuMsgBlockGet(devNum,MESSAGE_QUEUE_PRIMARY_AUQ_E,numOfFuPtr,fuMessagesPtr);
       }
    }
    else
    {
        return
          prvDxChBrgFdbAuMsgFifoBlockDevGet(devNum,numOfFuPtr,fuMessagesPtr);
    }

}

/*******************************************************************************
* cpssDxChBrgFdbAuMsgBlockGet
*
* DESCRIPTION:
*       The function return a block (array) of FDB Address Update (AU) messages,
*       the max number of elements defined by the caller
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; Lion; xCat2.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum     - the device number from which AU are taken
*       numOfAuPtr - (pointer to)max number of AU messages to get
*
* OUTPUTS:
*       numOfAuPtr - (pointer to)actual number of AU messages that were received
*       auMessagesPtr - array that holds received AU messages
*                       pointer is allocated by the caller , with enough memory
*                       for *numOfAuPtr entries that was given as INPUT
*                       parameter.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_NO_MORE  - the action succeeded and there are no more waiting
*                     AU messages
*
*       GT_FAIL                  - on failure
*       GT_BAD_PARAM             - wrong devNum
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       for multi-port groups device :
*           1. Unified FDB mode:
*              portGroup indication is required , for:
*                 a. Aging calculations of Trunks
*                 b. Aging calculations of regular entries when DA refresh is enabled.
*              In these 2 cases entries are considered as aged-out only if AA is
*              receives from all 4 portGroups.
*           2. In Unified-Linked FDB mode and Linked FDB mode:
*              portGroup indication is required for these reasons:
*                 a. Aging calculations of Trunk and regular entries which have
*                    been written to multiple portGroups.
*                 b. New addresses (NA) source portGroup indication is required
*                    so application can add new entry to the exact portGroup
*                    which saw this station (especially on trunk entries).
*                 c. Indication on which portGroup has removed this address when
*                    AA of delete is fetched (relevant when same entry was written
*                    to multiple portGroups).
*                 d. Indication on which portGroup currently has this address
*                    when QR (query reply) is being fetched (relevant when same
*                    entry was written to multiple portGroups).
*
*******************************************************************************/
GT_STATUS cpssDxChBrgFdbAuMsgBlockGet
(
    IN     GT_U8                       devNum,
    INOUT  GT_U32                      *numOfAuPtr,
    OUT    CPSS_MAC_UPDATE_MSG_EXT_STC *auMessagesPtr
)
{
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    CPSS_NULL_PTR_CHECK_MAC(numOfAuPtr);
    CPSS_NULL_PTR_CHECK_MAC(auMessagesPtr);

    if((PRV_CPSS_HW_IF_PCI_COMPATIBLE_MAC(devNum)) &&
       (PRV_CPSS_DXCH_PP_MAC(devNum)->errata.
                   info_PRV_CPSS_DXCH_XCAT_FDB_AU_FIFO_CORRUPT_WA_E.
                       enabled == GT_FALSE))
    {
        return
          prvDxChBrgFdbAuFuMsgBlockGet(devNum,GT_FALSE,numOfAuPtr,auMessagesPtr);
    }
    else
    {
        return
          prvDxChBrgFdbAuMsgFifoBlockDevGet(devNum,numOfAuPtr,auMessagesPtr);
    }

}

/************************************************************************
* auqFuqMessagesNumberGet
*
* DESCRIPTION:
*       The function scan the AU/FU queues and returns the number of
*       AU/FU messages in the queue.
*
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; Lion; xCat2.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum     - the device number on which AU are counted
*       portGroupId       - the portGroupId - for multi-port-groups support
*       queueType - AUQ or FUQ. FUQ valid for DxCh2 and above.
*
* OUTPUTS:
*       numOfAuPtr - (pointer to) number of AU messages in the specified queue.
*       endOfQueueReachedPtr - (pointer to) GT_TRUE: The queue reached to the end.
*                                        GT_FALSE: else
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - wrong devNum, queueType.
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       In order to have the accurate number of entries  application should
*       protect Mutual exclusion between HW access to the AUQ/FUQ
*       SW access to the AUQ/FUQ and calling to this API.
*       i.e. application should stop the PP from sending AU messages to CPU.
*       and should not call  the api's
*       cpssDxChBrgFdbFuMsgBlockGet, cpssDxChBrgFdbFuMsgBlockGet
*
***********************************************************************/
static GT_STATUS auqFuqMessagesNumberGet
(
    IN  GT_U8                         devNum,
    IN  GT_U32                        portGroupId,
    IN  MESSAGE_QUEUE_ENT             queueType,
    OUT GT_U32                       *numOfAuPtr,
    OUT GT_BOOL                      *endOfQueueReachedPtr
)
{
    PRV_CPSS_AU_DESC_STC        *descPtr;   /*pointer to the current descriptor*/
    PRV_CPSS_AU_DESC_CTRL_STC   *descCtrlPtr;  /* pointer to the descriptors DB
                                                 of the device */
    GT_BOOL fixFEr22;      /* GT_TRUE - handle errata 22 */
    GT_U32                      auCounter, tmpWord;
    GT_U8                       associatedDevNum;
    PRV_CPSS_AU_DESC_STC        *descBlockPtr; /* AU descriptors block */
    GT_U32                      ii;            /* iterator */
    CPSS_UPD_MSG_TYPE_ENT       updType;

    if(queueType == MESSAGE_QUEUE_PRIMARY_FUQ_E)
    {
        /* check that the FUQ initialized */
        PRV_CPSS_FUQ_DESCRIPTORS_INIT_DONE_CHECK_MAC(devNum);

        /* use separate FU queue if enabled, otherwise use common AU queue */
        descCtrlPtr = &(PRV_CPSS_PP_MAC(devNum)->intCtrl.fuDescCtrl[portGroupId]);

        /* not all upload CNC counter messages retrieved from the common */
        /* used queue                                                   */
        if (PRV_CPSS_DXCH3_FAMILY_CHECK_MAC(devNum)
            && (descCtrlPtr->unreadCncCounters != 0))
        {
            return GT_BAD_STATE;
        }
    }
    else
    {
        /* check that the AUQ initialized */
        PRV_CPSS_AUQ_DESCRIPTORS_INIT_DONE_CHECK_MAC(devNum);

        descCtrlPtr = &(PRV_CPSS_PP_MAC(devNum)->intCtrl.auDescCtrl[portGroupId]);
    }


    /* get address of AU descriptors block */
    descBlockPtr = (PRV_CPSS_AU_DESC_STC*)(descCtrlPtr->blockAddr);

    /* pointer to the current descriptor */
    descPtr = &(descBlockPtr[descCtrlPtr->currDescIdx]);

    *endOfQueueReachedPtr = GT_FALSE;
    /* read number of AU descriptors */
    for (ii = descCtrlPtr->currDescIdx, auCounter = 0; ii < descCtrlPtr->blockSize; ii++ ,descPtr++)
    {
        if(AU_DESC_IS_NOT_VALID(descPtr))
        {
            /* no more AU descriptors */
            break;
        }

        tmpWord = prvCpssDrvHwPpPortGroupByteSwap(devNum, portGroupId,descPtr->word0);
        updType = (GT_U8)U32_GET_FIELD_MAC(tmpWord, 4, 3);

        tmpWord = prvCpssDrvHwPpPortGroupByteSwap(devNum, portGroupId,descPtr->word3);
        associatedDevNum = (GT_U8)U32_GET_FIELD_MAC(tmpWord, 7, 5);

        if(NON_SOURCE_PORT_GROUP_FILTER_CHECK_MAC(devNum))
        {
            PRV_CPSS_AU_DESC_STC          auDesc;   /* Holds the address updated        */
                                                    /* descriptor after byte-swapping.  */

            /* check if need to 'filter' the message */

            auDesc.word0 = prvCpssDrvHwPpPortGroupByteSwap(devNum, portGroupId , descPtr->word0);
            auDesc.word1 = prvCpssDrvHwPpPortGroupByteSwap(devNum, portGroupId , descPtr->word1);
            auDesc.word2 = prvCpssDrvHwPpPortGroupByteSwap(devNum, portGroupId , descPtr->word2);
            auDesc.word3 = prvCpssDrvHwPpPortGroupByteSwap(devNum, portGroupId , descPtr->word3);

            /* function auDescMultiPortGroupNonSourceFilterCheck , must be called with
               'swapped' auDesc */
            if(GT_TRUE == auDescMultiPortGroupNonSourceFilterCheck(devNum,portGroupId,&auDesc))
            {
                /* 'filter' this AU/FU message */
                continue;
            }
        }

        if(updType == CPSS_AA_E)
        {
            fixFEr22 = PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
                                    PRV_CPSS_DXCH_FDB_AGING_WITH_REMOVAL_MODE_WA_E);

            if((fixFEr22 == GT_TRUE) &&
               (0 == (PRV_CPSS_DXCH_PP_MAC(devNum)->bridge.devTable &
                        (1 << associatedDevNum))))
            {
                /* FEr #22:
                   In Aging with removal mode, AA message is sent for entries
                   removed due to an invalid device
                */

                /* Workaround :
                   The CPU should ignore those messages,
                   after ensuring that the DeviceId is invalid.
                */
                /* Don't count this entry */
                continue;
            }
        }

        auCounter++;
    }

    if( ii == descCtrlPtr->blockSize )
    {
        *endOfQueueReachedPtr = GT_TRUE;
    }

    *numOfAuPtr = auCounter;
    return GT_OK;
}

/************************************************************************
* cpssDxChBrgFdbAuqFuqMessagesNumberGet
*
* DESCRIPTION:
*       The function scan the AU/FU queues and returns the number of
*       AU/FU messages in the queue.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; Lion; xCat2.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum     - the device number on which AU are counted
*       queueType - AUQ or FUQ. FUQ valid for DxCh2 and above.
*
* OUTPUTS:
*       numOfAuPtr - (pointer to) number of AU messages in the specified queue.
*                    for multi-port groups device :
*                       number of AU messages returned is the summary from AUQs
*                       of all port groups.
*       endOfQueueReachedPtr - (pointer to)
*                       for NON multi-port groups device :
*                           GT_TRUE:
*                               The queue reached to the end.
*                           GT_FALSE:
*                               The queue NOT reached to the end.
*                       for multi-port groups device :
*                           GT_TRUE:
*                               At least one queue of the port groups has reached
*                               its end.(this would alert the application to
*                               start fetching the waiting messages, as at least
*                               one of the AUQs can't accept additional messages).
*                           GT_FALSE:
*                               No queue reached to the end.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_BAD_PARAM             - wrong devNum, queueType.
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*       In order to have the accurate number of entries  application should
*       protect Mutual exclusion between HW access to the AUQ/FUQ
*       SW access to the AUQ/FUQ and calling to this API.
*       i.e. application should stop the PP from sending AU messages to CPU.
*       and should not call  the api's
*       cpssDxChBrgFdbFuMsgBlockGet, cpssDxChBrgFdbFuMsgBlockGet
*
***********************************************************************/
GT_STATUS cpssDxChBrgFdbAuqFuqMessagesNumberGet
(
    IN  GT_U8                         devNum,
    IN  CPSS_DXCH_FDB_QUEUE_TYPE_ENT  queueType,
    OUT GT_U32                       *numOfAuPtr,
    OUT GT_BOOL                      *endOfQueueReachedPtr
)
{
    GT_STATUS               rc;
    GT_U32  portGroupId;/*the port group Id - support multi-port-groups device */
    GT_U32  coreValue;
    GT_BOOL portGroupEndOfQueueReached;
    MESSAGE_QUEUE_ENT   internalQueueType;/* internal enum for queue type */

    CPSS_NULL_PTR_CHECK_MAC(numOfAuPtr);
    CPSS_NULL_PTR_CHECK_MAC(endOfQueueReachedPtr);
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    if(queueType > CPSS_DXCH_FDB_QUEUE_TYPE_FU_E ||
       queueType < CPSS_DXCH_FDB_QUEUE_TYPE_AU_E)
    {
        return GT_BAD_PARAM;
    }

    *numOfAuPtr = 0;
    *endOfQueueReachedPtr = GT_FALSE;

    if(queueType == CPSS_DXCH_FDB_QUEUE_TYPE_AU_E ||
       PRV_CPSS_DXCH_PP_MAC(devNum)->moduleCfg.fuqUseSeparate == GT_FALSE)
    {
        internalQueueType = MESSAGE_QUEUE_PRIMARY_AUQ_E;
    }
    else
    {
        internalQueueType = MESSAGE_QUEUE_PRIMARY_FUQ_E;
    }

    PRV_CPSS_GEN_PP_START_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)
    {
        rc =  auqFuqMessagesNumberGet(devNum ,portGroupId,
                internalQueueType,&coreValue,&portGroupEndOfQueueReached);
        if(rc != GT_OK)
        {
            return rc;
        }

        if(portGroupEndOfQueueReached == GT_TRUE)
        {
            /* if any of the port groups , reached end of queue , we state the device
               reached end of queue*/
            *endOfQueueReachedPtr = GT_TRUE;
        }

        /* summary of all the port groups */
        *numOfAuPtr += coreValue;
    }
    PRV_CPSS_GEN_PP_END_LOOP_PORT_GROUPS_MAC(devNum,portGroupId)

    return GT_OK;

}

/*******************************************************************************
* cpssDxChBrgFdbSecondaryAuMsgBlockGet
*
* DESCRIPTION:
*       The function returns a block (array) of FDB Address Update (AU) messages,
*       the max number of elements defined by the caller --> from the secondary AUQ.
*       The function cpssDxChHwPpPhase2Init configures queue for secondary AU
*       messages. If common FU queue is used then function returns all AU
*       messages in the queue including FU ones.
*       If separate AU queue is used then function returns only AU messages.
*
* APPLICABLE DEVICES:
*        DxCh1; DxCh1_Diamond; DxCh2; DxCh3; xCat; Lion; xCat2.
*
* NOT APPLICABLE DEVICES:
*        None.
*
* INPUTS:
*       devNum     - the device number from which AU are taken
*       numOfAuPtr - (pointer to)max number of AU messages to get
*
* OUTPUTS:
*       numOfAuPtr - (pointer to)actual number of AU messages that were received
*       auMessagesPtr - array that holds received AU messages
*                       pointer is allocated by the caller , with enough memory
*                       for *numOfAuPtr entries that was given as INPUT
*                       parameter.
*
* RETURNS:
*       GT_OK                    - on success
*       GT_NO_MORE   - the action succeeded and there are no more waiting
*                      AU messages
*       GT_BAD_PARAM             - wrong devNum
*       GT_BAD_PTR               - one of the parameters is NULL pointer
*       GT_HW_ERROR              - on hardware error.
*       GT_NOT_APPLICABLE_DEVICE - on not applicable device
*
* COMMENTS:
*
*******************************************************************************/
GT_STATUS cpssDxChBrgFdbSecondaryAuMsgBlockGet
(
    IN      GT_U8                                    devNum,
    INOUT   GT_U32                                   *numOfAuPtr,
    OUT     CPSS_MAC_UPDATE_MSG_EXT_STC              *auMessagesPtr
)
{
    PRV_CPSS_DXCH_DEV_CHECK_MAC(devNum);

    CPSS_NULL_PTR_CHECK_MAC(numOfAuPtr);
    CPSS_NULL_PTR_CHECK_MAC(auMessagesPtr);


    if(PRV_CPSS_DXCH_ERRATA_GET_MAC(devNum,
             PRV_CPSS_DXCH_FER_FDB_AUQ_LEARNING_AND_SCANING_DEADLOCK_WA_E) == GT_FALSE)
    {
        /* the secondary AUQ not active */
        *numOfAuPtr = 0;

        return GT_NO_MORE;
    }


    return prvDxChBrgFdbAuFuMsgBlockGet(devNum,
            MESSAGE_QUEUE_SECONDARY_AUQ_E,
            numOfAuPtr,
            auMessagesPtr);
}

