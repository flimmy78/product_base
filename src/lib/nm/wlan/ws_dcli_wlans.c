
/* cgicTempDir is the only setting you are likely to need
	to change in this file. */

/*******************************************************************************
Copyright (C) Autelan Technology


This software file is owned and distributed by Autelan Technology 
********************************************************************************


THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
********************************************************************************
* ws_dcli_wlans.c
*
*
* CREATOR:
* autelan.software.Network Dep. team
* qiaojie@autelan.com
*
* DESCRIPTION:
*
*
*
*******************************************************************************/


#ifdef __cplusplus
extern "C"
{
#endif

#include <fcntl.h> 
#include <dirent.h>
#include <syslog.h>
#include <unistd.h>
#include <sys/wait.h>
#include "ws_init_dbus.h"
#include "sysdef/npd_sysdef.h"
#include "dbus/npd/npd_dbus_def.h"
#include "dbus/wcpss/ACDbusDef1.h"
#include "dbus/asd/ASDDbusDef1.h"
#include "ws_dcli_ac.h"
#include "ws_public.h"
#include "ws_dcli_wlans.h"

int parse_radio_ifname(char* ptr,int *wtpid,int *radioid,int *wlanid)
{
	
    radio_ifname_state state = e_check_wtpid;
	char *str = NULL;
	str = ptr;
   
	while(1){
		switch(state){
			
		case e_check_wtpid: 
			
			*wtpid = strtoul(str,&str,10);
			
			if(*wtpid > 0 && *wtpid < 4095){
        		state=e_check_sub;
			}
			else state=e_check_fail;
			
			break;

		case e_check_sub: 
		
			if (PARSE_RADIO_IFNAME_SUB == str[0]){
		
				state = e_check_radioid;
				}
			else
				state = e_check_fail;
			break;

		case e_check_radioid: 
		
			*radioid = strtoul((char *)&(str[1]),&str,10);

			if(*radioid >= 0 && *radioid < 4){
        		state=e_check_point;
			}
			else state=e_check_fail;
			
			break;

		case e_check_point: 
		
			if (PARSE_RADIO_IFNAME_POINT == str[0]){
			
				state = e_check_wlanid;
				
				}
			else
				state = e_check_fail;
			break;
				
		case e_check_wlanid: 
		
			*wlanid = strtoul((char *)&(str[1]),&str,10);

			if(*wlanid > 0 && *wlanid < 16){
        		state=e_check_end;
			}
			else state=e_check_fail;
			
			break;
			
		
		
		case e_check_fail:
	
		
            return -1;
			break;

		case e_check_end: 
	
			if ('\0' == str[0]) {
				state = e_check_success;
				
				}
			else
				state = e_check_fail;
				break;
			
		case e_check_success: 
		
			return 0;
			break;
			
		default: break;
		}
		
		}
		
}

int strcheck(char **str) {  
	int i,len;
	char *ptr;

	len = strlen(*str);
	ptr = *str;

	for(i=0; i<len ; i++) {
		if((ptr[i]<32)||(ptr[i]>126))  
			return 0;  
	}
	
	return 1;
}

int parse_int(char* str,unsigned int* ID){
	char *endptr = NULL;
	char c;
	c = str[0];
	if (c>='0'&&c<='9'){
		*ID= strtoul(str,&endptr,10);
		if(endptr[0] == '\0')
			return WID_DBUS_SUCCESS;
		else
			return WID_UNKNOWN_ID;
	}
	else
		return WID_UNKNOWN_ID;
}


int parse_short_ID(char* str,unsigned short* ID){
	 
	  /* before modify*/
	 char *endptr = NULL;
	 char c;
	 unsigned long int t_ID; 
	 c = str[0];
	 if (c>='0'&&c<='9'){
		 
		 t_ID = strtoul(str,&endptr,10);
		 if(t_ID < 65536 ){
		   
		   *ID = (unsigned short)t_ID;
	 
		   if((c=='0')&&(str[1]!='\0'))
			  return WID_UNKNOWN_ID;
		   else if(endptr[0] == '\0')
			  return WID_DBUS_SUCCESS;
		   else
			  return WID_UNKNOWN_ID;
	   }
	   else{
		  
		   return WID_ILLEGAL_INPUT;
	   }
		 
	 }
	 else
		 return WID_UNKNOWN_ID;
	 
	
}


int parse_char_ID(char* str,unsigned char* ID){	
	 /* before modify*/
	char *endptr = NULL;
	char c;
	unsigned long int t_ID = 0;
	c = str[0];
	if (c>='0'&&c<='9'){
		t_ID=  strtoul(str,&endptr,10);
		if(t_ID < 256){
          *ID = (unsigned char)t_ID;
          if((c=='0')&&(str[1]!='\0'))
		  	return WID_UNKNOWN_ID;
		  else if(endptr[0] == '\0')
			return WID_DBUS_SUCCESS;
		  else
			return WID_UNKNOWN_ID;
		}
		else{
            return WID_ILLEGAL_INPUT;
		}
		
	}
	else
		return WID_UNKNOWN_ID;	
}

int parse_int_ID(char* str,unsigned int* ID){
	char *endptr = NULL;
	char c;
	c = str[0];
	if (c>='0'&&c<='9'){
		*ID= strtoul(str,&endptr,10);		
		if((endptr[0] == '\0')||(endptr[0] == '\n'))
			return WID_DBUS_SUCCESS;
		else
			return WID_UNKNOWN_ID;
	}
	else
		return WID_UNKNOWN_ID;
}


void str2lower(char **str) {  
	int i,len;
	char *ptr;

	len = strlen(*str);
	ptr = *str;

	for(i=0; i<len ; i++) {
		if((ptr[i]<='Z')&&(ptr[i]>='A'))  
			ptr[i] = ptr[i]-'A'+'a';  
	}
	
	return;
}


int Check_Time_Format(char* str){
	char *endptr = NULL;
	int endptr1 = 0;
	char c;
	int h,m,s;
	int time;
	c = str[0];
	if (c>='0'&&c<='9'){
		h= strtoul(str,&endptr,10);
		if(h < 0||h > 23)
			return -1;
		if(endptr[0] == '\0'||endptr[0] != ':')
			return -1;
		else{
			endptr1 = &endptr[1];
			m= strtoul(&endptr[1],&endptr,10);				
			if(m < 0||m > 59)
				return -1;				
		}
		
		if(endptr[0] == '\0'||endptr[0] != ':')
			return -1;
		else{
			endptr1 = &endptr[1];
			s = strtoul(&endptr[1],&endptr,10);				
			if(s < 0||s > 59)
				return -1;				
		}
		if(endptr[0] == '\0'){
			time = h*3600 + m*60 + s;
			return time;
		}
		else
			return -1;
	}
	else
		return -1;

}

CWBool_DCLI check_ascii_32_to126(const char * str)
{
	if(str == NULL)
	{
		return CW_TRUE_DCLI;
	}

	CWBool_DCLI ret = CW_TRUE_DCLI;
	const char *p = str;

	while(*p != '\0')
	{
		if((*p < 32 )||(*p > 126))
		{
			ret = CW_FALSE_DCLI;
			break;
		}
		p++;
	}
	return ret;
}

int parse_signedint_ID(char* str, int* ID)
{
    //char c;
	int numFlag = 0;
	int i=0;
	int j=0;
	int ret = WID_DBUS_SUCCESS;
    if ((str[0]>='0'&&str[0]<='9')||(str[0]=='-'))
		{
	        i= strlen(str);
			if((1 == i)&&(str[0]!='-')){
                  numFlag = 1;
			 
			}
			else if((str[0]=='0')&&(str[1] != '\0')){
                 numFlag = 0;
		    }
			else{
			 
             for(j=1;j< i;j++){
			  if(str[j]<'0'||str[j]>'9'){
	              numFlag = 0;
				  break;
				}
			   numFlag = 1;
		      }
		    }
			
			if(numFlag)
				{
	               * ID = atoi(str);
				   numFlag = 0;
				   ret = WID_DBUS_SUCCESS;
			    }
			else
				{
	               ret=WID_UNKNOWN_ID;
			    }
	   }
	   else
	   {
             ret = WID_UNKNOWN_ID;
	   }

    return ret;


}

static int ssid_illegal_character_check(char *str, int len)//xiaodawei add for checking ssid illegal character, 20110509
{
	int m = 0;
	char *tmp = NULL;
	tmp = str;
	if(str == NULL)
	{
		return -1;
	}
	if(strlen(str)!=len)
	{
		return -1;	//-1 means ssid is null or the parameter len do not match length of ssid
	}
	for(m=0; m<len; m++)
	{
		if(tmp[m]>=32&&tmp[m]<=126&&tmp[m]!='\\'&&tmp[m]!='"'&&tmp[m]!='&'&&tmp[m]!='`'&&tmp[m]!='('&&tmp[m]!=')'&&tmp[m]!='*') /*wcl modify*/
			continue;
		else
			break;
	}
	if(m==len)
	{
		return 0;
	}
	else
	{
		return -2;	//-2 means illegal character
	}
}


/*dcli_wlan.c V1.48*/
/*author liutao*/
/*update time 09-1-05*/
//wlan添加黑名单白名单功能没有增加 代码有问题

/*dcli_wlan.c V1.50*/
/*author liutao*/
/*update time 09-3-02*/

/*dcli_wlan.c V1.79*/
/*author qiaojie*/
/*update time 09-09-22*/

/*dcli_wlan.c V1.88*/
/*author zhouym*/
/*update time 09-12-08*/

/*dcli_wlan.c V1.114*/
/*author qiaojie*/
/*update time 10-04-02*/

int create_wlan(dbus_parameter parameter, DBusConnection *connection,char *id, char *wlan_name, char *wlan_essid)/*返回0表示创建失败，返回1表示创建成功，返回-1表示WLAN ID非法，返回-2表示wlan已存在，返回-3表示出错*/
																												   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if((NULL == id)||(NULL == wlan_name)||(NULL == wlan_essid))
		return 0;
	
	int ret,retu;
	unsigned char isAdd;	
	unsigned char wlan_id;
	char *name;
	char *ESSID;	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	isAdd = 1;

	ret = parse_char_ID((char*)id, &wlan_id);
	if(ret != WID_DBUS_SUCCESS){
		return -1;
	}	
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		return -1;
	}
	name = (char*)malloc(strlen(wlan_name)+1);
	if(name)
	{
		memset(name, 0, strlen(wlan_name)+1);
		memcpy(name, wlan_name, strlen(wlan_name)); 
	}
	ESSID = (char*)malloc(strlen(wlan_essid)+1);
	if(ESSID)
	{
		memset(ESSID, 0, strlen(wlan_essid)+1);
		memcpy(ESSID, wlan_essid, strlen(wlan_essid));
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_ADD_DEL_WLAN);


	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ADD_DEL_WLAN);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_BYTE,&isAdd,								
						DBUS_TYPE_BYTE,&wlan_id,
						DBUS_TYPE_STRING,&name,
						DBUS_TYPE_STRING,&ESSID,							 
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		if(name)
		{
			free(name);
			name = NULL;
		}
		if(ESSID)
		{
			free(ESSID);
			ESSID = NULL;
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	    retu=1;
	else if(ret == WLAN_ID_BE_USED)
		retu=-2;
	else
		retu=-3;
	dbus_message_unref(reply);
	FREE_OBJECT(name);
	FREE_OBJECT(ESSID);
	return retu;	
}

int create_wlan_cmd_cn(dbus_parameter parameter, DBusConnection *connection,char *id, unsigned char *wlan_name, unsigned char *wlan_essid)
																			  /*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
																			  /*返回-2表示wlan id should be 1 to WLAN_NUM-1，返回-3表示wlan name is too long,out of the limit of 15*/
																			  /*返回-4表示wlan name is illegal，返回-5表示essid is too long,out of the limit of 32*/
																			  /*返回-6表示wlan id exist，返回-7表示illegal input，返回-8表示error*/
																			  /*返回-9表示illegal input:Input exceeds the maximum value of the parameter type*/
																			  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if((NULL == id)||(NULL == wlan_name)||(NULL == wlan_essid))
		return 0;
	
	int ret,len;
	unsigned char isAdd;	
	unsigned char wlan_id;
	unsigned char *name;
	unsigned char *ESSID;		
	//unsigned char a[2];
	isAdd = 1;	
	//int i,j;
	int retu;
	
	ret = parse_char_ID((char*)id, &wlan_id);
	if(ret != WID_DBUS_SUCCESS){
        if(ret == WID_ILLEGAL_INPUT){
			retu = -9;
        }
		else{
			retu = -1;
		}
		return retu;
	}	
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		return -2;
	}
	len = strlen(wlan_name);
	if(len > 15){		
		return -3;
	}	
	if(check_ascii_32_to126(wlan_name) == CW_FALSE_DCLI)
	{
		return -4;
	}

	name = (unsigned char*)malloc(strlen(wlan_name)+1);
	if(name)
	{
		memset(name, 0, strlen(wlan_name)+1);
		memcpy(name, wlan_name, strlen(wlan_name)); 	
	}
	len = strlen(wlan_essid);
	if(len > 64){		
		if(name){
			free(name);
			name = NULL;
		}
		return -5;
	}
	if(len<ESSID_DEFAULT_LEN){
		ESSID = (unsigned char*)malloc(ESSID_DEFAULT_LEN);
		if(ESSID)
		{
			memset(ESSID, 0, ESSID_DEFAULT_LEN);
			memcpy(ESSID, wlan_essid, strlen(wlan_essid));
		}
	}else{
		ESSID = (unsigned char*)malloc(strlen(wlan_essid)+1);
		if(ESSID)
		{
			memset(ESSID, 0, strlen(wlan_essid)+1);
			memcpy(ESSID, wlan_essid, strlen(wlan_essid));
		}
	}
	#if 0
	unsigned long ul;
	ESSID = (unsigned char*)malloc(ESSID_DEFAULT_LEN);
	memset(ESSID, 0, ESSID_DEFAULT_LEN);
	for(i = 0;i < len;i=i+2)
	{
		memcpy(a,wlan_essid+i,2);
		unsigned long int(*dcli_init_func)(unsigned char *);			
		dcli_init_func = dlsym(ccgi_dl_handle,"HexToDec");
		ul =(*dcli_init_func)(a);
		ESSID[i/2] = ul;
	}
	#endif

		
	void *(*dcli_init_func)(
								int ,
								int ,
								int ,
								unsigned char ,
								char *,
								unsigned char *,
								DBusConnection *
							);

	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"create_wlan_CN");
		if(NULL != dcli_init_func && connection)
		{
			ret =(*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 isAdd,
					 wlan_id,
					 name,
					 ESSID,
					 connection
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(ret == -1)
	{
		if(name)
		{
			free(name);
			name = NULL;
		}
		if(ESSID)
		{
			free(ESSID);
			ESSID = NULL;
		}
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == 0)
	{
		retu = 1;
	}
	else if(ret == WLAN_ID_BE_USED)
	{
		retu = -6;
	}
	else if(ret == WID_ILLEGAL_INPUT)
	{
		retu = -7;
	}
	else
	{
		retu = -8;
	};
	
	FREE_OBJECT(name);
	FREE_OBJECT(ESSID);

	return retu;	
}

int delete_wlan(dbus_parameter parameter, DBusConnection *connection,int id)  /*返回0表示 删除失败，返回1表示删除成功*/
																				/*返回-1表示WLAN ID非法，返回-2表示WLAN ID NOT existed*/
																				/*返回-3表示please disable WLAN first，返回-4表示出错*/
																				/*返回-5表示some radios interface in ebr,please delete it from ebr first*/
																				/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
		
	int ret,retu;
	unsigned char isAdd;	
	unsigned char wlan_id;
	char *name;
	char *ESSID;	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	isAdd = 0;
	wlan_id = id;		
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		return -1;
	}
	name = (char*)malloc(1);
	if(NULL == name)
		return 0;
	memset(name, 0, 1);
	
	ESSID = (char*)malloc(1);
	if(NULL == ESSID)
		return 0;
	memset(ESSID, 0, 1);


	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_ADD_DEL_WLAN);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ADD_DEL_WLAN);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_BYTE,&isAdd,								
						DBUS_TYPE_BYTE,&wlan_id,
						DBUS_TYPE_STRING,&name,
						DBUS_TYPE_STRING,&ESSID,							 
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		if(name)
		{
			free(name);
			name = NULL;
		}
		if(ESSID)
		{
			free(ESSID);
			ESSID = NULL;
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == WLAN_ID_NOT_EXIST)
	    retu=-2;
	else if(ret == WLAN_BE_ENABLE)
	    retu=-3;
	else if(ret == RADIO_IN_EBR)
		retu=-5;
	else
		retu=-4;
	dbus_message_unref(reply);
	FREE_OBJECT(name);
	FREE_OBJECT(ESSID);

	return retu;	
}

int config_wlan_service(dbus_parameter parameter, DBusConnection *connection,int id,char *state)   
																 /*返回0表示失败，返回1表示成功，返回-1表示no security profile binded，返回-2表示wtp interface policy conflict*/
				                                                 /*返回-3表示you map layer3 interace error，返回-4表示you should bind interface first，返回-5表示error，返回-6示WLAN ID非法*/
																 /*返回-7表示wlan bingding securithindex same*/
																 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == state)
		return 0;
	
    int ret = -1,retu;
	unsigned char wlan_id;
	unsigned char stat;	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	//wlan_id = id;
	if (strcmp(state,"enable")==0){
		DBusMessage *query_check, *reply_check; 
		DBusMessageIter  iter_check;
		DBusError err_check;
		int ret_check;

		char BUSNAME[PATH_LEN];
		char OBJPATH[PATH_LEN];
		char INTERFACE[PATH_LEN];

		wlan_id = id;
		if(wlan_id >= WLAN_NUM || wlan_id == 0){
			syslog(LOG_DEBUG,"wlan id in config_wlan_service is %d\n",wlan_id);
			return -6;
		}
		
		ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,ASD_DBUS_BUSNAME,BUSNAME);
		ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,ASD_DBUS_SECURITY_OBJPATH,OBJPATH);
		ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,ASD_DBUS_SECURITY_INTERFACE,INTERFACE);
		query_check = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,ASD_DBUS_SECURITY_METHOD_SECURITY_WLAN_CHECK);

		/*query_check = dbus_message_new_method_call(ASD_DBUS_BUSNAME,ASD_DBUS_SECURITY_OBJPATH,\
							ASD_DBUS_SECURITY_INTERFACE,ASD_DBUS_SECURITY_METHOD_SECURITY_WLAN_CHECK);*/
		
		dbus_error_init(&err_check);
		
		dbus_message_append_args(query_check,
								 DBUS_TYPE_BYTE,&wlan_id,
								 DBUS_TYPE_INVALID);
		
		reply_check = dbus_connection_send_with_reply_and_block (connection,query_check,-1, &err_check);
		
		dbus_message_unref(query_check);
		
		if (NULL == reply_check) {
			if (dbus_error_is_set(&err_check)) {
				dbus_error_free(&err_check);
			}
			return SNMPD_CONNECTION_ERROR;
		}
		
		dbus_message_iter_init(reply_check,&iter_check);
		dbus_message_iter_get_basic(&iter_check,&ret_check);
		
		dbus_message_unref(reply_check);
			if(ret_check == ASD_DBUS_SUCCESS)
				stat = 0;
			else if(ret_check == ASD_SECURITY_PROFILE_NOT_BIND_WLAN){
				return -1;
			}
			else if(ret == IF_POLICY_CONFLICT)
				retu=-2;
			else if(ret == L3_INTERFACE_ERROR)
				retu=-3;
			else if(ret == SECURITYINDEX_IS_SAME)
				retu=-7;
			else {
				return -5;
			}
	
	}		
	else if (strcmp(state,"disable") == 0)
		stat = 1;
		
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	wlan_id = id;
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		syslog(LOG_DEBUG,"wlan id in config_wlan_service is %d\n",wlan_id);
		return -6;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WLAN_METHOD_ENABLE);

    /*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WLAN_OBJPATH,\
						WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_ENABLE);*/
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&wlan_id,
							 DBUS_TYPE_BYTE,&stat,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,300000, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if (ret == INTERFACE_NOT_BE_BINDED)
		retu=-4;
	else if(ret == L3_INTERFACE_ERROR)
		retu=-3;
	else if(ret == SECURITYINDEX_IS_SAME)
		retu=-7;
	else
		retu=-5;
	dbus_message_unref(reply);
	return retu;
}



int wlan_apply_interface(dbus_parameter parameter, DBusConnection *connection,int id,char *inter_name)   
																	   /*返回0表示失败，返回1表示成功，返回-1表示the length of interface name excel 16*/
				                                                       /*返回-2表示wlan id does not exist，返回-3表示interface dose not exist*/
				                                                       /*返回-4表示wlan is enable,please disable it first，返回-5表示error，返回-6示WLAN ID非法*/
																	   /*返回-7表示is no local interface, permission denial，返回-8表示interface has be binded in other hansi*/
																	   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == inter_name)
		return 0;
	
	int ret,retu;
	int ret6;
	unsigned char WlanID = 0;
	unsigned char * ifname;	
	int insize = 0;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	insize = strlen(inter_name);
	if(insize > 16)
	{
	  return -1;	
	}
	
	//WlanID = id;
	
	ifname = (char*)malloc(strlen(inter_name)+1);
	if(NULL == ifname)
		return 0;
	memset(ifname, 0, strlen(inter_name)+1);
	memcpy(ifname, inter_name, strlen(inter_name));	


	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	WlanID = id;
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in wlan_apply_interface is %d\n",WlanID);
		return -6;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WLAN_METHOD_APPAY_WLAN_IFNAME);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WLAN_OBJPATH,\
						WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_APPAY_WLAN_IFNAME);*/
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&WlanID,
							 DBUS_TYPE_STRING,&ifname,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		if(ifname)
		{
			free(ifname);
			ifname = NULL;
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	
	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&ret6);
	
	if((ret == 0)&&(ret6 == 0))
	{
		retu = 1;
		//vty_out(vty,"IPV4:wlan %d binding interface %s successfully.\n",WlanID,ifname);
		//vty_out(vty,"IPV6:wlan %d binding interface %s successfully.\n",WlanID,ifname);
	}
	else if(ret == 0){
		retu = 1;
		/*vty_out(vty,"IPV4:wlan %d binding interface %s successfully.\n",WlanID,ifname);
		if(ret6 == WLAN_ID_NOT_EXIST) 
			vty_out(vty,"<warnning>IPV6: wlan id does not exist\n");
		else if(ret6 == APPLY_IF_FAIL){
			vty_out(vty,"<warnning>IPV6: interface %s dose not exist\n",ifname);
		}
		else if(ret6 == WLAN_BE_ENABLE)
			vty_out(vty,"<warnning>IPV6: wlan is enable,please disable it first\n");
		else 
			vty_out(vty,"<warnning>IPV6: wlan apply interface fail.errno is %d.\n",ret6);*/
	}
	else if(ret6 ==0){
		retu = 1;
		/*if(ret == WLAN_ID_NOT_EXIST) 
			vty_out(vty,"<warnning>IPV4: wlan id does not exist\n");
		else if(ret == APPLY_IF_FAIL){
			vty_out(vty,"<warnning>IPV4: interface %s dose not exist\n",ifname);
		}
		else if(ret == WLAN_BE_ENABLE){
			vty_out(vty,"<warnning>IPV4: wlan is enable,please disable it first\n");
		}
		else if(ret == IF_BINDING_FLAG){
			vty_out(vty,"<error>IPV4: interface %s has be binded in other hansi.\n",ifname);
		}
		else if (ret == WID_INTERFACE_NOT_BE_LOCAL_BOARD){
			vty_out(vty,"<error> %s is no local interface, permission denial\n",ifname);
		}
		else 
			vty_out(vty,"<warnning>IPV4: wlan apply interface fail.errno is %d.\n",ret);
		vty_out(vty,"IPV6:wlan %d binding interface %s successfully.\n",WlanID,ifname);*/
	}
	else{
		if(ret == WLAN_ID_NOT_EXIST) 
			retu = -2;
			//vty_out(vty,"<error>IPV4: wlan id does not exist\n");
		else if(ret == APPLY_IF_FAIL){
			retu = -3;
			//vty_out(vty,"<error>IPV4: interface %s dose not exist\n",ifname);
		}
		else if(ret == WLAN_BE_ENABLE){
			retu = -4;
			//vty_out(vty,"<error>IPV4: wlan is enable,please disable it first\n");
		}
		else if(ret == IF_BINDING_FLAG){
			retu = -8;
			//vty_out(vty,"<error>IPV4: interface %s has be binded in other hansi.\n",ifname);
		}
		else 
			retu = -5;
			//vty_out(vty,"<error>IPV4: wlan apply interface fail.errno is %d.\n",ret);
		
		if(ret6 == WLAN_ID_NOT_EXIST) 
			retu = -2;
			//vty_out(vty,"<error>IPV6: wlan id does not exist\n");
		else if(ret6 == APPLY_IF_FAIL){
			retu = -3;
			//vty_out(vty,"<error>IPV6: interface %s dose not exist\n",ifname);
		}
		else if(ret6 == WLAN_BE_ENABLE)
			retu = -4;
			//vty_out(vty,"<error>IPV6: wlan is enable,please disable it first\n");
		
		else if (ret == WID_INTERFACE_NOT_BE_LOCAL_BOARD){
			retu = -7;
			//vty_out(vty,"<error> %s is no local interface, permission denial\n",ifname);
		}
		else
			retu = -5;
			//vty_out(vty,"<error>IPV6: wlan apply interface fail.errno is %d.\n",ret6);
	}
	
		
	dbus_message_unref(reply);
	FREE_OBJECT(ifname);
	return retu;
}

/*未使用*/
int wlan_apply_ipv6interface(dbus_parameter parameter, DBusConnection *connection,int id,char *inter_name)
																		 /*返回0表示失败，返回1表示成功*/
																		 /*返回-1表示input parameter size is excel the limit of 16*/
																		 /*返回-2表示wlan id does not exist，返回-3表示interface dose not exist*/
																		 /*返回-4表示wlan is enable,please disable it first*/
																		 /*返回-5表示wlan bingding ipv6 addr error make sure interface have ipv6 address*/
																		 /*返回-6表示error，返回-7示WLAN ID非法*/
																		 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == inter_name)
		return 0;
	
	int ret,retu;
	unsigned char WlanID = 0;
	unsigned char * ifname;
	int insize = 0;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	insize = strlen(inter_name);
	if(insize > 16)
	{
		//vty_out(vty,"<error> input parameter %s size is %d,excel the limit of 16\n",argv[0],insize);
		return -1;	
	}
	//WlanID = id;
	
	ifname = (char*)malloc(strlen(inter_name)+1);
	if(NULL == ifname)
		return 0;
	memset(ifname, 0, strlen(inter_name)+1);
	memcpy(ifname, inter_name, strlen(inter_name));	


	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	WlanID = id;
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in wlan_apply_ipv6interface is %d\n",WlanID);
		return -7;
	}

	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WLAN_METHOD_APPAY_WLAN_IFNAME_IPV6);
	
	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WLAN_OBJPATH,\
						WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_APPAY_WLAN_IFNAME_IPV6);*/
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&WlanID,
							 DBUS_TYPE_STRING,&ifname,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		//vty_out(vty,"<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			//vty_out(vty,"%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		if(ifname)
		{
			free(ifname);
			ifname = NULL;
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		//vty_out(vty,"wlan %d binding interface %s successfully.\n",WlanID,ifname);
		retu=1;
	}				
	else if(ret == WLAN_ID_NOT_EXIST)
	{
		//vty_out(vty,"<error> wlan id does not exist\n");
		retu=-2;
	}
	else if(ret == APPLY_IF_FAIL){
		//vty_out(vty,"<error> interface %s dose not exist\n",ifname);
		retu=-3;
	}
	else if(ret == WLAN_BE_ENABLE){
		//vty_out(vty,"<error> wlan is enable,please disable it first\n");
		retu=-4;
	}
	else if(ret == BINDING_IPV6_ADDRE_RROR){
		//vty_out(vty,"<error> wlan bingding ipv6 addr error make sure interface have ipv6 address\n");
		retu=-5;
	}
	
	else{
		//vty_out(vty,"<error>  %d\n",ret);
		retu=-6;
	}
		
	dbus_message_unref(reply);
	FREE_OBJECT(ifname);
	return retu;
}

int wlan_delete_interface(dbus_parameter parameter, DBusConnection *connection,int id,char *inter_name)   
																	   /*返回0表示失败，返回1表示成功，返回-1表示wlan doesn't binding this interface，返回-2表示Wlan ID Not existed*/
				                                                       /*返回-3表示Interface not existed，返回-4表示Wlan is enable binding error! please disable first，返回-5表示error，返回-6示WLAN ID非法*/
																	   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == inter_name)
		return 0;
		
	int ret,retu;
	unsigned char WlanID = 0;
	char * ifname;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	//WlanID = id;
	
	ifname = (char*)malloc(strlen(inter_name)+1);
	if(NULL == ifname)
		return 0;
	memset(ifname, 0, strlen(inter_name)+1);
	memcpy(ifname, inter_name, strlen(inter_name));	


	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	WlanID = id;
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in wlan_delete_interface is %d\n",WlanID);
		return -6;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WLAN_METHOD_DELETE_IF);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WLAN_OBJPATH,\
						WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_DELETE_IF);*/
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&WlanID,
							 DBUS_TYPE_STRING,&ifname,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		if(ifname)
		{
			free(ifname);
			ifname = NULL;
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		retu=1;
	}	
	else if(ret == WLAN_NOT_BINDING_IF)
	{
		retu=-1;
	}		
	else if(ret == WLAN_ID_NOT_EXIST)
	{
		retu=-2;
	}
	else if(ret == APPLY_IF_FAIL){
		retu=-3;
	}
	else if(ret == WLAN_BE_ENABLE){
		retu=-4;
	}
	else{
		retu=-5;
	}
		
	dbus_message_unref(reply);
	FREE_OBJECT(ifname);
	return retu;
}


void CheckWIDIfPolicy(char *whichinterface, unsigned char wlan_if_policy){
	
	switch(wlan_if_policy){

		case 0 :
			strcpy(whichinterface, "NO_IF");
			break;
			
		case 1 :
			strcpy(whichinterface, "WLAN_IF");
			break;
		
		case 2 :
			strcpy(whichinterface, "BSS_IF");
			break;
		}
}


void Free_wlan_head(DCLI_WLAN_API_GROUP *WLANINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WLAN_API_GROUP *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wlan_free_fun");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_CONF_METHOD_WLANLIST,WLANINFO);
		}
	}
}

/*返回1时，调用Free_wlan_head()释放空间*/
int show_wlan_list(dbus_parameter parameter, DBusConnection *connection,DCLI_WLAN_API_GROUP **WLANINFO)/*返回0表示失败，返回1表示成功，返回-1表示wlan not exsit*/
																										  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	int ret;
	int retu = 0;	
	
	void*(*dcli_init_func)(
					int ,
					unsigned char ,
					unsigned int ,
					unsigned int* ,
					unsigned char *,
					DBusConnection *,
					char *
					);

    *WLANINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wlan_show_api_group");
		if(NULL != dcli_init_func && connection)
		{
			
			*WLANINFO = (*dcli_init_func)
				(
					parameter.instance_id,
					0,
					parameter.local_id,
					&ret,
					0,
					connection,
					WID_DBUS_CONF_METHOD_WLANLIST
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(ret == -1)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if((ret == 0 )&&(*WLANINFO))
	{
		retu = 1;
	}
	else if(ret == 3)
	{
		retu = -1;
	}

	return retu;
}


void Free_one_wlan_head(DCLI_WLAN_API_GROUP *WLANINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WLAN_API_GROUP *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wlan_free_fun");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_CONF_METHOD_SHOWWLAN,WLANINFO);
		}
	}
}

/*返回1时，调用Free_one_wlan_head()释放空间*/
int show_wlan_one(dbus_parameter parameter, DBusConnection *connection,int id,DCLI_WLAN_API_GROUP **WLANINFO)
																			 /*返回0表示失败，返回1表示成功*/
				                                                             /*返回-1表示wlan id should be 1 to WLAN_NUM-1*/
				                                                             /*返回-2表示wlan id is not exited，返回-3表示error*/
																			 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
    if(NULL == connection)
        return 0;
        
	unsigned int ret;
	int retu;
	unsigned char wlan_id;

    wlan_id = id;
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		return -1;
	}
		


	void*(*dcli_init_func)(
					int ,
					unsigned char ,
					unsigned int ,
					unsigned int* ,
					unsigned char *,
					DBusConnection *,
					char *
					);

    *WLANINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wlan_show_api_group");
		if(NULL != dcli_init_func && connection)
		{
			*WLANINFO = (*dcli_init_func)
				(
					parameter.instance_id,
					wlan_id,
					parameter.local_id,
					&ret,
					0,
					connection,
					WID_DBUS_CONF_METHOD_SHOWWLAN
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if((ret == 0 )&&(*WLANINFO))
	{
		retu = 1;
	}
	else if (ret == WLAN_ID_NOT_EXIST)
	{
		retu = -2;
	}
	else
	{
		retu = -3;
	}

	return retu;
}

/*sec_ID表示security id;w_id表示wlan id*/
int apply_wlanID(dbus_parameter parameter, DBusConnection *connection,int sec_id,int w_id)   
														   /*返回0表示失败，返回1表示成功*/
			                                               /*返回-1表示wlan id not exist，返回-2表示asd security profile not exist*/
			                                               /*返回-3表示asd security profile not integrity，返回-4表示encryption type dosen't match with security type*/
			                                               /*返回-5表示should be disable wlan first，返回-6表示security ID非法，返回-7示WLAN ID非法*/
														   /*返回-8表示security rdc has not config!*/
														   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
    int ret,retu=0;
	unsigned char security_id;
	unsigned char WlanID;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	security_id = sec_id;	
	WlanID = w_id;	
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in apply_wlanID is %d\n",WlanID);
		return -7;
	}
	
	if(security_id >= WLAN_NUM || security_id == 0){
		return -6;
	}
	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,ASD_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,ASD_DBUS_SECURITY_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,ASD_DBUS_SECURITY_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,ASD_DBUS_SECURITY_METHOD_APPLY_WLAN);

	/*query = dbus_message_new_method_call(ASD_DBUS_BUSNAME,ASD_DBUS_SECURITY_OBJPATH,\
						ASD_DBUS_SECURITY_INTERFACE,ASD_DBUS_SECURITY_METHOD_APPLY_WLAN);*/
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&security_id,
							 DBUS_TYPE_BYTE,&WlanID,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == ASD_DBUS_SUCCESS)
		retu=1;
	else if(ret == ASD_WLAN_NOT_EXIST)
		retu=-1;
	else if(ret == ASD_SECURITY_NOT_EXIST)
		retu=-2;
	else if(ret == ASD_SECURITY_PROFILE_NOT_INTEGRITY)
		retu=-3;
	else if(ret == ASD_SECURITY_TYPE_NOT_MATCH_ENCRYPTION_TYPE)
		retu=-4;		
	else if(ret == ASD_SECURITY_RDC_NOT_EXIT)
		retu=-8;
	else if(ret == ASD_SECURITY_WLAN_SHOULD_BE_DISABLE)
        retu=-5;
		
	dbus_message_unref(reply);
	return retu;
}

/*Hessid==1表示yes，Hessid==0表示no*/
int set_hideessid(dbus_parameter parameter, DBusConnection *connection,int id,char *Hessid)
														/*返回0表示失败，返回1表示成功，返回-1表示wlan id not exist*/
				                                        /*返回-2表示WLAN is enable,please disable it first，返回-3表示error，返回-4示WLAN ID非法*/
														/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == Hessid)
		return 0;
		
	int ret,retu;
	unsigned char WlanID = 0;
	unsigned char hideessid;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	//WlanID = id;
	if (!strcmp(Hessid,"yes"))
	{
		hideessid = 1;	
	}		
	else if (!strcmp(Hessid,"no"))
	{
		hideessid = 0;
	}    


	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	WlanID = id;
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in set_hideessid is %d\n",WlanID);
		return -4;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WLAN_METHOD_HIDE_ESSID);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WLAN_OBJPATH,\
						WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_HIDE_ESSID);*/

	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&WlanID,
							 DBUS_TYPE_BYTE,&hideessid,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == WLAN_ID_NOT_EXIST)
	    retu=-1;
	else if(ret == WLAN_BE_ENABLE)
		retu=-2;
	else
		retu=-3;
	dbus_message_unref(reply);
	return retu;

}

/*未使用*/
int wlan_map_interface(dbus_parameter parameter, DBusConnection *connection,int id)    
													  /*返回0表示失败，返回1表示成功，返回-1表示Wlan ID Not existed*/
				                                      /*返回-2表示WLAN is enable, please disable it first*/
				                                      /*返回-3表示WLAN have already binding vlan,please undo wlan-vlan binding first*/
				                                      /*返回-4表示error，返回-5示WLAN ID非法*/
													  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	int ret,retu;
	unsigned char WlanID = 0;
	unsigned char wlan_oplicy;
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;
	
	//WlanID = (unsigned char)id;
	
	wlan_oplicy = 1;


	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	WlanID = (unsigned char)id;
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in wlan_map_interface is %d\n",WlanID);
		return -5;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WLAN_METHOD_L3IF_POLICY);


	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WLAN_OBJPATH,\
						WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_L3IF_POLICY);*/

	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&WlanID,
							 DBUS_TYPE_BYTE,&wlan_oplicy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == WLAN_ID_NOT_EXIST)
		retu=-1;
	else if(ret == WLAN_BE_ENABLE)
		retu=-2;
	else if(ret == WLAN_CREATE_L3_INTERFACE_FAIL)
		retu=0;	
	else if(ret == WLAN_BINDING_VLAN)
		retu=-3;
	else
		retu=-4;
	
	dbus_message_unref(reply);
	return retu;
}

/*未使用*/
int wlan_unmap_interface(int id)    /*返回0表示失败，返回1表示成功，返回-1表示Wlan ID Not existed*/
                                        /*返回-2表示WLAN is enable, please disable it first，返回-3表示error，返回-4示WLAN ID非法*/
{
	int ret,retu;
	unsigned char WlanID = 0;
	unsigned char wlan_oplicy;
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;
	
	WlanID = (unsigned char)id;
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in wlan_unmap_interface is %d\n",WlanID);
		return -4;
	}
	
	wlan_oplicy = 0;

	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WLAN_OBJPATH,\
						WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_L3IF_POLICY);

	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&WlanID,
							 DBUS_TYPE_BYTE,&wlan_oplicy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (ccgi_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return 0;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == WLAN_ID_NOT_EXIST)
		retu=-1;
	else if(ret == WLAN_BE_ENABLE)
		retu=-2;
	else if(ret == WLAN_CREATE_L3_INTERFACE_FAIL)
		retu=0;
	else
		retu=-3;
	
	dbus_message_unref(reply);
	return retu;
}

/*未使用*/
int wlan_bss_map_interface(int id)    /*返回0表示失败，返回1表示成功，返回-1表示Wlan ID Not existed*/
                                           /*返回-2表示WLAN is enable, please disable it first，返回-3表示error，返回-4示WLAN ID非法*/
{
	int ret,retu;
	unsigned char WlanID = 0;
	unsigned char wlan_oplicy;
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;
	
	WlanID = (unsigned char)id;
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in wlan_bss_map_interface is %d\n",WlanID);
		return -4;
	}
	
	wlan_oplicy = 2;

	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WLAN_OBJPATH,\
						WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_L3IF_POLICY);

	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&WlanID,
							 DBUS_TYPE_BYTE,&wlan_oplicy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (ccgi_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return 0;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == WLAN_ID_NOT_EXIST)
		retu=-1;
	else if(ret == WLAN_BE_ENABLE)
		retu=-2;
	else if(ret == WLAN_CREATE_L3_INTERFACE_FAIL)
		retu=0;
	else
		retu=-3;

	dbus_message_unref(reply);
	return retu;
}


/*未使用*/
int wlan_bss_unmap_interface(int id)    /*返回0表示失败，返回1表示成功，返回-1表示Wlan ID Not existed*/
                                              /*返回-2表示WLAN is enable, please disable it first，返回-3表示error，返回-4示WLAN ID非法*/
{
	int ret,retu;
	unsigned char WlanID = 0;
	unsigned char wlan_oplicy;
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;
	
	WlanID = (unsigned char)id;
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in wlan_bss_unmap_interface is %d\n",WlanID);
		return -4;
	}
	
	wlan_oplicy = 0;

	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WLAN_OBJPATH,\
						WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_L3IF_POLICY);

	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&WlanID,
							 DBUS_TYPE_BYTE,&wlan_oplicy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (ccgi_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return 0;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == WLAN_ID_NOT_EXIST)
		retu=-1;
	else if(ret == WLAN_BE_ENABLE)
		retu=-2;
	else if(ret == WLAN_CREATE_L3_INTERFACE_FAIL)
		retu=0;
	else
		retu=-3;
	
	dbus_message_unref(reply);
	return retu;
}

/*
int wlan_add_black(int id,char *stat,char *arg_mac)

	
{

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	int retu = 0;
	unsigned char mac1[6];
	unsigned int mac[6];
	unsigned int ret;
	unsigned char wlan_id = 0;
	unsigned char list_type=0;   //0--black list
								// 1--white list
	
	wlan_id = id;
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		syslog(LOG_DEBUG,"wlan id in wlan_add_black is %d\n",wlan_id);
		return -3
	}

	memset(mac,0,6);
	sscanf(arg_mac,"%X:%X:%X:%X:%X:%X",&mac[0],&mac[1],&mac[2],&mac[3],&mac[4],&mac[5]);
	mac1[0] = (unsigned char)mac[0];
	mac1[1] = (unsigned char)mac[1];	
	mac1[2] = (unsigned char)mac[2];	
	mac1[3] = (unsigned char)mac[3];	
	mac1[4] = (unsigned char)mac[4];	
	mac1[5] = (unsigned char)mac[5];	

	
	
	query = dbus_message_new_method_call(ASD_DBUS_BUSNAME,ASD_DBUS_STA_OBJPATH,\
						ASD_DBUS_STA_INTERFACE,ASD_DBUS_STA_METHOD_WLAN_ADD_MAC_LIST);
	dbus_error_init(&err);

	
	if (!strcmp(stat,"black")){
		list_type=0;
		dbus_message_append_args(query,
								DBUS_TYPE_BYTE,&wlan_id,
								DBUS_TYPE_BYTE,&list_type,
								DBUS_TYPE_BYTE,&mac1[0],
								DBUS_TYPE_BYTE,&mac1[1],
								DBUS_TYPE_BYTE,&mac1[2],
								DBUS_TYPE_BYTE,&mac1[3],
								DBUS_TYPE_BYTE,&mac1[4],
								DBUS_TYPE_BYTE,&mac1[5],
								DBUS_TYPE_INVALID);
		
	}
	else if (!strcmp(stat,"white")){
	
		list_type=1;
		dbus_message_append_args(query,
								DBUS_TYPE_BYTE,&wlan_id,
								DBUS_TYPE_BYTE,&list_type,
								DBUS_TYPE_BYTE,&mac1[0],
								DBUS_TYPE_BYTE,&mac1[1],
								DBUS_TYPE_BYTE,&mac1[2],
								DBUS_TYPE_BYTE,&mac1[3],
								DBUS_TYPE_BYTE,&mac1[4],
								DBUS_TYPE_BYTE,&mac1[5],
								DBUS_TYPE_INVALID);
	}
	
	reply = dbus_connection_send_with_reply_and_block (ccgi_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return 0;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	
	if(ret == ASD_DBUS_ERROR)//this should be modified, be careful
		//vty_out(vty,"<error> wlan id is invalid,should be 1 to %d\n",WLAN_NUM-1); 
		retu = -1;
	else if(ret==ASD_WLAN_NOT_EXIST)
		retu = -2;
		//vty_out(vty,"<error> make sure this wlan is applied by some wtp.\n");
	else 
		retu = 1;
		//vty_out(vty,"wlan add mac list successfully!\n"); 
	dbus_message_unref(reply);

	return retu; 
}
*/

/*num的范围是1-65536*/
int config_wlan_max_sta_num(dbus_parameter parameter, DBusConnection *connection,int id,char * num)   
																		/*返回0表示失败，返回1表示成功*/
																		/*返回-1表示unknown NUM format，返回-2表示wlan id not exist.*/
																		/*返回-3表示more sta(s) has accessed before you set max sta num*/
																		/*返回-4表示operation fail，返回-5表示error，返回-6示WLAN ID非法*/
																		/*返回-7表示input max sta num should be 1-65536*/
																		/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == num)
		return 0;
	
	int ret,retu;
	unsigned char WlanID = 0;
	unsigned int wlan_max_sta=0;
	unsigned int type=2;
	unsigned int wlanid;
	unsigned int stanum;
	unsigned int radioid = 0; //fengwenchao add 20110512
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;

	dbus_error_init(&err);
	
	//WlanID = (unsigned char)vty->index;
	
	ret = parse_int_ID((char*)num, &wlan_max_sta);
	if(ret != WID_DBUS_SUCCESS){
		return -1;
	}	

	/*compare max_sta_num  with  current sta num*/
	/*fengwenchao add 20110412*/
	if((wlan_max_sta > 65536)||(wlan_max_sta < 1))
	{
		return -7;
	}
	/*fengwenchao add end*/

	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	WlanID = (unsigned char)id;	
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in config_wlan_max_sta_num is %d\n",WlanID);
		return -6;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,ASD_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,ASD_DBUS_STA_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,ASD_DBUS_STA_INTERFACE,INTERFACE);
	wlanid=(unsigned int)WlanID;
	if(wlanid >= WLAN_NUM || wlanid == 0){
		syslog(LOG_DEBUG,"wlan id in config_wlan_max_sta_num is %d\n",wlanid);
		return -6;
	}
	
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,ASD_DBUS_STA_METHOD_GET_STA_INFO);
/*	query = dbus_message_new_method_call(ASD_DBUS_BUSNAME,ASD_DBUS_STA_OBJPATH,\
						ASD_DBUS_STA_INTERFACE,ASD_DBUS_STA_METHOD_GET_STA_INFO);*/
	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&type,
							 DBUS_TYPE_UINT32,&wlanid,
							 DBUS_TYPE_UINT32,&radioid,     //fengwenchao add 20110512
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
		
	dbus_message_unref(query);
		
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&stanum);
	dbus_message_unref(reply);

	if(stanum==-1){		
		//vty_out(vty,"<error> wlanid not exist.\n");
		return -2;
	}
	
	if(wlan_max_sta< stanum){
		//vty_out(vty,"<error> %d sta(s) has accessed before you set max sta num %d .\n",stanum,wlan_max_sta);
		return -3;
	}


	memset(BUSNAME,0,PATH_LEN);	
	memset(OBJPATH,0,PATH_LEN);
	memset(INTERFACE,0,PATH_LEN);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WLAN_METHOD_APPAY_WLAN_MAX_STA);
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WLAN_OBJPATH,\
						WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_APPAY_WLAN_MAX_STA);*/

	

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&WlanID,
							 DBUS_TYPE_UINT32,&wlan_max_sta,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu = 1;
		//vty_out(vty,"wlan %d set max sta num %d successfully\n",WlanID,wlan_max_sta);
	else if(ret == WLAN_ID_NOT_EXIST)
		retu = -2;
		//vty_out(vty,"<error> wlan id does not exist\n");
	else if(ret == WID_DBUS_ERROR)
		retu = -4;
		//vty_out(vty,"<error> operation fail .\n");
	else
		retu = -5;
		//vty_out(vty,"<error>  %d\n",ret);

	
	dbus_message_unref(reply);
	return retu;
}

int  set_interface_nasid_cmd(dbus_parameter parameter, DBusConnection *connection,int id,char *inter_name,char *nasid)
																					 /*返回0表示失败，返回1表示成功*/
 																					 /*返回-1表示the length of input parameter is excel the limit of 16*/
 																					 /*返回-2表示the length of input parameter is excel the limit of 128*/
 																					 /*返回-3表示nas identifier include unknow character*/
 																					 /*返回-4表示interface does not exist*/
 																					 /*返回-5表示interface unused*/
 																					 /*返回-6表示you should apply security first*/
 																					 /*返回-7表示no nas_id needed,please apply interface without nas_identifier*/
 																					 /*返回-8表示wlan be enable,please service disable first*/
 																					 /*返回-9表示error，返回-10示WLAN ID非法*/
																					 /*返回-11表示interface has be binded in other hansi*/
																					 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if((NULL == inter_name)||(NULL == nasid))
		return 0;
	
	int ret;
	char *ifname;
	char *nas_id;
	int insize = 0;
	int retu;
	unsigned char WLANID;
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;

	//make robust code
	insize = strlen(inter_name);
	if(insize > 16)
	{
	  //vty_out(vty,"<error> the length of input parameter %s is %d ,excel the limit of 16\n",argv[0],insize);
	  return -1; 
	}   
	insize = strlen(nasid);
	if(insize > 128)
	{
	 // vty_out(vty,"<error> the length of input parameter %s is %d ,excel the limit of 128\n",argv[0],insize);
	  return -2; 
	}
	insize = strcheck(&nasid);	  
	if(insize == 0)
	{
	 // vty_out(vty,"<error> nas identifier %s include unknow character\n",argv[1]);
	  return -3; 
	}
	ifname = (char*)malloc(strlen(inter_name)+1);
	if(ifname)
	{
		memset(ifname, 0, strlen(inter_name)+1);
		memcpy(ifname, inter_name, strlen(inter_name));   
	}
	nas_id = (char*)malloc(strlen(nasid)+1);
	if(nas_id)
	{
		memset(nas_id, 0, strlen(nasid)+1);
		memcpy(nas_id, nasid, strlen(nasid));	
	}
	//WLANID = (int)id;


	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	WLANID = (int)id;
	if(WLANID >= WLAN_NUM || WLANID == 0){
		syslog(LOG_DEBUG,"wlan id in set_interface_nasid_cmd is %d\n",WLANID);
		return -10;
	}


	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WLAN_METHOD_SET_NAS_IDENTIFIER);

	/* query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WLAN_OBJPATH,\
					  WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_SET_NAS_IDENTIFIER);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
					  DBUS_TYPE_BYTE,&WLANID,
					  DBUS_TYPE_STRING,&ifname,
					  DBUS_TYPE_STRING,&nas_id, 					   
					  DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);

	dbus_message_unref(query);

	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		if(ifname)
		{
			free(ifname);
			ifname = NULL;
		}
		if(nas_id)
		{
			free(nas_id);
			nas_id = NULL;
		}
		return SNMPD_CONNECTION_ERROR;
	}

	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu = 1;
	else if(ret == INTERFACE_NOT_EXIST)
		retu = -4;
	else if(ret == APPLY_IF_FAIL)
		retu = -5;
	else if(ret == WLAN_APPLY_SECURITY_FIRST)
		retu = -6;
	else if(ret == WLAN_NOT_NEED_NAS)
		retu = -7;
	else if(ret == WLAN_BE_ENABLE)
		retu = -8;
	else if(ret == IF_BINDING_FLAG)
		retu = -11;
	else
		retu = -9;
	
	dbus_message_unref(reply);
	FREE_OBJECT(ifname);
	FREE_OBJECT(nas_id);
	return retu;   
}

int remove_interface_nasid_cmd_func(dbus_parameter parameter, DBusConnection *connection,int WlanID,char *if_name)
																					/*返回0表示失败，返回1表示成功*/
																					/*返回-1表示the length of if_name is excel the limit of 16*/
																					/*返回-2表示wlan id is not exist*/
																					/*返回-3表示wlan WlanID is not binding interface if_name*/
																					/*返回-4表示interface error*/
																					/*返回-5表示no nas_id needed,please use <wlan apply interface IFNAME>,without nas_identifier*/
																					/*返回-6表示wlan be enable,please service disable first*/
																					/*返回-7表示error，返回-8示WLAN ID非法*/
																					/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == if_name)
		return 0;
	
	int ret,retu;
	char *ifname;
	int insize = 0;
	unsigned char WLANID;
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;

	/*make robust code*/
	insize = strlen(if_name);
	if(insize > 16)
	{
		return -1; 
	}   
  
	ifname = (char*)malloc(strlen(if_name)+1);
	if(NULL == ifname)
		return 0;
	memset(ifname, 0, strlen(if_name)+1);
	memcpy(ifname, if_name, strlen(if_name));   

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	WLANID = WlanID;
	if(WLANID >= WLAN_NUM || WLANID == 0){
		syslog(LOG_DEBUG,"wlan id in remove_interface_nasid_cmd_func is %d\n",WLANID);
		return -8;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WLAN_METHOD_REMOVE_NAS_IDENTIFIER);

	/* query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WLAN_OBJPATH,\
					  WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_REMOVE_NAS_IDENTIFIER);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
					  DBUS_TYPE_BYTE,&WLANID,
					  DBUS_TYPE_STRING,&ifname, 				   
					  DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);

	dbus_message_unref(query);
  
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
		  dbus_error_free(&err);
		}
		if(ifname)
		{
		  free(ifname);
		  ifname = NULL;
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == WLAN_ID_NOT_EXIST)
		retu=-2;
	else if(ret == WLAN_NOT_BINDING_IF)
		retu=-3;
	else if(ret == APPLY_IF_FAIL)
		retu=-4;
	else if(ret == WLAN_NOT_NEED_NAS)
		retu=-5;
	else if(ret == WLAN_BE_ENABLE)
		retu=-6;
	else
		retu=-7;

	dbus_message_unref(reply);
	FREE_OBJECT(ifname);
	return retu; 
}

/*未使用*/
int no_interface_ifname(char *ifname)
{		
	if(NULL == ifname)
		return 0;

	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	int retu = 0;
	int ret = 0;
	char ID = 0;
	int wtpid = 0;
	int wlanid = 0;
	int radioid = 0;
	int g_radioid = 0;
	char *ifmode = (char *)malloc(sizeof(char)*64);
	if(NULL == ifmode)
		return 0;
	char *ifmode1 = (char *)malloc(sizeof(char)*64);
	if(NULL == ifmode1)
		return 0;
	char *id1 = (char *)malloc(sizeof(char)*64);
	if(NULL == id1)
		return 0;
	char *id = (char *)malloc(sizeof(char)*64);
	if(NULL == id)
		return 0;

	unsigned char wlan_policy = 0;

	memset(ifmode,0,64);
	memset(ifmode1,0,64);
	memset(id,0,64);
	memset(id1,0,64);
	if (ifmode == NULL || ifmode1 == NULL || id == NULL || id1 == NULL)
	{
		//vty_out(vty,"malloc or memset failed\n");
		retu = -1;
		return retu;
	}
	//parse IFNAME
	memcpy(ifmode,ifname,4);
	memcpy(ifmode1,ifname,5);

	memcpy(id,ifname+4,(strlen(ifname)-4));
	memcpy(id1,ifname+5,(strlen(ifname)-5));

	//if ifname is wlan
	if (!strcmp(ifmode,"wlan")) {
		//vty_out(vty,"input ifname are small letters,please input capital letters");
		retu = -1;
		return retu;
		}
	else if (!strcmp(ifmode,"WLAN"))
	{
		ret = parse_char_ID(id,&ID);
		
		if (ret != WID_DBUS_SUCCESS) 
		{
			//vty_out(vty,"Wlan ID is unknown\n");

			//free resourse
			FREE_OBJECT(ifmode);
			FREE_OBJECT(ifmode1);
			FREE_OBJECT(id);
			FREE_OBJECT(id1);
			retu = -1;
			return retu;
		}
		
		if ((ID < 1) || (ID > 15))
		{
			//vty_out(vty,"Wlan ID is wrong,ID should be 1-%d\n",WLAN_NUM-1);

			//free resourse
			FREE_OBJECT(ifmode);
			FREE_OBJECT(ifmode1);
			FREE_OBJECT(id);
			FREE_OBJECT(id1);
			retu = -1;
			return retu;
		}	

		wlan_policy = 0;

		query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WLAN_OBJPATH,\
						WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_L3IF_POLICY);

		dbus_error_init(&err);

		dbus_message_append_args(query,
								 DBUS_TYPE_BYTE,&ID,
								 DBUS_TYPE_BYTE,&wlan_policy,
								 DBUS_TYPE_INVALID);

		reply = dbus_connection_send_with_reply_and_block (ccgi_dbus_connection,query,-1, &err);

		//free resourse
		FREE_OBJECT(ifmode);
		FREE_OBJECT(ifmode1);
		FREE_OBJECT(id);
		FREE_OBJECT(id1);

		
		dbus_message_unref(query);
		
		if (NULL == reply)
		{
			if (dbus_error_is_set(&err))
			{
				dbus_error_free(&err);
			}
			return 0;
		}
		
		dbus_message_iter_init(reply,&iter);
		dbus_message_iter_get_basic(&iter,&ret);

		if(ret == 0)
		{
			retu =1;
			return retu;
		}
		else if(ret == WLAN_ID_NOT_EXIST)
			retu = -2;
		else if(ret == WLAN_BE_ENABLE)
			retu = -3;
		else if(ret == WLAN_CREATE_L3_INTERFACE_FAIL)
			retu = -4;
		else
			retu = -5;
		dbus_message_unref(reply);

		
	}
	//if the ifname is radio
	else if (!strcmp(ifmode1,"radio")) {
		//vty_out(vty,"input ifname are small letters,please input capital letters");
		retu = -6;
		return retu;
	}
	else if (!strcmp(ifmode1,"RADIO"))
	{
		ret = parse_radio_ifname(id1,&wtpid,&radioid,&wlanid);
				
		if (ret != WID_DBUS_SUCCESS) 
		{
			//free resourse
			FREE_OBJECT(ifmode);
			FREE_OBJECT(ifmode1);
			FREE_OBJECT(id);
			FREE_OBJECT(id1);
			retu = -6;
			return retu;
		}
		
		// get g_radioid
		g_radioid = wtpid*4 + radioid;
		
		wlan_policy = 0;

		query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WLAN_OBJPATH,\
						WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_L3IF_POLICY2);

		dbus_error_init(&err);

		dbus_message_append_args(query,
								 DBUS_TYPE_UINT32,&wlanid,
								 DBUS_TYPE_BYTE,&wlan_policy,
								 DBUS_TYPE_UINT32,&wtpid,
								 DBUS_TYPE_UINT32,&radioid,
								 DBUS_TYPE_INVALID);

		reply = dbus_connection_send_with_reply_and_block (ccgi_dbus_connection,query,-1, &err);

		//free resourse
		FREE_OBJECT(ifmode);
		FREE_OBJECT(ifmode1);
		FREE_OBJECT(id);
		FREE_OBJECT(id1);
			
		
		dbus_message_unref(query);
		
		if (NULL == reply)
		{
			if (dbus_error_is_set(&err))
			{
				dbus_error_free(&err);
			}
			return 0;
		}
		
		dbus_message_iter_init(reply,&iter);
		dbus_message_iter_get_basic(&iter,&ret);

		if(ret == 0)
			retu = 1;
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -7;
		else if(ret == WLAN_ID_NOT_EXIST)
			retu = -8;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -9;
		else if(ret == WTP_IS_NOT_BINDING_WLAN_ID)
			retu = 10;
		else if(ret == WTP_WLAN_BINDING_NOT_MATCH)
			retu = -11;
		else if(ret == WLAN_BE_ENABLE)
			retu = -12;
		else if(ret == WLAN_CREATE_L3_INTERFACE_FAIL)
			retu = -13;		
		else if(ret == RADIO_IN_EBR)
			retu = -15;
		else
			retu= -14;
		dbus_message_unref(reply);
		
	}
	//the other ifnames,add here
	else {
		//free resourse
		FREE_OBJECT(ifmode);
		FREE_OBJECT(ifmode1);
		FREE_OBJECT(id);
		FREE_OBJECT(id1);
		retu = -1;
		return retu;
	}

	return retu;	  
}


/*type为"number","flow"或"disable"*/
int config_wlan_load_balance(dbus_parameter parameter, DBusConnection *connection,int wid,char *type)/*返回0表示失败，返回1表示成功，返回-1表示wlan id does not exist，返回-2表示operation fail，返回-3表示error，返回-4表示WLAN ID非法*/
																										  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == type)
		return 0;
	
	int ret,retu;
	unsigned char WlanID = 0;
	//unsigned char state=0;
	unsigned char method=0;

	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;

	dbus_error_init(&err);
	
	if (!strcmp(type,"number")){
		method=1;
	}
	else if (!strcmp(type,"flow")){
		method=2;
	} 
	else if (!strcmp(type,"disable")){
		method=0;
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	WlanID = (unsigned char)wid;
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in config_wlan_load_balance is %d\n",WlanID);
		return -4;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WLAN_METHOD_APPAY_WLAN_BALANCE_SWITCH);


	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WLAN_OBJPATH,\
						WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_APPAY_WLAN_BALANCE_SWITCH);*/

	

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&WlanID,
							 DBUS_TYPE_BYTE,&method,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == WLAN_ID_NOT_EXIST)
		retu=-1;
	else if(ret == WID_DBUS_ERROR)
		retu=-2;
	else
		retu=-3;

	
	dbus_message_unref(reply);
	return retu;
}


int config_wlan_number_balance_parameter(dbus_parameter parameter, DBusConnection *connection,int id,char * param)
																					  /*返回0表示失败，返回1表示成功，返回-1表示balance parameter should be 1 to 10*/
					                                                                  /*返回-2表示wlan id does not exist，返回-3表示operation fail ，返回-4表示error，返回-5示WLAN ID非法*/
																					  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{ 
    if(NULL == connection)
        return 0;
	
	if(NULL == param)
		return 0;
	
	int ret;
	int retu = 0;
	unsigned char WlanID = 0;
	unsigned int bal_para=0;
	int res = WID_DBUS_SUCCESS;

	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;

	dbus_error_init(&err);
	
	//WlanID = (unsigned char)id;
	res = parse_int((char*)param, &bal_para);
	if(res != WID_DBUS_SUCCESS){
		retu = -1;
		return retu;
	}	
	if(bal_para > 10 || bal_para < 1){
		retu = -1;
		return retu;
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	
	WlanID = (unsigned char)id;
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in config_wlan_number_balance_parameter is %d\n",WlanID);
		return -5;
	}

	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WLAN_METHOD_APPAY_WLAN_BALANCE_PARA);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WLAN_OBJPATH,\
						WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_APPAY_WLAN_BALANCE_PARA);*/

	

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&WlanID,
							 DBUS_TYPE_UINT32,&bal_para,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu = 1;
	else if(ret == WLAN_ID_NOT_EXIST)
		retu = -2;
	else if(ret == WID_DBUS_ERROR)
		retu = -3;
	else
		retu = -4;
	
	
	dbus_message_unref(reply);
	return retu;
}



int config_wlan_flow_balance_parameter(dbus_parameter parameter, DBusConnection *connection,int wid,char * para)/*返回0表示失败，返回1表示成功，返回-1表示balance parameter should be 1 to 30，返回-2表示wlan id does not exist， 返回-3表示operation fail，返回-4表示error，返回-5示WLAN ID非法*/
																													   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == para)
		return 0;
	
	int ret,retu;
	unsigned char WlanID = 0;
	unsigned int bal_para=0;
	int res = WID_DBUS_SUCCESS;

	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;

	dbus_error_init(&err);
	
	//WlanID = (unsigned char)wid;
	res = parse_int((char*)para, &bal_para);
	if(res != WID_DBUS_SUCCESS){
		return -1;
	}	
	if(bal_para > 30 || bal_para < 1){
		return -1;
	}


	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	WlanID = (unsigned char)wid;
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in config_wlan_flow_balance_parameter is %d\n",WlanID);
		return -5;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WLAN_METHOD_APPAY_WLAN_FLOW_BALANCE_PARA);

	
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WLAN_OBJPATH,\
						WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_APPAY_WLAN_FLOW_BALANCE_PARA);*/

	

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&WlanID,
							 DBUS_TYPE_UINT32,&bal_para,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == WLAN_ID_NOT_EXIST)
		retu=-2;
	else if(ret == WID_DBUS_ERROR)
		retu=-3;
	else
		retu=-4;
	
	dbus_message_unref(reply);
	return retu;
}

/*type为"l3"*/
int wlan_roam_policy(dbus_parameter parameter, DBusConnection *connection,int id,char *type,char*stat)   
																		/*返回0表示失败，返回1表示成功，返回-1表示wlan id does not exist*/
																		/*返回-2表示operation fail，返回-3表示wlan should be disable first*/
																		/*返回-4表示roaming should be disable first，返回-5表示error，返回-6示WLAN ID非法*/
																		/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if((NULL == type)||(NULL == stat))
		return 0;
	
	int ret;
	int retu = 1;
	unsigned char WlanID = 0;
	//unsigned char policy = 0;
	unsigned char state=0;

	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;

	dbus_error_init(&err);
	
	//WlanID = (unsigned char)id;
	
	/*if (!strcmp(type,"fast")){
		policy=1;
	}
	else*/
	/*if (!strcmp(type,"l3")){
		policy=2;
	}*/
	//policy = 2;
	
	if (!strcmp(stat,"enable")){
		state=1;
	}
	else if (!strcmp(stat,"disable")){
		state=0;
	}


	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	WlanID = (unsigned char)id;
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in wlan_roam_policy is %d\n",WlanID);
		return -6;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WLAN_METHOD_ROAMING_POLICY);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WLAN_OBJPATH,\
						WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_ROAMING_POLICY);*/

	

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&WlanID,
							 DBUS_TYPE_BYTE,&state,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}

	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu = 1;
	else if(ret == WLAN_ID_NOT_EXIST)
		retu = -1;
	else if(ret == WID_DBUS_ERROR)
		retu = -2;
	else if(ret == WLAN_BE_ENABLE)
		retu = -3;
	else if(ret == RAOMING_DISABLE_FIRST)		
		retu = -4;
	else
		retu = -5;

	
	dbus_message_unref(reply);
	return retu;
}

int set_wlan_vlan_id(dbus_parameter parameter, DBusConnection *connection,int wlan_id,char *vlan_id) 
																	/*返回0表示失败，返回1表示成功，返回-1表示unknown input*/
																	/*返回-2表示input parameter should be 1 to 4094，返回-3表示wlan id does not exist*/
																	/*返回-4表示wlan is in other L3 interface，返回-5表示wlan should be disable first*/
																	/*返回-6表示error，返回-7示WLAN ID非法*/
																	/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == vlan_id)
		return 0;
	
	int ret = WID_DBUS_SUCCESS;;
	int retu;
	unsigned char WlanID = 0;
	unsigned int vlanid=0;
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;

	dbus_error_init(&err);
	
	//WlanID = (unsigned char)wlan_id;
	
	ret = parse_int_ID((char*)vlan_id, &vlanid);
	
	if(ret != WID_DBUS_SUCCESS){
		return -1;
	}	
	
	if(vlanid > 4094 || vlanid < 1){
		return -2;
	}


	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	WlanID = (unsigned char)wlan_id;
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in set_wlan_vlan_id is %d\n",WlanID);
		return -7;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WLAN_METHOD_SET_WLAN_VLANID);

	
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WLAN_OBJPATH,\
						WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_SET_WLAN_VLANID);*/

	

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&WlanID,
							 DBUS_TYPE_UINT32,&vlanid,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);


	if(ret == 0)
		retu=1;
	else if(ret == WLAN_ID_NOT_EXIST)
		retu=-3;
	else if(ret == IF_POLICY_CONFLICT)
		retu=-4;
	else if(ret == WLAN_BE_ENABLE)
		retu=-5;
	else
		retu=-6;
	
	dbus_message_unref(reply);
	return retu;
}


int set_wlan_vlan_priority(dbus_parameter parameter, DBusConnection *connection,int wlan_id,char *value) 
																		/*返回0表示失败，返回1表示成功，返回-1表示unknown input*/
																		/*返回-2表示input parameter should be 0 to 7，返回-3表示wlan id does not exist*/
																		/*返回-4表示wlan is in other L3 interface，返回-5表示wlan has not binding vlan*/
																		/*返回-6表示wlan should be disable first，返回-7表示wlan is under tunnel wlan-vlan policy*/
																		/*返回-8表示error，返回-9示WLAN ID非法*/
																		/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == value)
		return 0;
		
	int ret = WID_DBUS_SUCCESS;;
	int retu;
	unsigned char WlanID = 0;
	unsigned int priority = 0;

	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;

	dbus_error_init(&err);
	
	//WlanID = (unsigned char)wlan_id;
	
	ret = parse_int_ID((char*)value, &priority);
	
	if(ret != WID_DBUS_SUCCESS)
	{
		return -1;
	}	
	if(priority > 7)
	{
		return -2;
	}



	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	WlanID = (unsigned char)wlan_id;
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in set_wlan_vlan_priority is %d\n",WlanID);
		return -9;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WLAN_METHOD_SET_WLAN_VLAN_PRIORITY);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WLAN_OBJPATH,\
						WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_SET_WLAN_VLAN_PRIORITY);*/

	

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&WlanID,
							 DBUS_TYPE_UINT32,&priority,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == WLAN_ID_NOT_EXIST)
		retu=-3;
	else if(ret == IF_POLICY_CONFLICT)
		retu=-4;
	else if(ret == WLAN_NOT_BINDING_VLAN)
		retu=-5;
	else if(ret == WLAN_BE_ENABLE)
		retu=-6;	
	else if(ret == SYSTEM_CMD_ERROR)
		retu=-7;
	else
		retu=-8;

	
	dbus_message_unref(reply);
	return retu;
}

int undo_wlan_vlan_cmd(dbus_parameter parameter, DBusConnection *connection,int wlan_id)   
															/*返回0表示失败，返回1表示成功，返回-1表示wlan id does not exist*/
															/*返回-2表示wlan is in other L3 interface，返回-3表示wlan should be disable first*/
															/*返回-4表示error，返回-5示WLAN ID非法*/
															/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret = WID_DBUS_SUCCESS;;
	int retu;
	unsigned char WlanID = 0;
	unsigned int vlanid = 0;
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;

	dbus_error_init(&err);
	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	WlanID = (unsigned char)wlan_id;	
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in undo_wlan_vlan_cmd is %d\n",WlanID);
		return -5;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WLAN_METHOD_UNDO_WLAN_VLANID);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WLAN_OBJPATH,\
						WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_UNDO_WLAN_VLANID);*/

	

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&WlanID,
							 DBUS_TYPE_UINT32,&vlanid,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);


	if(ret == 0)
		retu=1;
	else if(ret == WLAN_ID_NOT_EXIST)
		retu=-1;
	else if(ret == IF_POLICY_CONFLICT)
		retu=-2;
	else if(ret == WLAN_BE_ENABLE)
		retu=-3;
	else
		retu=-4;	

	
	dbus_message_unref(reply);
	return retu;
}

void Free_wlan_vlan_info(DCLI_WLAN_API_GROUP *WLANINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WLAN_API_GROUP *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wlan_free_fun");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_WLAN_METHOD_SHOW_WLAN_VLAN_INFO,WLANINFO);
		}
	}
}

/*返回1时，调用Free_wlan_vlan_info()释放空间*/
int show_wlan_vlan_info(dbus_parameter parameter, DBusConnection *connection,int wlan_id,DCLI_WLAN_API_GROUP **WLANINFO) /*返回0表示失败，返回1表示成功，返回-1表示wlan id does not exist，返回-2表示error，返回-3示WLAN ID非法*/
																															  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret = WID_DBUS_SUCCESS;;
	int retu;
	unsigned char WlanID = 0;
	DBusError err;

	dbus_error_init(&err);
	

	WlanID = (unsigned char)wlan_id;
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in show_wlan_vlan_info is %d\n",WlanID);
		return -3;
	}

	void*(*dcli_init_func)(
					int ,
					unsigned char ,
					unsigned int ,
					unsigned int* ,
					unsigned char *,
					DBusConnection *,
					char *
					);
  
    *WLANINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wlan_show_api_group");
		if(NULL != dcli_init_func && connection)
		{
			*WLANINFO = (*dcli_init_func)
				(
					parameter.instance_id,
					WlanID,
					parameter.local_id,
					&ret,
					0,
					connection,
					WID_DBUS_WLAN_METHOD_SHOW_WLAN_VLAN_INFO
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if((ret == 0 )&&(*WLANINFO))
	{
		retu = 1;
	}
	else if(ret == WLAN_ID_NOT_EXIST)
	{
		retu = -1;
	}
	else
	{
		retu = -2;
	}

	return retu;
}

int wlan_set_bridge_isolation_func(dbus_parameter parameter, DBusConnection *connection,int wlan_id,char *STATE)
																				/*返回0表示失败，返回1表示成功，返回-1表示input parameter should only be 'enable' or 'disable'*/
																				/*返回-2表示wlan id does not exist，返回-3表示wlan is not wlan if policy，返回-4表示wlan should be disable first*/
																				/*返回-5表示wlan bridge error，返回-6表示system cmd process error*/
																				/*返回-7表示sameportswitch and isolation are conflict,disable sameportswitch first，返回-8表示error，返回-9示WLAN ID非法*/
																				/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == STATE)
		return 0;
	
	int ret,retu;
	unsigned char WlanID = 0;
	unsigned char state=0;

	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;

	dbus_error_init(&err);
	
	//WlanID = wlan_id;
	
	if (!strcmp(STATE,"enable")){
		state=1;
	}
	else if (!strcmp(STATE,"disable")){
		state=0;
	}
	else
	{
		return -1;
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	WlanID = wlan_id;
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in wlan_set_bridge_isolation_func is %d\n",WlanID);
		return -9;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WLAN_METHOD_SET_BRIDGE_ISOLATION);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WLAN_OBJPATH,\
						WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_SET_BRIDGE_ISOLATION);*/

	

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&WlanID,
							 DBUS_TYPE_BYTE,&state,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == WLAN_ID_NOT_EXIST)
		retu=-2;
	else if(ret == IF_POLICY_CONFLICT)
		retu=-3;
	else if(ret == WLAN_BE_ENABLE)
		retu=-4;
	else if(ret == WLAN_CREATE_BR_FAIL)
		retu=-5;
	else if(ret == SYSTEM_CMD_ERROR)
		retu=-6;
	else if(ret == ISOLATION_CONFLICT)
		retu=-7;	
	else if (ret == WLAN_APPLY_SECURITY_FIRST)
		retu=-10;
	else
		retu=-8;
	
	
	dbus_message_unref(reply);
	return retu;
}

int wlan_set_bridge_multicast_isolation_func(dbus_parameter parameter, DBusConnection *connection,int wlan_id,char *STATE) 
																							/*返回0表示失败，返回1表示成功，返回-1表示input parameter should only be 'enable' or 'disable'*/
																							/*返回-2表示wlan id does not exist，返回-3表示wlan is not wlan if policy，返回-4表示wlan should be disable first*/
																							/*返回-5表示wlan bridge error，返回-6表示system cmd process error*/
																							/*返回-7表示sameportswitch and isolation are conflict,disable sameportswitch first，返回-8表示error，返回-9示WLAN ID非法*/
																							/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == STATE)
		return 0;
	
	int ret,retu;
	unsigned char WlanID = 0;
	unsigned char state=0;

	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;

	dbus_error_init(&err);
	
	//WlanID = wlan_id;
	
	if (!strcmp(STATE,"enable")){
		state=1;
	}
	else if (!strcmp(STATE,"disable")){
		state=0;
	}
	else
	{
		return -1;
	}


	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	WlanID = wlan_id;
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in wlan_set_bridge_multicast_isolation_func is %d\n",WlanID);
		return -9;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WLAN_METHOD_SET_BRIDGE_MULTICAST_ISOLATION);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WLAN_OBJPATH,\
						WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_SET_BRIDGE_MULTICAST_ISOLATION);*/

	

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&WlanID,
							 DBUS_TYPE_BYTE,&state,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == WLAN_ID_NOT_EXIST)
		retu=-2;
	else if(ret == IF_POLICY_CONFLICT)
		retu=-3;
	else if(ret == WLAN_BE_ENABLE)
		retu=-4;
	else if(ret == WLAN_CREATE_BR_FAIL)
		retu=-5;
	else if(ret == SYSTEM_CMD_ERROR)
		retu=-6;
	else if(ret == ISOLATION_CONFLICT)
		retu=-7;
	else if (ret == WLAN_APPLY_SECURITY_FIRST)
		retu=-10;
	else
		retu=-8;
	
	
	dbus_message_unref(reply);
	return retu;
}

void Free_bridge_isolation(DCLI_WLAN_API_GROUP *WLANINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WLAN_API_GROUP *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wlan_free_fun");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_WLAN_METHOD_SHOW_BRIDGE_ISOLATION,WLANINFO);
		}
	}
}

/*返回1时，调用Free_bridge_isolation()释放空间*/
int wlan_show_bridge_isolation_func(dbus_parameter parameter, DBusConnection *connection,int wlan_id,DCLI_WLAN_API_GROUP **WLANINFO)/*返回0表示失败，返回1表示成功，返回-1表示wlan id does not exist，返回-2表示error，返回-3示WLAN ID非法*/
																																		  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{  
    if(NULL == connection)
        return 0;
        
	int ret,retu;
	unsigned char WlanID = 0;
	DBusError err;

	dbus_error_init(&err);
	
	WlanID = wlan_id;
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in wlan_show_bridge_isolation_func is %d\n",WlanID);
		return -3;
	}
	
	void*(*dcli_init_func)(
					int ,
					unsigned char ,
					unsigned int ,
					unsigned int* ,
					unsigned char *,
					DBusConnection *,
					char *
					);

    *WLANINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wlan_show_api_group");
		if(NULL != dcli_init_func)
		{

			*WLANINFO = (*dcli_init_func)
				(
					parameter.instance_id,
					WlanID,
					parameter.local_id,
					&ret,
					0,
					connection,
					WID_DBUS_WLAN_METHOD_SHOW_BRIDGE_ISOLATION
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if((ret == 0 )&&(*WLANINFO))
	{
		retu = 1;
	}
	else if(ret == WLAN_ID_NOT_EXIST)
	{
		retu = -1;
	}
	else
	{
		retu = -2;
	}

	return retu;
}

int set_tunnel_wlan_vlan_cmd_func(dbus_parameter parameter, DBusConnection *connection,int wlan_id,char *STATE,char *IFNAME)  
																								/*返回0表示失败，返回1表示成功，返回-1表示input parameter should only be 'add' or 'delete'*/
																								/*返回-2表示input interface name should only start with 'radio',other interface you should use ebr configuration*/
																								/*返回-3表示if name too long，返回-4表示malloc error，返回-5表示wlan id does not exist*/
																								/*返回-6表示wlan is in local wlan-vlan interface，返回-7表示wlan should be disable first，返回-8表示input ifname is wrong*/
																								/*返回-9表示wlan is not in tunnel mode，返回-10表示if is already STATE,or system cmd error，返回-11表示error，返回-12示WLAN ID非法*/
																								/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if((NULL == STATE)||(NULL == IFNAME))
		return 0;
	
	int ret = WID_DBUS_SUCCESS;;
	int retu;
	unsigned char WlanID = 0;
	char *name;
	int state = 0;
	int lenth = 0;
	char *id = 0;
	int l_wtpid = 0;
	int l_radioid = 0;
	int l_wlanid = 0;
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;
	dbus_error_init(&err);
	
	//WlanID = wlan_id;
	/*if(vty->node == WLAN_NODE){
		WlanID = (int)vty->index;	
	}else if(vty->node == HANSI_WLAN_NODE){
		WlanID = (int)vty->index_sub;	
	}*/
	WlanID = wlan_id;
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in set_tunnel_wlan_vlan_cmd_func is %d\n",WlanID);
		return -12;
	}

	if (!strcmp(STATE,"add")){
		state = 1;
	}
	else if (!strcmp(STATE,"delete")){
		state = 0;
	}
	else
	{
		return -1;
	}

	
	if (strncasecmp(IFNAME,"radio",5))
	{
		return -2;
	}
	else
	{
		lenth = strlen((char *)IFNAME);
		
		if(lenth > 15)
		{		
			return -3;
		}
		
		name = (char *)malloc(sizeof(char)*20);
		if(name == NULL)
		{
			return -4;
		}
		memset(name,0,20);
		memcpy(name,IFNAME,strlen(IFNAME));
		
		char *id = (char *)malloc(sizeof(char)*25);
		if(id )
		{
			memset(id,0,25);
		}
		if(id == NULL)
		{			
			if(name)
			{
				free(name);
				name = NULL;
			}
			return -4;
		}
		memcpy(id,name+5,(lenth-5));
		ret = parse_radio_ifname(id,&l_wtpid,&l_radioid,&l_wlanid);
		if (ret != WID_DBUS_SUCCESS) 
		{
			if(id);
			{
				free(id);
				id = NULL;
			}
			if(name);
			{
				free(name);
				name = NULL;
			}
			return -8;
		}
		
		if (l_wlanid != WlanID)
		{
			//vty_out(vty,"<error> input interface name with wlanid %d not the same with wlan id %d\n",l_wlanid,WlanID);
			if(id);
			{
				free(id);
				id = NULL;
			}
			if(name);
			{
				free(name);
				name = NULL;
			}
			return -8;
		}
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	WlanID = wlan_id;
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in set_tunnel_wlan_vlan_cmd_func is %d\n",WlanID);
		return -12;
	}
	
	memset(name,0,20);
	sprintf(name,"radio%d-%d-%d.%d",index,l_wtpid,l_radioid,l_wlanid);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WLAN_METHOD_SET_TUNNEL_WLAN_VLAN);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WLAN_OBJPATH,\
						WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_SET_TUNNEL_WLAN_VLAN);*/

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&WlanID,
							 DBUS_TYPE_UINT32,&state,
							 DBUS_TYPE_STRING,&name,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		if(name)
		{
			free(name);
			name = NULL;
		}
		if(id)
		{
			free(id);
			id = NULL;
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);


	if(ret == 0)
		retu=1;
	else if(ret == WLAN_ID_NOT_EXIST)
		retu=-5;
	else if(ret == IF_POLICY_CONFLICT)
		retu=-6;
	else if(ret == WLAN_BE_ENABLE)
		retu=-7;
	else if(ret == APPLY_IF_FAIL)
		retu=-8;
	else if(ret == WLAN_CREATE_BR_FAIL)
		retu=-9;
	else if(ret == SYSTEM_CMD_ERROR)
		retu=-10;
	else
		retu=-11;

	
	if(name)
	{
		free(name);
		name = NULL;
	}
	if(id)
	{
		free(id);
		id = NULL;
	}
	dbus_message_unref(reply);
	return retu;
}

void Free_tunnel_wlan_vlan_head(DCLI_WLAN_API_GROUP *WLANINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WLAN_API_GROUP *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wlan_free_fun");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_WLAN_METHOD_SHOW_TUNNEL_WLAN_VLAN,WLANINFO);
		}
	}
}

/*返回1时，调用Free_tunnel_wlan_vlan_head()释放空间*/
int show_tunnel_wlan_vlan_cmd_func(dbus_parameter parameter, DBusConnection *connection,int wlan_id,DCLI_WLAN_API_GROUP **WLANINFO)
																		/*返回0表示失败，返回1表示成功，返回-1表示wlan id does not exist*/
																		/*返回-2表示wlan is in local wlan-vlan interface，返回-3表示wlan should be disable first*/
																		/*返回-4表示input ifname is wrong，返回-5表示wlan is not in tunnel mode*/
																		/*返回-6表示add if to br fail，返回-7表示remove if from br fail，返回-8表示error，返回-9示WLAN ID非法*/
																		/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret = WID_DBUS_SUCCESS;;
	int retu;
	unsigned char WlanID = 0;
	DBusError err;
	dbus_error_init(&err);
	
	WlanID = wlan_id;
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in show_tunnel_wlan_vlan_cmd_func is %d\n",WlanID);
		return -9;
	}

	void*(*dcli_init_func)(
					int ,
					unsigned char ,
					unsigned int ,
					unsigned int* ,
					unsigned char *,
					DBusConnection *,
					char *
					);
					
    *WLANINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wlan_show_api_group");
		if(NULL != dcli_init_func && connection)
		{
			*WLANINFO = (*dcli_init_func)
				(
					parameter.instance_id,
					WlanID,
					parameter.local_id,
					&ret,
					0,
					connection,
					WID_DBUS_WLAN_METHOD_SHOW_TUNNEL_WLAN_VLAN
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else if((ret == 0 )&&(*WLANINFO))
		retu = 1;
	else if(ret == WLAN_ID_NOT_EXIST)
		retu = -1;
	else if(ret == IF_POLICY_CONFLICT)
		retu = -2;
	else if(ret == WLAN_BE_ENABLE)
		retu = -3;
	else if(ret == APPLY_IF_FAIL)
		retu = -4;
	else if(ret == WLAN_CREATE_BR_FAIL)
		retu = -5;
	else if(ret == BSS_L3_INTERFACE_ADD_BR_FAIL)
		retu = -6;
	else if(ret == BSS_L3_INTERFACE_DEL_BR_FAIL)
		retu = -7;
	else
		retu = -8;
	
	return retu;
}

int wlan_set_sameportswitch_func(dbus_parameter parameter, DBusConnection *connection,int wlan_id,char *spswitch_state)
																						/*返回0表示失败，返回1表示成功，返回-1表示input parameter should only be 'enable' or 'disable'*/
																						/*返回-2表示wlan id does not exist，返回-3表示wlan is not wlan if policy，返回-4表示wlan should be disable first*/
																						/*返回-5表示wlan bridge error，返回-6表示system cmd process error*/
																						/*返回-7表示sameportswitch and isolation are conflict,disable isolation first，返回-8表示error，返回-9示WLAN ID非法*/
																						/*返回-10表示apply security in this wlan first*/
																						/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == spswitch_state)
		return 0;
	
	int ret,retu;
	unsigned char WlanID = 0;
	unsigned char state=0;

	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;

	dbus_error_init(&err);
	
	//WlanID = wlan_id;
	
	if (!strcmp(spswitch_state,"enable")){
		state=1;
	}
	else if (!strcmp(spswitch_state,"disable")){
		state=0;
	}
	else
	{
		return -1;
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	WlanID = wlan_id;
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in wlan_set_sameportswitch_func is %d\n",WlanID);
		return -9;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WLAN_METHOD_SET_BRIDGE_SAMEPORTSWICTH);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WLAN_OBJPATH,\
						WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_SET_BRIDGE_SAMEPORTSWICTH);*/

	

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&WlanID,
							 DBUS_TYPE_BYTE,&state,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == WLAN_ID_NOT_EXIST)
		retu=-2;
	else if(ret == IF_POLICY_CONFLICT)
		retu=-3;
	else if(ret == WLAN_BE_ENABLE)
		retu=-4;
	else if(ret == WLAN_CREATE_BR_FAIL)
		retu=-5;
	else if(ret == SYSTEM_CMD_ERROR)
		retu=-6;
	else if(ret == ISOLATION_CONFLICT)
		retu=-7;
	else if (ret == WLAN_APPLY_SECURITY_FIRST)
		retu=-10;
	else
		retu=-8;
	

	
	dbus_message_unref(reply);
	return retu;
}

/*type为"wds"或"mesh"*/
/*state为"enable"或"disable"*/
int config_wds_service_cmd_func(dbus_parameter parameter, DBusConnection *connection,int wlanID,char *type,char *state)  
																				/*返回0表示失败，返回1表示成功，返回-1表示you should bind interface first*/
																				/*返回-2表示you map layer3 interace error，返回-3表示you must first service enable wlan*/
																				/*返回-4表示error，返回-5示WLAN ID非法*/
																				/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if((NULL == type)||(NULL == state))
		return 0;
	
	int ret,retu;
	unsigned char wlan_id;
	unsigned char wds_state;	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	//wlan_id = wlanID;
	str2lower(&state);

	if(!strcmp(type,"wds")){
		if (!strcmp(state,"enable"))
		{
			wds_state = 1;	
		
		}		
		else if (!strcmp(state,"disable"))
		{
			wds_state = 0;
		}
	}
	else if(!strcmp(type,"mesh")){
		if (!strcmp(state,"enable"))
		{
			wds_state = 3;	
		
		}		
		else if (!strcmp(state,"disable"))
		{
			wds_state = 2;
		}
	}
	else{
		//vty_out(vty,"UNKOWN COMMAND\n");
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	wlan_id = wlanID;
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		syslog(LOG_DEBUG,"wlan id in config_wds_service_cmd_func is %d\n",wlan_id);
		return -5;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WDS_METHOD_ENABLE);

   /*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WLAN_OBJPATH,\
						WID_DBUS_WLAN_INTERFACE,WID_DBUS_WDS_METHOD_ENABLE);*/
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&wlan_id,
							 DBUS_TYPE_BYTE,&wds_state,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu = 1;
	else if (ret == INTERFACE_NOT_BE_BINDED)
		retu = -1;
	else if(ret == L3_INTERFACE_ERROR)
		retu = -2;
	else if(ret == WLAN_BE_DISABLE)
		retu = -3;
	else
		retu = -4;
	
	dbus_message_unref(reply);
	
	return retu;
}

/*未使用*/
int set_wlan_essid_func(dbus_parameter parameter, DBusConnection *connection,int wlan_id,char *ESSID)
																	/*返回0表示失败，返回1表示成功*/
																	/*返回-1表示essid is too long,out of the limit of 32*/
																	/*返回-2表示wlan id does not exist*/
																	/*返回-3表示wlan is enable,please disable it first*/
																	/*返回-4表示error，返回-5示WLAN ID非法*/
																	/*返回-6表示UNKNOWN COMMAND*/
																	/*返回-7表示illegal essid name!! ` \ \" & * ( ) not supported!*/
																	/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == ESSID)
		return 0;
	
	int ret,retu;
	unsigned char WlanID = 0;
	char *essid;
	int len = 0;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	//WlanID = wlan_id;
	
	/*len = strlen(ESSID);
	if(len > 32){		
		return -1;
	}
	essid = (char*)malloc(strlen(ESSID)+1);
	if(NULL == essid)
		return 0;
	memset(essid, 0, strlen(ESSID)+1);
	memcpy(essid, ESSID, strlen(ESSID));*/
	
	essid = WID_parse_CMD_str(&ESSID,1,NULL,0);
			if(essid == NULL){		
				//vty_out(vty,"UNKNOWN COMMAND\n");
				//vty_out(vty,"COMMAND should be :set wlan essid as sd\n");
				return -6;
			}
			len = strlen(essid);
			if(len > 32){		
				//vty_out(vty,"<error> essid is too long,out of the limit of 32\n");
				if(essid){
					free(essid);
					essid = NULL;
				}
				return -1;
			}
			if(-1 == ssid_illegal_character_check(essid,len)){
				//vty_out(vty,"essid is null!or checkout the parameter len!\n");
				if(essid){
					free(essid);
					essid = NULL;
				}
				return -1;
			}
			else if(-2==ssid_illegal_character_check(essid,len)){
				//vty_out(vty,"illegal essid name!! ` \ \" & * ( ) not supported!\n");
				if(essid){
					free(essid);
					essid = NULL;
				}
				return -7;
			}
			

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	WlanID = wlan_id;
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in set_wlan_essid_func is %d\n",WlanID);
		return -5;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WLAN_METHOD_SET_ESSID);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WLAN_OBJPATH,\
						WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_SET_ESSID);*/
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&WlanID,
							 DBUS_TYPE_STRING,&essid,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	if(essid)
	{
		free(essid);
		essid = NULL;
	}
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		retu=1;
	}	
	else if(ret == WLAN_ID_NOT_EXIST)
	{
		retu=-2;
	}
	else if(ret == WLAN_BE_ENABLE)
	{
		retu=-3;
	}
	else
	{
		retu=-4;
	}
		
	dbus_message_unref(reply);

	return retu;
}

/*未使用*/
/*state为"enable"或"disable"*/
int set_wlan_sta_ip_mac_binding_cmd(dbus_parameter parameter, DBusConnection *connection,int wlan_id,char *state)
																					/*返回0表示失败，返回1表示成功*/
																					/*返回-1表示input patameter only with 'enable' or 'disable'*/
																					/*返回-2表示error，返回-3示WLAN ID非法*/
																					/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == state)
		return 0;
	
	int ret;
	unsigned char wlanid = 0;
    int policy = 0;
	int retu;
	
	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -1;
	}
			
	wlanid = wlan_id;
	if(wlanid >= WLAN_NUM || wlanid == 0){
		syslog(LOG_DEBUG,"wlan id in set_wlan_sta_ip_mac_binding_cmd is %d\n",wlanid);
		return -3;
	}

	int(*dcli_init_func)(
							int ,
							int ,
							int ,
							unsigned char ,
							DBusConnection *
						);

	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wlan_sta_ip_mac_binding");
		if(NULL != dcli_init_func && connection)
		{
			ret =(*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 policy,
					 wlanid,
					 connection
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(ret == 0)
		retu = 1;
	else if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else
		retu = -2;
	
	return retu; 
}

/*type为(starttimer|stoptimer)，state为(enable|disable)*/
int set_wlan_timer_able_cmd(dbus_parameter parameter, DBusConnection *connection,int wlan_id,char *time_type,char *state)
																						 /*返回0表示失败，返回1表示成功*/
																						 /*返回-1表示first input patameter only with 'starttimer' or 'stoptimer'*/
																						 /*返回-2表示second input patameter only with 'enable' or 'disable'*/
																						 /*返回-3表示error，返回-4示WLAN ID非法*/
																						 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
    if(NULL == connection)
        return 0;
	
	if((NULL == time_type)||(NULL == state))
		return 0;
	
	int ret;
	unsigned char wlanid = 0;
    int policy = 0;
	int timer = 0;
	int retu;

	if (!strcmp(time_type,"starttimer"))
	{
		timer = 1;	
	}
	else if (!strcmp(time_type,"stoptimer"))
	{
		timer = 0;	
	}
	else
	{
		return -1;
	}
	
	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -2;
	}
			
	wlanid = wlan_id;
	if(wlanid >= WLAN_NUM || wlanid == 0){
		syslog(LOG_DEBUG,"wlan id in set_wlan_timer_able_cmd is %d\n",wlanid);
		return -4;
	}

	int(*dcli_init_func)(
							int ,
							int ,
							int ,
							int ,
							unsigned char ,
							DBusConnection *
						);

	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wlan_timer_able");
		if(NULL != dcli_init_func)
		{
			ret =(*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 policy,
					 timer,
					 wlanid,
					 connection
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else if(ret == 0)
		retu = 1;
	else
		retu = -3;
	
	return retu;
}

/*action为(start|stop)，Time's format should be like 12:32:56，Time为(once|cycle)*/
/*argv_num表示输入的weekdays的个数*/
/*char *weekdays[]存放输入的星期*/
int set_wlan_servive_timer_func_cmd(dbus_parameter parameter, DBusConnection *connection,int wlan_id,char *action,char *Time,char *type,int argv_num,char *weekdays[])
																					/*返回0表示失败，返回1表示成功*/
																				    /*返回-1表示input patameter only with 'start' or 'stop'*/
																				    /*返回-2表示input patameter format should be 12:32:56*/
																				    /*返回-3表示input patameter only with 'once' or 'cycle'*/
																				    /*返回-4表示weekdays you want (like Sun Mon Tue Wed Thu Fri Sat or hebdomad)*/																																	  
																				    /*返回-5表示error，返回-6示WLAN ID非法*/
																					/*返回-7表示the starttimer or stoptimer should be disabled*/
																					/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
    if(NULL == connection)
        return 0;
	
	if((NULL == action)||(NULL == Time)||(NULL == type))
		return 0;
	
	int ret;
	unsigned char wlanid = 0;
	unsigned int i = 0;
    int policy = 0;	
    int is_once = 0;
	int time;
	int num = 0;
	int wday = 0;
	int retu;
	if (!strcmp(action,"start"))
	{
		policy = 1;	
	}
	else if (!strcmp(action,"stop"))
	{
		policy = 0;	
	}
	else
	{
		return -1;
	}
	time = Check_Time_Format(Time);
	if(time == -1){
		return -2;
	}

	if (!strcmp(type,"once"))
	{
		is_once = 1;	
	}
	else if (!strcmp(type,"cycle"))
	{
		is_once = 0;	
	}
	else
	{
		return -3;
	}
	num = argv_num;
	if(num <= 0){
		return -4;		
	}
	for(i = 0; i < argv_num; i++){
		if(NULL == weekdays[i])
		{
			return 0;
		}
		
		str2lower(&(weekdays[i]));
		if(strcmp(weekdays[i],"mon") == 0){
			wday |= 0x01; 
		}
		else if(strcmp(weekdays[i],"tue") == 0){
			wday |= 0x02;

		}
		else if(strcmp(weekdays[i],"wed") == 0){
			wday |= 0x04;

		}
		else if(strcmp(weekdays[i],"thu") == 0){
			wday |= 0x08;

		}
		else if(strcmp(weekdays[i],"fri") == 0){
			wday |= 0x10;

		}
		else if(strcmp(weekdays[i],"sat") == 0){
			wday |= 0x20;

		}
		else if(strcmp(weekdays[i],"sun") == 0){
			wday |= 0x40;

		}
		else if(strcmp(weekdays[i],"hebdomad") == 0){
			wday |= 0x7f;
			break;
		}else{
			return -4; 	
		}
	}
			
	wlanid = wlan_id;
	if(wlanid >= WLAN_NUM || wlanid == 0){
		syslog(LOG_DEBUG,"wlan id in set_wlan_servive_timer_func_cmd is %d\n",wlanid);
		return -6;
	}

	int(*dcli_init_func)(
							int ,
							int ,
							int ,
							unsigned char ,
							int ,
							int ,
							int ,
							DBusConnection *
						);

	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wlan_service_control_timer");
		if(NULL != dcli_init_func)
		{
			ret =(*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 policy,
					 wlanid,
					 is_once,
					 wday,
					 time,
					 connection
				  );	
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else if(ret == 0)
		retu = 1;
	else if(ret == WLAN_SERVICE_CONTROL_BE_USED)
		retu = -7;
	else
		retu = -5;
	
	return retu;
}

/*value的范围是0-300000*/
int set_whole_wlan_traffic_limit_cmd(dbus_parameter parameter, DBusConnection *connection,int wlan_id,char *value)
																				  /*返回0表示失败，返回1表示成功*/
																			      /*返回-1表示input parameter error*/
																			      /*返回-2表示wlan id does not exist*/
																			      /*返回-3表示error，返回-4示WLAN ID非法*/
																				  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
																				  /*返回-5表示input parameter should be 0~300000*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == value)
		return 0;
		
	int ret;
	unsigned char WlanID = 0;
	unsigned int traffic_value;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	int retu;

	ret = parse_int_ID((char *)value,&traffic_value);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
		return -1;
	} 
	if(traffic_value<0 || traffic_value> 300000)
	{
		return -5;
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	WlanID = (unsigned char)wlan_id;			
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in set_whole_wlan_traffic_limit_cmd is %d\n",WlanID);
		return -4;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WLAN_METHOD_WHOLE_WLAN_TRAFFIC_LIMIT_VALUE);
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&WlanID,
							 DBUS_TYPE_UINT32,&traffic_value,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);

	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}		
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu = 1;
	else if(ret == WLAN_ID_NOT_EXIST)
		retu = -2;
	else
		retu = -3;
		
	dbus_message_unref(reply);

	return retu;
}

/*value的范围是0-300000*/
int set_whole_wlan_send_traffic_limit_cmd(dbus_parameter parameter, DBusConnection *connection,int wlan_id,char *value)
																						/*返回0表示失败，返回1表示成功*/
																				        /*返回-1表示input parameter error*/
																				        /*返回-2表示wlan id does not exist*/
																				        /*返回-3表示error，返回-4示WLAN ID非法*/
																						/*返回SNMPD_CONNECTION_ERROR表示connection error*/
																						/*返回-5表示input parameter should be 0~300000*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == value)
		return 0;
	
	int ret;
	unsigned char WlanID = 0;
	unsigned int send_traffic_value;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	int retu;

	ret = parse_int_ID((char *)value,&send_traffic_value);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
		return -1;
	} 
	if(send_traffic_value<0 || send_traffic_value> 300000)
	{
		return -5;
	}
	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	WlanID = (unsigned char)wlan_id;	
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in set_whole_wlan_send_traffic_limit_cmd is %d\n",WlanID);
		return -4;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WLAN_METHOD_WHOLE_WLAN_SEND_TRAFFIC_LIMIT_VALUE);
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&WlanID,
							 DBUS_TYPE_UINT32,&send_traffic_value,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);

	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}		
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu = 1;
	else if(ret == WLAN_ID_NOT_EXIST)
		retu = -2;
	else
		retu = -3;
		
	dbus_message_unref(reply);

	return retu;
}


/*未使用*/
/*value的范围是0-300000*/
int set_whole_wlan_station_average_traffic_limit_cmd(dbus_parameter parameter, DBusConnection *connection,int wlan_id,char *value)
																									/*返回0表示失败，返回1表示成功*/
																							        /*返回-1表示input parameter error*/
																							        /*返回-2表示wlan id does not exist*/
																							        /*返回-3表示error，返回-4示WLAN ID非法*/
																									/*返回SNMPD_CONNECTION_ERROR表示connection error*/
																									/*返回-5表示input parameter should be 0~300000*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == value)
		return 0;
	
	int ret;
	unsigned char WlanID = 0;
	unsigned int station_average_traffic_value;
	//int len = 0;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	int retu;

	ret = parse_int_ID((char *)value,&station_average_traffic_value);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
		return -1;
	} 
	if(station_average_traffic_value<0 || station_average_traffic_value> 300000)
	{
		return -5;
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	WlanID = (unsigned char)wlan_id;	
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in set_whole_wlan_station_average_traffic_limit_cmd is %d\n",WlanID);
		return -4;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WLAN_METHOD_WHOLE_WLAN_STA_AVERAGE_TRAFFIC_LIMIT_VALUE);
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&WlanID,
							 DBUS_TYPE_UINT32,&station_average_traffic_value,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);

	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}		
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu = 1;
	else if(ret == WLAN_ID_NOT_EXIST)
		retu = -2;
	else
		retu = -3;
		
	dbus_message_unref(reply);

	return retu;

}


/*未使用*/
/*value的范围是0-300000*/
int set_whole_wlan_station_average_send_traffic_limit_cmd(dbus_parameter parameter, DBusConnection *connection,int wlan_id,char *value)
																										   /*返回0表示失败，返回1表示成功*/
																								           /*返回-1表示input parameter error*/
																								           /*返回-2表示wlan id does not exist*/
																								           /*返回-3表示error，返回-4示WLAN ID非法*/
																										   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
																										   /*返回-5表示input parameter should be 0~300000*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == value)
		return 0;
	
	int ret;
	unsigned char WlanID = 0;
	unsigned int station_average_send_traffic_value;
	//int len = 0;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	int retu;

	ret = parse_int_ID((char *)value,&station_average_send_traffic_value);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
		return -1;
	} 
	if(station_average_send_traffic_value<0 || station_average_send_traffic_value> 300000)
	{
		return -5;
	}
	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
			
	WlanID = (unsigned char)wlan_id;	
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in set_whole_wlan_station_average_send_traffic_limit_cmd is %d\n",WlanID);
		return -4;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WLAN_METHOD_WHOLE_WLAN_STA_AVERAGE_SEND_TRAFFIC_LIMIT_VALUE);
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&WlanID,
							 DBUS_TYPE_UINT32,&station_average_send_traffic_value,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);

	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}		
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu = 1;
	else if(ret == WLAN_ID_NOT_EXIST)
		retu = -2;
	else
		retu = -3;
		
	dbus_message_unref(reply);

	return retu;
}

void Free_show_all_wlan_wapi_basic_information_cmd(struct ConfigWapiInfo *WlanHead)
{
	void (*dcli_init_free_func)(struct ConfigWapiInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_wtp_ConfigWapiInfoInfo");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WlanHead);
		}
	}
}

/*只要调用，就通过Free_show_all_wlan_wapi_basic_information_cmd()释放空间*/
int show_all_wlan_wapi_basic_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct ConfigWapiInfo **WlanHead)
																									   /*返回0表示失败，返回1表示成功*/
																									   /*返回-1表示There is no Wlan now*/
																									   /*返回-2表示There is no Wapi Wlan now*/
																									   /*返回-3表示error*/
																									   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int num = 0;
	int retu;
	
	void*(*dcli_init_func)(
					int ,
					int ,
					DBusConnection *, 
					unsigned int *, 
					unsigned int *
					);

	*WlanHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_ConfigWapiInfo_of_all_wtp");
		if(NULL != dcli_init_func && connection)
		{
			*WlanHead = (*dcli_init_func)
				(
					parameter.instance_id,
					parameter.local_id,
					connection, 
					&num, 
					&ret
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if((*WlanHead!=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if (ret == ASD_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == ASD_WLAN_NOT_EXIST)
	{
		retu = -1;
	}
	else if(ret == ASD_WAPI_WLAN_NOT_EXIST)
	{
		retu = -2;
	}
	else
	{
		retu = -3;
	}

	return retu;
}


void Free_show_all_wlan_ssid_config_information_cmd(struct SSIDConfigInfo *WlanHead)
{
	void (*dcli_init_free_func)(struct SSIDConfigInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_SSIDConfigInfo_head");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WlanHead);
		}
	}
}

/*当*WlanHead不为空时，调用Free_show_all_wlan_ssid_config_information_cmd()释放空间*/
int show_all_wlan_ssid_config_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct SSIDConfigInfo **WlanHead)
																									   /*返回0表示失败，返回1表示成功*/
																									   /*返回-1表示there is no wlan*/
																									   /*返回-2表示error*/
																									   /*返回-3表示security profile does not exist*/
																									   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int wlan_num;
	int ret=0;
	int retu;
	
	void*(*dcli_init_func)(
					int ,
					int ,
					DBusConnection *, 
					unsigned int *, 
					unsigned int *
					);

	*WlanHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_SSIDConfig_info_of_all_wlan");
		if(NULL != dcli_init_func)
		{
			*WlanHead = (*dcli_init_func)
				(
					parameter.instance_id,
					parameter.local_id,
					connection,
					&wlan_num,
					&ret
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(*WlanHead!=NULL && ret==0)
	{
		retu = 1;
	}
	else if(ret == WLAN_ID_NOT_EXIST)
	{	
		retu = -1;
	}
	else if(ret == ASD_SECURITY_NOT_EXIST)
	{
		retu = -3;
	}
	else if(ret == ASD_DBUS_ERROR || ret == WID_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else
	{
		retu = -2;
	}
	
	return retu;
}

void Free_show_all_wlan_unicast_information_cmd(struct UnicastInfo *WlanHead)
{
	void (*dcli_init_free_func)(struct UnicastInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_wtp_UnicastInfo");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WlanHead);
		}
	}
}

/*只要调用，就通过Free_show_all_wlan_unicast_information_cmd()释放空间*/
int show_all_wlan_unicast_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct UnicastInfo **WlanHead)
																								/*返回0表示失败，返回1表示成功*/
																							    /*返回-1表示There is no Wlan now*/
																							    /*返回-2表示There is no Wapi Wlan now*/
																							    /*返回-3表示error*/
																								/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int num = 0;
	int retu;

	void*(*dcli_init_func)(
					int ,
					int ,
					DBusConnection *, 
					unsigned int *, 
					unsigned int *
					);

	*WlanHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_UnicastInfo_of_all_wtp");
		if(NULL != dcli_init_func && connection)
		{
			*WlanHead = (*dcli_init_func)
				(
					parameter.instance_id,
					parameter.local_id,
					connection,
					&num,
					&ret
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if((*WlanHead!=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if (ret == ASD_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == ASD_WLAN_NOT_EXIST)
	{
		retu = -1;
	}
	else if(ret == ASD_WAPI_WLAN_NOT_EXIST)
	{
		retu = -2;
	}
	else
	{
		retu = -3;
	}

	return retu;
}

void Free_show_all_wlan_wapi_performance_stats_information_cmd(struct WtpWAPIPerformanceStatsInfo *WlanHead)
{
	void (*dcli_init_free_func)(struct WtpWAPIPerformanceStatsInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpWAPIPerformanceStatsInfo");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WlanHead);
		}
	}
}

/*只要调用，就通过Free_show_all_wlan_wapi_performance_stats_information_cmd()释放空间*/
int show_all_wlan_wapi_performance_stats_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct WtpWAPIPerformanceStatsInfo **WlanHead)
																								   /*返回0表示失败，返回1表示成功*/
																							       /*返回-1表示There is no Wlan now*/
																							       /*返回-2表示There is no Wapi Wlan now*/
																							       /*返回-3表示error*/
																								   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int num = 0;
	int retu;
	
	void*(*dcli_init_func)(
					int ,
					int ,
					DBusConnection *, 
					unsigned int *, 
					unsigned int *
					);

	*WlanHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_WtpWAPIPerformanceStatsInfo_of_all_wlan");
		if(NULL != dcli_init_func && connection)
		{
			*WlanHead = (*dcli_init_func)
				(
					parameter.instance_id,
					parameter.local_id,
					connection,
					&num,
					&ret
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if((*WlanHead!=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if (ret == ASD_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == ASD_WLAN_NOT_EXIST)
	{
		retu = -1;
	}
	else if(ret == ASD_WAPI_WLAN_NOT_EXIST)
	{
		retu = -2;
	}
	else
	{
		retu = -3;
	}

	return retu;
}

void Free_show_all_wlan_wapi_extend_config_information_cmd(struct WtpWAPIExtendConfigInfo *WlanHead)
{
	void (*dcli_init_free_func)(struct WtpWAPIExtendConfigInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WAPI_WLAN_ExtendConfigInfo");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WlanHead);
		}
	}
}

/*只要调用，就通过Free_show_all_wlan_wapi_extend_config_information_cmd()释放空间*/
int show_all_wlan_wapi_extend_config_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct WtpWAPIExtendConfigInfo **WlanHead)
																								  /*返回0表示失败，返回1表示成功*/
																							      /*返回-1表示There is no Wlan now*/
																							      /*返回-2表示There is no Wapi Wlan now*/
																							      /*返回-3表示error*/
																								  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int num = 0;
	int retu;

	void*(*dcli_init_func)(
					int ,
					int ,
					DBusConnection *, 
					unsigned int *, 
					unsigned int *
					);

	*WlanHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_All_WAPIWlan_ExtendConfigInfo");
		if(NULL != dcli_init_func)
		{
			*WlanHead = (*dcli_init_func)
				(
					parameter.instance_id,
					parameter.local_id,
					connection,
					&num,
					&ret
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if((*WlanHead!=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if (ret == ASD_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == ASD_WLAN_NOT_EXIST)
	{
		retu = -1;
	}
	else if(ret == ASD_WAPI_WLAN_NOT_EXIST)
	{
		retu = -2;
	}
	else
	{
		retu = -3;
	}

	return retu;
}

void Free_show_all_wlan_bss_wapi_performance_stats_information_cmd(struct BssWAPIPerformanceStatsInfo *WlanHead)
{
	void (*dcli_init_free_func)(struct BssWAPIPerformanceStatsInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_BssWAPIPerformanceStatsInfo");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WlanHead);
		}
	}
}

/*只要调用，就通过Free_show_all_wlan_bss_wapi_performance_stats_information_cmd()释放空间*/
int show_all_wlan_bss_wapi_performance_stats_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct BssWAPIPerformanceStatsInfo **WlanHead)
																							  /*返回0表示失败，返回1表示成功*/
																						      /*返回-1表示There is no Wlan now*/
																						      /*返回-2表示There is no Wapi Wlan now*/
																						      /*返回-3表示error*/
																							  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int num = 0;
	int retu;
	
	void*(*dcli_init_func)(
					int ,
					int ,
					DBusConnection *, 
					unsigned int *, 
					unsigned int *
					);

	*WlanHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_BssWAPIPerformanceStatsInfo_of_all_wlan");
		if(NULL != dcli_init_func)
		{
			*WlanHead = (*dcli_init_func)
				(
					parameter.instance_id,
					parameter.local_id,
					connection,
					&num,
					&ret
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if((*WlanHead!=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if (ret == ASD_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == ASD_WLAN_NOT_EXIST)
	{
		retu = -1;
	}
	else if(ret == ASD_WAPI_WLAN_NOT_EXIST)
	{
		retu = -2;
	}
	else
	{
		retu = -3;
	}

	return retu;
}

int set_wlan_ascii_essid_cmd(dbus_parameter parameter, DBusConnection *connection,int wlan_id,unsigned char *new_essid) 
																						/*返回0表示失败，返回1表示成功*/
																						/*返回-1表示essid is too long,out of the limit of 64*/
																						/*返回-2表示wlan id does not exist*/
																						/*返回-3表示wlan is enable,please disable it first*/
																						/*返回-4表示error，返回-5示WLAN ID非法*/
																						/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
        return 0;
	
	if(NULL == new_essid)
		return 0;
	
	int ret;
	unsigned char WlanID = 0;
	unsigned char *ESSID;
	int len = 0;
	//int i = 0;
	unsigned char *a = NULL;
	a = (unsigned char*)malloc(3);
	if(NULL == a)
		return 0;
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;
	int retu = 0;
		
	len = strlen(new_essid);
	if(len > 64)
	{		
		if(a)
		{
			free(a);
			a = NULL;
		}
		return -1;
	}
	if(len<ESSID_DEFAULT_LEN){
		ESSID = (unsigned char*)malloc(ESSID_DEFAULT_LEN);
		if(NULL == ESSID)
			return 0;
		memset(ESSID, 0, ESSID_DEFAULT_LEN);
		memcpy(ESSID, new_essid, strlen(new_essid));
	}else{
		ESSID = (unsigned char*)malloc(strlen(new_essid)+1);
		if(NULL == ESSID)
			return 0;
		memset(ESSID, 0, strlen(new_essid)+1);
		memcpy(ESSID, new_essid, strlen(new_essid));
	}
	
	#if 0
	unsigned long ul;
	ESSID = (unsigned char*)malloc(ESSID_DEFAULT_LEN);
	memset(ESSID, 0, ESSID_DEFAULT_LEN);
	for(i = 0;i < len;i=i+2)
	{
		memset(a,0,3);
		memcpy(a,new_essid+i,2);
		unsigned long int(*dcli_init_func)(unsigned char *);
		if(NULL != ccgi_dl_handle)
		{
			dcli_init_func = dlsym(ccgi_dl_handle,"HexToDec");
			if(NULL != dcli_init_func)
			{
				ul =(*dcli_init_func)(a);
			}
			else
			{
				FREE_OBJECT(ESSID);
				FREE_OBJECT(a);
				return 0;
			}
		}
		else
		{
			FREE_OBJECT(ESSID);
			FREE_OBJECT(a);
			return 0;
		}
		ESSID[i/2] = ul;
		memset(a,0,3);
	}
	#endif

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	

	WlanID = wlan_id;
	if(WlanID >= WLAN_NUM || WlanID == 0){
		syslog(LOG_DEBUG,"wlan id in set_wlan_ascii_essid_cmd is %d\n",WlanID);
		return -5;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WLAN_METHOD_SET_ASCII_ESSID);
																	
	dbus_error_init(&err);
	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&WlanID,
							 DBUS_TYPE_BYTE,&ESSID[0],
							 DBUS_TYPE_BYTE,&ESSID[1],
							 DBUS_TYPE_BYTE,&ESSID[2],
							 DBUS_TYPE_BYTE,&ESSID[3],
							 DBUS_TYPE_BYTE,&ESSID[4],
							
							 DBUS_TYPE_BYTE,&ESSID[5],
							 DBUS_TYPE_BYTE,&ESSID[6],
							 DBUS_TYPE_BYTE,&ESSID[7],
							 DBUS_TYPE_BYTE,&ESSID[8],
							 DBUS_TYPE_BYTE,&ESSID[9],
							
							 DBUS_TYPE_BYTE,&ESSID[10],
							 DBUS_TYPE_BYTE,&ESSID[11],
							 DBUS_TYPE_BYTE,&ESSID[12],
							 DBUS_TYPE_BYTE,&ESSID[13],
							 DBUS_TYPE_BYTE,&ESSID[14],
							
							 DBUS_TYPE_BYTE,&ESSID[15],
							 DBUS_TYPE_BYTE,&ESSID[16],
							 DBUS_TYPE_BYTE,&ESSID[17],
							 DBUS_TYPE_BYTE,&ESSID[18],
							 DBUS_TYPE_BYTE,&ESSID[19],
							
							 DBUS_TYPE_BYTE,&ESSID[20],
							 DBUS_TYPE_BYTE,&ESSID[21],
							 DBUS_TYPE_BYTE,&ESSID[22],
							 DBUS_TYPE_BYTE,&ESSID[23],
							 DBUS_TYPE_BYTE,&ESSID[24],
							 
							 DBUS_TYPE_BYTE,&ESSID[25],
							 DBUS_TYPE_BYTE,&ESSID[26],
							 DBUS_TYPE_BYTE,&ESSID[27],
							 DBUS_TYPE_BYTE,&ESSID[28],
							 DBUS_TYPE_BYTE,&ESSID[29],
							 
							 DBUS_TYPE_BYTE,&ESSID[30],
							 DBUS_TYPE_BYTE,&ESSID[31],
									DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	if(ESSID)
	{
		free(ESSID);
		ESSID = NULL;
	}
	if(a)
	{
		free(a);
		a = NULL;	
	}
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}		
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu = 1;
	else if(ret == WLAN_ID_NOT_EXIST)
		retu = -2;
	else if(ret == WLAN_BE_ENABLE)
		retu = -3;
	else
		retu = -4;
		
	dbus_message_unref(reply);
	return retu;
	
}
//fengwenchao add end

void Free_show_wlan_of_all_cmd(struct WLAN_INFO *wlan_info)
{
	void (*dcli_init_free_func)(struct WLAN_INFO *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wlan_free_info_all");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(wlan_info);
		}
	}
}

/*只要调用，就通过Free_show_wlan_of_all_cmd()释放空间*/
int show_wlan_of_all_cmd(dbus_parameter parameter, DBusConnection *connection,struct WLAN_INFO **wlan_info)
																		   /*返回0表示失败，返回1表示成功*/
																	       /*返回-1表示wlan id does not exist*/
																	       /*返回-2表示error*/
{	
	if(NULL == connection)
        return 0;
	
	int ret = 0;
	int wlan_num = 0;
	int retu = 0;
		
	void*(*dcli_init_func)(
						DBusConnection *,
						int ,
						int ,
						int *,
						int *
					);

	*wlan_info = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_wlan_of_all");
		if(NULL != dcli_init_func)
		{
			*wlan_info = (*dcli_init_func)
				(
					connection,
					parameter.instance_id,
					parameter.local_id,
					&ret,
					&wlan_num
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1)
	{
		retu = 0;
	}
	else if((ret == 0 )&&(*wlan_info != NULL))
	{
		retu = 1;
	}
	else if (ret == WLAN_ID_NOT_EXIST)
	{
		retu = -1;
	}
	else
	{
		retu = -2;
	}

	return retu;
}

/*Switch的取值是"enable"或"disable"*/
int set_wlan_bss_multi_user_optimize_cmd(dbus_parameter parameter, DBusConnection *connection,int wlan_id,char *Switch)
																				/*返回0表示失败，返回1表示成功*/
																				/*返回-1表示WLAN ID非法，返回-2表示bss not exist*/
																				/*返回-3表示operation fail，返回-4表示wlan is not binded radio*/
																				/*返回-5表示error*/
{
	int ret = 0 ; 
	DBusMessage *query,*reply;
	DBusError err;
	DBusMessageIter iter;
	unsigned char type = 0 ; 
	unsigned char wlanid = 0 ;
	int retu = 0;

	if((NULL == connection) || (NULL == Switch))
		return 0;
	
	if(!strcmp(Switch,"enable"))
	{
		type = 1; 
	}
	else if(!strcmp(Switch,"disable"))
	{
		type = 0 ; 
	}
	dbus_error_init(&err);
	
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	wlanid = (unsigned char)wlan_id;			
	if(wlanid >= WLAN_NUM || wlanid == 0){
		syslog(LOG_DEBUG,"wlan id in set_wlan_bss_multi_user_optimize_cmd is %d\n",wlanid);
		return -1;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WLAN_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WLAN_METHOD_WHOLE_WLAN_BSS_MULTI_USER_OPTIMIZE_SWITCH);
	
	dbus_message_append_args(query,
					DBUS_TYPE_BYTE,&wlanid,
					DBUS_TYPE_BYTE,&type,
					DBUS_TYPE_INVALID);
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
		
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return 0;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(WID_DBUS_SUCCESS == ret )
		retu = 1;
	else if(ret==WLAN_ID_NOT_EXIST) 	
		retu = -2;
	else if(ret==WID_DBUS_ERROR)
		retu = -3;
	else if(ret == Wlan_IF_NOT_BE_BINDED)	  
		retu = -4;
	else
		retu = -5;

	dbus_message_unref(reply);
	return retu;
}






/*dcli_wtp.c V1.57*/
/*author liutao*/
/*update time 09-1-05*/

/*dcli_wtp.c V1.72*/
/*author liutao*/
/*update time 09-3-02*/

/*dcli_wtp.c V1.73*/
/*author wangpeng*/
/*update time 09-3-16*/

/*dcli_wtp.c V1.155*/
/*author qiaojie*/
/*update time 09-9-22*/

/*dcli_wtp.c V1.168*/
/*author zhouym*/
/*update time 09-12-08*/

/*dcli_wtp.c V1.192*/
/*author qiaojie*/
/*update time 10-03-31*/


void CheckWTPState(char *state, unsigned char WTPstate){
	
	switch(WTPstate){

		case 2 :
			strcpy(state, "join");
			break;
			
		case 3 :
			strcpy(state, "configure");
			break;
		
		case 4 :
			strcpy(state, "datacheck");
			break;

		case 5 :
			strcpy(state, "run");
			break;
			
		case 7 :
			strcpy(state, "quit");
			break;		

	    case 8 :
			strcpy(state, "imagedata");
			break;
			
		case 9 :
			strcpy(state, "bak_run");
			break;			
		
	}

}
int parse_wtpid_list(char* ptr,update_wtp_list **wtplist)
{
	char* endPtr = NULL;
	int   wtpid1 = 0;
	int   wtpid2 = 0;
	int   min = 0;
	int	  max = 0;
	endPtr = ptr;
	wtp_list_state state = dcli_wtp_check_wtpid;
	struct tag_wtpid *wtp_id = NULL;
	
	while(1)
	{
		switch(state)
		{
			
			case dcli_wtp_check_wtpid: 
									wtpid1 = strtoul(endPtr,&endPtr,10);
									if(wtpid1>0&&wtpid1<WTP_NUM)
									{
					            		state=dcli_wtp_check_comma;
									}
									else
										state=dcli_wtp_check_fail;
									break;
		
			case dcli_wtp_check_comma: 
				
									if(WTP_LIST_SPLIT_COMMA == endPtr[0])
									{
										endPtr = (char*)endPtr + 1;
										state = dcli_wtp_check_wtpid;
										//save wtpid1
										wtp_id = (struct tag_wtpid*)malloc(sizeof(struct tag_wtpid));
										wtp_id->wtpid = wtpid1;
										wtp_id->next = NULL;

										//insert to list
										wtp_id->next = (*wtplist)->wtpidlist;
										(*wtplist)->wtpidlist = wtp_id;
										(*wtplist)->count++;
																				
									}
									else if(WTP_LIST_SPLIT_BAR == endPtr[0])
									{
										endPtr = (char*)endPtr + 1;
										wtpid2 = strtoul(endPtr,&endPtr,10);
										if(wtpid2>0&&wtpid2<WTP_NUM)
										{
						            		//save wtpid1
											min = (wtpid2 > wtpid1)?wtpid1:wtpid2;
											max = (wtpid2 > wtpid1)?wtpid2:wtpid1;
											while(min <= max)
											{
												wtp_id = (struct tag_wtpid*)malloc(sizeof(struct tag_wtpid));
												wtp_id->wtpid = min;
												wtp_id->next = NULL;

												//insert to list
												wtp_id->next = (*wtplist)->wtpidlist;
												(*wtplist)->wtpidlist = wtp_id;
												(*wtplist)->count++;	
													
												min++;
											}
											if('\0' == endPtr[0])
											{
												return 0;
											}
											else
											{											
												endPtr = (char*)endPtr + 1;
												state=dcli_wtp_check_wtpid;
											}
										}
										else
										{
											state = dcli_wtp_check_fail;
										}
										
									}
									else
										state = dcli_wtp_check_end;
									break;
				
		
			case dcli_wtp_check_fail:
				
									return -1;
									break;

			case dcli_wtp_check_end: 
				
									if ('\0' == endPtr[0]) 
									{
										state = dcli_wtp_check_success;
									}
									else
										state = dcli_wtp_check_fail;
									break;
			
			case dcli_wtp_check_success: 
				
										//save wtpid1
										wtp_id = (struct tag_wtpid*)malloc(sizeof(struct tag_wtpid));
										wtp_id->wtpid = wtpid1;
										wtp_id->next = NULL;

										//insert to list
										wtp_id->next = (*wtplist)->wtpidlist;
										(*wtplist)->wtpidlist = wtp_id;
										(*wtplist)->count++;				
									return 0;
									break;
			
			default:

				break;
		}
		
	}
	
}
void destroy_input_wtp_list(update_wtp_list *pwtplist)
{

	if(pwtplist == NULL)
	{
		return;
	}

	struct tag_wtpid *phead = NULL;
	struct tag_wtpid *pnext = NULL;
	phead = pwtplist->wtpidlist;
	
	
	while(phead != NULL)
	{			
		pnext = phead->next;	
		free(phead);
		phead = NULL;
		phead = pnext;

	}	
	
	free(pwtplist);
	pwtplist = NULL;
}
void delsame(update_wtp_list *pwtplist)
{
	struct tag_wtpid *p,*q,*temp1,*temp2;
	
	p = pwtplist->wtpidlist;
	if(p == NULL) return;
	
	q = p->next;
	if(q == NULL) return;
	
	while((p != NULL)&&(p->next != NULL))
	{
	  temp1=p;
	  q=p->next;  
	  while(q)
	  {
		if(p->wtpid != q->wtpid)
	 	{
  			q=q->next;temp1=temp1->next;
	    }
		else
		{
			temp2=q;
			q=q->next;
			temp1->next=q;
			free(temp2);
			temp2 = NULL;
			pwtplist->count--;
			
		}
	  }
	  p=p->next;
	  
	}
}

void str2higher(char **str) {  
	int i,len;
	char *ptr;

	len = strlen(*str);
	ptr = *str;

	for(i=0; i<len ; i++) {
		if((ptr[i]<='z')&&(ptr[i]>='a'))  
			ptr[i] = ptr[i]-'a'+'A';  
	}
	
	return;
}

void CheckWTPQuitReason(char *quitreason,unsigned char quitstate){

	switch(quitstate){

		case 0 :
			strcpy(quitreason, "unknown");
			break;
			
		case 1 :
			strcpy(quitreason, "wtp_unused");
			break;
		
		case 2 :
			strcpy(quitreason, "wtp_normal");
			break;

		case 3 :
			strcpy(quitreason, "no_interface");
			break;
			
		case 4 :
			strcpy(quitreason, "no_if_flag");
			break;				

		case 5 :
			strcpy(quitreason, "if_down");
			break;
		case 6 :
			strcpy(quitreason, "no_if_addr");
			break;
		case 7 :
			strcpy(quitreason, "wtp_timeout");
			break;
		
	}

}


int WID_Check_IP_Format(char* str){
	char *endptr = NULL;
	int endptr1 = 0;
	char c;
	int IP,i;
	c = str[0];
	if (c>='0'&&c<='9'){
		IP= strtoul(str,&endptr,10);
		if(IP < 0||IP > 255)
			return WID_UNKNOWN_ID;
		else if(((IP < 10)&&((endptr - str) > 1))||((IP < 100)&&((endptr - str) > 2))||((IP < 256)&&((endptr - str) > 3))){
			return WID_UNKNOWN_ID;
		}
		for(i = 0; i < 3; i++){
			if(endptr[0] == '\0'||endptr[0] != '.')
				return WID_UNKNOWN_ID;
			else{
				endptr1 = &endptr[1];
				IP= strtoul(&endptr[1],&endptr,10);				
				if(IP < 0||IP > 255)
					return WID_UNKNOWN_ID;				
				else if(((IP < 10)&&((endptr - endptr1) > 1))||((IP < 100)&&((endptr - endptr1) > 2))||((IP < 256)&&((endptr - endptr1) > 3))){
					return WID_UNKNOWN_ID;
				}
			}
		}
		if(endptr[0] == '\0' && IP > 0)
			return WID_DBUS_SUCCESS;
		else
			return WID_UNKNOWN_ID;
	}
	else
		return WID_UNKNOWN_ID;

}


int wid_wtp_parse_char_ID(char* str,unsigned char* ID)
{
	char *endptr = NULL;
	char c;
	c = str[0];
	if (c>='0'&&c<='9')
	{
		*ID= strtoul(str,&endptr,10);
		if(endptr[0] == '\0')
		{
			return WID_DBUS_SUCCESS;
		}
		else
		{
			return WID_UNKNOWN_ID;
		}
	}
	else
	{
		return WID_UNKNOWN_ID;
	}
}

int read_ac_info(char *FILENAME,char *buff)
{
	int len,fd;
	
	fd = open(FILENAME,O_RDONLY);
	if (fd < 0) {
		return 1;
	}	
	len = read(fd,buff,DEFAULT_LEN);	
	if (len < 0) {
		close(fd);
		return 1;
	}	
	close(fd);
	return 0;
}

#if 0
void DcliWReInit(){
	unsigned int count = 0;
	char WTP_COUNT_PATH[] = "/devinfo/maxwtpcount";
	char buf[DEFAULT_LEN];
	memset(buf,0,DEFAULT_LEN);
	if(read_ac_info(WTP_COUNT_PATH,buf) == 0){
		if(parse_int_ID(buf, &count)!=WID_DBUS_SUCCESS)
			return;
		else{
			if(count <= WTP_NUM)
				return;
			WTP_NUM = count;
		}
	}else
		return;
	WTP_NUM += 1;
	G_RADIO_NUM = WTP_NUM*L_RADIO_NUM;
	BSS_NUM = G_RADIO_NUM*L_BSS_NUM;
	return;
}


void DcliWInit(){
	char WTP_COUNT_PATH[] = "/devinfo/maxwtpcount";
	char buf[DEFAULT_LEN];
	memset(buf,0,DEFAULT_LEN);
	if(read_ac_info(WTP_COUNT_PATH,buf) == 0){
		if(parse_int_ID(buf, &WTP_NUM)!=WID_DBUS_SUCCESS)
			WTP_NUM = WTP_DEFAULT_NUM;
	}else
		WTP_NUM = WTP_DEFAULT_NUM;
	WTP_NUM += 1;
	G_RADIO_NUM = WTP_NUM*L_RADIO_NUM;
	BSS_NUM = G_RADIO_NUM*L_BSS_NUM;
	return;
}
#endif

int get_dir_wild_file_count(char *dir, char *wildfile)
{
	DIR *dp = NULL;
	struct dirent *dirp;
	int wildfilecount = 0;

	dp = opendir(dir);
	if(dp == NULL)
	{
		return wildfilecount;
	}

	while((dirp = readdir(dp)) != NULL)
	{
		//printf("dirname = %s count = %d\n",dirp->d_name,wildfilecount);
		if((memcmp(dirp->d_name,wildfile,strlen(wildfile))) ==  0)
		{
			wildfilecount++;
			//printf("count = %d\n",wildfilecount);
		}
	}
	
	//printf("last count = %d\n",wildfilecount);
	closedir(dp);
	return wildfilecount;
	
}

//modify by qiaojie
#if 0
void DcliWReInit(){
	unsigned int count = 0,newlicensecount = 0;
	unsigned int flag = 0;
	int i=0;
	char WTP_COUNT_PATH_BASE[] = "/devinfo/maxwtpcount";
	char buf_base[DEFAULT_LEN];
	char strdir[DEFAULT_LEN];

	newlicensecount = get_dir_wild_file_count("/devinfo","maxwtpcount");
	
	
	if((newlicensecount >= glicensecount))
	{
		{
			/*xiaodawei modify, 20101029*/
			g_wtp_count = realloc(g_wtp_count,newlicensecount*(sizeof(LICENSE_TYPE *)));
			
			for(i=0; i<newlicensecount; i++)
			{
				if(i >= glicensecount){
					g_wtp_count[i] = malloc(sizeof(LICENSE_TYPE));
					g_wtp_count[i]->gmax_wtp_count = 0;
					g_wtp_count[i]->gcurrent_wtp_count = 0;
					g_wtp_count[i]->flag = 0;
				}
				memset(strdir,0,DEFAULT_LEN);
				memset(buf_base,0,DEFAULT_LEN); 
		
				if(i == 0)
				{
					if(read_ac_info(WTP_COUNT_PATH_BASE,buf_base) == 0)
					{
						if(parse_int_ID(buf_base, &count)==-1)
						{
							return WID_NEED_REBOOT;
						}
						if(count < g_wtp_count[i]->gmax_wtp_count)
						{
							return WID_NEED_REBOOT;
						}
						else
						{
							flag = g_wtp_count[i]->flag;
							if(flag!=0)
							{
								g_wtp_binding_count[flag]->gmax_wtp_count -= g_wtp_count[i]->gmax_wtp_count;
								g_wtp_count[i]->gmax_wtp_count = count;
								g_wtp_binding_count[flag]->gmax_wtp_count += g_wtp_count[i]->gmax_wtp_count;
							}
							else
							{
								g_wtp_count[i]->gmax_wtp_count = count;
							}
						}
					}
					else
					{
		
						return WID_NEED_REBOOT;
					}
		
				}
				else
				{
					sprintf(strdir,"/devinfo/maxwtpcount%d",i+1);
					if(read_ac_info(strdir,buf_base) == 0)
					{
						if(parse_int_ID(buf_base, &count)==-1)
						{
							return WID_NEED_REBOOT;
						}
						if(count < g_wtp_count[i]->gmax_wtp_count)
						{
							return WID_NEED_REBOOT;
						}
						else
						{
							flag = g_wtp_count[i]->flag;
							if(flag!=0)
							{
								g_wtp_binding_count[flag]->gmax_wtp_count -= g_wtp_count[i]->gmax_wtp_count;
								g_wtp_count[i]->gmax_wtp_count = count;
								g_wtp_binding_count[flag]->gmax_wtp_count += g_wtp_count[i]->gmax_wtp_count;
							}
							else
							{
								g_wtp_count[i]->gmax_wtp_count = count;
							}
						}
					}
					else
					{
						return WID_NEED_REBOOT;
					}
				}
		
			}
			
			#if 0
			WTP_NUM = 0;
			for(i=0; i<newlicensecount; i++)
			{
				WTP_NUM += g_wtp_count[i]->gmax_wtp_count;
			}
			#endif
		}
		glicensecount = newlicensecount; 
	}	
#if 0
	WTP_NUM += 1;
	G_RADIO_NUM = WTP_NUM*L_RADIO_NUM;
	BSS_NUM = G_RADIO_NUM*L_BSS_NUM;	
#endif
	return;
}
#endif

void DcliWInit(){
	//int licensecount = 0;
	int i = 0;

	
	char WTP_COUNT_PATH_BASE[] = "/devinfo/maxwtpcount";
	char buf_base[DEFAULT_LEN];
	char strdir[DEFAULT_LEN];

	glicensecount = get_dir_wild_file_count("/devinfo","maxwtpcount");
	/*xiaodawei add, 20101115, initialization for g_wtp_binding_count*/
	g_wtp_binding_count = malloc((glicensecount+1)*sizeof(LICENSE_TYPE *));
	for(i=0; i<glicensecount+1; i++){
		g_wtp_binding_count[i] = NULL;
	}
	if(glicensecount == 0)
	{
		/*xiaodawei modify, 20101029*/
		g_wtp_count = malloc(sizeof(LICENSE_TYPE *));
		g_wtp_count[0] = malloc(sizeof(LICENSE_TYPE));
		g_wtp_count[0]->gcurrent_wtp_count = 0;
		g_wtp_count[0]->gmax_wtp_count = WTP_DEFAULT_NUM_AUTELAN;
		g_wtp_count[0]->flag = 0;
		glicensecount = 1;
		/*WTP_NUM = WTP_DEFAULT_NUM_AUTELAN;*/
	}
	else
	{
		/*xiaodawei modify, 20101029*/
		g_wtp_count = malloc(glicensecount*(sizeof(LICENSE_TYPE *)));
		
		for(i=0; i<glicensecount; i++)
		{
			g_wtp_count[i] = malloc(sizeof(LICENSE_TYPE));
			g_wtp_count[i]->gmax_wtp_count = 0;
			g_wtp_count[i]->gcurrent_wtp_count = 0;
			g_wtp_count[i]->flag = 0;
			
			memset(strdir,0,DEFAULT_LEN);
			memset(buf_base,0,DEFAULT_LEN); 
	
			if(i == 0)
			{
				if(read_ac_info(WTP_COUNT_PATH_BASE,buf_base) == 0)
				{
					if(parse_int_ID(buf_base, &g_wtp_count[i]->gmax_wtp_count)==-1)
					g_wtp_count[i]->gmax_wtp_count = WTP_DEFAULT_NUM_AUTELAN;
				}
				else
				{
	
					g_wtp_count[i]->gmax_wtp_count = WTP_DEFAULT_NUM_AUTELAN;
				}
	
			}
			else
			{
				sprintf(strdir,"/devinfo/maxwtpcount%d",i+1);
				if(read_ac_info(strdir,buf_base) == 0)
				{
					if(parse_int_ID(buf_base, &g_wtp_count[i]->gmax_wtp_count)==-1)
					g_wtp_count[i]->gmax_wtp_count = WTP_DEFAULT_NUM_OEM;
				}
				else
				{
					g_wtp_count[i]->gmax_wtp_count = WTP_DEFAULT_NUM_OEM;
				}
			}
	
		}		
/*		for(i=0; i<glicensecount; i++)
		{
			WTP_NUM += g_wtp_count[i]->gmax_wtp_count;
		}
*/
	}
	
	WTP_NUM += 1;
	G_RADIO_NUM = WTP_NUM*L_RADIO_NUM;
	BSS_NUM = G_RADIO_NUM*L_BSS_NUM;
	return;
}

int wtp_check_wtp_ip_addr(char *ipaddr, char *WTPIP)
{
	char c;
	c = WTPIP[0];
	int ret = 0;
	if(c == '\0')
	{
		/*strcpy(ipaddr, "***.***.***.***:*****");*/
		strcpy(ipaddr, "  *.  *.  *.  *:****");
		ret = 1;
	}
	else
	{
		ret = 0;
	}
	
	return ret;
}

int WID_Check_Mask_Format(char* str){
	char *endptr = NULL;
	int endptr1 = 0;
	char c;
	int IP,i;
	c = str[0];
	if (c>='0'&&c<='9'){
		IP= strtoul(str,&endptr,10);
		if(IP < 0||IP > 255)
			return WID_UNKNOWN_ID;
		else if(((IP < 10)&&((endptr - str) > 1))||((IP < 100)&&((endptr - str) > 2))||((IP < 256)&&((endptr - str) > 3))){
			return WID_UNKNOWN_ID;
		}
		for(i = 0; i < 3; i++){
			if(endptr[0] == '\0'||endptr[0] != '.')
				return WID_UNKNOWN_ID;
			else{
				endptr1 = &endptr[1];
				IP= strtoul(&endptr[1],&endptr,10);				
				if(IP < 0||IP > 255)
					return WID_UNKNOWN_ID;				
				else if(((IP < 10)&&((endptr - endptr1) > 1))||((IP < 100)&&((endptr - endptr1) > 2))||((IP < 256)&&((endptr - endptr1) > 3))){
					return WID_UNKNOWN_ID;
				}
			}
		}
		if(endptr[0] == '\0' && IP >= 0)
			return WID_DBUS_SUCCESS;
		else
			return WID_UNKNOWN_ID;
	}
	else
		return WID_UNKNOWN_ID;

}

int check_ip_with_mask(unsigned long ipaddr,unsigned long mask,char * WTPIP)
{
	unsigned long wtpip = dcli_ip2ulong(WTPIP);

	if(((((ipaddr>>24) & 0xFF) & ((mask>>24) & 0xFF)) == (((wtpip>>24) & 0xFF) & ((mask>>24) & 0xFF)))&&
		((((ipaddr>>16) & 0xFF) & ((mask>>16) & 0xFF)) == (((wtpip>>16) & 0xFF) & ((mask>>16) & 0xFF)))&&
		((((ipaddr>>8) & 0xFF) & ((mask>>8) & 0xFF)) == (((wtpip>>8) & 0xFF) & ((mask>>8) & 0xFF)))&&
		((((ipaddr) & 0xFF) & ((mask) & 0xFF)) == (((wtpip) & 0xFF) & ((mask)& 0xFF)))
		)
	{
		return 1;
	}
	else
	{
		return 0;
	}	

}

int check_mac_with_mask(WIDMACADDR *macaddr,WIDMACADDR *macmask,char *WTPMAC)
{
	if(((macaddr->macaddr[0] & macmask->macaddr[0]) == (WTPMAC[0] & macmask->macaddr[0]))&&
		((macaddr->macaddr[1] & macmask->macaddr[1]) == (WTPMAC[1] & macmask->macaddr[1]))&&
		((macaddr->macaddr[2] & macmask->macaddr[2]) == (WTPMAC[2] & macmask->macaddr[2]))&&
		((macaddr->macaddr[3] & macmask->macaddr[3]) == (WTPMAC[3] & macmask->macaddr[3]))&&
		((macaddr->macaddr[4] & macmask->macaddr[4]) == (WTPMAC[4] & macmask->macaddr[4]))&&
		((macaddr->macaddr[5] & macmask->macaddr[5]) == (WTPMAC[5] & macmask->macaddr[5]))
		)
	{
		return 1;
	}
	else
	{
		return 0;
	}	


}

int dcli_wtp_remove_list_repeat(int list[],int num)
{
	int i,j,k;
	for(i=0;i<num;i++){ 
        for(j=i+1;j<num;j++)  { 
              if(list[i]==list[j])  { 
                  num--;
                  for(k=j;k<num;k++) { 
                       list[k]=list[k+1]; 
                  } 
                  j--; 
               } 
         } 
     } 
	/*for(i=0;i<num;i++)
	 {
	 	printf("%d\n",list[i]);
	 }*/
     return num; 

}

int dcli_wtp_parse_wtp_list(char* ptr,int* count,int wtpId[])
{
	char* endPtr = NULL;
	int   i=0;
	endPtr = ptr;
	wtp_list_state state = dcli_wtp_check_wtpid;
	int tempid = 0;

	while(1)
	{
		switch(state)
		{
			
			case dcli_wtp_check_wtpid: 
									wtpId[i] = strtoul(endPtr,&endPtr,10);
									if(wtpId[i]>0&&wtpId[i]<WTP_NUM)
									{
					            		state=dcli_wtp_check_comma;
									}
									else
										state=dcli_wtp_check_fail;
									break;
		
			case dcli_wtp_check_comma: 
									if (WTP_LIST_SPLIT_COMMA== endPtr[0])
									{
										endPtr = (char*)endPtr + 1;
										state = dcli_wtp_check_wtpid;
										i++;
									}
									else if(WTP_LIST_SPLIT_BAR == endPtr[0]){
										endPtr = (char*)endPtr + 1;
										tempid = strtoul(endPtr,&endPtr,10);
										
										if(tempid > 0 && tempid < 4096){
											if(tempid > wtpId[i]){
												while(i<(tempid-wtpId[i]+i)){
													wtpId[i+1] = wtpId[i]+1;
													i++;
 
												}
											}
											else{
												while(i<(wtpId[i]-tempid+i)){
													wtpId[i+1] = wtpId[i]-1; 
													i++; 
												}
											}
											if('\0' == endPtr[0]){
												//return 0;
												state = dcli_wtp_check_success;
												i++;
											}
											else{
												endPtr = (char*)endPtr + 1;
												state = dcli_wtp_check_wtpid;
											}
										}
										else
											state = dcli_wtp_check_fail;
									}
									else
										state = dcli_wtp_check_end;
									break;
				
		
			case dcli_wtp_check_fail:
									return -1;
									break;

			case dcli_wtp_check_end: 
									if ('\0' == endPtr[0]) 
									{
										state = dcli_wtp_check_success;
										i++;
									}
									else
										state = dcli_wtp_check_fail;
									break;
			
			case dcli_wtp_check_success: 
									*count = i;
									return 0;
									break;
			
			default: break;
		}
		
	}
		
}

/*未使用*/
int create_wtp(dbus_parameter parameter, DBusConnection *connection,char *id, char *wtp_name, char* wtp_model, char *wtp_sn)   
																							/*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
																							/*返回-2表示wtp id should be 1 to WTP_NUM-1，返回-3表示wtp name is too long,should be 1 to DEFAULT_LEN-1*/
																							/*返回-4表示the model is wrong，返回-5表示wtp id exist*/
																							/*返回-6表示create wtp count reach to max wtp count，返回-7表示wtp sn exist*/
																							/*返回-8表示error，返回-9表示wtp sn is too long,should be 1 to 127*/
																							/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if((NULL == id)||(NULL == wtp_name)||(NULL == wtp_model)||(NULL == wtp_sn))
		return 0;
	
	int ret,len,retu,snlen;
	unsigned char isAdd = 1;	
	unsigned int wtp_id = 0;
	char *name;
	char* model=NULL;		
	char *sn = NULL;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	int	apcodeflag = 0;
	ret = parse_int_ID((char*)id, &wtp_id);
	if(ret != WID_DBUS_SUCCESS){
		return -1;
	}

	if(wtp_id >= WTP_NUM || wtp_id == 0){
		return -2;
	}    
	
	len = strlen(wtp_name);
	if(len >= DEFAULT_LEN){		
		return -3;
	}	
	name = (char*)malloc(strlen(wtp_name)+1);
	if(NULL == name)
        return 0;
	memset(name, 0, strlen(wtp_name)+1);
	memcpy(name, wtp_name, strlen(wtp_name));	
	
	model = (char*)malloc(strlen(wtp_model)+1);
	if(NULL == model)
        return 0;
	memset(model,0, strlen(wtp_model)+1);
	memcpy(model,wtp_model,strlen(wtp_model)+1);
	
	sn = (char*)malloc(strlen(wtp_sn)+1);
	if(NULL == sn)
        return 0;
	memset(sn, 0, strlen(wtp_sn)+1);
	memcpy(sn, wtp_sn, strlen(wtp_sn));
	str2higher(&wtp_sn);

	
    snlen = strlen(sn);
    if(snlen >= NAS_IDENTIFIER_NAME){
        FREE_OBJECT(name);
		FREE_OBJECT(model);
		FREE_OBJECT(sn);
		return -9;
    }


	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_ADD_DEL_WTP);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ADD_DEL_WTP);*/
	//str2higher(&wtp_sn);
	
	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ADD_DEL_WTP);
	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_BYTE,&isAdd,						
						DBUS_TYPE_STRING,&name,
						DBUS_TYPE_UINT32,&wtp_id,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_STRING,&model,
						DBUS_TYPE_UINT32,&apcodeflag,
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

		if(ret == 0)
        	retu=1;		
		else if(ret == WID_DBUS_ERROR)
			retu=-4;
		else if(ret == WTP_ID_BE_USED)
			retu=-5;
		else if(ret == WTP_OVER_MAX_NUM)
			retu=-6;
		else if(ret == WTP_SN_BE_USED)
			retu=-7;
		else if(ret == WTP_ID_LARGE_THAN_MAX)
			retu=-2;
		else
			retu=-8;
		
	dbus_message_unref(reply);
	FREE_OBJECT(name);	
	FREE_OBJECT(model);
	FREE_OBJECT(sn);
	return retu;	
}

int create_wtp_bymac_cmd_func(dbus_parameter parameter, DBusConnection *connection,char *id, char *wtp_name, char* wtp_model, char *wtp_mac)
																				/*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
																				/*返回-2表示wtp id should be 1 to WTP_NUM-1，返回-3表示wtp name is too long,should be 1 to DEFAULT_LEN-1*/
																				/*返回-4表示Unknow mac addr format，返回-5表示input should not be broadcast or multicast mac*/
																				/*返回-6表示the model is wrong，返回-7表示wtp id exist*/
																				/*返回-8表示create wtp count reach to max wtp count，返回-9表示wtp mac exist，返回-10表示error*/
																				/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if((NULL == id)||(NULL == wtp_name)||(NULL == wtp_model)||(NULL == wtp_mac))
		return 0;
	
	int ret,len;
	unsigned char isAdd;	
	unsigned int wtp_id = 0;
	char *name;
	char *model = NULL;
	unsigned char *mac = NULL;
	int	apcodeflag = 0;
	int boot_flag = 0;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	unsigned char   macAddr[MAC_LEN];
	int op_ret,retu;

	
	isAdd = 1;
	ret = parse_int_ID((char*)id, &wtp_id);
	if(ret != WID_DBUS_SUCCESS){
		return -1;
	}	
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		return -2;
	}	
	len = strlen(wtp_name);	
	if(len >= DEFAULT_LEN){		
		return -3;
	}	
	name = (char*)malloc(strlen(wtp_name)+1);
	if(NULL == name)
        return 0;
	memset(name, 0, strlen(wtp_name)+1);
	memcpy(name, wtp_name, strlen(wtp_name));	
	
	model = (char*)malloc(strlen(wtp_model)+1);
	if(NULL == model)
        return 0;
	memset(model,0, strlen(wtp_model)+1);
	memcpy(model,wtp_model,strlen(wtp_model)+1);
	//str2higher(&model);
	
	mac = (char*)malloc(strlen(wtp_mac)+1);
	if(NULL == mac)
        return 0;
	memset(mac, 0, strlen(wtp_mac)+1);
	memcpy(mac, wtp_mac, strlen(wtp_mac));

	memset(&macAddr,0,sizeof(macAddr));
	
	op_ret = parse_mac_addr(mac,&macAddr);
	if (NPD_FAIL == op_ret) {
		FREE_OBJECT(name);
		FREE_OBJECT(model);
		FREE_OBJECT(mac);
		return -4;
	}
   
	op_ret=is_muti_brc_mac(&macAddr);
	if(op_ret==1){
		FREE_OBJECT(name);
		FREE_OBJECT(model);
		FREE_OBJECT(mac);
		return -5;
	}	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_ADD_DEL_WTP_BY_MAC);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ADD_DEL_WTP_BY_MAC);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_BYTE,&isAdd,						
						DBUS_TYPE_STRING,&name,
						DBUS_TYPE_UINT32,&wtp_id,
						DBUS_TYPE_BYTE,&macAddr[0],
					 	DBUS_TYPE_BYTE,&macAddr[1],
					 	DBUS_TYPE_BYTE,&macAddr[2],
					 	DBUS_TYPE_BYTE,&macAddr[3],
					 	DBUS_TYPE_BYTE,&macAddr[4],
					 	DBUS_TYPE_BYTE,&macAddr[5],
						DBUS_TYPE_STRING,&model,
						DBUS_TYPE_UINT32,&apcodeflag,
						DBUS_TYPE_UINT32,&boot_flag,
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
	    FREE_OBJECT(name);
		FREE_OBJECT(model);
		FREE_OBJECT(mac);

		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

		if(ret == 0)
			retu=1;
		else if(ret == WID_DBUS_ERROR)
			retu=-6;
		else if(ret == WTP_ID_BE_USED)
			retu=-7;
		else if(ret == WTP_OVER_MAX_NUM)
			retu=-8;
		else if(ret == WTP_MAC_BE_USED)
			retu=-9;
		else if(ret == WTP_ID_LARGE_THAN_MAX)
			retu=-2;
		else
			retu=-10;

	dbus_message_unref(reply);
	
	FREE_OBJECT(name);
	FREE_OBJECT(model);
	FREE_OBJECT(mac);

	return retu;	
}


int delete_wtp(dbus_parameter parameter, DBusConnection *connection,int id) /*返回0表示删除失败，返回1表示删除成功*/
																			 /*返回-1表示input wtp id should be 1 to WTP_NUM-1*/
																			 /*返回-2表示wtp id not exist，返回-3表示please unused first*/
																			 /*返回-4表示error，返回-5表示input wtp has some radios interface in ebr,please delete it first*/
																			 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret,retu;
	unsigned char isAdd;	
	unsigned int wtp_id = 0;
	char *name;
	char * model = NULL;
	char *sn = NULL;
	int apcodeflag = 0;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	isAdd = 0;		
	wtp_id = id;		
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		return -1;
	}
	name = (char*)malloc(1);
	if(NULL == name)
        return 0;
	memset(name, 0, 1);
	
	model = (char*)malloc(1);
	if(NULL == model)
        return 0;
	memset(model,0,1);
	
	sn = (char*)malloc(1);
	if(NULL == sn)
        return 0;
	memset(sn, 0, 1);


	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_ADD_DEL_WTP);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ADD_DEL_WTP);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_BYTE,&isAdd,						
						DBUS_TYPE_STRING,&name,
						DBUS_TYPE_UINT32,&wtp_id,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_STRING,&model,
						DBUS_TYPE_UINT32,&apcodeflag,
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);

	FREE_OBJECT(name);
	FREE_OBJECT(sn);
	FREE_OBJECT(model);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
        retu=1;
	else if(ret == WTP_ID_NOT_EXIST)
        retu=-2;		
	else if(ret == WTP_ID_BE_USED)
	    retu=-3;		
	else if(ret == WTP_ID_LARGE_THAN_MAX)
		retu=-1;
	else if(ret == RADIO_IN_EBR)
		retu=-5;
	else
		retu=-4;
	dbus_message_unref(reply);
	FREE_OBJECT(name);
	FREE_OBJECT(sn);
	FREE_OBJECT(model);
	return retu;	
}

/*未使用*/
int delete_model(dbus_parameter parameter, DBusConnection *connection,char*model)/*返回0表示失败，返回1表示成功*/
									 											   /*返回-1表示model does not exist or the model is system default model*/
									 											   /*返回-2表示error*/
																				   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == model)
		return 0;
	
	int ret,retu;
	DBusMessage *query, *reply;	
	DBusMessageIter  iter;
	DBusError err;

	char *buf_model;

	buf_model = (char*)malloc(strlen(model)+1);
	if(NULL == buf_model)
		return 0;
	memset(buf_model, 0, strlen(model)+1);
	memcpy(buf_model, model, strlen(model));	
	
	dbus_error_init(&err);


	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_DELETE_AP_MODEL);


	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_DELETE_AP_MODEL);*/
	
	dbus_message_append_args(query,
						DBUS_TYPE_STRING,&buf_model,
						DBUS_TYPE_INVALID);
	
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	dbus_message_unref(query);

	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		FREE_OBJECT(buf_model);
		return SNMPD_CONNECTION_ERROR;
	}

	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu = 1;
	else if(ret ==WID_NO_SURPORT_MODEL)
		retu = -1;
	else
		retu = -2;
	
	dbus_message_unref(reply);	
	
	FREE_OBJECT(buf_model);

	return retu; 

}

/*echotime的范围是3-30*/
/*wtp_id为0时，表示全局配置*/
int set_ap_echotimer(dbus_parameter parameter, DBusConnection *connection,int wtp_id,int echotime)/*返回0表示失败，返回1表示成功，返回-1表示error，返回-2表示WTP ID非法，返回-3表示input echotimer should be 3~30*/
																									 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	 int ret,retu;
	 DBusMessage *query, *reply; 
	 DBusMessageIter  iter;
	 DBusError err;
	 unsigned int wtpid = 0;
 
	 dbus_error_init(&err);
	 
	 int echotimer = 10;	 
	 /*if((vty->node == CONFIG_NODE)||(vty->node == ENABLE_NODE))
	 {
		 wtpid = 0;
	 }else if(vty->node == WTP_NODE)
	 {
		 wtpid = (unsigned int)vty->index;
	 }*/
	 wtpid = wtp_id;
	if(wtp_id >= WTP_NUM || wtp_id < 0){
		syslog(LOG_DEBUG,"wtp id in set_ap_echotimer is %d\n",wtp_id);
		return -2;
	}
	
	/*fengwenchao modify 20110412*/
	/*ret = parse_int_ID((char*)argv[0], &echotimer);
	if(ret != WID_DBUS_SUCCESS)
	{
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}*/
	//echotimer = atoi(argv[0]);
	echotimer = echotime;
	if((echotimer < 3)||(echotimer > 30))
	{
		return -3;
	}
	/*fengwenchao modify end*/	
	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_AP_TIMER);

	/* query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						 WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_AP_TIMER);*/
	 
	 dbus_message_append_args(query,
						 DBUS_TYPE_UINT32,&wtpid,
						 DBUS_TYPE_UINT32,&echotimer,
						 DBUS_TYPE_INVALID);
	 
	 reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
 
	 dbus_message_unref(query);
	 
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	 
	 dbus_message_iter_init(reply,&iter);
	 dbus_message_iter_get_basic(&iter,&ret);
 
	 if(ret == 0)
		retu = 1;
	 else
		 retu = -1;
	 
	 dbus_message_unref(reply);  
 
	 return retu; 
 
 }

void free_show_ap_echotimer(DCLI_WTP_API_GROUP_THREE *WTPINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_THREE *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun_three");	
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_CONF_METHOD_ECHOTIMER,WTPINFO);
		}
	}
}
/*retu =1 的时候调用释放函数free_show_ap_echotimer(DCLI_WTP_API_GROUP_THREE *WTPINFO)*/
int  show_ap_echotimer(dbus_parameter parameter, DBusConnection *connection,DCLI_WTP_API_GROUP_THREE **WTPINFO)/*返回0表示失败，返回1表示成功*/
																													/*返回SNMPD_CONNECTION_ERROR表示connection error*/
 {
    if(NULL == connection)
        return 0;
        
	int ret,retu = 0;
	
	void *(*dcli_init_func)(
					int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int* ,
					unsigned int* ,
					unsigned int* ,
					unsigned char *,
					unsigned char *,
					int *,
					DBusConnection *,
					char *
					);

    *WTPINFO = NULL;	
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_three");
		if(NULL != dcli_init_func && connection)
		{
			*WTPINFO = (*dcli_init_func)(
				parameter.instance_id,
				FIRST,/*"show ap echotimer"*/
				0,
				0,
				0,
				&ret,/**/
				0,/*num2*/
				0,
				0,
				0,
				&(parameter.local_id),
				connection,
				WID_DBUS_CONF_METHOD_ECHOTIMER
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}


	if(ret == -1)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if((ret == 0)&&(*WTPINFO))
	{
 		retu = 1;
	}
	
	return retu;
}

int set_ap_model(dbus_parameter parameter, DBusConnection *connection,char*model,char*ver,char*path, char* radio,char * bss)/*返回0表示失败，返回1表示成功，返回-1表示wireless-control does not surport this model，返回-2表示error*/
																																/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if((NULL == model)||(NULL == ver)||(NULL == path)||(NULL == radio)||(NULL == bss))
		return 0;
	
	int ret,retu;
	DBusMessage *query, *reply;	
	DBusMessageIter  iter;
	DBusError err;

	char *buf_model;
	char *buf_version;//[256];
	char *buf_path;//[256];

	unsigned char radiocount;
	unsigned char bsscount;
	
	buf_model = (char*)malloc(strlen(model)+1);
	if(NULL == buf_model)
        return 0;
	memset(buf_model, 0, strlen(model)+1);
	memcpy(buf_model, model, strlen(model));	

	buf_version = (char*)malloc(strlen(ver)+1);
	if(NULL == buf_version)
        return 0;
	memset(buf_version, 0, strlen(ver)+1);
	memcpy(buf_version, ver, strlen(ver));	

	buf_path = (char*)malloc(strlen(path)+1);
	if(NULL == buf_path)
        return 0;
	memset(buf_path, 0, strlen(path)+1);
	memcpy(buf_path, path, strlen(path));	

	radiocount = atoi(radio);
	bsscount = atoi(bss);
	
	dbus_error_init(&err);

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_VERSION_PATH);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_VERSION_PATH);*/
	
	dbus_message_append_args(query,
						DBUS_TYPE_STRING,&buf_model,
						DBUS_TYPE_STRING,&buf_version,
						DBUS_TYPE_STRING,&buf_path,
						DBUS_TYPE_BYTE,&radiocount,
						DBUS_TYPE_BYTE,&bsscount,
						DBUS_TYPE_INVALID);
	
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);

	dbus_message_unref(query);

	
    if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu = 1;
	else if(ret ==WID_NO_SURPORT_MODEL)
		retu = -1;
	else
		retu = -2;
	
	dbus_message_unref(reply);	
	
	FREE_OBJECT(buf_model);
	FREE_OBJECT(buf_path);
	FREE_OBJECT(buf_version);
	
	return retu; 

}

int download_ap_version(char *url,char *user,char *passwd)
{
	if((NULL == url)||(NULL == user)||(NULL == passwd))
		return -1;
	
	char cmd[256];
	int op_ret=-1,status=0,tt_ret=-1;
	char* filename=strrchr(url,'/');
	memset(cmd,0,256);
	if(filename)
	{
		sprintf(cmd,"down_ap_img.sh %s %s %s %s \n",url,user,passwd,filename+1);
		op_ret=system(cmd);

		if(op_ret==0)
		{
			memset(cmd,0,256);
			sprintf(cmd,"sudo sor.sh cp wtp/%s %d > /dev/null",filename+1,LONG_SORT);
		    status = system(cmd);
	        tt_ret = WEXITSTATUS(status);		
		}		
	}
	
	return tt_ret;
}

void Free_one_wtp_head(DCLI_WTP_API_GROUP_ONE *WTPINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_ONE *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_CONF_METHOD_SHOWWTP,WTPINFO);
		}
	}
}

/*返回1时，调用Free_one_wtp_head()释放空间*/
int show_wtp_one(dbus_parameter parameter, DBusConnection *connection,int id,DCLI_WTP_API_GROUP_ONE **WTPINFO)
																			   /*返回0表示失败，返回1表示成功*/
                                                                               /*返回-1表示wtp id should be 1 to WTP_NUM-1*/
																			   /*返回-2表示wtp不存在，返回-3表示error*/
																			   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret;
	unsigned int wtp_id = 0;
	unsigned char num;
	int retu;

	wtp_id = id;
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		return -1;
	}
	

	void*(*dcli_init_func)(
					int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int* ,
					unsigned int* ,
					unsigned int* ,
					unsigned char *,
					unsigned char *,
					int *,
					DBusConnection *,
					char *
					);

    *WTPINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_one");
		if(NULL != dcli_init_func && connection)
		{
			*WTPINFO =(*dcli_init_func)
				  (
					parameter.instance_id,
					FIRST,
					wtp_id,
					0,
					0,
					0,/**/
					&ret,/*num2*/
					0,
					num,
					0,
					&(parameter.local_id),
					connection,
					WID_DBUS_CONF_METHOD_SHOWWTP
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1)
	{
	    retu = SNMPD_CONNECTION_ERROR;    
    }
	else if((ret == 0)&&(*WTPINFO))
	{
		retu = 1;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -2;
	}
	else if(ret == WTP_ID_LARGE_THAN_MAX)
	{
		retu = -1;
	}
	else 
	{
		retu = -3;
	}

	return retu;	
}

void Free_wtp_list_new_head(DCLI_WTP_API_GROUP_ONE *WTPINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_ONE *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_CONF_METHOD_WTPLIST_NEW,WTPINFO);
		}
	}
}

/*返回1时，调用Free_wtp_list_new_head()释放空间*/
int show_wtp_list_new_cmd_func(dbus_parameter parameter, DBusConnection *connection,DCLI_WTP_API_GROUP_ONE **WTPINFO)/*返回0表示失败，返回1表示成功，返回-1表示no wtp exist*/
																															 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret;
	int retu = 0;

	void*(*dcli_init_func)(
					int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int* ,
					unsigned int* ,
					unsigned int* ,
					unsigned char *,
					unsigned char *,
					int *,
					DBusConnection *,
					char *
					);

    *WTPINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_one");
		if(NULL != dcli_init_func && connection)
		{
			*WTPINFO =(*dcli_init_func)
				  (
					parameter.instance_id,
					SECOND,/*"show wtp (list|all)"*/
					0,
					0,
					0,
					0,/**/
					&ret,/*num2*/
					0,
					0,
					0,
					&(parameter.local_id),
					connection,
					WID_DBUS_CONF_METHOD_WTPLIST_NEW
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if((ret == 0)&&(*WTPINFO))
	{
		retu = 1;
	}
	else if(ret == 5)
	{
		retu = -1;
	}
	
	return retu;	
}


void Free_wtp_list_by_sn_head(DCLI_WTP_API_GROUP_ONE *WTPINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_ONE *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_CONF_METHOD_WTPLIST,WTPINFO);
		}
	}
}

/*返回1时，调用Free_wtp_list_by_sn_head()释放空间*/
int show_wtp_list_by_sn_cmd_func(dbus_parameter parameter, DBusConnection *connection,DCLI_WTP_API_GROUP_ONE **WTPINFO)/*返回0表示失败，返回1表示成功*/
																															   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret;
	int retu = 0;

	void*(*dcli_init_func)(
					int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int* ,
					unsigned int* ,
					unsigned int* ,
					unsigned char *,
					unsigned char *,
					int *,
					DBusConnection *,
					char *
					);

    *WTPINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_one");
		if(NULL != dcli_init_func)
		{
			*WTPINFO =(*dcli_init_func)
				  (
					parameter.instance_id,
					THIRD,/*"show wtp (list|all) by sn"*/
					0,
					0,
					0,
					0,/**/
					&ret,/*num2*/
					0,
					0,
					0,
					&(parameter.local_id),
					connection,
					WID_DBUS_CONF_METHOD_WTPLIST
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if((ret == 0)&&(*WTPINFO))
	{
		retu = 1;
	}

	return retu;	
}

void Free_wtp_list_by_mac_head(DCLI_WTP_API_GROUP_ONE *WTPINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_ONE *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_CONF_METHOD_WTPLIST_BYMAC,WTPINFO);
		}
	}
}

/*返回1时，调用Free_wtp_list_by_mac_head()释放空间*/
int show_wtp_list_by_mac_cmd_func(dbus_parameter parameter, DBusConnection *connection,DCLI_WTP_API_GROUP_ONE **WTPINFO)/*返回0表示失败，返回1表示成功*/
																																 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret;
	int retu = 04;

	void*(*dcli_init_func)(
					int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int* ,
					unsigned int* ,
					unsigned int* ,
					unsigned char *,
					unsigned char *,
					int *,
					DBusConnection *,
					char *
					);
					
    *WTPINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_one");
		if(NULL != dcli_init_func && connection)
		{
			*WTPINFO =(*dcli_init_func)
				  (
					parameter.instance_id,
					FOURTH,/*"show wtp (list|all) by mac"*/
					0,
					0,
					0,
					0,/**/
					&ret,/*num2*/
					0,
					0,
					0,
					&(parameter.local_id),
					connection,
					WID_DBUS_CONF_METHOD_WTPLIST_BYMAC
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(ret == -1)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if((ret == 0)&&(*WTPINFO))
	{	
		retu = 1;
	}

	return retu;
}

void Free_wtp_model(DCLI_WTP_API_GROUP_ONE *WTPINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_ONE *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun");	
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_CONF_METHOD_ACVERSION,WTPINFO);
		}
	}
}

/*返回1时，调用Free_wtp_model()释放空间*/
int show_version(dbus_parameter parameter, DBusConnection *connection,DCLI_WTP_API_GROUP_ONE **WTPINFO)/*返回1表示成功，返回0表示失败*/
																										  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{

    if(NULL == connection)
        return 0;
        
	int ret,retu = 0;
	
	void *(*dcli_init_func)(
					int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int* ,
					unsigned int* ,
					unsigned int* ,
					unsigned char *,
					unsigned char *,
					int *,
					DBusConnection *,
					char *
					);
					
    *WTPINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_one");
		if(NULL != dcli_init_func && connection)
		{
			*WTPINFO = (*dcli_init_func)(
			   parameter.instance_id,
			   FIFTH,/*"show wtp (list|all)"*/
			   0,
			   0,
			   0,
			   0,/**/
			   &ret,/*num2*/
			   0,
			   0,
			   0,
			   &(parameter.local_id),
			   connection,
			   WID_DBUS_CONF_METHOD_ACVERSION
			   );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1){
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if((ret == 0)&&(*WTPINFO)){
 		retu = 1;
	}
	return retu;

}

#if _GROUP_POLICY
void Free_wtp_apply_interface_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-7时，调用Free_wtp_apply_interface_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int wtp_apply_interface_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *inter_name,struct WtpList **WtpList_Head)   
						/*返回0表示失败，返回1表示成功，返回-1表示the length of interface name excel 16*/
						/*返回-2表示interface does not exist，返回-3表示if you want to change binding interface, please delete binding wlan id first*/
						/*返回-4表示error，返回-5示WTP ID非法，返回-6表示Group ID非法，返回-7表示partial failure*/
						/*返回-8表示is no local interface, permission denial*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == inter_name)
	{
		*WtpList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int ret6 = 0;
	int count =0;
	int insize = 0;
	unsigned int id= 0;
	unsigned int type = 0;
	char *ifname = NULL;
	int retu = 0;
	
	insize = strlen(inter_name);
	if(insize > 16)
	{
		return -1; 
	}
	
	//wtp_id = (unsigned int)vty->index;
	
	ifname = (char*)malloc(strlen(inter_name)+1);
	if(NULL == ifname)
        return 0;
	memset(ifname, 0, strlen(inter_name)+1);
	memcpy(ifname, inter_name, strlen(inter_name));	

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id == 0){
			syslog(LOG_DEBUG,"wtp id in wtp_apply_interface_group is %d\n",id);
			return -5;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in wtp_apply_interface_group is %d\n",id);
			return -6;
		}
	}

	void*(*dcli_init_func)(
						int ,
						int ,
					    DBusConnection * , 
					    unsigned int ,
					    unsigned int ,
					    char *,
					    int *,
					    unsigned int *,
					    unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"wtp_apply_interface_cmd_wtp_apply_interface");
		if(NULL != dcli_init_func && connection)
		{
			
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection,
					  type,id,
					  &ifname,
					  &count,
					  &ret,
					  &ret6
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if((ret == 0)&&(ret6 == 0))
	{
		retu = 1;
		if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL)){
			retu = -7;
			/*vty_out(vty,"wtp ");					
			for(i=0; i<count; i++){
				
				vty_out(vty," 555.\n");
				if(Wtp_Show_Node == NULL)
					Wtp_Show_Node = WtpList_Head->WtpList_list;
				else 
					Wtp_Show_Node = Wtp_Show_Node->next;

				if(Wtp_Show_Node == NULL)
					break;
				
				vty_out(vty,"%d \n",Wtp_Show_Node->WtpId);					
			}
			
			vty_out(vty," failed.\n");*/
		}
	}	
	else if(ret == 0)
	{
		retu = 1;
	}
	else if(ret6 == 0)
	{
		retu = 1;
	}
	else
	{			
		if(ret == INTERFACE_NOT_EXIST) 
			retu = -2;
		else if(ret == APPLY_IF_FAIL)
			retu = 0;
		else if(ret == WID_BINDING_WLAN)
			retu = -3;		
		else if (ret == WID_INTERFACE_NOT_BE_LOCAL_BOARD)
			retu = -8;
		else
			retu = -4;
	}
	
	if(ifname!= NULL){
		free(ifname);
		ifname = NULL;
	}
	/*if(*WtpList_Head != NULL){
		dcli_free_WtpList(WtpList_Head);
	}*/
	
	return retu; 
}
#endif

int wtp_apply_interface(dbus_parameter parameter, DBusConnection *connection,int id,char *inter_name)  
																	  /*返回0表示失败，返回1表示成功，返回-1表示the length of interface name excel 16*/
																	  /*返回-2表示interface does not exist，返回-3表示if you want to change binding interface, please delete binding wlan id first*/
																	  /*返回-4表示error，返回-5示WTP ID非法*/
																	  /*返回-8表示is no local interface, permission denial*/
																	  /*返回-9表示if you want to change binding interface, please unused wtp  first*/
																	  /*返回-10表示interface has be binded in other hansi*/
																	  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == inter_name)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = wtp_apply_interface_group(parameter, connection,0,id,inter_name,&WtpList_Head);
	if(retu == -7)
	{
		Free_wtp_apply_interface_group(WtpList_Head);
	}
	return retu;
#else
	int ret,retu;
	int ret6;
	unsigned int wtp_id;
	char *ifname;	
	int insize = 0;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	insize = strlen(inter_name);
	if(insize > 16)
	{
		return -1;	
	}
	
	//wtp_id = id;
	
	ifname = (char*)malloc(strlen(inter_name)+1);
	if(NULL == ifname)
        return 0;
	memset(ifname, 0, strlen(inter_name)+1);
	memcpy(ifname, inter_name, strlen(inter_name));	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	
	wtp_id = id;
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		syslog(LOG_DEBUG,"wtp id in wtp_apply_interface is %d\n",wtp_id);
		return -5;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_IFNAME);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_IFNAME);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,					
						DBUS_TYPE_UINT32,&wtp_id,
						DBUS_TYPE_STRING,&ifname,						 
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		if(ifname)
		{
			free(ifname);
			ifname = NULL;
		}

		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&ret6);
    
		
		if((ret == 0)&&(ret6 == 0)){
			retu = 1;
			//vty_out(vty,"IPV4: wtp %d bind interface %s successfully.\n",wtp_id,ifname);
			//vty_out(vty,"IPV6: wtp %d bind interface %s successfully.\n",wtp_id,ifname);
		}
		else if(ret == 0){
			retu = 1;
			/*vty_out(vty,"IPV4: wtp %d bind interface %s successfully.\n",wtp_id,ifname);
			if(ret6 != 0) 
				vty_out(vty,"<warnning>IPV6: wtp binding ipv6 addr fail.\n");*/
		}
		else if(ret6 == 0){
			retu = 1;
			/*if(ret == INTERFACE_NOT_EXIST) 
				vty_out(vty,"<warnning>IPV4: interface %s does not exist\n",ifname);
			else if(ret == APPLY_IF_FAIL)
				vty_out(vty,"<warnning>IPV4: apply interface %s failed\n",ifname);
			else if(ret == WID_BINDING_WLAN)
				vty_out(vty,"<warnning>IPV4: if you want to change binding interface, please delete binding wlan id first\n");
			else if(ret == WTP_BE_USING) 
				vty_out(vty,"<warnning>IPV4: if you want to change binding interface, please unused wtp  first\n");
			else if(ret == IF_BINDING_FLAG){
				vty_out(vty,"<error>IPV4: interface %s has be binded in other hansi.\n",ifname);
			}
			vty_out(vty,"IPV6: wtp %d bind interface %s successfully.\n",wtp_id,ifname);*/
		}
		else{			
			if(ret == INTERFACE_NOT_EXIST) 
				retu = -2;
				//vty_out(vty,"<error>IPV4: interface %s does not exist\n",ifname);
			else if(ret == APPLY_IF_FAIL)
				retu = 0;
				//vty_out(vty,"<error>IPV4: apply interface %s failed\n",ifname);
			else if(ret == WID_BINDING_WLAN)
				retu = -3;
				//vty_out(vty,"<error>IPV4: if you want to change binding interface, please delete binding wlan id first\n");
			else if(ret == IF_BINDING_FLAG)
				retu = -10;
				//vty_out(vty,"<error>IPV4: interface %s has be binded in other hansi.\n",ifname);
			else if (ret == WID_INTERFACE_NOT_BE_LOCAL_BOARD)
				retu = -8;
				//vty_out(vty,"<error> %s is no local interface, permission denial\n",ifname);
			else if(ret == WTP_BE_USING)  /*wcl modify for AUTELAN-2814*/
				{
					retu = -9;
				//vty_out(vty,"<warnning>IPV4: if you want to change binding interface, please unused wtp  first\n");
				}
			else {
					retu = -4;
				//vty_out(vty,"<error>IPV4:wtp binding ipv4 fail.errno is %d\n",ret);
				}
			if(ret6 == WTP_BE_USING)
				{
					retu = -9;
			//vty_out(vty,"<warnning>IPV6: if you want to change binding interface, please unused wtp  first\n");
				}
			else if(ret6 == APPLY_IF_FAIL)
				{	
					retu = -4;
			//vty_out(vty,"<error>IPV6: apply interface %s failed\n",ifname);
			}
			else 
				{
			//vty_out(vty,"<error>IPV6:wtp binding ipv6 addr fail.errno is %d\n",ret6);
				}/*wcl modify for AUTELAN-2814*/
		}

	/*	else if((ret == WTP_ID_NOT_EXIST)||(ret6 == WTP_ID_NOT_EXIST))
			vty_out(vty,"<error> wtp id does not exist\n");
		else if((ret == WTP_BE_USING)||(ret6 == WTP_BE_USING))
			vty_out(vty,"<error> wtp is using\n");
		else if((ret == INTERFACE_NOT_EXIST)&&(ret6 == 0))
			vty_out(vty,"<warnning>wtp bingding ipv6 addr success,but bingding ipv4 addr fail\n");		
		else if((ret == APPLY_IF_FAIL)&&(ret6 == 0))			
			vty_out(vty,"<warnning>wtp bingding ipv6 addr success,but bingding ipv4 addr fail\n");
		else if(ret == WID_BINDING_WLAN)
			vty_out(vty,"<error> if you want to change binding interface, please delete binding wlan id first\n");
		else if((ret == 0)&&(ret6 != 0)){
			vty_out(vty,"<warnning> wtp bingding ipv4 addr success,but bingding ipv6 addr fail\n");
			 }
		else if((ret != 0)&&(ret6 == 0)){
			vty_out(vty,"<warnning> wtp bingding ipv6 addr success,but bingding ipv4 addr fail\n");
			 }	
		else if((ret != 0)&&(ret6 != 0)){
			vty_out(vty,"<error> wtp bingding ipv6 addr fail,but bingding ipv4 addr fail\n");
			 }			
		else
			vty_out(vty,"<error>  %d\n",ret); */
		
	dbus_message_unref(reply);
	FREE_OBJECT(ifname);
	return retu;	
#endif
}

/*未使用*/
int wtp_apply_ipv6interface(dbus_parameter parameter, DBusConnection *connection,int id,char *inter_name) 
																		/*返回0表示失败，返回1表示成功*/
																		/*返回-1表示the length of input parameter is excel the limit of 16*/
																		/*返回-2表示wtp id does not exist，返回-3表示wtp is using*/
																		/*返回-4表示interface does not exist，返回-5表示apply interface failed*/
																		/*返回-6表示if you want to change binding interface, please delete binding wlan id first*/
																		/*返回-7表示wtp bingding ipv6 addr error make sure interface have ipv6 address*/
																		/*返回-8表示error，返回-9示WTP ID非法*/
																		/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == inter_name)
		return 0;
	
	int ret,retu;
	unsigned int wtp_id;
	char *ifname;
	int insize = 0;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

	/*make robust code*/
	insize = strlen(inter_name);
	if(insize > 16)
	{
		//vty_out(vty,"<error> the length of input parameter %s is %d ,excel the limit of 16\n",argv[0],insize);
		return -1;	
	}
	
	//wtp_id = (unsigned int)id;
	
	ifname = (char*)malloc(strlen(inter_name)+1);
	if(NULL == ifname)
        return 0;
	memset(ifname, 0, strlen(inter_name)+1);
	memcpy(ifname, inter_name, strlen(inter_name));	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
		
	wtp_id = (unsigned int)id;
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		syslog(LOG_DEBUG,"wtp id in wtp_apply_ipv6interface is %d\n",wtp_id);
		return -9;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_IFNAME_IPV6);
		
	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_IFNAME_IPV6);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,					
						DBUS_TYPE_UINT32,&wtp_id,
						DBUS_TYPE_STRING,&ifname,						 
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		//vty_out(vty,"<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			//vty_out(vty,"%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		if(ifname)
		{
			free(ifname);
			ifname = NULL;
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

		if(ret == 0)
			//vty_out(vty,"wtp %d bind interface %s successfully.\n",wtp_id,ifname);
			retu=1;
		else if(ret == WTP_ID_NOT_EXIST)
			//vty_out(vty,"<error> wtp id does not exist\n");
			retu=-2;
		else if(ret == WTP_BE_USING)
			//vty_out(vty,"<error> wtp is using\n");
			retu=-3;
		else if(ret == INTERFACE_NOT_EXIST)
			//vty_out(vty,"<error> interface %s does not exist\n",ifname);	
			retu=-4;
		else if(ret == APPLY_IF_FAIL)
			//vty_out(vty,"<error> apply interface %s failed\n",ifname);
			retu=-5;
		else if(ret == WID_BINDING_WLAN)
			//vty_out(vty,"<error> if you want to change binding interface, please delete binding wlan id first\n");
			retu=-6;
		else if(ret == BINDING_IPV6_ADDRE_RROR){
			//vty_out(vty,"<error> wtp bingding ipv6 addr error make sure interface have ipv6 address\n");
			retu=-7;
		     }
	    else
			//vty_out(vty,"<error>  %d\n",ret);
			retu=-8;
		
	dbus_message_unref(reply);
	FREE_OBJECT(ifname);
	
	return retu;
}

#if _GROUP_POLICY
void Free_wtp_apply_wlan_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-15时，调用Free_wtp_apply_wlan_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*注意判断wlan ID的合法性1--15*/
int wtp_apply_wlan_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,int wlanID,struct WtpList **WtpList_Head)  
										/*返回0表示失败，返回1表示成功，返回-1表示WTP ID Not existed*/
										/*返回-2表示WTP be using, you can't binding wlan ID，返回-3表示 binding wlan is not exist*/
										/*返回-4表示Wlan does not binding interface，返回-5表示 Wtp does not binding interface*/
										/*返回-6表示wlan and wtp binding interface don't match，返回-7表示 Clear wtp binding wlan list successfully*/
										/*返回-8表示wlan being enable，返回-9表示wtp over max bss count*/
										/*返回-10表示wtp over max wep wlan count，返回-11表示 error，返回-12示WTP ID非法*/
										/*返回-13表示wep conflict, wtp binding wlan securityindex is same with others，返回-14表示Group ID非法*/
										/*返回-15表示partial failure*/
{
    if(NULL == connection)
        return 0;
        
	int ret = 0;
	int count =0;
	unsigned int id= 0;
	unsigned int type = 0;
	unsigned char wlan_id = 0;
	int retu = 0;	
	
	wlan_id = wlanID;
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id == 0){
			syslog(LOG_DEBUG,"wtp id in wtp_apply_wlan_group is %d\n",id);
			return -12;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in wtp_apply_wlan_group is %d\n",id);
			return -14;
		}
	}

	void*(*dcli_init_func)(
						int ,
						int ,
					    DBusConnection * , 
					    unsigned int ,
					    unsigned int ,
					    unsigned char ,
					    int *,
					    unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"wtp_apply_wlan_cmd_wtp_apply_wlan_id");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection,
					  type,
					  id,
					  wlan_id,
					  &count,
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(ret == 0)
	{
		retu = 1;
		if((count != 0)&&(type == 1)&&(*WtpList_Head!= NULL)){
			retu = -15;
			/*vty_out(vty,"wtp ");					
			for(i=0; i<count; i++){
				if(Wtp_Show_Node == NULL)
					Wtp_Show_Node = WtpList_Head->WtpList_list;
				else 
					Wtp_Show_Node = Wtp_Show_Node->next;

				if(Wtp_Show_Node == NULL)
					break;
				
				vty_out(vty,"%d \n",Wtp_Show_Node->WtpId);					
			}
			
			vty_out(vty," failed.\n");*/
			//dcli_free_WtpList(WtpList_Head);
		}
	}	
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -1;
	}
	else if(ret == WTP_ID_BE_USED)
	{
		retu = -2;
	}
	else if(ret == WLAN_ID_NOT_EXIST)
	{
		retu = -3;
	}
	else if(ret == Wlan_IF_NOT_BE_BINDED)
	{
		retu = -4;
	}
	else if(ret == WTP_IF_NOT_BE_BINDED)
	{
		retu = -5;
	}
	else if(ret == WTP_WLAN_BINDING_NOT_MATCH)
	{
		retu = -6;
	}
	else if(ret == WTP_CLEAR_BINDING_WLAN_SUCCESS)
	{
		retu = -7;
	}
	else if(ret == WLAN_BE_ENABLE)
	{
		retu = -8;
	}
	else if(ret == WTP_OVER_MAX_BSS_NUM)
	{
		retu = -9;
	}
	else if(ret == WTP_WEP_NUM_OVER)
	{
		retu = -10;
	}
	else if(ret == SECURITYINDEX_IS_SAME)
	{
		retu = -13;
	}
	else
	{
		retu = -11;
	}

	/*if(WtpList_Head!=NULL){
		dcli_free_WtpList(WtpList_Head);
	}*/

	return retu;	
}
#endif

/*注意判断wlan ID的合法性1--15*/
int wtp_apply_wlan(dbus_parameter parameter, DBusConnection *connection,int wtpID,int wlanID)   
															   /*返回0表示失败，返回1表示成功，返回-1表示WTP ID Not existed*/
				                                               /*返回-2表示WTP be using, you can't binding wlan ID，返回-3表示 binding wlan is not exist*/
				                                               /*返回-4表示Wlan does not binding interface，返回-5表示 Wtp does not binding interface*/
				                                               /*返回-6表示wlan and wtp binding interface don't match，返回-7表示 Clear wtp binding wlan list successfully*/
				                                               /*返回-8表示wlan being enable，返回-9表示wtp over max bss count*/
				                                               /*返回-10表示wtp over max wep wlan count，返回-11表示 error，返回-12示WTP ID非法*/
															   /*返回-13表示wep conflict, wtp binding wlan securityindex is same with others*/
															   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = wtp_apply_wlan_group(parameter, connection,0,wtpID,wlanID,&WtpList_Head);
	if(retu == -15)
	{
		Free_wtp_apply_wlan_group(WtpList_Head);
	}
	return retu;
#else
	int ret,retu;
	unsigned int wtp_id;
	unsigned char wlan_id;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	//wtp_id = wtpID;	
	wlan_id = wlanID;


	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
		
	wtp_id = wtpID;	
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		syslog(LOG_DEBUG,"wtp id in wtp_apply_wlan is %d\n",wtp_id);
		return -12;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_WLANID);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_WLANID);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,					
						DBUS_TYPE_UINT32,&wtp_id,
						DBUS_TYPE_BYTE,&wlan_id,						 
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

		if(ret == 0)
			retu=1;
		else if(ret == WTP_ID_NOT_EXIST)
			retu=-1;		
		else if(ret == WTP_ID_BE_USED)
		    retu=-2;
		else if(ret == WLAN_ID_NOT_EXIST)
			retu=-3;
		else if(ret == Wlan_IF_NOT_BE_BINDED)
			retu=-4;
		else if(ret == WTP_IF_NOT_BE_BINDED)
			retu=-5;
		else if(ret == WTP_WLAN_BINDING_NOT_MATCH)
			retu=-6;
		else if(ret == WTP_CLEAR_BINDING_WLAN_SUCCESS)
			retu=-7;
		else if(ret == WLAN_BE_ENABLE)
			retu=-8;		
		else if(ret == WTP_OVER_MAX_BSS_NUM)
			retu=-9;
		else if(ret == WTP_WEP_NUM_OVER)
			retu=-10;
		else if(ret == SECURITYINDEX_IS_SAME)
			retu=-13;
		else
			retu=-11;
	dbus_message_unref(reply);

	return retu;
#endif
}


/*注意判断wlan ID的合法性1--15*/
/*wlanID==0，表示all*/
int wtp_delete_wlan(dbus_parameter parameter, DBusConnection *connection,int wtpID,int wlanID)  
																/*返回0表示失败，返回1表示成功*/
				                                               /*返回-1表示 wtp id not exist，返回-2表示WTP be using, you can't binding wlan ID*/
				                                               /*返回-3表示wlan is not exist，返回-4表示 Wlan does not binding interface*/
				                                               /*返回-5表示Wtp does not binding interface，返回-6表示 wlan and wtp binding interface don't match*/
				                                               /*返回-7表示Clear wtp binding wlan list successfully，返回-8表示 wlan being enable*/
				                                               /*返回-9表示BSS being enable，返回-10表示wtp doesn't binding this wlan id，返回-11表示 error*/
															   /*返回-12示WTP ID非法，返回-13表示wtp interface is in ebr,please delete it from ebr first*/
															   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret,retu;
	unsigned int wtp_id;
	unsigned char wlan_id;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	//wtp_id = wtpID;	
	wlan_id=wlanID;


	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	
	wtp_id = wtpID;	
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		syslog(LOG_DEBUG,"wtp id in wtp_delete_wlan is %d\n",wtp_id);
		return -12;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_DELETE_WLAN_ID);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_DELETE_WLAN_ID);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,					
						DBUS_TYPE_UINT32,&wtp_id,
						DBUS_TYPE_BYTE,&wlan_id,						 
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

		if(ret == 0)
			retu=1;
		else if(ret == WTP_ID_NOT_EXIST)
		    retu=-1;
		else if(ret == WTP_ID_BE_USED)
			retu=-2;
		else if(ret == WLAN_ID_NOT_EXIST)
			retu=-3;
		else if(ret == Wlan_IF_NOT_BE_BINDED)
		    retu=-4;
		else if(ret == WTP_IF_NOT_BE_BINDED)
			retu=-5;
		else if(ret == WTP_WLAN_BINDING_NOT_MATCH)
			retu=-6;
		else if(ret == WTP_CLEAR_BINDING_WLAN_SUCCESS)
			retu=-7;
		else if(ret == WLAN_BE_ENABLE)
			retu=-8;		
		else if(ret == BSS_BE_ENABLE)
			retu=-9;		
		else if(ret == 	INTERFACE_NOT_BE_BINDED)
			retu=-10;
		else if(ret == RADIO_IN_EBR)
			retu=-13;
		else
			retu=-11;
	dbus_message_unref(reply);

	return retu;	

}

#if _GROUP_POLICY
void Free_wtp_disable_wlan_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-8时，调用Free_wtp_disable_wlan_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*注意判断wlan ID的合法性1--15*/
int wtp_disable_wlan_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,int wlanID,struct WtpList **WtpList_Head)   
										/*返回0表示失败，返回1表示成功，返回-1表示WTP ID Not existed*/
                                        /*返回-2表示binding wlan is not exist，返回-3表示 Wtp does not binding this wlan*/
                                        /*返回-4表示wtp binding wlan id not match，返回-5表示 error，返回-6示WTP ID非法*/
										/*返回-7表示Group ID非法，返回-8表示partial failure，返回-9表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	int ret = 0;
	int count = 0;
	int index = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned char wlan_id = 0;
	int retu = 0;
	
	
	wlan_id = wlanID;
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id == 0){
			syslog(LOG_DEBUG,"wtp id in wtp_disable_wlan_group is %d\n",id);
			return -6;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in wtp_disable_wlan_group is %d\n",id);
			return -7;
		}
	}
	
	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						unsigned char , 
						int *,
						unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"wtp_disable_wlan_cmd_wtp_disable_wlan");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection, 
					  type, 
					  id, 
					  wlan_id, 
					  &count, 
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type == 1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL)){
				retu = -8;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d \n",Wtp_Show_Node->WtpId);					
				}
				
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -9;
	}
	else if (type == 0){
		if(ret == 0)
		{
			retu = 1;
		}
		else if(ret == WTP_ID_NOT_EXIST)
		{
			retu = -1;
		}
		else if(ret == WLAN_ID_NOT_EXIST)
		{
			retu = -2;
		}
		else if(ret ==	INTERFACE_NOT_BE_BINDED)
		{
			retu = -3;
		}
		else if(ret ==	WTP_WLAN_BINDING_NOT_MATCH)
		{
			retu = -4;
		}
		else
		{
			retu = -5;
		}
	}

	return retu;
}
#endif

/*未使用*/
/*注意判断wlan ID的合法性1--15*/
int wtp_disable_wlan(dbus_parameter parameter, DBusConnection *connection,int wtpID,int wlanID)  
																/*返回0表示失败，返回1表示成功，返回-1表示WTP ID Not existed*/
				                                                /*返回-2表示binding wlan is not exist，返回-3表示 Wtp does not binding this wlan*/
				                                                /*返回-4表示wtp binding wlan id not match，返回-5表示 error，返回-6示WTP ID非法*/
															    /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = wtp_disable_wlan_group(parameter, connection,0,wtpID,wlanID,&WtpList_Head);
	if(retu == -8)
	{
		Free_wtp_disable_wlan_group(WtpList_Head);
	}
	return retu;
#else
	int ret,retu;
	unsigned int wtp_id;
	unsigned char wlan_id;
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;
	
	//wtp_id = wtpID;	
	wlan_id = wlanID;

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	wtp_id = wtpID;	
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		syslog(LOG_DEBUG,"wtp id in wtp_disable_wlan is %d\n",wtp_id);
		return -6;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_DISABLE_WLAN_ID);
		

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_DISABLE_WLAN_ID);*/
	dbus_error_init(&err);

	dbus_message_append_args(query, 				
						DBUS_TYPE_UINT32,&wtp_id,
						DBUS_TYPE_BYTE,&wlan_id,						 
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

		if(ret == 0)
			retu=1;
		else if(ret == WTP_ID_NOT_EXIST)
			retu=-1;
		else if(ret == WLAN_ID_NOT_EXIST)
			retu=-2;
		else if(ret ==	INTERFACE_NOT_BE_BINDED)
			retu=-3;
		else if(ret ==	WTP_WLAN_BINDING_NOT_MATCH)
			retu=-4;
		else
			retu=-5;
		
	    dbus_message_unref(reply);
    	return retu; 
#endif
}

#if _GROUP_POLICY
void Free_wtp_enable_wlan_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-13时，调用Free_wtp_enable_wlan_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*注意判断wlan ID的合法性1--15*/
int wtp_enable_wlan_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,int wlanID,struct WtpList **WtpList_Head)   
														/*返回0表示失败，返回1表示成功，返回-1表示WTP ID Not existed*/
		                                                /*返回-2表示binding wlan is not exist，返回-3表示 Wtp does not binding this wlan*/
		                                                /*返回-4表示wtp not in run state，返回-5表示 wtp binding wlan id not match*/
		                                                /*返回-6表示Wlan is not enable，返回-7表示map L3 interace no ip error*/
		                                                /*返回-8表示BSS interface policy conflict，返回-9代表wtp over max wep wlan count*/
		                                                /*返回-10表示 error，返回-11示WTP ID非法，返回-12表示Group ID非法*/
														/*返回-13表示partial failure，返回-14表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned char wlan_id = 0;
	int retu = 0;

	
	wlan_id = wlanID;
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id == 0){
			syslog(LOG_DEBUG,"wtp id in wtp_enable_wlan_group is %d\n",id);
			return -11;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in wtp_enable_wlan_group is %d\n",id);
			return -12;
		}
	}
	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						unsigned char , 
						int *,
						unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"wtp_enable_wlan_cmd_wtp_enable_wlan");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection, 
					  type, 
					  id, 
					  wlan_id, 
					  &count, 
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(0 == type)
	{
		if(ret == 0)
		{
			retu = 1;
		}
		else if(ret == WTP_ID_NOT_EXIST)
		{
			retu = -1;
		}
		else if(ret == WLAN_ID_NOT_EXIST)
		{
			retu = -2;
		}
		else if(ret ==	INTERFACE_NOT_BE_BINDED)
		{
			retu = -3;
		}
		else if(ret ==	WTP_NOT_IN_RUN_STATE)
		{
			retu = -4;
		}
		else if(ret ==	WTP_WLAN_BINDING_NOT_MATCH)
		{
			retu = -5;
		}
		else if(ret ==	WLAN_BE_DISABLE)
		{
			retu = -6;
		}
		else if(ret == L3_INTERFACE_ERROR)
		{
			retu = -7;
		}
		else if(ret == IF_POLICY_CONFLICT)
		{
			retu = -8;
		}
		else if(ret == WTP_WEP_NUM_OVER)
		{
			retu = -9;
		}
		else
		{
			retu = -10;
		}
	}
	else if(type == 1)
	{
		if(ret == 0)
		{			
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL)){
				retu = -13;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d \n",Wtp_Show_Node->WtpId);					
				}
				
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -14;
	}

	return retu; 
}
#endif

/*未使用*/
/*注意判断wlan ID的合法性1--15*/
int wtp_enable_wlan(dbus_parameter parameter, DBusConnection *connection,int wtpID,int wlanID)   
																/*返回0表示失败，返回1表示成功，返回-1表示WTP ID Not existed*/
				                                                /*返回-2表示binding wlan is not exist，返回-3表示 Wtp does not binding this wlan*/
				                                                /*返回-4表示wtp not in run state，返回-5表示 wtp binding wlan id not match*/
				                                                /*返回-6表示Wlan is not enable，返回-7表示map L3 interace no ip error*/
				                                                /*返回-8表示BSS interface policy conflict，返回-9代表wtp over max wep wlan count*/
				                                                /*返回-10表示 error，返回-11示WTP ID非法*/
																/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = wtp_enable_wlan_group(parameter, connection,0,wtpID,wlanID,&WtpList_Head);
	if(retu == -13)
	{
		Free_wtp_enable_wlan_group(WtpList_Head);
	}
	return retu;
#else
	int ret,retu;
	unsigned int wtp_id;
	unsigned char wlan_id;
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;
	
	//wtp_id = wtpID;	
	wlan_id = wlanID;

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	wtp_id = wtpID;	
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		syslog(LOG_DEBUG,"wtp id in wtp_enable_wlan is %d\n",wtp_id);
		return -11;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_ENABLE_WLAN_ID);
		

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_ENABLE_WLAN_ID);*/
	dbus_error_init(&err);

	dbus_message_append_args(query, 				
						DBUS_TYPE_UINT32,&wtp_id,
						DBUS_TYPE_BYTE,&wlan_id,						 
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == WTP_ID_NOT_EXIST)
		retu=-1;
	else if(ret == WLAN_ID_NOT_EXIST)
		retu=-2;
	else if(ret ==	INTERFACE_NOT_BE_BINDED)
		retu=-3;
	else if(ret ==	WTP_NOT_IN_RUN_STATE)
		retu=-4;
	else if(ret ==	WTP_WLAN_BINDING_NOT_MATCH)
		retu=-5;
	else if(ret ==	WLAN_BE_DISABLE)
		retu=-6;	
	else if(ret == L3_INTERFACE_ERROR)
		retu=-7;
	else if(ret == IF_POLICY_CONFLICT)
		retu=-8;
	else if(ret == WTP_WEP_NUM_OVER)
		retu=-9;
	else
		retu=-10;
	
	dbus_message_unref(reply);
    return retu;
#endif
}

#if _GROUP_POLICY
void Free_wtp_used_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-9时，调用Free_wtp_used_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*use_sta=0表示"used"，use_sta=1表示"unused"*/
int wtp_used_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,int use_sta,struct WtpList **WtpList_Head)
				/*返回0表示失败，返回1表示成功，返回-1表示WTP ID Not existed，返回-2表示You should be apply interface first*/
				/*返回-3表示You should be apply wlan id first，返回-4表示map L3 interace error，返回-5表示BSS interface policy conflict*/
				/*返回-6表示error，返回-7示WTP ID非法，返回-8表示Group ID非法，返回-9表示partial failure*/
{	
	if(NULL == connection)
        return 0;
        
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int stat = 0;
	unsigned int type = 0;	
	int retu = 0;
	
	stat=use_sta;
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id == 0){
			syslog(LOG_DEBUG,"wtp id in wtp_used_group is %d\n",id);
			return -7;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in wtp_used_group is %d\n",id);
			return -8;
		}
	}

	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						unsigned int ,
						int *,
						unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"config_wtp_service_cmd_wtp_used");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection,
					  type,
					  id,
					  stat,
					  &count,
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == 0)
	{
		retu = 1;
		if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL)){
			retu = -9;
			/*vty_out(vty,"wtp ");					
			for(i=0; i<count; i++){
				if(Wtp_Show_Node == NULL)
					Wtp_Show_Node = WtpList_Head->WtpList_list;
				else 
					Wtp_Show_Node = Wtp_Show_Node->next;

				if(Wtp_Show_Node == NULL)
					break;
				
				vty_out(vty,"%d \n",Wtp_Show_Node->WtpId);					
			}
			
			vty_out(vty," failed.\n");*/
		}
	}	
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -1;
	}
	else if(ret == INTERFACE_NOT_BE_BINDED)
	{
		retu = -2;
	}
	else if(ret == WTP_IS_NOT_BINDING_WLAN_ID)
	{
		retu = -3;
	}
	else if(ret == L3_INTERFACE_ERROR)
	{
		retu = -4;
	}
	else if(ret == IF_POLICY_CONFLICT)
	{
		retu = -5;
	}
	else
	{
		retu = -6;
	}
	
	return retu; 
}
#endif

/*use_sta=0表示"used"，use_sta=1表示"unused"*/
int wtp_used(dbus_parameter parameter, DBusConnection *connection,int id,int use_sta)
												   /*返回0表示失败，返回1表示成功，返回-1表示WTP ID Not existed，返回-2表示You should be apply interface first*/
				                                   /*返回-3表示You should be apply wlan id first，返回-4表示map L3 interace error，返回-5表示BSS interface policy conflict*/
				                                   /*返回-6表示error，返回-7示WTP ID非法*/
												   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
    if(NULL == connection)
        return 0;
        
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = wtp_used_group(parameter, connection,0,id,use_sta,&WtpList_Head);
	if(retu == -9)
	{
		Free_wtp_used_group(WtpList_Head);
	}
	return retu;
#else
	int ret,retu;
	unsigned int wtp_id;
	unsigned int stat;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	//wtp_id = id;	
    stat=use_sta;

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
			
    wtp_id = id;	
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		syslog(LOG_DEBUG,"wtp id in wtp_used is %d\n",wtp_id);
		return -7;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_WTP_USED);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_WTP_USED);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,					
						DBUS_TYPE_UINT32,&wtp_id,
						DBUS_TYPE_UINT32,&stat,						 
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

		if(ret == 0)
			retu=1;
		else if(ret == WTP_ID_NOT_EXIST)
			retu=-1;
		else if(ret == INTERFACE_NOT_BE_BINDED)
			retu=-2;		
		else if(ret == WTP_IS_NOT_BINDING_WLAN_ID)
			retu=-3;			
		else if(ret == L3_INTERFACE_ERROR)
			retu=-4;		
		else if(ret == IF_POLICY_CONFLICT)
			retu=-5;
		else
			retu=-6;
	dbus_message_unref(reply);

	return retu;	
#endif
}

#if _GROUP_POLICY
void Free_config_wtp_max_sta_num_group(struct WtpList *WtpList_Head)
{
	if(WtpList_Head != NULL)
	{
		free(WtpList_Head);
		WtpList_Head == NULL;
	}
}

/*返回-8时，调用Free_config_wtp_max_sta_num_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int config_wtp_max_sta_num_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char*max_num,struct WtpList **WtpList_Head,int *fail_num)  
															/*返回0表示失败，返回1表示成功，返回-1表示wtp not exist*/
															/*返回-2表示more sta(s) has accessed before you set max sta num*/
															/*返回-3表示operation fail，返回-4表示error，返回-5示WTP ID非法*/
															/*返回-6表示unknown NUM format，返回-7表示Group ID非法*/
															/*返回-8表示partial failure，返回-9表示group id does not exist*/
															/*返回-10表示input num should be 0-64*/
{

	if(NULL == connection)
        return 0;
        
	if(NULL == max_num)
	{
		*WtpList_Head = NULL;
		return 0;
	}
	
	unsigned int id = 0;
	unsigned int wtp_max_sta=0;
	unsigned int stanum;
	int ret = 0;
	int ret1 = 0;
	int count = 0;
	int finalnum = 0;
	unsigned int type = 0;
	int retu = 0;	

	ret = parse_int_ID((char*)max_num, &wtp_max_sta);
	if(ret != WID_DBUS_SUCCESS){
		return -6;
	}	
	if((wtp_max_sta < 0)||(wtp_max_sta > 64))
	{
		return -10;
	}
	
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id < 0){
			syslog(LOG_DEBUG,"wtp id in config_wtp_max_sta_num_group is %d\n",id);
			return -5;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in config_wtp_max_sta_num_group is %d\n",id);
			return -7;
		}
	}
	
	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						unsigned int ,
						unsigned int *,
						int *,
						int *,
						unsigned int *,
						int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"wtp_max_sta_cmd_set_wtp_max_sta_num");
		if(NULL != dcli_init_func && connection)
		{
			
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection,
					  type,
					  id,
					  wtp_max_sta,
					  &stanum,&count,
					  &finalnum,
					  &ret,
					  &ret1
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type == 0)
	{	
		if((ret == 0)&&(ret1 == 0))
			retu = 1;
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -1;
		else if(ret1 == -1)
			retu = -2;
		else
			retu = -4;
	}

	else if(type == 1){
		if((ret == 0)&&(ret1 == 0))
		{
			retu = 1;
			if(( finalnum!= 0)&&(type == 1)&&(*WtpList_Head!=NULL)){
				*fail_num = finalnum;
				retu = -8;
				/*vty_out(vty,"wtp ");
				for(i=0; i<finalnum; i++)
				{
					vty_out(vty,"%d \n",WtpList_Head[i].WtpId);
					 if(WtpList_Head[i].FailReason == 'f')
					{
						vty_out(vty,"<error> %d sta(s) has accessed before you set max sta num %d\n",WtpList_Head[i].WtpStaNum,wtp_max_sta);
					}
					else
					{
						vty_out(vty,"fail\n");
					}
				}*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -9;
	}	
	return retu;
}
#endif

/*max_num的范围是0-32767*/
int config_wtp_max_sta_num(dbus_parameter parameter, DBusConnection *connection,int id,char*max_num)  
																		/*返回0表示失败，返回1表示成功，返回-1表示wtp not exist*/
																		/*返回-2表示more sta(s) has accessed before you set max sta num*/
																		/*返回-3表示operation fail，返回-4表示error，返回-5示WTP ID非法*/
																		/*返回-10表示input num should be 0-32767*/
																		/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == max_num)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;
	int fail_num = 0;

	retu = config_wtp_max_sta_num_group(parameter, connection,0,id,max_num,&WtpList_Head,&fail_num);
	if(retu == -8)
	{
		Free_config_wtp_max_sta_num_group(WtpList_Head);
	}
	return retu;
#else
	int ret;
	unsigned int wtp_id = 0;
	unsigned int wtp_max_sta=0;
	
	unsigned int type=3;
	unsigned int stanum;
	unsigned int radioid = 0;   //fengwenchao add 20110512
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;

	
	dbus_error_init(&err);
	int retu = 0;
	
	//wtp_id = (unsigned int)id;
	
	wtp_max_sta=atoi(max_num);
	if(/*(wtp_max_sta < 0)||*/(wtp_max_sta > 32767))
	{
		return -10;
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	wtp_id = (unsigned int)id;
	if(wtp_id >= WTP_NUM || wtp_id < 0){
		syslog(LOG_DEBUG,"wtp id in config_wtp_max_sta_num is %d\n",wtp_id);
		return -5;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,ASD_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,ASD_DBUS_STA_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,ASD_DBUS_STA_INTERFACE,INTERFACE);
	
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,ASD_DBUS_STA_METHOD_GET_STA_INFO);

	/*query = dbus_message_new_method_call(ASD_DBUS_BUSNAME,ASD_DBUS_STA_OBJPATH,\
						ASD_DBUS_STA_INTERFACE,ASD_DBUS_STA_METHOD_GET_STA_INFO);*/
	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&type,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_UINT32,&radioid,	  //fengwenchao add 20110512
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
		
	dbus_message_unref(query);
		
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&stanum);
	dbus_message_unref(reply);

	if(stanum==-1){
		return -1;
	}
	
	if(wtp_max_sta< stanum){
		return -2;
	}

	memset(BUSNAME,0,PATH_LEN);	
	memset(OBJPATH,0,PATH_LEN);
	memset(INTERFACE,0,PATH_LEN);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_MAX_STA);


	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_MAX_STA);*/

	

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_UINT32,&wtp_max_sta,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu =1;
	else if(ret == WTP_ID_NOT_EXIST)
		retu = -1;
	else if(ret == WID_DBUS_ERROR)
		retu = -3;
	else
		retu = -4;

	
	dbus_message_unref(reply);
	return retu;
#endif
}

#if _GROUP_POLICY
void Free_config_wtp_triger_num_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}


/*返回-7时，调用Free_config_wtp_triger_num_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*triger_num的范围是1-64*/
int config_wtp_triger_num_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char* triger_num,struct WtpList **WtpList_Head)	
												/*返回0表示失败，返回1表示成功，返回-1表示wtp id does not exist*/
												/*返回-2表示operation fail，返回-3表示triger number must be little than max sta num*/
												/*返回-4表示error，返回-5示WTP ID非法，返回-6表示Group ID非法*/
												/*返回-7表示partial failure，返回-8表示group id does not exist*/
												/*返回-9表示unknown id format，返回-10表示input triger num should be 1~64*/
{
    if(NULL == connection)
        return 0;
        
	if(NULL == triger_num)
	{
		*WtpList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned int triger=0;
	int retu = 0;
	
	/*fengwenchao modify 20110412*/
	ret = parse_int_ID((char*)triger_num, &triger);
	if(ret != WID_DBUS_SUCCESS){
		return -9;
	}
	//triger=atoi(argv[0]);
	if((triger < 1)||(triger > 64))
	{
		return -10;
	}
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id == 0){
			syslog(LOG_DEBUG,"wtp id in config_wtp_triger_num_group is %d\n",id);
			return -5;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in config_wtp_triger_num_group is %d\n",id);
			return -6;
		}
	}
	
	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						unsigned int , 
						int *,
						unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"wtp_triger_num_cmd_set_wtp_number_triger");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection, 
					  type, 
					  id, 
					  triger, 
					  &count, 
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type ==0){
		if(ret == 0)
			retu = 1;
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -1;
		else if(ret == WID_DBUS_ERROR)
			retu = -2;
		else if(ret == APPLY_IF_FAIL)
			retu = -3;
		else
			retu = -4;		
	}	
	else if(type == 1){
		if(ret == 0){
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL)){
				retu = -7;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d \n",Wtp_Show_Node->WtpId);					
				}
				
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -8;
	}

	return retu;
}
#endif

/*triger_num的范围是1-64*/
int config_wtp_triger_num(dbus_parameter parameter, DBusConnection *connection,int id,char* triger_num)  
																		/*返回0表示失败，返回1表示成功，返回-1表示wtp id does not exist，返回-2表示operation fail，返回-3表示triger number must be little than max sta num，返回-4表示error，返回-5示WTP ID非法*/
																		/*返回-9表示unknown id format，返回-10表示input triger num should be 1~64*/
																		/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == triger_num)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = config_wtp_triger_num_group(parameter, connection,0,id,triger_num,&WtpList_Head);
	if(retu == -7)
	{
		Free_config_wtp_triger_num_group(WtpList_Head);
	}
	return retu;
#else
	int ret,retu;
	unsigned int wtp_id = 0;
	unsigned int triger=0;
	
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;

	dbus_error_init(&err);

	//wtp_id = (unsigned int)id;	
	/*fengwenchao modify 20110412*/
	ret = parse_int_ID((char*)triger_num, &triger);
	if(ret != WID_DBUS_SUCCESS){
		return -9;
	}
	//triger=atoi(argv[0]);
	if((triger < 1)||(triger > 64))
	{
		return -10;
	}
	/*fengwenchao modify end*/
	
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
		
	wtp_id = (unsigned int)id;
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		syslog(LOG_DEBUG,"wtp id in config_wtp_triger_num is %d\n",wtp_id);
		return -5;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_TRIGER);
		

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_TRIGER);*/


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_UINT32,&triger,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == WTP_ID_NOT_EXIST)
		retu=-1;
	else if(ret == WID_DBUS_ERROR)
		retu=-2;
	else if(ret == APPLY_IF_FAIL)
		retu=-3;
	else
		retu=-4;
	
	dbus_message_unref(reply);
	return retu;
#endif
}

#if _GROUP_POLICY
void Free_set_wtp_flow_trige_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-7时，调用Free_set_wtp_flow_trige_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*triger_num的范围是0-1024*/
int set_wtp_flow_trige_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char* triger_num,struct WtpList **WtpList_Head)  
											/*返回0表示失败，返回1表示成功，返回-1表示wtp id does not exist*/
											/*返回-2表示operation fail，返回-3表示flow triger must be <0-1024>*/
											/*返回-4表示error，返回-5示WTP ID非法，返回-6表示Group ID非法*/
											/*返回-7表示partial failure，返回-8表示group id does not exist*/
											/*返回-9表示unknown id format，返回-10表示input flow triger should be 0~1024*/
{
    if(NULL == connection)
        return 0;
        
	if(NULL == triger_num)
	{
		*WtpList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	int index = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned int triger=0;
	int retu = 0;	
	
	/*fengwenchao modify 20110412*/
	ret = parse_int_ID((char*)triger_num, &triger);
	if(ret != WID_DBUS_SUCCESS){
		return -9;
	}
	//triger=atoi(argv[0]);
	if((triger < 0)||(triger > 1024))
	{
		return -10;
	}
	/*fengwenchao modify end*/

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id < 0){
			syslog(LOG_DEBUG,"wtp id in set_wtp_flow_trige_group is %d\n",id);
			return -5;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_wtp_flow_trige_group is %d\n",id);
			return -6;
		}
	}
	
	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						unsigned int , 
						int *,
						unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"wtp_triger_num_cmd_set_wtp_flow_triger");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection, 
					  type, 
					  id, 
					  triger, 
					  &count, 
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type ==0){
		if(ret == 0)
			retu = 1;
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -1;
		else if(ret == WID_DBUS_ERROR)
			retu = -2;
		else if(ret == APPLY_IF_FAIL)
			retu = -3;
		else
			retu = -4;
	}	
	else if(type == 1){
		if(ret == 0){
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL)){
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;					
					vty_out(vty,"%d \n",Wtp_Show_Node->WtpId);					
				}				
				vty_out(vty," failed.\n");*/
				retu = -7;
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -8;
	}
	
	return retu;

}
#endif

/*triger_num的范围是0-1024*/
int set_wtp_flow_trige(dbus_parameter parameter, DBusConnection *connection,int id,char* triger_num)  
																	/*返回0表示失败，返回1表示成功，返回-1表示wtp id does not exist，返回-2表示operation fail，返回-3表示flow triger must be <0-1024>，返回-4表示error，返回-5示WTP ID非法*/
																	/*返回-9表示unknown id format，返回-10表示input flow triger should be 0~1024*/
																	/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == triger_num)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_wtp_flow_trige_group(parameter, connection,0,id,triger_num,&WtpList_Head);
	return retu;
#else
	int ret,retu;
	unsigned int wtp_id = 0;
	unsigned int triger=0;
	
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;

	
	dbus_error_init(&err);


	//wtp_id = (unsigned int)id;	
	/*fengwenchao modify 20110412*/
	ret = parse_int_ID((char*)triger_num, &triger);
	if(ret != WID_DBUS_SUCCESS){
		return -9;
	}
	//triger=atoi(argv[0]);
	if(/*(triger < 0)||*/(triger > 1024))
	{
		return -10;
	}
	/*fengwenchao modify end*/	


	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
		
	wtp_id = (unsigned int)id;
	if(wtp_id >= WTP_NUM || wtp_id < 0){
		syslog(LOG_DEBUG,"wtp id in set_wtp_flow_trige is %d\n",wtp_id);
		return -5;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_FLOW_TRIGER);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_FLOW_TRIGER);//*/


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_UINT32,&triger,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == WTP_ID_NOT_EXIST)
		retu=-1;
	else if(ret == WID_DBUS_ERROR)
		retu=-2;
	else if(ret == APPLY_IF_FAIL)
		retu=-3;
	else
		retu=-4;
	
	dbus_message_unref(reply);
	return retu;
#endif
}

#if _GROUP_POLICY
void Free_set_ap_max_throughout_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}


/*返回-8时，调用Free_set_ap_max_throughout_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_ap_max_throughout_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *para,struct WtpList **WtpList_Head)
													/*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
													/*返回-2表示ap max throughout should be 1 to 108，返回-3表示wtp id does not exist*/
													/*返回-4表示error，返回-5示WTP ID非法*/
													/*返回-6表示illegal input:Input exceeds the maximum value of the parameter type*/
													/*返回-7表示Group ID非法，返回-8表示partial failure*/
													/*返回-9表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	if(NULL == para)
	{
		*WtpList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int ret1 = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
    unsigned char bandwidth = 0;
	int retu = 0;	

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id < 0){
			syslog(LOG_DEBUG,"wtp id in set_ap_max_throughout_group is %d\n",id);
			return -5;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_ap_max_throughout_group is %d\n",id);
			return -7;
		}
	}
	
	ret1 = parse_char_ID((char*)para, &bandwidth);
	if(ret1 != WID_DBUS_SUCCESS){
        if(ret1 == WID_ILLEGAL_INPUT){
			retu = -6;
        }
		else{
			retu = -1;
		}
		return retu;
	}	
	
	if(bandwidth > 108 || bandwidth == 0){
		return -2;
	}
	
	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						unsigned char , 
						int *,
						unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_ap_max_throughout_cmd_set_ap_max_throught");
		if(NULL != dcli_init_func && connection)
		{	
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection, 
					  type, 
					  id, 
					  bandwidth, 
					  &count, 
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(type == 0){
		if(ret == 0){
			retu = 1;
		}
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -3;
		
		else{
			retu = -4;
		}
	}
	else if(type == 1){
		if(ret == 0){
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL)){
				retu = -8;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d \n",Wtp_Show_Node->WtpId);					
				}
				
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -9;
	}	
	return retu;			
}
#endif

/*未使用*/
int set_ap_max_throughout(dbus_parameter parameter, DBusConnection *connection,int id,char *para)/*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
																									   /*返回-2表示ap max throughout should be 1 to 108，返回-3表示wtp id does not exist*/
																									   /*返回-4表示error，返回-5示WTP ID非法*/
																									   /*返回-6表示illegal input:Input exceeds the maximum value of the parameter type*/
																									   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == para)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_ap_max_throughout_group(parameter, connection,0,id,para,&WtpList_Head);
	if(retu == -8)
	{
		Free_set_ap_max_throughout_group(WtpList_Head);
	}
	return retu;
#else
	int ret,ret1,retu;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

    unsigned char bandwidth = 0;
	unsigned int wtp_id = 0;
	//wtp_id = (unsigned int)id;
	
	ret1 = parse_char_ID((char*)para, &bandwidth);
	if(ret1 != WID_DBUS_SUCCESS){
			if(ret1 == WID_ILLEGAL_INPUT){
				retu = -6;
			}
			else{
				retu = -1;
			}
			return retu;
	}	
	if(bandwidth > 108 || bandwidth == 0){
		return -2;
	}
		
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
			
	wtp_id = (unsigned int)id;
	if(wtp_id >= WTP_NUM || wtp_id < 0){
		syslog(LOG_DEBUG,"wtp id in set_ap_max_throughout is %d\n",wtp_id);
		return -5;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_AP_MAX_THROUGHOUT);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_AP_MAX_THROUGHOUT);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,	
							 DBUS_TYPE_BYTE,&bandwidth,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		

		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == WTP_ID_NOT_EXIST)
		retu=-3;
	else
		retu=-4;
	
	dbus_message_unref(reply);
	return retu;			
#endif
}

#if _GROUP_POLICY
void Free_set_ap_extension_command_func_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-6时，调用Free_set_ap_extension_command_func_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*该命令是在AC上直接操作AP的一个隐藏命令，不开放给用户，WEB上不用实现。*/
int set_ap_extension_command_func_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,const char *command,struct WtpList **WtpList_Head)
													/*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
													/*返回-2表示wtp id does not exist，返回-3表示error，返回-4示WTP ID非法*/
													/*返回-5表示Group ID非法，返回-6表示partial failure，返回-7表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == command)
	{
		*WtpList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0; 
	int retu = 0;	
	
	/*if (argc > 0)
	{
    	command = WID_parse_ap_extension_command(argv, argc);
 	}
	else
	{
    	command = NULL;
	}*/
	if(!command) 
	{
		return -1;
	}
	if(strlen(command) > 512)
	{
		if(command)
		{
			free(command);
			command = NULL;
		}
		return -1;
	}
	/*if(vty->node == WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (unsigned)vty->index_sub;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (unsigned)vty->index_sub;
		type = 1;
	}*/
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id == 0){
			syslog(LOG_DEBUG,"wtp id in set_ap_extension_command_func_group is %d\n",id);
			return -4;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_ap_extension_command_func_group is %d\n",id);
			return -5;
		}
	}
	
	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						unsigned char *,
						int *,
						unsigned int *
						);
    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_ap_extension_command_cmd_set_ap_extension_command");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.slot_id,
					  connection, 
					  type, 
					  id, 
					  command, 
					  &count, 
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -2;
		else
			retu = -3;
	}
	if(type==1)
	{
		if(ret == 0){
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL)){
				retu = -6;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d \n",Wtp_Show_Node->WtpId);					
				}
				
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -7;
  	}

	return retu;		
}
#endif

/*该命令是在AC上直接操作AP的一个隐藏命令，不开放给用户，WEB上不用实现。*/
int set_ap_extension_command_func(dbus_parameter parameter, DBusConnection *connection,int WtpId,const char *command)
																							/*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
																							/*返回-2表示wtp id does not exist，返回-3表示error，返回-4示WTP ID非法*/
																							/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == command)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_ap_extension_command_func_group(parameter, connection,0,WtpId,command,&WtpList_Head);
	if(retu == -6)
	{
		Free_set_ap_extension_command_func_group(WtpList_Head);
	}
	return retu;
#else
    
	int ret;
	int retu;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

	unsigned int wtp_id = 0;
	//wtp_id = WtpId;
	
	//command = (char*)malloc(strlen(argv[0])+1);
	//memset(command, 0, strlen(argv[0])+1);
	//memcpy(command, argv[0], strlen(argv[0]));
	/*if (argc > 0)
	{
    	command = "syscoldreboot";
 	}
	else
	{
    	command = NULL;
	}*/
	if(!command) 
	{
		return -1;
	}
	if(strlen(command) > 128)
	{
	   	/*if(command)
		{
			free(command);
			command = NULL;
		}*/

		return -1;
	}
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
			
	wtp_id = WtpId;
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		syslog(LOG_DEBUG,"wtp id in set_ap_extension_command_func is %d\n",wtp_id);
		return -4;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_AP_EXTENSION_COMMAND);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_AP_EXTENSION_COMMAND);*/
	
	dbus_error_init(&err);
	
	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_STRING,&command,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	dbus_message_unref(query);
	/*if(command)
	{
		free(command);
		command = NULL;
	}*/
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		

		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		retu=1;
	}
	else if(ret == WTP_ID_NOT_EXIST)
		retu=-2;
	else
	{
		retu=-3;
	}
		
	dbus_message_unref(reply);

	
	return retu;			
#endif	
}


/*未使用*/
int set_ap_ip_address(dbus_parameter parameter, DBusConnection *connection,int id,char *IP,char *MASK,char *GATEWAY)
																				   /*返回0表示失败，返回1表示成功，返回-1表示unknown ip format，返回-2表示unknown id format*/
																				   /*返回-3表示unknown mask parameters，返回-4表示wtp id does not exist，返回-5表示error，返回-6示WTP ID非法*/
																				   /*返回-7表示illegal input:Input exceeds the maximum value of the parameter type*/
																				   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if((NULL == IP)||(NULL == MASK)||(NULL == GATEWAY))
		return 0;
	
	int ret,ret1,ret2,retu;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

    unsigned int ip;
	unsigned char mask;
	unsigned int gateway;
	unsigned int wtp_id = 0;
	unsigned char myipBuf[WTP_IP_BUFF_LEN] = {0};	
	unsigned char *myipPtr = myipBuf;

	
	//wtp_id = (unsigned int)id;
	
	ret = WID_Check_IP_Format((char*)IP);
	if(ret != WID_DBUS_SUCCESS){
		return -1;
	}
	
	ip = dcli_ip2ulong((char*)IP);
	ret = ip_long2str(ip,&myipPtr);


	ret1 = parse_char_ID((char*)MASK, &mask);
	if(ret1 != WID_DBUS_SUCCESS){
        if(ret1 == WID_ILLEGAL_INPUT){
			retu = -7;
        }
		else{
			retu = -2;
		}
		return retu;
	}
	if(mask != 8 && mask != 16 &&mask !=24){
		return -3;
	}


	ret2 = WID_Check_IP_Format((char*)GATEWAY);
	if(ret2 != WID_DBUS_SUCCESS){
		return -1;
	}
	
	gateway = dcli_ip2ulong((char*)GATEWAY);

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
			
	wtp_id = (unsigned int)id;
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		syslog(LOG_DEBUG,"wtp id in set_ap_ip_address is %d\n",wtp_id);
		return -6;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_AP_IP_GATEWAY);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_AP_IP_GATEWAY);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_UINT32,&ip,
							 DBUS_TYPE_BYTE,&mask,
							 DBUS_TYPE_UINT32,&gateway,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		

		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == WTP_ID_NOT_EXIST)
		retu=-4;
	else
		retu=-5;

	dbus_message_unref(reply);
	return retu;			
}

void free_show_wtp_runtime(DCLI_WTP_API_GROUP_THREE *WTPINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_THREE *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun_three");	
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_CONF_METHOD_SHOW_WID_WTP_RUNTIME ,WTPINFO);
		}
	}
}

/*retu==1调用释放函数free_show_wtp_runtime(DCLI_WTP_API_GROUP_THREE *WTPINFO)*/
int show_wtp_runtime(dbus_parameter parameter, DBusConnection *connection, int id,DCLI_WTP_API_GROUP_THREE **WTPINFO)  /*返回0表示失败，返回1表示成功，返回-1表示wtp id does not exist，返回-2表示WTP ID非法*/
																															/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
	if(NULL == connection)
	    return 0;
	    
	unsigned int WTPID = 0;
	int ret = WID_DBUS_SUCCESS;

	int retu = 0;
	
	WTPID = id;
	if(WTPID >= WTP_NUM || WTPID == 0){
		syslog(LOG_DEBUG,"wtp id in show_wtp_runtime is %d\n",WTPID);
		return -2;
	}

	void *(*dcli_init_func)(
						int ,
						unsigned int ,
						unsigned int ,
						unsigned int ,
						unsigned int ,
						unsigned int* ,
						unsigned int* ,
						unsigned int* ,
						unsigned char *,
						unsigned char *,
						int *,
						DBusConnection *,
						char *
						);

    *WTPINFO = NULL;	
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_three");
		if(NULL != dcli_init_func && connection)
		{
			*WTPINFO = (*dcli_init_func)(
				parameter.instance_id,
				SECOND,/*"show wtp runtime"*/
				WTPID,
				0,
				0,
				&ret,/**/
				0,/*num2*/
				0,
				0,
				0,
				&(parameter.local_id),
				connection,
				WID_DBUS_CONF_METHOD_SHOW_WID_WTP_RUNTIME
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}


	if(ret == -1)
	{
	    retu = SNMPD_CONNECTION_ERROR;    
	}
	else if((ret == 0)&&(*WTPINFO))
	{
		retu = 1;
	}	
	else if (ret == WTP_ID_NOT_EXIST)
	{
		retu = -1;
	}
	
	return retu;
}

#if _GROUP_POLICY
void Free_set_wtp_location_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-5时，调用Free_set_wtp_location_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_wtp_location_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *Location,struct WtpList **WtpList_Head)
										/*返回0表示失败，返回1表示成功，返回-1表示wtp location is too long,should be 1 to 15*/
										/*返回-2表示wtp id does not exist，返回-3示WTP ID非法，返回-4表示Group ID非法*/
										/*返回-5表示partial failure，返回-6表示group id does not exist*/
{	
    if(NULL == connection)
        return 0;
	
	if(NULL == Location)
	{
		*WtpList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0; 
	int retu = 0;
	char *location = NULL;
	int len = 0;

	len = strlen(Location);
	if(len > 15){		
		return -1;
	}
	
	location = (char*)malloc(strlen(Location)+1);
	if(NULL == location)
        return 0;
	memset(location, 0, strlen(Location)+1);
	memcpy(location, Location, strlen(Location));

	/*if(vty->node == WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (unsigned)vty->index_sub;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (unsigned)vty->index_sub;
		type = 1;
	}*/
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id == 0){
			syslog(LOG_DEBUG,"wtp id in set_wtp_location_group is %d\n",id);
			return -3;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_wtp_location_group is %d\n",id);
			return -4;
		}
	}

	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						char * ,
						int *,
						unsigned int *
						);
    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_wtp_location_cmd_set_wtp_location");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection, 
					  type, 
					  id, 
					  location, 
					  &count, 
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if (ret == WTP_ID_NOT_EXIST)
			retu = -2;
	}
	if(type==1)
	{
		if(ret == 0){
			retu = 1;
		if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL)){
			retu = -5;
			/*vty_out(vty,"wtp ");					
			for(i=0; i<count; i++){
				if(Wtp_Show_Node == NULL)
					Wtp_Show_Node = WtpList_Head->WtpList_list;
				else 
					Wtp_Show_Node = Wtp_Show_Node->next;

				if(Wtp_Show_Node == NULL)
					break;
				
				vty_out(vty,"%d \n",Wtp_Show_Node->WtpId);					
			}
			
			vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -6;
	}

	FREE_OBJECT(location);
	return retu;
}

#endif

int set_wtp_location(dbus_parameter parameter, DBusConnection *connection,int id,char *Location)/*返回0表示失败，返回1表示成功，返回-1表示wtp location is too long,should be 1 to 15，返回-2表示wtp id does not exist，返回-3示WTP ID非法*/
																								   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
    if(NULL == connection)
        return 0;
	
	if(NULL == Location)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_wtp_location_group(parameter, connection, 0,id,Location,&WtpList_Head);
	if(retu == -5)
	{
		Free_set_wtp_location_group(WtpList_Head);
	}
	return retu;
#else	

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID;
	int ret = WID_DBUS_SUCCESS,retu=0;
	char *location = NULL;
	int len = 0;
	//WTPID = (unsigned int)id;

	len = strlen(Location);
	if(len > 15){		
		return -1;
	}
	
	location = (char*)malloc(strlen(Location)+1);
	if(NULL == location)
        return 0;
	memset(location, 0, strlen(Location)+1);
	memcpy(location, Location, strlen(Location));

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
			
	WTPID = (unsigned int)id;
	if(WTPID >= WTP_NUM || WTPID == 0){
		syslog(LOG_DEBUG,"wtp id in set_wtp_location is %d\n",WTPID);
		return -3;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_WTP_LOCATION);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_WTP_LOCATION);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_STRING,&location,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		if(location)
		{
			free(location);
			location = NULL;
		}

		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
		
	dbus_message_unref(reply);
	if(ret == 0)
		retu=1;
	else if (ret == WTP_ID_NOT_EXIST)
		retu=-2;

	FREE_OBJECT(location);
	return retu;
#endif	
}

void free_show_wtp_location(DCLI_WTP_API_GROUP_THREE *WTPINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_THREE *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun_three");	
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_CONF_METHOD_SHOW_WID_WTP_LOCATION ,WTPINFO);
		}
	}
}

/*返回1时，调用free_show_wtp_location()释放空间*/
int show_wtp_location(dbus_parameter parameter, DBusConnection *connection,int id,DCLI_WTP_API_GROUP_THREE **WTPINFO)   /*返回0表示失败，返回1表示成功，返回-1表示wtp does not set location，返回-2表示wtp id does not exist，返回-3示WTP ID非法*/
																															/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
    if(NULL == connection)
        return 0;
        
	unsigned int WTPID = 0;
	int ret = WID_DBUS_SUCCESS;	
	int retu = 0;
	
	WTPID = id;
	if(WTPID >= WTP_NUM || WTPID == 0){
		syslog(LOG_DEBUG,"wtp id in show_wtp_location is %d\n",WTPID);
		return -3;
	}

	void *(*dcli_init_func)(
								int ,
								unsigned int ,
								unsigned int ,
								unsigned int ,
								unsigned int ,
								unsigned int* ,
								unsigned int* ,
								unsigned int* ,
								unsigned char *,
								unsigned char *,
								int *,
							//	DCLI_WTP_API_GROUP_THREE *,	
								DBusConnection *,
								char *
							);

    *WTPINFO = NULL;	
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_three");
		if(NULL != dcli_init_func && connection)
		{
			*WTPINFO = (*dcli_init_func)(
					parameter.instance_id,
					THIRD,/*"show wtp location"*/
					WTPID,
					0,
					0,
					&ret,/**/
					0,/*num2*/
					0,
					0,
					0,
					&(parameter.local_id),
				//	WTPINFO,
					connection,
					WID_DBUS_CONF_METHOD_SHOW_WID_WTP_LOCATION
					);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1)
	{
        retu = SNMPD_CONNECTION_ERROR;
	}
	else if((ret == 0)&&(*WTPINFO))
	{
		retu = 1;
	}
	else if (ret == WID_WTP_LOCATION_NOT_SET)
	{
		retu = -1;
	}
	else if (ret == WTP_ID_NOT_EXIST)
	{
		retu = -2;
	}
	
	return retu;
}

void Free_ap_ip_bywtpid(DCLI_AC_API_GROUP_THREE *network)
{
	void (*dcli_init_free_func)(char *,DCLI_WQOS *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_ac_free_fun_three");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_CONF_METHOD_AP_SHOW_IPADDR,network);
			network = NULL;
		}
	}
}

/*返回1时，调用Free_ap_ip_bywtpid()释放空间*/
int show_ap_ip_bywtpid_cmd(dbus_parameter parameter, DBusConnection *connection,int id,DCLI_AC_API_GROUP_THREE **network)
																				   /*返回0表示失败，返回1表示成功，返回-1表示input wtp id should be 1 to WTP_NUM-1*/
																				   /*返回-2表示ap have not ip information，返回-3表示wtp id no exist*/
																				   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret = -1;
	int retu = 0;
	int wtpid = 0;
	
	wtpid = id;
	if ((wtpid <= 0) || (wtpid >= WTP_NUM)) {
		return -1;
	}

	void*(*dcli_init_func)(
					int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int* ,
					unsigned int* ,
					unsigned int* ,
					DBusConnection *,
					char *
					);

    *network = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_ac_show_api_group_three");
		if(NULL != dcli_init_func && connection)
		{			
			*network =(*dcli_init_func)
				  (
					parameter.instance_id,
					SECOND,/*"show ap ip bywtp ID"*/
					wtpid,
					0,
					0,
					&ret,
					0,
					&(parameter.local_id),
					connection,
					WID_DBUS_CONF_METHOD_AP_SHOW_IPADDR
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(ret == -1)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if((ret == 0)&&(*network))
	{
		retu = 1;
	}
	else if(ret == WID_AP_NO_STATICS)
	{
		retu = -2;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -3;
	}
	else if(ret == WTP_ID_LARGE_THAN_MAX)
	{
		retu = -1;
	}
		
	return retu;			
}


void Free_ap_model_infomation(DCLI_AC_API_GROUP_FOUR *modelinfo)
{
	void (*dcli_init_free_func)(char *,DCLI_AC_API_GROUP_FOUR *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_ac_free_fun_four");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_CONF_METHOD_AP_SHOW_MODEL_INFOMATION,modelinfo);
			modelinfo = NULL;
		}
	}
}

/*未使用*/
/*返回1时，调用Free_ap_model_infomation()释放空间*/
int show_ap_model_infomation(dbus_parameter parameter, DBusConnection *connection,char *modetype,DCLI_AC_API_GROUP_FOUR **modelinfo)
																									  /*返回0表示失败，返回1表示成功，返回-1表示input model is wrong*/
																									  /*返回-2表示ac support model does not set，返回-3表示this model does not supportted, set it first*/
																									  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	if(NULL == modetype)
	{
		*modelinfo = NULL;
		return 0;
	}
	
	int ret = -1;
	unsigned int model = 0 ;
	int retu = 0;
	if (!strcmp(modetype,"1110T"))
	{
		model = 1;	
	}
	else if (!strcmp(modetype,"2010"))
	{
		model = 2;	
	}
	else if (!strcmp(modetype,"2110"))
	{
		model = 3;	
	}
	else if (!strcmp(modetype,"AQ1000"))
	{
		model = 4;	
	}
	else if (!strcmp(modetype,"AQ1000-H"))
	{
		model = 5;	
	}
	else if (!strcmp(modetype,"AQ3110-H"))
	{
		model = 6;	
	}
	else if (!strcmp(modetype,"AQ3120-H"))
	{
		model = 7;	
	}
	else
	{
		return -1;
	}
	
	
	void*(*dcli_init_func)(
					int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int *,
					char *,
					char *,
					int ,
					DBusConnection *,
					char *
					);
    *modelinfo = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_ac_show_api_group_four");
		if(NULL != dcli_init_func && connection)
		{
			*modelinfo = (*dcli_init_func)
				(
					parameter.instance_id,
					FIRST,/*"show ap MODEL infomation"*/
					0,
					model,
					&ret,
					0,
					0,
					parameter.local_id,
					connection,
					WID_DBUS_CONF_METHOD_AP_SHOW_MODEL_INFOMATION
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(ret == -1)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if((ret == 0)&&(*modelinfo))
	{
		retu = 1;
	}
	else if(ret == SUPPORT_VERSION_NOT_EXIST)
	{
		retu = -2;
	}
	else if(ret == VERSION_NOT_SUPPORTED)
	{
		retu = -3;
	}
	
	return retu;		
}

#if _GROUP_POLICY
void Free_set_wtp_netid_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-5时，调用Free_set_wtp_netid_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_wtp_netid_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char*content,struct WtpList **WtpList_Head)
														/*返回0表示失败，返回1表示成功*/
														/*返回-1表示wtp location is too long,should be 1 to 32*/
														/*返回-2表示wtp id does not exist，返回-3示WTP ID非法*/
														/*返回-4表示Group ID非法，返回-5表示partial failure*/
														/*返回-6表示group id does not exist*/
{	
    if(NULL == connection)
        return 0;
	
	if(NULL == content)
	{
		*WtpList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	int retu = 0;
	char *netid = NULL;
	int len = 0;

	len = strlen(content);
	if(len > 32){		
		return -1;
	}
	
	netid = (char*)malloc(strlen(content)+1);
	if(NULL == netid)
        return 0;
	memset(netid, 0, strlen(content)+1);
	memcpy(netid, content, strlen(content));
	

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id == 0){
			syslog(LOG_DEBUG,"wtp id in set_wtp_netid_group is %d\n",id);
			return -3;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_wtp_netid_group is %d\n",id);
			return -4;
		}
	}

	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						char * ,
						int *,
						unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_wtp_netid_cmd_set_wtp_netid");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection, 
					  type, 
					  id, 
					  netid, 
					  &count, 
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if (ret == WTP_ID_NOT_EXIST)
			retu = -2;
	}

	if(type==1)
	{
		if(ret == 0){
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL)){
				retu = -5;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d \n",Wtp_Show_Node->WtpId);					
				}				
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -6;
	}
	FREE_OBJECT(netid);
	return retu;
}

#endif

//设置AP的网元编码
int set_wtp_netid(dbus_parameter parameter, DBusConnection *connection,int id,char*content)
														/*返回0表示失败，返回1表示成功*/
														/*返回-1表示wtp location is too long,should be 1 to 32*/
														/*返回-2表示wtp id does not exist，返回-3示WTP ID非法*/
														/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
    if(NULL == connection)
        return 0;
	
	if(NULL == content)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_wtp_netid_group(parameter, connection,0,id,content,&WtpList_Head);
	if(retu == -5)
	{
		Free_set_wtp_netid_group(WtpList_Head);
	}
	return retu;
#else	
	int retu = 1;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID;
	int ret = WID_DBUS_SUCCESS;
	char *netid = NULL;
	int len = 0;
	//WTPID = (unsigned int)id;

	len = strlen(content);
	if(len > 32){		
		return -1;
	}
	
	netid = (char*)malloc(strlen(content)+1);
	if(netid)
	{
		memset(netid, 0, strlen(content)+1);
		memcpy(netid, content, strlen(content));
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
		
	WTPID = (unsigned int)id;
	if(WTPID >= WTP_NUM || WTPID == 0){
		syslog(LOG_DEBUG,"wtp id in set_wtp_netid is %d\n",WTPID);
		return -3;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_WTP_NETID);
		

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_WTP_NETID);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_STRING,&netid,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) 
	{
		if (dbus_error_is_set(&err)) 
		{
			dbus_error_free(&err);
		}
		if(netid)
		{
			free(netid);
			netid = NULL;
		}

		return SNMPD_CONNECTION_ERROR;
	}

	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
		
	dbus_message_unref(reply);
	if(ret == 0)
		retu = 1;
	else if (ret == WTP_ID_NOT_EXIST)
		retu = -2;

	FREE_OBJECT(netid);

	return retu;
#endif	
}

void free_show_wtp_netid(DCLI_WTP_API_GROUP_THREE *WTPINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_THREE *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun_three");	
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_CONF_METHOD_SHOW_WID_WTP_NETID ,WTPINFO);
		}
	}
}
/*retu ==1 调用释放函数free_show_wtp_netid(DCLI_WTP_API_GROUP_THREE *WTPINFO)*/
int show_wtp_netid(dbus_parameter parameter, DBusConnection *connection,int id,DCLI_WTP_API_GROUP_THREE **WTPINFO)/*返回0表示失败，返回1表示成功，返回-1表示wtp does not set netid，返回-2表示 wtp id does not exist，返回-3示WTP ID非法*/
																													  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
	if(NULL == connection)
        return 0;
        
	unsigned int WTPID;
	int ret = WID_DBUS_SUCCESS;
	int retu = 0;

	WTPID = id;
	if(WTPID >= WTP_NUM || WTPID == 0){
		syslog(LOG_DEBUG,"wtp id in show_wtp_netid is %d\n",WTPID);
		return -3;
	}
	
    void *(*dcli_init_func)(
					int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int* ,
					unsigned int* ,
					unsigned int* ,
					unsigned char *,
					unsigned char *,
					int *,
					DBusConnection *,
					char *
					);

    *WTPINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_three");
		if(NULL != dcli_init_func && connection)
		{
			*WTPINFO = (*dcli_init_func)(
				parameter.instance_id,
				FOURTH,/*"show wtp netid"*/
				WTPID,
				0,
				0,
				&ret,/**/
				0,/*num2*/
				0,
				0,
				0,
				&(parameter.local_id),
				connection,
				WID_DBUS_CONF_METHOD_SHOW_WID_WTP_NETID
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if((ret == 0)&&(*WTPINFO))
	{
		retu = 1;
	}
	else if (ret == WID_WTP_LOCATION_NOT_SET)
	{
		retu = -1;
	}
	else if (ret == WTP_ID_NOT_EXIST)
	{
		retu = -2;
	}
	
	return retu;
}

/*未使用*/
int show_wtp_extension_information(int id,wid_wifi_info *head)
{	
	if(NULL == head)
	{
		return -1;
	}
	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	int retu = 1;
	unsigned int WTPID;
	int ret = WID_DBUS_SUCCESS;
	WTPID = (unsigned int)id;
	if(WTPID >= WTP_NUM || WTPID == 0){
		syslog(LOG_DEBUG,"wtp id in show_wtp_extension_information is %d\n",WTPID);
		return -4;
	}
	
	int i = 0;
	wid_wifi_info info;
	info.cpu = 0;
	info.tx_mgmt = 0;
	info.rx_mgmt = 0;
	info.tx_packets = 0;
	info.tx_errors = 0;
	info.tx_retry = 0;
	info.eth_count = 0;
	info.ath_count = 0;
	for(i=0;i<AP_ETH_IF_NUM;i++)
	{
		info.eth_updown_time[i] = 0;
	}
	for(i=0;i<AP_ATH_IF_NUM;i++)
	{
		info.ath_updown_time[i] = 0;
	}
	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_AP_SHOW_WTP_EXTENSION_INFOMATION);
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (ccgi_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) 
	{
		if (dbus_error_is_set(&err)) 
		{
			dbus_error_free(&err);
		}
		return -1;
	}


	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0)
	{	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.cpu);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_mgmt);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.rx_mgmt);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_packets);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_errors);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_retry);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.eth_count);

		for(i=0;i<info.eth_count;i++)
		{
			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info.eth_updown_time[i]);
		}

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.ath_count);

		for(i=0;i<info.ath_count;i++)
		{
			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info.ath_updown_time[i]);
		}
	}
	
	if(ret == 0){		
		//head->wtpid = WTPID;
		head->cpu = info.cpu/100.00;
		head->tx_mgmt = info.tx_mgmt;
		head->rx_mgmt = info.rx_mgmt;
		//head->totle_mgmt = info.rx_mgmt+info.tx_mgmt;
		head->rx_mgmt = info.rx_mgmt;
		head->tx_mgmt = info.tx_mgmt;
		head->tx_packets = info.tx_packets;
		head->tx_errors = info.tx_errors;
		head->tx_retry = info.tx_retry;
		head->eth_count = info.eth_count;
		
		for(i=0;i<AP_ETH_IF_NUM;i++)
		{
			if(info.eth_updown_time[i] != 0)
			{
				head->eth_updown_time[i] = info.eth_updown_time[i];
			}
		}
		head->ath_count = info.ath_count;
		for(i=0;i<AP_ATH_IF_NUM;i++)
		{
			if(info.ath_updown_time[i] != 0)
			{
				head->ath_updown_time[i] = info.ath_updown_time[i];
			}
		}
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
	 	retu = -1;
	else if (ret == WTP_ID_NOT_EXIST)
		retu = -2;
	else if (ret == SWITCH_IS_DISABLE)
		retu=-3;

	dbus_message_unref(reply);
	return retu;
}


void free_show_wtp_sample_throughput_information(DCLI_WTP_API_GROUP_TWO *INFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_TWO *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun_two");	
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_CONF_METHOD_SHOW_WID_WTP_SAMPLE_THROUGHPUT_INFO ,INFO);
		}
	}
}
/*retu==1 调用释放函数free_show_wtp_sample_throughput_information(DCLI_WTP_API_GROUP_TWO *INFO)*/
int show_wtp_sample_throughput_information(dbus_parameter parameter, DBusConnection *connection,int id,DCLI_WTP_API_GROUP_TWO **INFO)/*返回0表示失败，返回1表示成功，返回-1表示wtp is not in run state，返回-2表示wtp id does not exist，返回-3表示sample switch disable,enable it first，返回-4示WTP ID非法*/
																																			   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
    if(NULL == connection)
        return 0;
        
	unsigned int WTPID;
	int ret = WID_DBUS_SUCCESS;
	int retu = 0;	

    WTPID = id;
	if(WTPID >= WTP_NUM || WTPID == 0){
		syslog(LOG_DEBUG,"wtp id in show_wtp_sample_throughput_information is %d\n",WTPID);
		return -4;
	}
	
	void *(*dcli_init_func)(
				int ,
				unsigned int ,
				unsigned int ,
				unsigned int ,
				unsigned int ,
				unsigned int* ,
				unsigned int* ,
				unsigned int* ,
				unsigned char *,
				unsigned char *,
				int *,
				DBusConnection *,
				char *
				);

    *INFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_two");
		if(NULL != dcli_init_func && connection)
		{
			*INFO = (*dcli_init_func)(
				   parameter.instance_id,
				   FIRST,/*"show wtp sample throughput information"*/
				   WTPID,
				   0,
				   0,
				   &ret,/**/
				   0,/*num2*/
				   0,
				   0,
				   0,
				   &(parameter.local_id),
				   connection,
				   WID_DBUS_CONF_METHOD_SHOW_WID_WTP_SAMPLE_THROUGHPUT_INFO
				   );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if((ret == 0)&&(*INFO))
	{
		retu = 1;
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
	{
		retu = -1;
	}
	else if (ret == WTP_ID_NOT_EXIST)
	{
		retu = -2;
	}
	else if (ret == SAMPLE_THROUGHPUT_NOT_ENABLE)
	{
		retu = -3;
	}

	return retu;
}

#if _GROUP_POLICY
void Free_set_wtp_wtpname_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-5时，调用Free_set_wtp_wtpname_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_wtp_wtpname_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char * wtpname,struct WtpList **WtpList_Head)
																/*返回0表示失败，返回1表示成功*/
																/*返回-1表示wtp name is too long,should be 1 to DEFAULT_LEN-1*/
																/*返回-2表示wtp id does not exist，返回-3示WTP ID非法*/
																/*返回-4表示Group ID非法，返回-5表示partial failure*/
																/*返回-6表示group id does not exist*/
{	
    if(NULL == connection)
        return 0;
	
	if(NULL == wtpname)
	{
		*WtpList_Head = NULL;
		return 0;
	}

	char *name = NULL;
	int len = 0;
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	int retu = 0;
	
	len = strlen(wtpname);
	if(len >= DEFAULT_LEN){		
		return -1;
	}
	
	name = (char*)malloc(strlen(wtpname)+1);
	if(NULL == name)
        return 0;
	memset(name, 0, strlen(wtpname)+1);
	memcpy(name, wtpname, strlen(wtpname));
	
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id == 0){
			syslog(LOG_DEBUG,"wtp id in set_wtp_wtpname_group is %d\n",id);
			return -3;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_wtp_wtpname_group is %d\n",id);
			return -4;
		}
	}

	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						char * ,
						int *,
						unsigned int *
						);
    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_wtp_wtpname_cmd_set_wtp_name");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.slot_id,
					  connection, 
					  type, 
					  id, 
					  name, 
					  &count, 
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if (ret == WTP_ID_NOT_EXIST)
			retu = -2;
	}
	
	if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL))
			{
				retu = -5;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++)
				{
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);
					vty_out(vty,"%c",Wtp_Show_Node->FailReason);
				}					
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -6;
	}
   
	FREE_OBJECT(name);
	return retu;
}
#endif

int set_wtp_wtpname(dbus_parameter parameter, DBusConnection *connection,int id,char * wtpname)
															   /*返回0表示失败，返回1表示成功*/
															   /*返回-1表示wtp name is too long,should be 1 to DEFAULT_LEN-1*/
															   /*返回-2表示wtp id does not exist，返回-3示WTP ID非法*/
															   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == wtpname)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_wtp_wtpname_group(parameter, connection,0,id,wtpname,&WtpList_Head);
	if(retu == -5)
	{
		Free_set_wtp_wtpname_group(WtpList_Head);
	}
	return retu;
#else

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID = 0;
	int ret = WID_DBUS_SUCCESS;
	char *name = NULL;
	int len = 0;
	int retu = 0;

	len = strlen(wtpname);
	if(len >= DEFAULT_LEN)
	{		
		return -1;
	}
	
	name = (char*)malloc(strlen(wtpname)+1);
	if(name)
	{
		memset(name, 0, strlen(wtpname)+1);
		memcpy(name,wtpname, strlen(wtpname));
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	
	WTPID = id;
	if(WTPID >= WTP_NUM || WTPID == 0){
		syslog(LOG_DEBUG,"wtp id in set_wtp_wtpname is %d\n",WTPID);
		return -3;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id, WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id, WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id, WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTPNAME);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTPNAME);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_STRING,&name,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection, query, -1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) 
	{
		if(dbus_error_is_set(&err)) 
		{
			dbus_error_free(&err);
		}
		if(name)
		{
			free(name);
			name = NULL;
		}

		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
		
	dbus_message_unref(reply);
	if(ret == 0)
		retu = 1;
	else if(ret == WTP_ID_NOT_EXIST)
		retu = -2;
	
	FREE_OBJECT(name);

	return retu;
#endif	
}

#if _GROUP_POLICY
void Free_set_ap_extension_infomation_enable_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-7时，调用Free_set_ap_extension_infomation_enable_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_ap_extension_infomation_enable_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *state,struct WtpList **WtpList_Head)
							/*返回0表示失败，返回1表示成功，返回-1表示input patameter only with 'enable' or 'disable'*/
							/*返回-2表示wtp id does not exist，返回-3表示wtp id does not run，返回-4表示error*/
							/*返回-5示WTP ID非法，返回-6表示Group ID非法，返回-7表示partial failure*/
							/*返回-8表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	if(NULL == state)
	{
		*WtpList_Head = NULL;
		return 0;
	}
	
    int policy = 0;
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	int retu = 0;
	
	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -1;
	}	

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id == 0){
			syslog(LOG_DEBUG,"wtp id in set_ap_extension_infomation_enable_group is %d\n",id);
			return -5;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_ap_extension_infomation_enable_group is %d\n",id);
			return -6;
		}
	}

	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						int ,
						int *,
						unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_ap_extension_infomation_enable_cmd_set_ap_extension_infomation_switch");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection, 
					  type, 
					  id, 
					  policy, 
					  &count, 
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}	

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if (ret == WTP_ID_NOT_EXIST)
			retu = -2;
		else if (ret == WTP_NOT_IN_RUN_STATE)
			retu = -3;
		else
			retu = -4;
	}

	if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL))
			{
				retu = -7;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++)
				{
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);
					vty_out(vty,"%c",Wtp_Show_Node->FailReason);
				}	
				
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -8;
	}	
	return retu;			
}
#endif

int set_ap_extension_infomation_enable(dbus_parameter parameter, DBusConnection *connection,int wtp_id,char *state)
																					/*返回0表示失败，返回1表示成功，返回-1表示input patameter only with 'enable' or 'disable'*/
																					/*返回-2表示wtp id does not exist，返回-3表示wtp id does not run，返回-4表示error，返回-5示WTP ID非法*/
																					/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == state)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_ap_extension_infomation_enable_group(parameter, connection,0,wtp_id,state,&WtpList_Head);
	if(retu == -7)
	{
		Free_set_ap_extension_infomation_enable_group(WtpList_Head);
	}
	return retu;
#else	
	int ret,retu;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID = 0;
    int policy = 0;
	//WTPID = (unsigned int)wtp_id;
	
	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -1;
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
			
	WTPID = (unsigned int)wtp_id;
	if(WTPID >= WTP_NUM || WTPID == 0){
		syslog(LOG_DEBUG,"wtp id in set_ap_extension_infomation_enable is %d\n",WTPID);
		return -5;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_EXTENSION_INFOMATION_SWITCH);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_EXTENSION_INFOMATION_SWITCH);*/
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		retu=1;
	}
	else if (ret == WTP_ID_NOT_EXIST)
		retu=-2;
	else if (ret == WTP_NOT_IN_RUN_STATE)
		retu=-3;
	else
	{
		retu=-4;
	}
		
	dbus_message_unref(reply);
	return retu;			
#endif	
}

#if _GROUP_POLICY
void Free_set_ap_extension_infomation_reportinterval_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-9时，调用Free_set_ap_extension_infomation_reportinterval_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_ap_extension_infomation_reportinterval_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *para,struct WtpList **WtpList_Head) 
									/*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
									/*返回-2表示ap extension infomation reportinterval error，返回-3表示wtp is not in run state*/
									/*返回-4表示wtp id does not exist，返回-5表示error，返回-6示WTP ID非法*/
									/*返回-7表示illegal input:Input exceeds the maximum value of the parameter type*/
									/*返回-8表示Group ID非法，返回-9表示partial failure，返回-10表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	if(NULL == para)
	{
		*WtpList_Head = NULL;
		return 0;
	}
	
	int count = 0;
	unsigned int type = 0;
	unsigned int id = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret1 =WID_DBUS_SUCCESS; 
    unsigned int interval = 0;
	int retu = 0;	
	
	ret1 = parse_int_ID((char*)para, &interval);
	if(ret1 != WID_DBUS_SUCCESS){
        if(ret1 == WID_ILLEGAL_INPUT){
			retu = -7;
        }
		else{
			retu = -1;
		}
		return retu;
	}	
	if(interval > 600 || interval == 0){
		return -2;
	}	

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id < 0){
			syslog(LOG_DEBUG,"wtp id in set_ap_extension_infomation_reportinterval_group is %d\n",id);
			return -6;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_ap_extension_infomation_reportinterval_group is %d\n",id);
			return -8;
		}
	}

	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						unsigned char ,
						int *,
						unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_ap_extension_infomation_reportinterval_cmd_set_ap_extension_infomation_reportinterval");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection, 
					  type, 
					  id, 
					  interval, 
					  &count, 
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == WTP_NOT_IN_RUN_STATE)
			retu = -3;
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -4;
		else
			retu = -5;
	}
	if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL))
			{
				retu = -9;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++)
					{
						if(Wtp_Show_Node == NULL)
								Wtp_Show_Node = WtpList_Head->WtpList_list;
						else 
								Wtp_Show_Node = Wtp_Show_Node->next;

						if(Wtp_Show_Node == NULL)
								break;
				
						vty_out(vty,"%d ",Wtp_Show_Node->WtpId);
						vty_out(vty,"%c",Wtp_Show_Node->FailReason);
					}					
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -10;
	}			
	return retu;			
}
#endif

int set_ap_extension_infomation_reportinterval(dbus_parameter parameter, DBusConnection *connection,int WTPID,char *para)  
																							/*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
																							/*返回-2表示ap extension infomation reportinterval error，返回-3表示wtp is not in run state*/
																							/*返回-4表示wtp id does not exist，返回-5表示error，返回-6示WTP ID非法*/
																							/*返回-7表示illegal input:Input exceeds the maximum value of the parameter type*/
																							/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == para)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_ap_extension_infomation_reportinterval_group(parameter, connection,0,WTPID,para,&WtpList_Head);
	if(retu == -9)
	{
		Free_set_ap_extension_infomation_reportinterval_group(WtpList_Head);
	}
	return retu;
#else	
	int ret,ret1,retu;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

    unsigned int interval = 0;
	unsigned int wtp_id = 0;
	//wtp_id = (unsigned int)WTPID;
	
	ret1 = parse_int_ID((char*)para, &interval);
	if(ret1 != WID_DBUS_SUCCESS){
			if(ret1 == WID_ILLEGAL_INPUT){
				retu = -7;
			}
			else{
				retu = -1;
			}
			return retu;
	}	
	if(interval > 32767 || interval == 0){
		return -2;
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
		
	wtp_id = (unsigned int)WTPID;
	if(wtp_id >= WTP_NUM || wtp_id < 0){
		syslog(LOG_DEBUG,"wtp id in set_ap_extension_infomation_reportinterval is %d\n",wtp_id);
		return -6;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_EXTENSION_INFOMATION_REPORTINTERVAL);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_EXTENSION_INFOMATION_REPORTINTERVAL);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,	
							 DBUS_TYPE_UINT32,&interval,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		retu=1;
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
		retu=-3;
	else if(ret == WTP_ID_NOT_EXIST)
		retu=-4;
	else
	{
		retu=-5;
	}
		
	dbus_message_unref(reply);
	return retu;			
#endif	
}


void free_show_wtp_wlan_vlan_information(DCLI_WTP_API_GROUP_THREE *WTPINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_THREE *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun_three");	
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_CONF_METHOD_SHOW_WID_WTP_WLAN_VLAN_INFO ,WTPINFO);
		}
	}
}
/*retu==1,调用free_show_wtp_wlan_vlan_information(DCLI_WTP_API_GROUP_THREE *WTPINFO)*/
int show_wtp_wlan_vlan_information(dbus_parameter parameter, DBusConnection *connection,int wtp_id,DCLI_WTP_API_GROUP_THREE **WTPINFO)/*返回0表示失败，返回1表示成功，返回-1表示wtp id does not exist，返回-2表示WTP ID非法*/
																																			 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
    if(NULL == connection)
        return 0;
        
	unsigned int WTPID = 0;
	int ret = WID_DBUS_SUCCESS;
	int retu = 0;

	WTPID = wtp_id;
	if(WTPID >= WTP_NUM || WTPID == 0){
		syslog(LOG_DEBUG,"wtp id in show_wtp_wlan_vlan_information is %d\n",WTPID);
		return -2;
	}
	
	void *(*dcli_init_func)(
                        	int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int* ,
                        	unsigned int* ,
                        	unsigned int* ,
                        	unsigned char *,
                        	unsigned char *,
                        	int *,
                        //	DCLI_WTP_API_GROUP_THREE *,	
                        	DBusConnection *,
                        	char *
                        	);
                        	
    *WTPINFO= NULL; 
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_three");
		if(NULL != dcli_init_func && connection)
		{
			*WTPINFO = (*dcli_init_func)(
				parameter.instance_id,
				FIFTH,/*show wtp wlan vlan information*/
				WTPID,
				0,
				0,
				&ret,/**/
				0,/*num2*/
				0,
				0,
				0,
				&(parameter.local_id),
			//	WTPINFO,
				connection,
				WID_DBUS_CONF_METHOD_SHOW_WID_WTP_WLAN_VLAN_INFO
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else if((ret == 0)&&(*WTPINFO))
		retu = 1;
	else if (ret == WTP_ID_NOT_EXIST)
		retu = -1;

	return retu;
}

/*未使用*/
int show_wtp_extension_information_v2(int wtp_id,wid_wifi_info *exten_info)/*返回0表示失败，返回1表示成功，返回-1表示wtp id does not exist，返回-2表示wtp extension info report switch disable，返回-3示WTP ID非法*/
{	
	if(NULL == exten_info)
	{
		return 0;
	}
	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID;
	int ret = WID_DBUS_SUCCESS;
	int retu=1;
	WTPID = (unsigned int)wtp_id;
	if(WTPID >= WTP_NUM || WTPID == 0){
		syslog(LOG_DEBUG,"wtp id in show_wtp_extension_information_v2 is %d\n",WTPID);
		return -3;
	}
	
	int i = 0;
	wid_wifi_info info;
	{
		info.reportswitch = 0;
		info.reportinterval = 0;
		info.cpu = 0;
		info.tx_mgmt = 0;
		info.rx_mgmt = 0;
		info.tx_packets = 0;
		info.tx_errors = 0;
		info.tx_retry = 0;
		info.ipmode = 0;
		info.memoryall = 0;
		info.memoryuse = 0;
		info.flashall = 0;
		info.flashempty = 0;
		info.wifi_snr = 0;
		info.eth_count = 0;
		info.ath_count = 0;
		memset(info.eth_updown_time,0,AP_ETH_IF_NUM);
		memset(info.ath_updown_time,0,AP_ATH_IF_NUM);
	}
	for(i=0;i<AP_ETH_IF_NUM;i++)
	{
		info.eth_updown_time[i] = 0;
	}
	for(i=0;i<AP_ATH_IF_NUM;i++)
	{
		info.ath_updown_time[i] = 0;
	}
	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_AP_SHOW_WTP_EXTENSION_INFOMATION_V2);
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (ccgi_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return 0;
	}

	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0)
	{	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.cpu);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_mgmt);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.rx_mgmt);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_packets);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_errors);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_retry);

		//add something diff from v1
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.reportswitch);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.reportinterval);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.ipmode);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.memoryall);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.memoryuse);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.flashall);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.flashempty);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.wifi_snr);
		//end
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.eth_count);

		for(i=0;i<AP_ETH_IF_NUM;i++)
		{
			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info.eth_updown_time[i]);
		}

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.ath_count);

		for(i=0;i<AP_ATH_IF_NUM;i++)
		{
			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info.ath_updown_time[i]);
		}
	}
	
	if(ret == 0){		
		exten_info->reportswitch=info.reportswitch;
		exten_info->reportinterval=info.reportinterval;
		exten_info->cpu=info.cpu;
		exten_info->ipmode=info.ipmode;
		exten_info->memoryall=info.memoryall;
		exten_info->memoryuse=info.memoryuse;
		exten_info->flashall=info.flashall;
		exten_info->flashempty=info.flashempty;
		exten_info->wifi_snr=info.wifi_snr;
		exten_info->tx_mgmt=info.tx_mgmt;
		exten_info->rx_mgmt=info.rx_mgmt;
		exten_info->tx_packets=info.tx_packets;
		exten_info->tx_errors=info.tx_errors;
		exten_info->tx_retry=info.tx_retry;
		exten_info->eth_count=info.eth_count;
		for(i=0;i<AP_ETH_IF_NUM;i++)
		{
			exten_info->eth_updown_time[i]=info.eth_updown_time[i];
		}
		exten_info->ath_count=info.ath_count;
		for(i=0;i<AP_ATH_IF_NUM;i++)
		{
			exten_info->ath_updown_time[i]=info.ath_updown_time[i];
		}
	}
	else if (ret == WTP_ID_NOT_EXIST)
		retu=-1;
	else if (ret == SWITCH_IS_DISABLE)
		retu=-2;

	dbus_message_unref(reply);
	return retu;
}

void free_how_wtp_extension_information_v3(DCLI_WTP_API_GROUP_TWO *WTPINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_TWO *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun_two");	
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_CONF_METHOD_AP_SHOW_WTP_EXTENSION_INFOMATION_V3 ,WTPINFO);
		}
	}
}
/*retu==1 调用释放函数free_how_wtp_extension_information_v3(DCLI_WTP_API_GROUP_TWO *WTPINFO)*/
int show_wtp_extension_information_v3(dbus_parameter parameter, DBusConnection *connection,int wtp_id,DCLI_WTP_API_GROUP_TWO **WTPINFO)/*返回0表示失败，返回1表示成功，返回-1表示wtp id does not exist，返回-2表示wtp extension info report switch disable，返回-3示WTP ID非法*/
																																			   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
	if(NULL == connection)
        return 0;
        
	unsigned int WTPID = 0;
	int ret = WID_DBUS_SUCCESS;
	int retu = 0;

	WTPID = wtp_id;
	if(WTPID >= WTP_NUM || WTPID == 0){
		syslog(LOG_DEBUG,"wtp id in show_wtp_extension_information_v3 is %d\n",WTPID);
		return -3;
	}
	
	void *(*dcli_init_func)(
                        	int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int* ,
                        	unsigned int* ,
                        	unsigned int* ,
                        	unsigned char *,
                        	unsigned char *,
                        	int *,
                        //	DCLI_WTP_API_GROUP_TWO *,	
                        	DBusConnection *,
                        	char *
                        	);

	*WTPINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_two");
		if(NULL != dcli_init_func && connection)
		{
			*WTPINFO = (*dcli_init_func)(
				parameter.instance_id,
				SECOND,/*"show wtp cmt extension information"*/
				WTPID,
				0,
				0,
				&ret,/**/
				0,/*num2*/
				0,
				0,
				0,
				&(parameter.local_id),
			//	WTPINFO,
				connection,
				WID_DBUS_CONF_METHOD_AP_SHOW_WTP_EXTENSION_INFOMATION_V3
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else if((ret == 0)&&(*WTPINFO))
		retu = 1;
	else if (ret == WTP_ID_NOT_EXIST)
		retu = -1;
	else if (ret == SWITCH_IS_DISABLE)
		retu = -2;

	return retu;
}


/*未使用*/
int show_wtp_ethernet_interface_information(dbus_parameter parameter, DBusConnection *connection,int wtp_id,struct wtp_eth_inf_infor_profile *eth_inf_info_head,int *NUM,int *temperature)/*返回0表示失败，返回1表示成功，返回-1表示wtp id does not exist，返回-2表示WTP ID非法*/
																																																 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
	if(NULL == connection)
        return 0;
        
	if(NULL == eth_inf_info_head)
	{
		*NUM = 0;
		*temperature = 0;
		return 0;
	}
	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID;	
	unsigned int model = 0;
	unsigned char num = 0;
	int ret = WID_DBUS_SUCCESS;
	int retu=1;
	//WTPID = (unsigned int)wtp_id;
	unsigned char state = 0;
	int i = 0;
	struct wtp_eth_inf_infor_profile *q,*tail;
	char *name;
	unsigned int temp = 0;


	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	
	WTPID = (unsigned int)wtp_id;
	if(WTPID >= WTP_NUM || WTPID == 0){
		syslog(LOG_DEBUG,"wtp id in show_wtp_ethernet_interface_information is %d\n",WTPID);
		return -2;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WID_WTP_ETH_IF_INFO);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WID_WTP_ETH_IF_INFO);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}

	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0)
	{	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&num);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&state);

		dbus_message_iter_next(&iter);			
		dbus_message_iter_get_basic(&iter,&model);
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&name);
	}
	
	switch(model)
	{
		case 1 : temp = 37; break;// 1110T
		case 2 : temp = 35; break;// 2010
		case 3 : temp = 60; break;// 2110
		case 4 : temp = 36; break;// AQ1000
		case 5 : temp = 37; break;// AQ1000-H
		case 6 : temp = 39; break;// AQ3110-H
		case 7 : temp = 40; break;// AQ3120-H
		default : break;
	}
	
	if(ret == 0){			
		eth_inf_info_head->next = NULL;
		tail=eth_inf_info_head;
		*NUM=num;
		*temperature=temp;
		for(i=0;i<num;i++)
		{
			q=(struct wtp_eth_inf_infor_profile*)malloc(sizeof(struct wtp_eth_inf_infor_profile));
			if(q)
			{
				q->name=(char*)malloc(strlen(name)+1);
				if(q->name)
				{
					memset(q->name,0,strlen(name)+1);
					memcpy(q->name,name,strlen(name));
				}
				if(i == 0)
				{
					q->state=state;
				}
				q->next=NULL;
				if(tail)
				{
					tail->next=q;
					tail=q; 
				}
			}
		}
	}
	else if (ret == WTP_ID_NOT_EXIST)
		retu=-1;

	dbus_message_unref(reply);
	return retu;
}

#if _GROUP_POLICY
void Free_set_ap_l2_isolation_func_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-10时，调用Free_set_ap_l2_isolation_func_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*wlan_id的范围是1-15*/
/*state为"enable"或"disable"*/
int set_ap_l2_isolation_func_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,int wlan_id,int state,struct WtpList **WtpList_Head)  
																	/*返回0表示失败，返回1表示成功*/
																	/*返回-1表示input patameter only with 'enable' or 'disable'*/
																	/*返回-2表示wlan not exist，返回-3表示wtp not binding wlan*/
																	/*返回-4表示wtp id does not run，返回-5表示binding wlan error*/
																	/*返回-6表示error，返回-7示WTP ID非法*/
																	/*返回-8表示wlan l2 isolation state already，返回-9表示Group ID非法*/
																	/*返回-10表示partial failure，返回-11表示group id does not exist*/
																	/*返回-12表示input wlanid should be 1~15*/
{
	if(NULL == connection)
        return 0;
        
	int count = 0;
	unsigned int type = 0;
	unsigned int id = 0;
	unsigned char wlanid = 0;
	int ret = WID_DBUS_SUCCESS;
    int policy = 0;
	int retu = 0;


	/*fengwenchao modify 20110412*/
	/*ret = parse_char_ID((char*)argv[0], &wlanid);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}*/	
	//wlanid = (unsigned char)atoi(argv[0]);
	wlanid = wlan_id;
	if((wlanid < 1)||(wlanid > 15))
	{
		return -12;
	}
	/*fengwenchao modify end*/	
	/*if (!strcmp(argv[1],"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[1],"disable"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}*/
	policy = state;
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id == 0){
			syslog(LOG_DEBUG,"wtp id in set_ap_l2_isolation_func_group is %d\n",id);
			return -7;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_ap_l2_isolation_func_group is %d\n",id);
			return -9;
		}
	}

	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						int ,
						unsigned char ,
						int *,
						unsigned int *
						);
						
    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_ap_l2_isolation_cmd_set_wlan_l2_isolation");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection, 
					  type, 
					  id, 
					  policy,
					  wlanid, 
					  &count, 
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if (ret == WLAN_ID_NOT_EXIST)
			retu = -2;
		else if (ret == WTP_IS_NOT_BINDING_WLAN_ID)
			retu = -3;
		else if (ret == WTP_NOT_IN_RUN_STATE)
			retu = -4;
		else if (ret == AP_L2_ISOLATION_ENABLE_OR_DIS_ALREADY)
			retu = -8;
		else if (ret == WTP_OVER_MAX_BSS_NUM)
			retu = -5;
		else
			retu = -6;
	}
	else if(type == 1){
		if(ret == 0){
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL)){
				retu = -10;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}				
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -11;
	}
	return retu;
}
#endif

/*wlan_id的范围是1-15*/
int set_ap_l2_isolation_func(dbus_parameter parameter, DBusConnection *connection,int wtp_id,int wlan_id,int state)  
																					/*返回0表示失败，返回1表示成功*/
																					/*返回-1表示input patameter only with 'enable' or 'disable'*/
																					/*返回-2表示wlan not exist，返回-3表示wtp not binding wlan*/
																					/*返回-4表示wtp id does not run，返回-5表示binding wlan error*/
																					/*返回-6表示error，返回-7示WTP ID非法*/
																					/*返回-8表示wlan l2 isolation state already*/
																					/*返回-12表示input wlanid should be 1~15*/
																					/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_ap_l2_isolation_func_group(parameter, connection,0,wtp_id,wlan_id,state,&WtpList_Head);
	if(retu == -10)
	{
		Free_set_ap_l2_isolation_func_group(WtpList_Head);
	}
	return retu;
#else	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID = 0;
	unsigned char wlanid = 0;
	int ret = WID_DBUS_SUCCESS;
	int retu;
	//WTPID = wtp_id;
    int policy = 0;

	
	/*fengwenchao modify 20110412*/
	/*ret = parse_char_ID((char*)argv[0], &wlanid);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}*/	
	//wlanid = (unsigned char)atoi(argv[0]);
	wlanid = wlan_id;
	if((wlanid < 1)||(wlanid > 15))
	{
		return -12;
	}
	
	policy = state;	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
		
	WTPID = wtp_id;
	if(WTPID >= WTP_NUM || WTPID == 0){
		syslog(LOG_DEBUG,"wtp id in set_ap_l2_isolation_func is %d\n",WTPID);
		return -7;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SET_AP_L2_ISOLATION_ABLE);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_AP_L2_ISOLATION_ABLE);*/
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_BYTE,&wlanid,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		retu=1;
	}
	else if (ret == WLAN_ID_NOT_EXIST)
	{
		retu=-2;
	}
	else if (ret == WTP_IS_NOT_BINDING_WLAN_ID)
	{
		retu=-3;
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
	{
		retu=-4;
	}	
	else if (ret == AP_L2_ISOLATION_ENABLE_OR_DIS_ALREADY)				/*xiaodawei add for l2 isolation enable or disable already, 20101207*/
	{
		retu=-8;
	}
	else if (ret == WTP_OVER_MAX_BSS_NUM)
	{
		retu=-5;
	}
	else
	{
		retu=-6;
	}
		
	dbus_message_unref(reply);
	return retu;			
#endif	
}

#if _GROUP_POLICY
void Free_set_ap_dos_def_func_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-6时，调用Free_set_ap_dos_def_func_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*state为1表示state，state为0表示disable*/
int set_ap_dos_def_func_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,int state,struct WtpList **WtpList_Head)
						/*返回0表示失败，返回1表示成功，返回-1表示input patameter only with 'enable' or 'disable'*/
						/*返回-2表示wtp id does not run，返回-3表示error，返回-4示WTP ID非法*/
						/*返回-5表示Group ID非法，返回-6表示partial failure，返回-7表示group id does not exist*/
{
	if(NULL == connection)
        return 0;
        
	int count = 0;
	unsigned int type = 0;
	unsigned int id;
	int ret = WID_DBUS_SUCCESS;
	//WTPID = (unsigned int)vty->index;
	int policy = 0;
	int retu = 0;	
	
	if (!strcmp(state,"enable"))
	{
		policy = 1; 
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0; 
	}
	else
	{
		return -1;
	}
	
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id == 0){
			syslog(LOG_DEBUG,"wtp id in set_ap_dos_def_func_group is %d\n",id);
			return -4;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_ap_dos_def_func_group is %d\n",id);
			return -5;
		}
	}
	
	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						int ,
						int *,
						unsigned int *
						);
						
    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_ap_dos_def_cmd_set_ap_dos_def");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection, 
					  type, 
					  id, 
					  policy, 
					  &count, 
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{	if(ret == 0)
			retu = 1;
		else if (ret == WTP_NOT_IN_RUN_STATE)
			retu = -2;
		else
			retu = -3;
	}	

	else if(type == 1){
		if(ret == 0){
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL)){
				retu = -6;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}
				
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -7;
	}
	return retu;
}
#endif

/*state为1表示state，state为0表示disable*/
int set_ap_dos_def_func(dbus_parameter parameter, DBusConnection *connection,int wtp_id,int state)/*返回0表示失败，返回1表示成功，返回-1表示input patameter only with 'enable' or 'disable'，返回-2表示wtp id does not run，返回-3表示error，返回-4示WTP ID非法*/
																									  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_ap_dos_def_func_group(parameter, connection,0,wtp_id,state,&WtpList_Head);
	if(retu == -6)
	{
		Free_set_ap_dos_def_func_group(WtpList_Head);
	}
	return retu;
#else	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID;
	int ret = WID_DBUS_SUCCESS;
	int retu;
	//WTPID = wtp_id;
    int policy = 0;

	
	
	policy = state;	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
		
	WTPID = wtp_id;
	if(WTPID >= WTP_NUM || WTPID == 0){
		syslog(LOG_DEBUG,"wtp id in set_ap_dos_def_func is %d\n",WTPID);
		return -4;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SET_AP_PREVENT_DOS_ATTACK);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_AP_PREVENT_DOS_ATTACK);*/
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		retu=1;
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
		retu=-2;
	else
	{
		retu=-3;
	}
		
	dbus_message_unref(reply);
	return retu;			
#endif	
}

#if _GROUP_POLICY
void Free_set_ap_igmp_snoop_func_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-6时，调用Free_set_ap_igmp_snoop_func_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*state为1表示enable，state为0表示disable*/
int set_ap_igmp_snoop_func_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,int state,struct WtpList **WtpList_Head)
					/*返回0表示失败，返回1表示成功，返回-1表示input patameter only with 'enable' or 'disable'*/
					/*返回-2表示wtp id does not run，返回-3表示error，返回-4示WTP ID非法*/
					/*返回-5表示Group ID非法，返回-6表示partial failure，返回-7表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	int count = 0;
	unsigned int type = 0;
	unsigned int id;
	int ret = WID_DBUS_SUCCESS;
	//WTPID = (unsigned int)vty->index;
	int policy = 0;
	int retu = 0;	
	
	/*if (!strcmp(argv[0],"enable"))
	{
		policy = 1; 
	}
	else if (!strcmp(argv[0],"disable"))
	{
		policy = 0; 
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}*/
	policy = state;	
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id == 0){
			syslog(LOG_DEBUG,"wtp id in set_ap_igmp_snoop_func_group is %d\n",id);
			return -4;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_ap_igmp_snoop_func_group is %d\n",id);
			return -5;
		}
	}
	
	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						int ,
						int *,
						unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_ap_igmp_snoop_cmd_set_ap_igmp_snoop");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection, 
					  type, 
					  id, 
					  policy, 
					  &count, 
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
 
	if(type==0)
	{	if(ret == 0)
			retu = 1;
		else if (ret == WTP_NOT_IN_RUN_STATE)
			retu = -2;
		else
			retu = -3;
	}	

	else if(type == 1){
		if(ret == 0){
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL)){
				retu = -6;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}				
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -7;
	}
	return retu; 
}
#endif

/*state为1表示enable，state为0表示disable*/
int set_ap_igmp_snoop_func(dbus_parameter parameter, DBusConnection *connection,int wtp_id,int state)/*返回0表示失败，返回1表示成功，返回-1表示input patameter only with 'enable' or 'disable'，返回-2表示wtp id does not run，返回-3表示error，返回-4示WTP ID非法*/
																											/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_ap_igmp_snoop_func_group(parameter, connection,0,wtp_id,state,&WtpList_Head);
	if(retu == -6)
	{
		Free_set_ap_igmp_snoop_func_group(WtpList_Head);
	}
	return retu;
#else		
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID;
	int ret = WID_DBUS_SUCCESS;
	int retu;
	//WTPID = wtp_id;
    int policy = 0;
	
	
	policy = state;	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
			
	WTPID = wtp_id;
	if(WTPID >= WTP_NUM || WTPID == 0){
		syslog(LOG_DEBUG,"wtp id in set_ap_igmp_snoop_func is %d\n",WTPID);
		return -4;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SET_AP_IGMP_SNOOPING);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_AP_IGMP_SNOOPING);*/
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		retu=1;
	}	
	else if (ret == WTP_NOT_IN_RUN_STATE)
		retu=-2;
	else
	{
		retu=-3;
	}
		
	dbus_message_unref(reply);
	return retu;			
#endif	
}

void free_show_ap_mib_information(DCLI_WTP_API_GROUP_TWO *WTPINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_TWO *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun_two");	
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_CONF_METHOD_SHOW_AP_MIB_INFO ,WTPINFO);
		}
	}
}
/*retu==1,调用释放函数free_show_ap_mib_information(DCLI_WTP_API_GROUP_TWO *WTPINFO)*/
int show_ap_mib_information_func(dbus_parameter parameter, DBusConnection *connection,int wtp_id,DCLI_WTP_API_GROUP_TWO **WTPINFO)/*返回0表示失败，返回1表示成功，返回-1表示wtp id does not exist，返回-2表示WTP ID非法*/
																																		 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
	if(NULL == connection)
        return 0;
        
	unsigned int WTPID = 0;
	int ret = WID_DBUS_SUCCESS;
	
	int retu = 0;

	WTPID = wtp_id;
	if(WTPID >= WTP_NUM || WTPID == 0){
		syslog(LOG_DEBUG,"wtp id in show_ap_mib_information_func is %d\n",WTPID);
		return -2;
	}
	
	void *(*dcli_init_func)(
                        	int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int* ,
                        	unsigned int* ,
                        	unsigned int* ,
                        	unsigned char *,
                        	unsigned char *,
                        	int *,
                        //	DCLI_WTP_API_GROUP_TWO *,	
                        	DBusConnection *,
                        	char *
                        	);

    *WTPINFO = NULL;	
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_two");
		if(NULL != dcli_init_func && connection)
		{
			*WTPINFO = (*dcli_init_func)(
				parameter.instance_id,
				NINTH,/*"show ap mib information"*/
				WTPID,
				0,
				0,
				&ret,/**/
				0,/*num2*/
				0,
				0,
				0,
				&(parameter.local_id),
			//	WTPINFO,
				connection,
				WID_DBUS_CONF_METHOD_SHOW_AP_MIB_INFO
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}


	if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else if((ret == 0)&&(*WTPINFO))
		retu = 1;
	else if(ret == WTP_ID_NOT_EXIST)
	    retu = -1;
	
	return retu;
}

void free_show_ap_cm_statistics(DCLI_WTP_API_GROUP_TWO *WTPINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_TWO *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun_two");	
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_CONF_METHOD_SHOW_AP_CM_STATISTICS ,WTPINFO);
		}
	}
}

/*返回1时，调用free_show_ap_cm_statistics()释放空间*/
int show_ap_cm_statistics_func(dbus_parameter parameter, DBusConnection *connection,int wtp_id,DCLI_WTP_API_GROUP_TWO **WTPINFO)/*返回0表示失败，返回1表示成功，返回-1表示wtp id does not exist，返回-2表示WTP ID非法*/
																																	  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
	if(NULL == connection)
        return 0;
        
	unsigned int WTPID = 0;
	int ret = WID_DBUS_SUCCESS;

	int retu = 0;

	WTPID = wtp_id;
	if(WTPID >= WTP_NUM || WTPID == 0){
		syslog(LOG_DEBUG,"wtp id in show_ap_cm_statistics_func is %d\n",WTPID);
		return -2;
	}
	
	void *(*dcli_init_func)(
                        	int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int* ,
                        	unsigned int* ,
                        	unsigned int* ,
                        	unsigned char *,
                        	unsigned char *,
                        	int *,
                        //	DCLI_WTP_API_GROUP_TWO *,	
                        	DBusConnection *,
                        	char *
                        	);

    *WTPINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_two");
		if(NULL != dcli_init_func && connection)
		{
			*WTPINFO = (*dcli_init_func)(
				parameter.instance_id,
				THIRD,/*"show ap cm statistics"*/
				WTPID,
				0,
				0,
				&ret,/**/
				0,/*num2*/
				0,
				0,
				0,
				&(parameter.local_id),
				//WTPINFO,
				connection,
				WID_DBUS_CONF_METHOD_SHOW_AP_CM_STATISTICS
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}


	if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else if((ret == 0)&&(*WTPINFO))
		retu = 1;
	else if (ret == WTP_ID_NOT_EXIST)
		retu = -1;

	return retu;
}

#if _GROUP_POLICY
void Free_set_ap_sta_infomation_report_enable_func_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-7时，调用Free_set_ap_sta_infomation_report_enable_func_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_ap_sta_infomation_report_enable_func_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *state,struct WtpList **WtpList_Head) 
									/*返回0表示失败，返回1表示成功，返回-1表示input patameter only with 'enable' or 'disable'*/
									/*返回-2表示wtp id does not exist，返回-3表示wtp id does not run，返回-4表示error*/
									/*返回-5示WTP ID非法，返回-6表示Group ID非法，返回-7表示partial failure*/
									/*返回-8表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	if(NULL == state)
	{
		*WtpList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	int retu = 0;	
    int policy = 0;
	
	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -1;
	}

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id < 0){
			syslog(LOG_DEBUG,"wtp id in set_ap_sta_infomation_report_enable_func_group is %d\n",id);
			return -5;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_ap_sta_infomation_report_enable_func_group is %d\n",id);
			return -6;
		}
	}
	
	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						int ,
						int *,
						unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_ap_sta_infomation_report_enable_cmd_set_ap_sta_infomation_report_switch");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection, 
					  type, 
					  id, 
					  policy, 
					  &count, 
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{	if(ret == 0)
			retu = 1;
		else if (ret == WTP_ID_NOT_EXIST)
			retu = -2;
		else if (ret == WTP_NOT_IN_RUN_STATE)
			retu = -3;
		else
			retu = -4;
	}	

	else if(type == 1){
		if(ret == 0){
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL)){
				retu = -7;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);	
					
				}				
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -8;
	}
	return retu;				
}
#endif

/*未使用*/
int set_ap_sta_infomation_report_enable_func(dbus_parameter parameter, DBusConnection *connection,int wtp_id,char *state) 
																							/*返回0表示失败，返回1表示成功，返回-1表示input patameter only with 'enable' or 'disable'*/
																							/*返回-2表示wtp id does not exist，返回-3表示wtp id does not run，返回-4表示error，返回-5示WTP ID非法*/
																							/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == state)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_ap_sta_infomation_report_enable_func_group(parameter, connection,0,wtp_id,state,&WtpList_Head);
	if(retu == -7)
	{
		Free_set_ap_sta_infomation_report_enable_func_group(WtpList_Head);
	}
	return retu;
#else		
	int ret,retu;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID = 0;
    int policy = 0;
	//WTPID = wtp_id;
	
	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -1;
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
			
	WTPID = wtp_id;
	if(WTPID >= WTP_NUM || WTPID < 0){
		syslog(LOG_DEBUG,"wtp id in set_ap_sta_infomation_report_enable_func is %d\n",WTPID);
		return -5;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_INFOMATION_SWITCH);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_INFOMATION_SWITCH);*/
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if (ret == WTP_ID_NOT_EXIST)
		retu=-2;
	else if (ret == WTP_NOT_IN_RUN_STATE)
		retu=-3;
	else
		retu=-4;
		
	dbus_message_unref(reply);
	
	return retu;			
#endif	
}

#if _GROUP_POLICY
void Free_set_ap_sta_infomation_reportinterval_cmd_func_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-9时，调用Free_set_ap_sta_infomation_reportinterval_cmd_func_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_ap_sta_infomation_reportinterval_cmd_func_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *para,struct WtpList **WtpList_Head) 
												/*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
												/*返回-2表示ap sta infomation reportinterval error，返回-3表示wtp is not in run state*/
												/*返回-4表示wtp id does not exist，返回-5表示error，返回-6示WTP ID非法*/
												/*返回-7表示illegal input:Input exceeds the maximum value of the parameter type*/
												/*返回-8表示Group ID非法，返回-9表示partial failure*/
												/*返回-10表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	if(NULL == para)
	{
		*WtpList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	int retu = 0;	
    unsigned int interval = 0;
	
	ret = parse_int_ID((char*)para, &interval);
	if(ret != WID_DBUS_SUCCESS){
        if(ret == WID_ILLEGAL_INPUT){
			retu = -7;
        }
		else{
			retu = -1;
		}
		return retu;
	}	
	if(interval > 350 || interval <5){
		return -2;
	}
	
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id < 0){
			syslog(LOG_DEBUG,"wtp id in set_ap_sta_infomation_reportinterval_cmd_func_group is %d\n",id);
			return -6;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_ap_sta_infomation_reportinterval_cmd_func_group is %d\n",id);
			return -8;
		}
	}
	
	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						unsigned char ,
						int *,
						unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_ap_sta_infomation_reportinterval_cmd_set_ap_sta_infomation_reportinterval");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection, 
					  type, 
					  id, 
					  interval, 
					  &count, 
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if (ret == WTP_NOT_IN_RUN_STATE)
			retu = -3;
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -4;
		else
			retu = -5;
	}

	else if(type == 1){
		if(ret == 0){
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL)){
				retu = -9;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}				
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -10;
	}
	return retu;			
}
#endif

/*未使用*/
/*para的范围是5-32767*/
int set_ap_sta_infomation_reportinterval_cmd_func(dbus_parameter parameter, DBusConnection *connection,int WtpID,char *para) 
																						/*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
																						/*返回-2表示ap sta infomation reportinterval error,should be 5-32767，返回-3表示wtp is not in run state*/
																						/*返回-4表示wtp id does not exist，返回-5表示error，返回-6示WTP ID非法*/
																						/*返回-7表示illegal input:Input exceeds the maximum value of the parameter type*/
																						/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == para)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_ap_sta_infomation_reportinterval_cmd_func_group(parameter, connection,0,WtpID,para,&WtpList_Head);
	if(retu == -9)
	{
		Free_set_ap_sta_infomation_reportinterval_cmd_func_group(WtpList_Head);
	}
	return retu;
#else
	int ret = 0,retu;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

    unsigned int interval = 0;
	unsigned int wtp_id = 0;
	//wtp_id = WtpID;
	
	ret = parse_int_ID((char*)para, &interval);
	if(ret != WID_DBUS_SUCCESS){
			if(ret == WID_ILLEGAL_INPUT){
				retu = -7;
			}
			else{
				retu = -1;
			}
			return retu;
	}	
	if(interval > 32767 || interval < 5){
		return -2;
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
			
	wtp_id = WtpID;
	if(wtp_id >= WTP_NUM || wtp_id < 0){
		syslog(LOG_DEBUG,"wtp id in set_ap_sta_infomation_reportinterval_cmd_func is %d\n",wtp_id);
		return -6;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_INFOMATION_REPORTINTERVAL);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_INFOMATION_REPORTINTERVAL);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,	
							 DBUS_TYPE_UINT32,&interval,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}	

		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if (ret == WTP_NOT_IN_RUN_STATE)
		retu=-3;
	else if(ret == WTP_ID_NOT_EXIST)
		retu=-4;
	else
		retu=-5;
		
	dbus_message_unref(reply);
	
	return retu;			
#endif	
}

#if _GROUP_POLICY
void Free_set_ap_if_info_report_enable_func_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-7时，调用Free_set_ap_if_info_report_enable_func_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*state为"enable"或"disable"*/
int set_ap_if_info_report_enable_func_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *state,struct WtpList **WtpList_Head)  
									/*返回0表示失败，返回1表示成功，返回-1表示input patameter only with 'enable' or 'disable'*/
									/*返回-2表示wtp id does not exist，返回-3表示wtp id does not run，返回-4表示error*/
									/*返回-5示WTP ID非法，返回-6表示Group ID非法，返回-7表示partial failure*/
									/*返回-8表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	if(NULL == state)
	{
		*WtpList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
    int policy = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	int retu = 0;	

	//WTPID = (unsigned int)vty->index;	
	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -1;
	}
	

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id < 0){
			syslog(LOG_DEBUG,"wtp id in set_ap_if_info_report_enable_func_group is %d\n",id);
			return -5;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_ap_if_info_report_enable_func_group is %d\n",id);
			return -6;
		}
	}
	
	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						int ,
						int *,
						unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_ap_if_info_report_enable_cmd_sep_ap_interface_information_report_switch");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection,
					  type,
					  id,
					  policy,
					  &count,
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type == 0)
	{
		if(ret == 0)
		{
			retu = 1;
		}
		else if (ret == WTP_ID_NOT_EXIST)
		{
			retu = -2;
		}
		else if (ret == WTP_NOT_IN_RUN_STATE)
		{
			retu = -3;
		}
		else
		{
			retu = -4;
		}
	}
	else if(type == 1){
		if(ret == 0){
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL)){
				retu = -7;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}				
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -8;
	}
		
	return retu;			
}
#endif

/*未使用*/
/*state为"enable"或"disable"*/
int set_ap_if_info_report_enable_func(dbus_parameter parameter, DBusConnection *connection,int wtp_id,char *state)  
																					/*返回0表示失败，返回1表示成功，返回-1表示input patameter only with 'enable' or 'disable'*/
																					/*返回-2表示wtp id does not exist，返回-3表示wtp id does not run，返回-4表示error，返回-5示WTP ID非法*/
																					/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == state)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_ap_if_info_report_enable_func_group(parameter, connection,0,wtp_id,state,&WtpList_Head);
	if(retu == -7)
	{
		Free_set_ap_if_info_report_enable_func_group(WtpList_Head);
	}
	return retu;
#else
	int ret,retu;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID = 0;
    int policy = 0;
	//WTPID = wtp_id;
	
	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -1;
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
			
	WTPID = wtp_id;
	if(wtp_id >= WTP_NUM || wtp_id < 0){
		syslog(LOG_DEBUG,"wtp id in set_ap_if_info_report_enable_func is %d\n",wtp_id);
		return -5;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_IF_INFO_SWITCH);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_IF_INFO_SWITCH);*/
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if (ret == WTP_ID_NOT_EXIST)
		retu=-2;
	else if (ret == WTP_NOT_IN_RUN_STATE)
		retu=-3;
	else
		retu=-4;
		
	dbus_message_unref(reply);
	
	return retu;			
#endif
}

#if _GROUP_POLICY
void Free_set_ap_if_info_reportinterval_cmd_func_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-9时，调用Free_set_ap_if_info_reportinterval_cmd_func_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_ap_if_info_reportinterval_cmd_func_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *para,struct WtpList **WtpList_Head)   
													/*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
													/*返回-2表示ap sta infomation reportinterval error，返回-3表示wtp is not in run state*/
													/*返回-4表示wtp id does not exist，返回-5表示error，返回-6示WTP ID非法*/
													/*返回-7表示illegal input:Input exceeds the maximum value of the parameter type*/
													/*返回-8表示Group ID非法，返回-9表示partial failure，返回-10表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	if(NULL == para)
	{
		*WtpList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned char interval = 0;	
	int retu = 0;	
	
	ret = parse_char_ID((char*)para, &interval);
	if(ret != WID_DBUS_SUCCESS){
        if(ret == WID_ILLEGAL_INPUT){
			retu = -7;
        }
		else{
			retu = -1;
		}
		return retu;
	}	
	if(interval > 120 || interval == 0){
		return -2;
	}
	
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id < 0){
			syslog(LOG_DEBUG,"wtp id in set_ap_if_info_reportinterval_cmd_func_group is %d\n",id);
			return -6;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_ap_if_info_reportinterval_cmd_func_group is %d\n",id);
			return -8;
		}
	}
	
	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						unsigned int , 
						int *,
						unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_ap_if_info_report_enable_cmd_sep_ap_interface_information_report_interval");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection,
					  type,
					  id,
					  interval,
					  &count,
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type == 0)
	{
		if(ret == 0)
		{
			retu = 1;
		}
		else if (ret == WTP_NOT_IN_RUN_STATE)
		{
			retu = -3;
		}
		else if(ret == WTP_ID_NOT_EXIST)
		{
			retu = -4;
		}
		else
		{
			retu = -5;
		}
	}
	else if(type == 1){
		if(ret == 0){
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL)){
				retu = -9;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}				
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -10;
	}
	
	return retu;			
}
#endif

/*未使用*/
int set_ap_if_info_reportinterval_cmd_func(dbus_parameter parameter, DBusConnection *connection,int WtpID,char *para)   
																				/*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
																				/*返回-2表示ap sta infomation reportinterval error，返回-3表示wtp is not in run state*/
																				/*返回-4表示wtp id does not exist，返回-5表示error，返回-6示WTP ID非法*/
																				/*返回-7表示illegal input:Input exceeds the maximum value of the parameter type*/
																				/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == para)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_ap_if_info_reportinterval_cmd_func_group(parameter, connection,0,WtpID,para,&WtpList_Head);
	if(retu == -9)
	{
		Free_set_ap_if_info_reportinterval_cmd_func_group(WtpList_Head);
	}
	return retu;
#else
	int ret = 0,retu;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
    unsigned int interval = 0;
	unsigned int wtp_id = 0;
	//wtp_id = WtpID;
	
	ret = parse_int_ID((char*)para, &interval);
	if(ret != WID_DBUS_SUCCESS){
		if(ret == WID_ILLEGAL_INPUT){
			retu = -7;
		}
		else{
			retu = -1;
		}
			return retu;
	}	
	if(interval > 32767 || interval == 0){
		return -2;
	}	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
		
	wtp_id = WtpID;
	if(wtp_id >= WTP_NUM || wtp_id < 0){
		syslog(LOG_DEBUG,"wtp id in set_ap_if_info_reportinterval_cmd_func is %d\n",wtp_id);
		return -6;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_IF_INFO_REPORTINTERVAL);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_IF_INFO_REPORTINTERVAL);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,	
							 DBUS_TYPE_UINT32,&interval,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if (ret == WTP_NOT_IN_RUN_STATE)
		retu=-3;
	else if(ret == WTP_ID_NOT_EXIST)
		retu=-4;
	else
		retu=-5;
		
	dbus_message_unref(reply);
	
	return retu;			
#endif
}

#if _GROUP_POLICY
void Free_set_ap_if_updown_func_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-9时，调用Free_set_ap_if_updown_func_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*inter_type为"eth"或"wifi"*/
/*state为"uplink"或"downlink"*/
int set_ap_if_updown_func_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *inter_type,char *If_index,char *state,struct WtpList **WtpList_Head) 
								/*返回0表示失败，返回1表示成功，返回-1表示input interface only with 'ath' 'eth' or 'wifi'*/
								/*返回-2表示unknown id format，返回-3表示input interface only with 'uplink' or 'downlink'*/
								/*返回-4表示wtp is not in run state，返回-5表示wtp id does not exist，返回-6表示error*/
								/*返回-7示WTP ID非法，返回-8表示Group ID非法，返回-9表示partial failure*/
								/*返回-10表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	if((NULL == inter_type)||(NULL == If_index)||(NULL == state))
	{
		*WtpList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type1 = 0;
	int retu = 0;	
	unsigned char type = 4;
	unsigned char policy = 2;
	unsigned char ifindex = 0;

	if (!strcmp(inter_type,"eth"))
	{
		type = 0;	
	}
	else if (!strcmp(inter_type,"wifi"))
	{
		type = 1;	
	}
	else
	{
		return -1;
	}
	
	ret = wid_wtp_parse_char_ID((char*)If_index, &ifindex);
	if(ret != WID_DBUS_SUCCESS){
		return -2;
	}

	if (!strcmp(state,"uplink"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"downlink"))
	{
		policy = 0;	
	}
	else
	{
		return -3;
	}	

	id = group_id;
	type1 = group_type;
	if(type1 == 0)
	{
		if(id >= WTP_NUM || id == 0){
			syslog(LOG_DEBUG,"wtp id in set_ap_if_updown_func_group is %d\n",id);
			return -7;
		}
	}
	else if(type1 == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_ap_if_updown_func_group is %d\n",id);
			return -8;
		}
	}
	
	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						unsigned char ,
						unsigned char ,
						unsigned char ,
						int *,
						unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_ap_if_updown_cmd_set_ap_interface");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection,
					  type1,
					  id,
					  type,
					  ifindex,
					  policy,
					  &count,
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}		

	if(type1==0)
	{		
		if(ret == 0)
			retu = 1;
		else if (ret == WTP_NOT_IN_RUN_STATE)
			retu = -4;
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -5;
		else
			retu = -6;
	}

	if(type1==1)
	{
		if(ret == 0){
			retu = 1;
			if((count != 0)&&(type1 == 1)&&(*WtpList_Head!=NULL)){
				retu = -9;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}
				
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -10;
	}
	return retu;		
}
#endif

int set_ap_if_updown_func(dbus_parameter parameter, DBusConnection *connection,int WtpID,char *inter_type,char *id,char *state) 
																					/*返回0表示失败，返回1表示成功，返回-1表示input interface only with 'ath' 'eth' or 'wifi'*/
																					/*返回-2表示unknown id format，返回-3表示input interface only with 'uplink' or 'downlink'*/
																					/*返回-4表示wtp is not in run state，返回-5表示wtp id does not exist，返回-6表示error，返回-7示WTP ID非法*/
																					/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if((NULL == inter_type)||(NULL == id)||(NULL == state))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_ap_if_updown_func_group(parameter, connection,0,WtpID,inter_type,id,state,&WtpList_Head);
	if(retu == -9)
	{
		Free_set_ap_if_updown_func_group(WtpList_Head);
	}
	return retu;
#else
	int ret = 0,retu;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned char type = 4;
	unsigned char policy = 2;
	unsigned int wtp_id = 0;
	unsigned char ifindex = 0;
	//wtp_id = WtpID;

	if (!strcmp(inter_type,"eth"))
	{
		type = 0;	
	}
	else if (!strcmp(inter_type,"wifi"))
	{
		type = 1;	
	}
	else
	{
		return -1;
	}
	
	ret = wid_wtp_parse_char_ID((char*)id, &ifindex);
	if(ret != WID_DBUS_SUCCESS){
			return -2;
	}

	if (!strcmp(state,"uplink"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"downlink"))
	{
		policy = 0;	
	}
	else
	{
		return -3;
	}
	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
			
	wtp_id = WtpID;
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		syslog(LOG_DEBUG,"wtp id in set_ap_if_updown_func is %d\n",wtp_id);
		return -7;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_INTERFACE_UPDOWN);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_INTERFACE_UPDOWN);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,	
							 DBUS_TYPE_BYTE,&type,
							 DBUS_TYPE_BYTE,&ifindex,
							 DBUS_TYPE_BYTE,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}	

		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if (ret == WTP_NOT_IN_RUN_STATE)
		retu=-4;
	else if(ret == WTP_ID_NOT_EXIST)
		retu=-5;
	else
		retu=-6;
		
	dbus_message_unref(reply);

	return retu;
#endif
}

#if _GROUP_POLICY
void Free_set_ap_if_rate_cmd_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-9时，调用Free_set_ap_if_rate_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*rate的范围是"10","100"或"1000"*/
int set_ap_if_rate_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *if_index,char *if_rate,struct WtpList **WtpList_Head)
											/*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
											/*返回-2表示input interface only with '10'  or '100' or '1000'，返回-3表示wtp is not in run state*/
											/*返回-4表示wtp id does not exist，返回-5表示eth if_index does not exist*/
											/*返回-6表示error，返回-7示WTP ID非法，返回-8表示Group ID非法*/
											/*返回-9表示partial failure，返回-10表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	if((NULL == if_index)||(NULL == if_rate))
	{
		*WtpList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;	
	int retu = 0;	
	unsigned char ifindex = 0;
	unsigned int rate = 0;
	ret = wid_wtp_parse_char_ID((char*)if_index, &ifindex);
	if(ret != WID_DBUS_SUCCESS){
		return -1;
	}
	ret = wid_wtp_parse_char_ID((char*)if_rate, &rate); 
	
	if (!strcmp(if_rate,"10"))
	{
		rate = 10;	
	}
	else if (!strcmp(if_rate,"100"))
	{
		rate = 100;	
	}	
	else if (!strcmp(if_rate,"1000"))
	{
		rate = 1000;	
	}	
	else
	{
		return -2;
	}

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id < 0){
			syslog(LOG_DEBUG,"wtp id in set_ap_if_rate_cmd_group is %d\n",id);
			return -7;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_ap_if_rate_cmd_group is %d\n",id);
			return -8;
		}
	}
	
	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						unsigned char ,
						unsigned int ,
						int *,
						unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_ap_if_eth_rate_cmd_set_ap_interface_eth_rate");
		if(NULL != dcli_init_func && connection)
		{			
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection,
					  type,
					  id,
					  ifindex,
					  rate,
					  &count,
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{		
		if(ret == 0)
			retu = 1;
		else if (ret == WTP_NOT_IN_RUN_STATE)
			retu = -3;
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -4;
		else
			retu = -6;
	}

	if(type==1)
	{
		if(ret == 0){
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL)){
				retu = -9;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}				
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -10;
	}
	return retu;			
}
#endif

/*rate的范围是"10","100"或"1000"*/
int set_ap_if_rate_cmd(dbus_parameter parameter, DBusConnection *connection,int WtpID,char *if_index,char *if_rate)
																				  /*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
																				  /*返回-2表示input interface only with '10' or '100' or '1000'，返回-3表示wtp is not in run state*/
																				  /*返回-4表示wtp id does not exist，返回-5表示eth if_index does not exist*/
																				  /*返回-6表示error，返回-7示WTP ID非法*/
																				  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if((NULL == if_index)||(NULL == if_rate))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_ap_if_rate_cmd_group(parameter, connection,0,WtpID,if_index,if_rate,&WtpList_Head);
	if(retu == -9)
	{
		Free_set_ap_if_rate_cmd_group(WtpList_Head);
	}
	return retu;
#else
	int ret = 0;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned char type = 4;
	unsigned int wtp_id = 0;
	unsigned char ifindex = 0;
	//wtp_id = (unsigned int)WtpID;
	unsigned int rate = 0;
	int retu;

	ret = wid_wtp_parse_char_ID((char*)if_index, &ifindex);
	if(ret != WID_DBUS_SUCCESS){
			return -1;
	}
	ret = wid_wtp_parse_char_ID((char*)if_rate, &rate);

	
	if (!strcmp(if_rate,"10"))
	{
		rate = 10;	
	}
	else if (!strcmp(if_rate,"100"))
	{
		rate = 100;	
	}
	else if (!strcmp(if_rate,"1000"))
	{
		rate = 1000;	
	}	
	else
	{
		return -2;
	}
	
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
			
	wtp_id = WtpID;
	if(wtp_id >= WTP_NUM || wtp_id < 0){
		syslog(LOG_DEBUG,"wtp id in set_ap_if_rate_cmd is %d\n",wtp_id);
		return -7;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_INTERFACE_ETH_RATE);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_INTERFACE_ETH_RATE);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,	
							 DBUS_TYPE_BYTE,&type,
							 DBUS_TYPE_BYTE,&ifindex,
							 DBUS_TYPE_UINT32,&rate,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		retu = 1;
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
	{
		retu = -3;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -4;
	}
	else if(ret == ETH_NOT_EXIST)
	{
		retu = -5;
	}
	else 
	{
		retu = -6;
	}
		
	dbus_message_unref(reply);

	return retu;		
#endif	
}
void free_show_ap_if_info(DCLI_WTP_API_GROUP_TWO *WTPINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_TWO *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun_two");	
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_WTP_METHOD_SHOW_WTP_IF_INFO,WTPINFO);
		}
	}

}
/*retu=1,释放函数free_show_ap_if_info(DCLI_WTP_API_GROUP_TWO *WTPINFO)*/
int show_ap_if_info_func(dbus_parameter parameter, DBusConnection *connection, int wtp_id,DCLI_WTP_API_GROUP_TWO **WTPINFO)/*返回0表示失败，返回1表示成功，返回-1表示wtp id does not exist，返回-2表示wtp interface infomation report switch is disable，返回-3示WTP ID非法*/
																															   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
	if(NULL == connection)
	    return 0;
	    
	unsigned int WTPID = 0;
	int ret = WID_DBUS_SUCCESS;	
	int retu = 0;
		
	WTPID = wtp_id;
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		syslog(LOG_DEBUG,"wtp id in show_ap_if_info_func is %d\n",wtp_id);
		return -3;
	}
	
	void *(*dcli_init_func)(
                    		int ,
                    		unsigned int ,
                    		unsigned int ,
                    		unsigned int ,
                    		unsigned int ,
                    		unsigned int* ,
                    		unsigned int* ,
                    		unsigned int* ,
                    		unsigned char *,
                    		unsigned char *,
                    		int *,
                    	//	DCLI_WTP_API_GROUP_TWO *,	
                    		DBusConnection *,
                    		char *
                    		);

    *WTPINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_two");
		if(NULL != dcli_init_func && connection)
		{
			*WTPINFO = (*dcli_init_func)(
				parameter.instance_id,
				TENTH,/*"show ap interface information"*/
				WTPID,
				0,
				0,
				&ret,/**/
				0,/*num2*/
				0,
				0,
				0,
				&(parameter.local_id),
			//	WTPINFO,
				connection,
				WID_DBUS_WTP_METHOD_SHOW_WTP_IF_INFO
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(ret == -1)
	    retu = SNMPD_CONNECTION_ERROR;    
	else if((ret == 0)&&(*WTPINFO))
		retu = 1;
	else if (ret == WTP_ID_NOT_EXIST)
		retu = -1;
	else if (ret == SWITCH_IS_DISABLE)
		retu = -2;

	return retu;
}

#if _GROUP_POLICY
void Free_get_wtp_bss_pkt_info_func_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-6时，调用Free_get_wtp_bss_pkt_info_func_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int get_wtp_bss_pkt_info_func_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,struct WtpList **WtpList_Head)   
												/*返回0表示失败，返回1表示成功，返回-1表示not expect error*/
												/*返回-2表示wtp id does not exist，返回-3表示error，返回-4示WTP ID非法*/
												/*返回-5表示Group ID非法，返回-6表示partial failure，返回-7表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	int retu = 0;	
	
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id == 0){
			syslog(LOG_DEBUG,"wtp id in get_wtp_bss_pkt_info_func_group is %d\n",id);
			return -4;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in get_wtp_bss_pkt_info_func_group is %d\n",id);
			return -5;
		}
	}
	
	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						int *,
						unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"get_wtp_bss_pkt_info_cmd_update_wtp_bss_pakets_infomation");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection,
					  type,
					  id,
					  &count,
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == WID_DBUS_ERROR)
			retu = -1;
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -2;
		else
			retu = -3;
	}
	if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL))
			{
				retu = -6;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++)
				{
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;
		
					if(Wtp_Show_Node == NULL)
						break;
							
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}
						
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -7;
	}	
	return retu;			
}
#endif

int get_wtp_bss_pkt_info_func(dbus_parameter parameter, DBusConnection *connection,int WtpID)   
																/*返回0表示失败，返回1表示成功，返回-1表示not expect error*/
																/*返回-2表示wtp id does not exist，返回-3表示error，返回-4示WTP ID非法*/
																/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = get_wtp_bss_pkt_info_func_group(parameter, connection,0,WtpID,&WtpList_Head);
	if(retu == -6)
	{
		Free_get_wtp_bss_pkt_info_func_group(WtpList_Head);
	}
	return retu;
#else
	int ret = 0,retu;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtp_id = 0;
	//wtp_id = WtpID;


	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
			
	wtp_id = WtpID;
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		syslog(LOG_DEBUG,"wtp id in get_wtp_bss_pkt_info_func is %d\n",wtp_id);
		return -4;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_GET_WTP_BSS_PKT_INFO);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_GET_WTP_BSS_PKT_INFO);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,	
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}		

		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == WID_DBUS_ERROR)
		retu=-1;
	else if(ret == WTP_ID_NOT_EXIST)
		retu=-2;
	else
		retu=-3;
		
	dbus_message_unref(reply);

	return retu;			
#endif	
}

void free_show_wtp_bss_pkt_info(DCLI_WTP_API_GROUP_TWO *INFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_TWO *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun_two");	
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_WTP_METHOD_SHOW_WTP_BSS_PKT_INFO,INFO);
		}
	}
}

/*当retu==1调用释放函数free_show_wtp_bss_pkt_info(DCLI_WTP_API_GROUP_TWO *INFO)*/
int show_wtp_bss_pkt_info_func(dbus_parameter parameter, DBusConnection *connection,int wtp_id,DCLI_WTP_API_GROUP_TWO **INFO)/*返回0表示失败，返回1表示成功，返回-1表示wtp id does not exist，返回-2表示WTP ID非法*/
																																	/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
    if(NULL == connection)
        return 0;
        
	int ret = WID_DBUS_SUCCESS;	
	unsigned int WTPID = 0;	
	unsigned char wlanid[L_RADIO_NUM*L_BSS_NUM];
	memset(wlanid,0,L_RADIO_NUM*L_BSS_NUM);
	int retu = 0;

    WTPID = wtp_id;
	if(WTPID >= WTP_NUM || WTPID == 0){
		syslog(LOG_DEBUG,"wtp id in show_wtp_bss_pkt_info_func is %d\n",WTPID);
		return -2;
	}
	
	void *(*dcli_init_func)(
                        	int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int* ,
                        	unsigned int* ,
                        	unsigned int* ,
                        	unsigned char *,
                        	unsigned char *,
                        	int *,
                        //	DCLI_WTP_API_GROUP_TWO *LIST,	
                        	DBusConnection *,
                        	char *
                        	);

    *INFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_two");
		if(NULL != dcli_init_func && connection)
		{	
			*INFO = (*dcli_init_func)(
			   parameter.instance_id,
			   FOURTH,/*"show wtp bss pkt information"*/
			   WTPID,
			   0,
			   0,
			   &ret,/**/
			   0,/*num2*/
			   0,
			   0,
			   0,
			   &(parameter.local_id),
			//	 INFO,
			   connection,
			   WID_DBUS_WTP_METHOD_SHOW_WTP_BSS_PKT_INFO
			   );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	
	if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else if((ret == 0)&&(*INFO))
		retu = 1;
	else if (ret == WTP_ID_NOT_EXIST)
		retu = -1;

	return retu;
}

void free_show_wtp_eth_pkt_info_info(DCLI_WTP_API_GROUP_TWO *WTPINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_TWO *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun_two");	
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_WTP_METHOD_SHOW_WTP_ETH_PKT_INFO,WTPINFO);
		}
	}
}

/*未使用*/
/*当retu==1调用释放函数free_dcli_wtp_free_fun_two(DCLI_WTP_API_GROUP_TWO *WTPINFO)*/
int show_wtp_eth_pkt_info_func(dbus_parameter parameter, DBusConnection *connection,int wtp_id,DCLI_WTP_API_GROUP_TWO **WTPINFO)/*返回0表示失败，返回1表示成功，返回-1表示wtp id does not exist，返回-2表示WTP ID非法*/
																																	  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
	if(NULL == connection)
        return 0;
        
	int ret = WID_DBUS_SUCCESS;	
	unsigned int WTPID = 0;
	int retu = 0;

	WTPID = wtp_id;
	if(WTPID >= WTP_NUM || WTPID == 0){
		syslog(LOG_DEBUG,"wtp id in show_wtp_eth_pkt_info_func is %d\n",WTPID);
		return -2;
	}

	void *(*dcli_init_func)(
                        	int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int* ,
                        	unsigned int* ,
                        	unsigned int* ,
                        	unsigned char *,
                        	unsigned char *,
                        	int *,
                        //	DCLI_WTP_API_GROUP_TWO *LIST,	
                        	DBusConnection *,
                        	char *
                        	);

    *WTPINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_two");
		if(NULL != dcli_init_func && connection)
		{
			*WTPINFO = (*dcli_init_func)(
					parameter.instance_id,
					FIFTH,/*"show wtp eth pkt information"*/
					WTPID,
					0,
					0,
					&ret,/**/
					0,/*num2*/
					0,
					0,
					0,
					&(parameter.local_id),
				//	WTPINFO,
					connection,
					WID_DBUS_WTP_METHOD_SHOW_WTP_ETH_PKT_INFO
					);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else if((ret == 0)&&(*WTPINFO))
		retu = 1;	
	else if (ret == WTP_ID_NOT_EXIST)
		retu = -1;

	return retu;
}

void free_show_wtp_radio_pkt_info(DCLI_WTP_API_GROUP_TWO *WTPINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_TWO *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun_two");	
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_WTP_METHOD_SHOW_WTP_RADIO_PKT_INFO,WTPINFO);
		}
	}
}

/*当retu==1时，调用free_show_wtp_radio_pkt_info(DCLI_WTP_API_GROUP_TWO *WTPINFO)释放空间*/
int show_wtp_radio_pkt_info_func(dbus_parameter parameter, DBusConnection *connection,int wtp_id,DCLI_WTP_API_GROUP_TWO **WTPINFO)/*返回0表示失败，返回1表示成功，返回-1表示wtp id does not exist，返回-2表示WTP ID非法*/
																																		/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
	if(NULL == connection)
        return 0;
        
	int ret = WID_DBUS_SUCCESS;	
	unsigned int WTPID = 0;
	int retu = 0;

	WTPID = wtp_id;
	if(WTPID >= WTP_NUM || WTPID == 0){
		syslog(LOG_DEBUG,"wtp id in show_wtp_radio_pkt_info_func is %d\n",WTPID);
		return -2;
	}
	
	void *(*dcli_init_func)(
                    		int ,
                    		unsigned int ,
                    		unsigned int ,
                    		unsigned int ,
                    		unsigned int ,
                    		unsigned int* ,
                    		unsigned int* ,
                    		unsigned int* ,
                    		unsigned char *,
                    		unsigned char *,
                    		int *,
                    	//	DCLI_WTP_API_GROUP_TWO *,	
                    		DBusConnection *,
                    		char *
                    		);

    *WTPINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_two");
		if(NULL != dcli_init_func && connection)
		{	
			*WTPINFO = (*dcli_init_func)(
				parameter.instance_id,
				SEVENTH,/*"show wtp radio pkt information"*/
				WTPID,
				0,
				0,
				&ret,/**/
				0,/*num2*/
				0,
				0,
				0,
				&(parameter.local_id),
				//WTPINFO,
				connection,
				WID_DBUS_WTP_METHOD_SHOW_WTP_RADIO_PKT_INFO
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}


	if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else if((ret == 0)&&(*WTPINFO))
		retu = 1;
	else if (ret == WTP_ID_NOT_EXIST)
		retu = -1;

	return retu;
}


void free_show_wtp_wifi_snr(DCLI_WTP_API_GROUP_TWO *WTPINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_TWO *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun_two");	
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_WTP_METHOD_SHOW_WTP_WIFI_SNR_INFO,WTPINFO);
		}
	}
}

/*返回1时，调用free_show_wtp_wifi_snr()释放空间*/
int show_wtp_wifi_snr_func(dbus_parameter parameter, DBusConnection *connection,int wtp_id,DCLI_WTP_API_GROUP_TWO **WTPINFO)   
																								/*返回0表示失败，返回1表示成功*/
																								/*返回-1表示wtp id does not exist*/
																								/*返回-2表示wtp wifi snr report switch is，返回-3示WTP ID非法*/		
																								/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{		
    if(NULL == connection)
        return 0;
        
	int ret = WID_DBUS_SUCCESS;	
	unsigned int WTPID = 0;
	int retu = 0;	

	WTPID = wtp_id;
	if(WTPID >= WTP_NUM || WTPID == 0){
		syslog(LOG_DEBUG,"wtp id in show_wtp_wifi_snr_func is %d\n",WTPID);
		return -3;
	}

	void *(*dcli_init_func)(
                    		int ,
                    		unsigned int ,
                    		unsigned int ,
                    		unsigned int ,
                    		unsigned int ,
                    		unsigned int* ,
                    		unsigned int* ,
                    		unsigned int* ,
                    		unsigned char *,
                    		unsigned char *,
                    		int *,
                    	//	DCLI_WTP_API_GROUP_TWO *LIST,	
                    		DBusConnection *,
                    		char *
                    		);

    *WTPINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_two");
		if(NULL != dcli_init_func && connection)
		{	
			*WTPINFO = (*dcli_init_func)(
				parameter.instance_id,
				SIXTH,/*"show wtp wifi snr info"*/
				WTPID,
				0,
				0,
				&ret,/**/
				0,/*num2*/
				0,
				0,
				0,
				&(parameter.local_id),
			//	WTPINFO,
				connection,
				WID_DBUS_WTP_METHOD_SHOW_WTP_WIFI_SNR_INFO
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}


	if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else if((ret == 0)&&(*WTPINFO))
		retu = 1;
	else if (ret == WTP_ID_NOT_EXIST)
		retu = -1;
	else if (ret == SWITCH_IS_DISABLE)
		retu = -2;

	return retu;
}

#if _GROUP_POLICY
void Free_set_ac_ap_ntp_func_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-8时，调用Free_set_ac_ap_ntp_func_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*type为"start"或"stop"*/
/*value的范围是60-65535*/
int set_ac_ap_ntp_func_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *Type,char *value,struct WtpList **WtpList_Head)
												/*返回0表示失败，返回1表示成功*/
												/*返回-2表示wtp id does not exist，返回-3表示error，返回-4示WTP ID非法*/
												/*返回-5表示input interface only with 'start' or 'stop'，返回-6表示interval should be 60-65535*/
												/*返回-7表示Group ID非法，返回-8表示partial failure，返回-9表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	if((NULL == Type)||(NULL == value))
	{
		*WtpList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	int retu = 0;	
	unsigned int policy = 0;
	unsigned int ntpinterval = 0;

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id < 0){
			syslog(LOG_DEBUG,"wtp id in set_ac_ap_ntp_func_group is %d\n",id);
			return -4;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_ac_ap_ntp_func_group is %d\n",id);
			return -7;
		}
	}

	if (!strcmp(Type,"start"))
	{
		policy = 0;	
	}
	else if (!strcmp(Type,"stop"))
	{
		policy = 1;	
	}
	else
	{
		return -5;
	}
	
	//if (2 == argc) {
		ntpinterval = strtoul((char *)value, NULL, 10);
		/*if (ntpinterval <= 0)
		{
			vty_out(vty,"%% Invalid ntp interval: %s !", argv[1]);
			return CMD_WARNING;
		}*/
		if (ntpinterval < 60 || ntpinterval > 65535)
			{
   				//vty_out(vty,"%% Invalid ntp interval: %s ! interval should be 60-65535!\n", argv[1]);   				
   				return -6;
			}
	//}
	
	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						unsigned int ,
						unsigned int ,
						int *,
						unsigned *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_ac_ap_ntp_cmd_set_ap_ntp");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection,
					  type,
					  id,
					  policy,
					  ntpinterval,
					  &count,
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		/*else if (ret == WTP_NOT_IN_RUN_STATE)
			retu = -1;*/
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -2;
		else
			retu = -3;
	}
	if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL))
			{
				retu = -8;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++)
				{
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;
		
					if(Wtp_Show_Node == NULL)
						break;
							
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}						
				vty_out(vty," failed.\n");*/
			}
		}
	else if (ret == GROUP_ID_NOT_EXIST)
		retu = -9;
	}		
	return retu;		
}
#endif

/*type为"start"或"stop"*/
/*value的范围是60-65535s，默认3600s*/
int set_ac_ap_ntp_func(dbus_parameter parameter, DBusConnection *connection,int WtpId,char *type,char *value)
																			/*返回0表示失败，返回1表示成功*/
																			/*返回-2表示wtp id does not exist，返回-3表示error，返回-4示WTP ID非法*/
																			/*返回-5表示input interface only with 'start' or 'stop'，返回-6表示interval should be 60-65535*/
																			/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if((NULL == type)||(NULL == value))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_ac_ap_ntp_func_group(parameter, connection,0,WtpId,type,value,&WtpList_Head);
	if(retu == -8)
	{
		Free_set_ac_ap_ntp_func_group(WtpList_Head);
	}
	return retu;
#else
	int ret = 0,retu;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtp_id = 0;
	//wtp_id = WtpId;
	unsigned int policy = 0;
	unsigned int ntpinterval = 0;

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
			
	wtp_id = WtpId;

	if (!strcmp(type,"start"))
	{
		policy = 0;	
	}
	else if (!strcmp(type,"stop"))
	{
		policy = 1;	
	}
	else
	{
		return -5;
	}
	
	//if (2 == argc) {
		ntpinterval = strtoul((char *)value, NULL, 10);		
		if (ntpinterval < 60 || ntpinterval > 65535)		
		{
			return -6;
		}
	//}
	
	if(wtp_id >= WTP_NUM || wtp_id < 0){
		syslog(LOG_DEBUG,"wtp id in set_ac_ap_ntp_func is %d\n",wtp_id);
		return -4;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_NTPCLIENT);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_NTPCLIENT);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_UINT32,&ntpinterval,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}

		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	/*else if (ret == WTP_NOT_IN_RUN_STATE)
		retu=-1;*/
	else if(ret == WTP_ID_NOT_EXIST)
		retu=-2;
	else
		retu=-3;
	
	dbus_message_unref(reply);

	return retu;		
#endif	
}

#if _GROUP_POLICY
void Free_set_ap_config_update_func_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-7时，调用Free_set_ap_config_update_func_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_ap_config_update_func_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *IP,struct WtpList **WtpList_Head) 
											/*返回0表示失败，返回1表示成功，返回-1表示unknown ip format*/
											/*返回-2表示wtp is not in run state，返回-3表示wtp id does not exist*/
											/*返回-4表示error，返回-5示WTP ID非法，返回-6表示Group ID非法*/
											/*返回-7表示partial failure，返回-8表示group id does not exist*/
{
	if(NULL == connection)
	    return 0;
	
	if(NULL == IP)
	{
		*WtpList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int ret2 = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	int retu = 0;	
	char *ip = NULL;

	ret2 = WID_Check_IP_Format((char *)IP);
	if(ret2 != WID_DBUS_SUCCESS){
		return -1;
	}
	
	ip = (char *)malloc(strlen(IP)+1);  
	if(ip)
	{
		memset(ip, 0, strlen(IP)+1);
		memcpy(ip, IP, strlen(IP));
	}

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id == 0){
			syslog(LOG_DEBUG,"wtp id in set_ap_config_update_func_group is %d\n",id);
			return -5;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_ap_config_update_func_group is %d\n",id);
			return -6;
		}
	}

	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						char *,
						int *,
						unsigned *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_ap_config_update_cmd_set_ap_config_update_from_ip");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection,
					  type,
					  id,
					  ip,
					  &count,
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if (ret == WTP_NOT_IN_RUN_STATE)
			retu = -2;
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -3;
		else
			retu = -4;
	}
	if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL))
			{
				retu = -7;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++)
				{
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;
		
					if(Wtp_Show_Node == NULL)
						break;
							
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}
						
				vty_out(vty," failed.\n");*/
			}
		}
	else if (ret == GROUP_ID_NOT_EXIST)
		retu = -8;
	}
	FREE_OBJECT(ip);
	return retu;		
}
#endif

int set_ap_config_update_func(dbus_parameter parameter, DBusConnection *connection,int WtpID,char *IP)
																		/*返回0表示error，返回1表示成功，返回-1表示unknown ip format*/
																		/*返回-2表示wtp is not in run state，返回-3表示wtp id does not exist*/
																		/*返回-4表示error，返回-5示WTP ID非法，return 3 表示dbus error*/
																		/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == IP)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_ap_config_update_func_group(parameter, connection,0,WtpID,IP,&WtpList_Head);
	if(retu == -7)
	{
		Free_set_ap_config_update_func_group(WtpList_Head);
	}
	return retu;
#else

	int ret = 0,retu;
	char *ip;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtp_id = 0;
	//wtp_id = WtpID;
	
	
	ret = WID_Check_IP_Format((char *)IP);
	if(ret != WID_DBUS_SUCCESS){
		return -1;
	}
	
	ip = (char *)malloc(strlen(IP)+1);  
	if(ip)
	{
		memset(ip, 0, strlen(IP)+1);
		memcpy(ip, IP, strlen(IP));
	}
	
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
		
	wtp_id = WtpID;
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		syslog(LOG_DEBUG,"wtp id in set_ap_config_update_func is %d\n",wtp_id);
		return -5;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_UPDATE_WTP_CONFIG);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_UPDATE_WTP_CONFIG);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_STRING,&ip,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		FREE_OBJECT(ip);
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if (ret == WTP_NOT_IN_RUN_STATE)
		retu=-2;
	else if(ret == WTP_ID_NOT_EXIST)
		retu=-3;
	else
		retu=-4;
		
	dbus_message_unref(reply);
	FREE_OBJECT(ip);

	return retu;		
#endif	
}

void free_show_wtp_extension_information_v4(DCLI_WTP_API_GROUP_TWO *WTPINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_TWO *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun_two");	
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_CONF_METHOD_AP_SHOW_WTP_EXTENSION_INFOMATION_V4,WTPINFO);
		}
	}
}
/*reut = 1 调用释放函数free_show_wtp_extension_information_v4(DCLI_WTP_API_GROUP_TWO *WTPINFO)*/
int show_wtp_extension_information_v4_func(dbus_parameter parameter, DBusConnection *connection,int wtp_id,DCLI_WTP_API_GROUP_TWO **WTPINFO)/*返回0表示失败，返回1表示成功，返回-1表示wtp id does not exist，返回-2表示wtp extension info report switch disable，返回-3示WTP ID非法*/
																																					 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
	
	unsigned int WTPID = 0;
	int ret = WID_DBUS_SUCCESS;
	int retu = 0;

	WTPID = wtp_id;
	if(WTPID >= WTP_NUM || WTPID == 0){
		syslog(LOG_DEBUG,"wtp id in show_wtp_extension_information_v4_func is %d\n",WTPID);
		return -3;
	}
	
	void *(*dcli_init_func)(
                        	int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int* ,
                        	unsigned int* ,
                        	unsigned int* ,
                        	unsigned char *,
                        	unsigned char *,
                        	int *,
                        //	DCLI_WTP_API_GROUP_TWO *,	
                        	DBusConnection *,
                        	char *
                        	);

    *WTPINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_two");
		if(NULL != dcli_init_func && connection)
		{	
			*WTPINFO = (*dcli_init_func)(
				parameter.instance_id,
				EIGHTH,/*"show wtp cmt extension information v4"*/
				WTPID,
				0,
				0,
				&ret,/**/
				0,/*num2*/
				0,
				0,
				0,
				&(parameter.local_id),
			//	WTPINFO,
				connection,
				WID_DBUS_CONF_METHOD_AP_SHOW_WTP_EXTENSION_INFOMATION_V4
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else if((ret == 0)&&(*WTPINFO))
		retu  = 1;
	else if (ret == WTP_ID_NOT_EXIST)
		retu = -1;
	else if (ret == SWITCH_IS_DISABLE)
		retu = -2;

	return retu;
}

void free_show_ap_wids_set_cmd(DCLI_WTP_API_GROUP_THREE *WTPINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_THREE *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun_three");	
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_WTP_METHOD_SHOW_WTP_WIDS_SET ,WTPINFO);
		}
	}
}

/*retu==1调用释放函数 free_show_ap_wids_set_cmd(DCLI_WTP_API_GROUP_THREE *WTPINFO)*/
int show_ap_wids_set_cmd_func(dbus_parameter parameter, DBusConnection *connection,DCLI_WTP_API_GROUP_THREE **WTPINFO)/*返回0表示失败，返回1表示成功，返回-1表示error*/
																															  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	unsigned int WTPID = 0;
	int ret = WID_DBUS_SUCCESS;
	int retu;

	void *(*dcli_init_func)(
					int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int* ,
					unsigned int* ,
					unsigned int* ,
					unsigned char *,
					unsigned char *,
					int *,
					DBusConnection *,
					char *
					);

    *WTPINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_three");
		if(NULL != dcli_init_func && connection)
		{		
			*WTPINFO = (*dcli_init_func)(
				parameter.instance_id,
				SIXTH,/*"show ap wids"*/
				WTPID,
				0,
				0,
				&ret,/**/
				0,/*num2*/
				0,
				0,
				0,
				&(parameter.local_id),
				connection,
				WID_DBUS_WTP_METHOD_SHOW_WTP_WIDS_SET
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if((ret == 0)&&(*WTPINFO))
	{
		retu = 1;
	}
	else
	{
		retu = -1;
	}
	return retu;

}


int set_ap_wids_set_cmd_func(dbus_parameter parameter, DBusConnection *connection,char *type1,char *type2,char *type3,char *state) /*返回0表示失败，返回1表示成功，返回-1表示input parameter error，返回-2表示error*/
																																		 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if((NULL == type1)||(NULL == type2)||(NULL == type3)||(NULL == state))
		return 0;
	
	int ret = 0;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
 	unsigned char flooding = 2;
	unsigned char sproof = 2;
	unsigned char weakiv = 2;
	unsigned int wtp_id = 0;
	int para_num=1,retu;
	
	if(strcmp(type1,""))     
		para_num+=1;
	if(strcmp(type2,""))     
		para_num+=1;
	if(strcmp(type3,""))     
		para_num+=1;
	
	if(para_num == 1)
	{
		if(!strncmp(state,"enable",strlen(state)))
		{
			flooding = 1;
			sproof = 1;
			weakiv = 1;
			
		}
		else if(!strncmp(state,"disable",strlen(state)))
		{
			flooding = 0;
			sproof = 0;
			weakiv = 0;
		}
		else
		{
			return -1;
		}
	}
	else if(para_num == 2)
	{
		if(!strncmp(type1,"flooding",strlen(type1)))
		{
			if(!strncmp(state,"enable",strlen(state)))
			{
				flooding = 1;			
			}
			else if(!strncmp(state,"disable",strlen(state)))
			{
				flooding = 0;
			}
			else
			{
				return -1;
			}
			
		}
		else if(!strncmp(type1,"spoofing",strlen(type1)))
		{
			if(!strncmp(state,"enable",strlen(state)))
			{
				sproof= 1;			
			}
			else if(!strncmp(state,"disable",strlen(state)))
			{
				sproof= 0;
			}
			else
			{
				return -1;
			}
			
		}
		else if(!strncmp(type1,"weakiv",strlen(type1)))
		{
			if(!strncmp(state,"enable",strlen(state)))
			{
				weakiv = 1;			
			}
			else if(!strncmp(state,"disable",strlen(state)))
			{
				weakiv= 0;
			}
			else
			{
				return -1;
			}
			
		}
		else
		{
			return -1;
		}

		
	}
	else if(para_num == 3)
	{
		if(!strncmp(type1,"flooding",strlen(type1)))
		{
			if(!strncmp(state,"enable",strlen(state)))
			{
				flooding = 1;			
			}
			else if(!strncmp(state,"disable",strlen(state)))
			{
				flooding= 0;
			}
			else
			{
				return -1;
			}

			
		}
		else if(!strncmp(type1,"spoofing",strlen(type1)))
		{
			if(!strncmp(state,"enable",strlen(state)))
			{
				sproof= 1;			
			}
			else if(!strncmp(state,"disable",strlen(state)))
			{
				sproof= 0;
			}
			else
			{
				return -1;
			}

			
		}
		else if(!strncmp(type1,"weakiv",strlen(type1)))
		{
			if(!strncmp(state,"enable",strlen(state)))
			{
				weakiv= 1;			
			}
			else if(!strncmp(state,"disable",strlen(state)))
			{
				weakiv= 0;
			}
			else
			{
				return -1;
			}

			
		}
		else
		{
			return -1;
		}

		if(!strncmp(type2,"flooding",strlen(type2)))
		{
			if(!strncmp(state,"enable",strlen(state)))
			{
				flooding = 1;			
			}
			else if(!strncmp(state,"disable",strlen(state)))
			{
				flooding= 0;
			}
			else
			{
				return -1;
			}

			
		}
		else if(!strncmp(type2,"spoofing",strlen(type2)))
		{
			if(!strncmp(state,"enable",strlen(state)))
			{
				sproof= 1;			
			}
			else if(!strncmp(state,"disable",strlen(state)))
			{
				sproof= 0;
			}
			else
			{
				return -1;
			}

			
		}
		else if(!strncmp(type2,"weakiv",strlen(type2)))
		{
			if(!strncmp(state,"enable",strlen(state)))
			{
				weakiv= 1;			
			}
			else if(!strncmp(state,"disable",strlen(state)))
			{
				weakiv= 0;
			}
			else
			{
				return -1;
			}

			
		}

		else
		{
			return -1;
		}

	}
	else if(para_num == 4)
	{
		if(!strncmp(type1,"flooding",strlen(type1)))
		{
			if(!strncmp(state,"enable",strlen(state)))
			{
				flooding = 1;			
			}
			else if(!strncmp(state,"disable",strlen(state)))
			{
				flooding= 0;
			}
			else
			{
				return -1;
			}

			
		}
		else if(!strncmp(type1,"spoofing",strlen(type1)))
		{
			if(!strncmp(state,"enable",strlen(state)))
			{
				sproof= 1;			
			}
			else if(!strncmp(state,"disable",strlen(state)))
			{
				sproof= 0;
			}
			else
			{
				return -1;
			}

			
		}
		else if(!strncmp(type1,"weakiv",strlen(type1)))
		{
			if(!strncmp(state,"enable",strlen(state)))
			{
				weakiv= 1;			
			}
			else if(!strncmp(state,"disable",strlen(state)))
			{
				weakiv= 0;
			}
			else
			{
				return -1;
			}

			
		}

		else
		{
			return -1;
		}

		if(!strncmp(type2,"flooding",strlen(type2)))
		{
			if(!strncmp(state,"enable",strlen(state)))
			{
				flooding = 1;			
			}
			else if(!strncmp(state,"disable",strlen(state)))
			{
				flooding= 0;
			}
			else
			{
				return -1;
			}

			
		}
		else if(!strncmp(type2,"spoofing",strlen(type2)))
		{
			if(!strncmp(state,"enable",strlen(state)))
			{
				sproof= 1;			
			}
			else if(!strncmp(state,"disable",strlen(state)))
			{
				sproof= 0;
			}
			else
			{
				return -1;
			}

			
		}
		else if(!strncmp(type2,"weakiv",strlen(type2)))
		{
			if(!strncmp(state,"enable",strlen(state)))
			{
				weakiv= 1;			
			}
			else if(!strncmp(state,"disable",strlen(state)))
			{
				weakiv= 0;
			}
			else
			{
				return -1;
			}

			
		}
		else
		{
			return -1;
		}

		
		if(!strncmp(type3,"flooding",strlen(type3)))
		{
			if(!strncmp(state,"enable",strlen(state)))
			{
				flooding = 1;			
			}
			else if(!strncmp(state,"disable",strlen(state)))
			{
				flooding= 0;
			}
			else
			{
				return -1;
			}

			
		}
		else if(!strncmp(type3,"spoofing",strlen(type3)))
		{
			if(!strncmp(state,"enable",strlen(state)))
			{
				sproof= 1;			
			}
			else if(!strncmp(state,"disable",strlen(state)))
			{
				sproof= 0;
			}
			else
			{
				return -1;
			}

			
		}
		else if(!strncmp(type3,"weakiv",strlen(type3)))
		{
			if(!strncmp(state,"enable",strlen(state)))
			{
				weakiv= 1;			
			}
			else if(!strncmp(state,"disable",strlen(state)))
			{
				weakiv= 0;
			}
			else
			{
				return -1;
			}

			
		}
		else
		{
			return -1;
		}


	}


	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_WIDS_SET);


	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE, WID_DBUS_WTP_METHOD_SET_WTP_WIDS_SET);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,	
							 DBUS_TYPE_BYTE,&flooding,
							 DBUS_TYPE_BYTE,&sproof,
							 DBUS_TYPE_BYTE,&weakiv,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		

		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else
		retu=-2;
		
	dbus_message_unref(reply);

	
	return retu;			
}

void free_show_wtp_max_power_base_model(DCLI_WTP_API_GROUP_THREE *WTPINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_THREE *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun_three");	
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_CONF_METHOD_AP_SHOW_WTP_MAX_POWER,WTPINFO);
		}
	}
}

/*未使用*/
/*retu = 1 时，调用free_show_wtp_max_power_base_model()释放空间*/
int show_wtp_max_power_base_model_func(dbus_parameter parameter, DBusConnection *connection,int WtpID,DCLI_WTP_API_GROUP_THREE **WTPINFO)
																								/*返回0表示失败，返回1表示成功*/
																							    /*返回-1表示wtp id does not exist*/
																							    /*返回-2表示wtp model is wrong，返回-3示WTP ID非法*/
																								/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
	if(NULL == connection)
        return 0;
        
	unsigned int WTPID = 0;
	int ret = WID_DBUS_SUCCESS;

	int retu = 0;

	WTPID = WtpID;
	if(WTPID >= WTP_NUM || WTPID == 0){
		syslog(LOG_DEBUG,"wtp id in show_wtp_max_power_base_model_func is %d\n",WTPID);
		return -3;
	}
	
	void *(*dcli_init_func)(
                        	int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int* ,
                        	unsigned int* ,
                        	unsigned int* ,
                        	unsigned char *,
                        	unsigned char *,
                        	int *,
                        //	DCLI_WTP_API_GROUP_THREE *,	
                        	DBusConnection *,
                        	char *
                        	);

    *WTPINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_three");
		if(NULL != dcli_init_func && connection)
		{
			*WTPINFO = (*dcli_init_func)(
				parameter.instance_id,
				SEVENTH,/*"show wtp max power"*/
				WTPID,
				0,
				0,
				&ret,/**/
				0,/*num2*/
				0,
				0,
				0,
				&(parameter.local_id),
			//	WTPINFO,
				connection,
				WID_DBUS_CONF_METHOD_AP_SHOW_WTP_MAX_POWER
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else if((ret == 0)&&(*WTPINFO))
		retu = 1;
	else if (ret == WTP_ID_NOT_EXIST)
		retu = -1;
	else if (ret == MODEL_NO_EXIST)
		retu = -2;

	return retu;
}

#if _GROUP_POLICY
void Free_set_ap_reboot_func_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-6时，调用Free_set_ap_reboot_func_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_ap_reboot_func_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,struct WtpList **WtpList_Head)
												/*返回0表示失败，返回1表示成功，返回-1表示wtp is not in run state*/
												/*返回-2表示wtp id does not exist，返回-3表示error，返回-4示WTP ID非法*/
												/*返回-5表示Group ID非法，返回-6表示partial failure，返回-7表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;	
	int retu = 0;

	/*if(vty->node == WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (unsigned)vty->index_sub;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (unsigned)vty->index_sub;
		type = 1;
	}*/
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id == 0){
			syslog(LOG_DEBUG,"wtp id in set_ap_reboot_func_group is %d\n",id);
			return -4;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_ap_reboot_func_group is %d\n",id);
			return -5;
		}
	}

	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						int *,
						unsigned *
						);
    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_ap_reboot_cmd_set_ap_reboot");
		if(NULL != dcli_init_func)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection,
					  type,
					  id,
					  &count,
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if (ret == WTP_NOT_IN_RUN_STATE)
			retu = -1;
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -2;
		else
			retu = -3;
	}
	if(type==1)
	{
		if(ret == 0){
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL)){
				retu = -6;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}
				
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -7;
	}	
	
	return retu;		
}
#endif

int set_ap_reboot_func(dbus_parameter parameter, DBusConnection *connection,int WtpID)
													 /*返回0表示失败，返回1表示成功，返回-1表示wtp is not in run state*/
													 /*返回-2表示wtp id does not exist，返回-3表示error，返回-4示WTP ID非法*/
													 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_ap_reboot_func_group(parameter, connection,0,WtpID,&WtpList_Head);
	if(retu == -6)
	{
		Free_set_ap_reboot_func_group(WtpList_Head);
	}
	return retu;
#else

	int ret = 0,retu;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtp_id = 0;
	//wtp_id = WtpID;

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
		
	wtp_id = WtpID;
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		syslog(LOG_DEBUG,"wtp id in set_ap_reboot_func is %d\n",wtp_id);
		return -4;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id, WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id, WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id, WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}		

		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if (ret == WTP_NOT_IN_RUN_STATE)
		retu=-1;
	else if(ret == WTP_ID_NOT_EXIST)
		retu=-2;
	else
		retu=-3;
		
	dbus_message_unref(reply);

	return retu;		
#endif	
}

/*未使用*/
int set_ap_reboot_all_func(dbus_parameter parameter, DBusConnection *connection)/*返回0表示失败，返回1表示成功，返回-1表示error*/
																					/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret = 0,retu;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT_ALL);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT_ALL);*/
	
	dbus_error_init(&err);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}	

		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else
		retu=-1;
		
	dbus_message_unref(reply);

	return retu;		
}

int set_ap_reboot_by_wlanid_func(dbus_parameter parameter, DBusConnection *connection,char *WLAN_ID)
																	 /*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
																	 /*返回-2表示wlan id should be 1 to WLAN_NUM-1*/
																	 /*返回-3表示wlan id does not exist，返回-4表示error*/
																	 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == WLAN_ID)
		return 0;
	
	int ret = 0,retu;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wlanid = 0;
	ret = parse_int_ID((char*)WLAN_ID, &wlanid);
	if(ret != WID_DBUS_SUCCESS){
			return -1;
	}	
	if(wlanid >= WLAN_NUM || wlanid == 0){
		return -2;
	}
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT_BY_WLANID);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT_BY_WLANID);*/

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wlanid,
							 DBUS_TYPE_INVALID);
	
	dbus_error_init(&err);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}	

		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == WLAN_ID_NOT_EXIST)
		retu=-3;
	else
		retu=-4;

		
	dbus_message_unref(reply);

	return retu;		
}

/*未使用*/
int set_ap_reboot_by_interface_func(dbus_parameter parameter, DBusConnection *connection,char *IF_Name)
																		/*返回0表示失败，返回1表示成功*/
																		/*返回-1表示the length of input parameter is excel the limit of 16*/
																		/*返回-2表示interface error，返回-3表示error*/
																		/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == IF_Name)
		return 0;
		
	int ret = 0,retu;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

	char *ifname;
	int insize = 0;

	insize = strlen(IF_Name);
	if(insize > 16)
	{
		return -1;	
	}
	
	ifname = (char*)malloc(strlen(IF_Name)+1);
	if(NULL == ifname)
        return 0;
	memset(ifname, 0, strlen(IF_Name)+1);
	memcpy(ifname, IF_Name, strlen(IF_Name));	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT_BY_INTERFACE);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT_BY_INTERFACE);*/

	dbus_message_append_args(query,
							 DBUS_TYPE_STRING,&ifname,
							 DBUS_TYPE_INVALID);
	
	dbus_error_init(&err);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	if(ifname)
	{
		free(ifname);
		ifname = NULL;
	}

	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}		

		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == APPLY_IF_FAIL)
		retu=-2;
	else
		retu=-3;
		
	dbus_message_unref(reply);

	return retu;		
}


int set_ap_reboot_by_model_func(dbus_parameter parameter, DBusConnection *connection,char *AP_Model)
																	  /*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
																	  /*返回-2表示model is not exist，返回-3表示error*/
																	  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == AP_Model)
		return 0;
	
	int ret = 0,retu;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned char* model;
	
	model=AP_Model;
	
	if(strlen(model) > 80)
	{
		return -1;
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT_BY_MODEL);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT_BY_MODEL);*/

	dbus_message_append_args(query,
							 DBUS_TYPE_STRING,&model,
							 DBUS_TYPE_INVALID);
	
	dbus_error_init(&err);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}	

		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == MODEL_NO_EXIST)
		retu=-2;
	else
		retu=-3;
	
	dbus_message_unref(reply);

	return retu;		
}

/*未使用*/
int set_ap_reboot_by_list_func(dbus_parameter parameter, DBusConnection *connection,char *ap_list)
																 /*返回0表示失败，返回1表示成功*/
																 /*返回-1表示input wtp id is too long,you should input less than 80 letters*/
																 /*返回-2表示parse wtp list failed，返回-3表示error*/
																 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == ap_list)
		return 0;
	
	int ret = 0,retu;
	int i = 0;
	int n = 0, num = 0;
	int len;
	int list[DEFAULT_LEN];
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

	len = strlen(ap_list);
	if(len > 80)
	{
		return -1;
	}
	/*get wtp id list*/
	ret = dcli_wtp_parse_wtp_list((char*)ap_list,&n,list);
	if(ret != 0){
	    return -2;
	} 

	/*parse if there is repeat wtpid*/
	num = dcli_wtp_remove_list_repeat(list,n);
	
	dbus_error_init(&err);

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT_BY_LIST);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT_BY_LIST);*/

	
	dbus_message_iter_init_append (query, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&num);
			
	for(i = 0; i < num; i++)
	{			
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&list[i]);		
	}

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}	

		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else
		retu=-3;
		
	dbus_message_unref(reply);

	return retu;		
}



/*state为(join|configure|datacheck|run|quit|imagedata|bak_run)*/
/*返回1时，调用Free_wtp_list_new_head()释放空间*/
int show_wtp_list_by_state_func(dbus_parameter parameter, DBusConnection *connection,DCLI_WTP_API_GROUP_ONE **WTPINFO)
																						  /*返回0表示失败，返回1表示成功，返回2表示no wtp exist*/
																						  /*返回-1表示input patameter should only be join|configure|datacheck|run|quit|imagedata|bak_run*/
																						  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	int ret;
	int retu = 0;
/*
	unsigned char inputstate = 0;

	//parameter check start
	if (!strcmp(STATE,"join"))
	{
		inputstate = 2;	
	}		
	else if (!strcmp(STATE,"configure"))
	{
		inputstate = 3;
	}
	else if (!strcmp(STATE,"datacheck"))
	{
		inputstate = 4;
	}
	else if (!strcmp(STATE,"run"))
	{
		inputstate = 5;
	}
	else if (!strcmp(STATE,"quit"))
	{
		inputstate = 7;
	}	
	else if (!strcmp(STATE,"imagedata"))
	{
		inputstate = 8;
	}
	else if (!strcmp(STATE,"bak_run"))
	{
		inputstate = 9;
	}		
	else
	{
		return -1;
	}
	
*/	

	void*(*dcli_init_func)(
					int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int* ,
					unsigned int* ,
					unsigned int* ,
					unsigned char *,
					unsigned char *,
					int *,
					DBusConnection *,
					char *
					);

    *WTPINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_one");
		if(NULL != dcli_init_func && connection)
		{
			*WTPINFO =(*dcli_init_func)
				  (
					   parameter.instance_id,
					   SECOND,/*"show wtp list by state (join|configure|datacheck|run|quit|imagedata|bak_run)"*/
					   0,
					   0,
					   0,
					   0,/**/
					   &ret,/*num2*/
					   0,
					   0,
					   0,
					   &(parameter.local_id),
					   connection,
					   WID_DBUS_CONF_METHOD_WTPLIST_NEW
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if((ret == 0)&&(*WTPINFO))
	{
		retu = 1;
	}
	else if(ret == 5)
	{
		retu = 2;
	}

	return retu;	
}

/*返回1时，调用Free_wtp_list_new_head()释放空间*/
int show_wtp_list_by_ip_func(dbus_parameter parameter, DBusConnection *connection,char *IP,char *MASK,DCLI_WTP_API_GROUP_ONE **WTPINFO)
																					/*返回0表示失败，返回1表示成功，返回2表示no wtp exist*/
																				    /*返回-1表示unknown ip format*/
																				    /*返回-2表示unknown mask format*/
																				    /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	if((NULL == IP)||(NULL == MASK))
	{
		*WTPINFO = NULL;
		return 0;
	}
	
	int ret,ret1;
	int retu = 0;
	unsigned long ipaddr = 0;
	unsigned long mask = 0;

	//parameter check start
	
	ret = WID_Check_IP_Format((char*)IP);
	if(ret != WID_DBUS_SUCCESS){
		return -1;
	}
	
	ipaddr = dcli_ip2ulong((char*)IP);

	ret1 = WID_Check_Mask_Format((char*)MASK);
	if(ret1 != WID_DBUS_SUCCESS){
		return -2;
	}
	
	mask = dcli_ip2ulong((char*)MASK);
	
	//parameter check end

	
	//WTP = malloc(WTP_NUM*(sizeof(WID_WTP *)));

	void*(*dcli_init_func)(
					int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int* ,
					unsigned int* ,
					unsigned int* ,
					unsigned char *,
					unsigned char *,
					int *,
					DBusConnection *,
					char *
					);

    *WTPINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_one");
		if(NULL != dcli_init_func && connection)
		{
			*WTPINFO =(*dcli_init_func)
				  (
					   parameter.instance_id,
					   SECOND,/*"show wtp list by ip IP mask MASk"*/
					   0,
					   0,
					   0,
					   0,/**/
					   &ret,/*num2*/
					   0,
					   0,
					   0,
					   &(parameter.local_id),
					   connection,
					   WID_DBUS_CONF_METHOD_WTPLIST_NEW
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if((ret == 0)&&(*WTPINFO))
	{
		retu = 1;
	}
	else if(ret == 5)
	{
		retu = 2;
	}

	return retu;	
}


/*返回1时，调用Free_wtp_list_new_head()释放空间*/
int show_wtp_list_by_macex_func(dbus_parameter parameter, DBusConnection *connection,char *MAC,char *MASK,DCLI_WTP_API_GROUP_ONE **WTPINFO)
																							 /*返回0表示失败，返回1表示成功，返回2表示no wtp exist*/
																						     /*返回-1表示Unknown mac addr format*/
																						     /*返回-2表示Unknown macmask addr format*/
																							 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if((NULL == MAC)||(NULL == MASK))
	{
		*WTPINFO = NULL;
		return 0;
	}
	
	int ret;
	int retu = 0;	
	WIDMACADDR  macaddr;
	WIDMACADDR  macmask;

	//parameter check start

	ret = wid_parse_mac_addr((char *)MAC,&macaddr);
	if (CMD_FAILURE == ret) {
		return -1;
	}
	
	ret = wid_parse_mac_addr((char *)MASK,&macmask);
	if (CMD_FAILURE == ret) {
		return -2;
	}


	void*(*dcli_init_func)(
					int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int* ,
					unsigned int* ,
					unsigned int* ,
					unsigned char *,
					unsigned char *,
					int *,
					DBusConnection *,
					char *
					);
					
    *WTPINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_one");
		if(NULL != dcli_init_func && connection)
		{
			*WTPINFO =(*dcli_init_func)
				  (
					   parameter.instance_id,
					   SECOND,/*"show wtp list by mac MAC mask MASk"*/
					   0,
					   0,
					   0,
					   0,/**/
					   &ret,/*num2*/
					   0,
					   0,
					   0,
					   &(parameter.local_id),
					   connection,
					   WID_DBUS_CONF_METHOD_WTPLIST_NEW
				   );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if((ret == 0)&&(*WTPINFO))
	{
		retu = 1;
	}
	else if(ret == 5)
	{
		retu = 2;
	}

	return retu;
}

void Free_wtp_model_list_head(DCLI_WTP_API_GROUP_ONE *WTPINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_ONE *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_CONF_METHOD_WTPLIST_NEW,WTPINFO);
		}
	}
}

/*未使用*/
/*返回1时，调用Free_wtp_model_list_head()释放空间*/
int show_wtp_model_list_cmd(dbus_parameter parameter, DBusConnection *connection,DCLI_WTP_API_GROUP_ONE **WTPINFO)/*返回0表示失败，返回1表示成功，返回-1表示no wtp exist*/
																														/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret;
	int retu = 0;
	
	void*(*dcli_init_func)(
					int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int* ,
					unsigned int* ,
					unsigned int* ,
					unsigned char *,
					unsigned char *,
					int *,
					DBusConnection *,
					char *
					);

    *WTPINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_one");
		if(NULL != dcli_init_func)
		{
			*WTPINFO =(*dcli_init_func)
				  (
					parameter.instance_id,
					SECOND,/*"show wtp model list"*/
					0,
					0,
					0,
					0,/**/
					&ret,/*num2*/
					0,
					0,
					0,
					&(parameter.local_id),
					connection,
					WID_DBUS_CONF_METHOD_WTPLIST_NEW
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if((ret == 0)&&(*WTPINFO))
	{
		retu = 1;
	}
	else if(ret == 5)
	{
		retu = -1;
	}

	return retu;
}


int wtp_set_ap_update_config_cmd_func(dbus_parameter parameter, DBusConnection *connection,char *path,char *count,char *model,char *version)
																									   /*返回0表示失败，返回1表示成功*/
																									   /*返回-1表示set update failed due to system cann't find file*/
																									   /*返回-2表示set update failed due to file version error*/
																									   /*返回-3表示wireless-control does not surport model MODEL*/
																									   /*返回-4表示update is process,please wait several minutes*/
																									   /*返回-5表示error*/
																									   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if((NULL == path)||(NULL == count)||(NULL == model)||(NULL == version))
		return 0;
	
	int ret,retu;
	DBusMessage *query, *reply;	
	DBusMessageIter  iter;
	DBusError err;
	char *buf_model;
	char *buf_version;
	char *buf_path;
	int fd;

	unsigned char count_onetime;
	
	buf_model = model;	
	str2higher(&buf_model);

	buf_version = version;
	
	buf_path = (char*)malloc(strlen(path)+1);
	if(buf_path)
	{
		memset(buf_path, 0, strlen(path)+1);
		memcpy(buf_path, path, strlen(path));	
	}

	
	char syscmd[WID_SYSTEM_CMD_LENTH];
	memset(syscmd,0,WID_SYSTEM_CMD_LENTH);
	sprintf(syscmd,"/mnt/wtp/%s",buf_path);

	fd = open(syscmd, O_RDONLY);
	if(fd < 0)
	{
		FREE_OBJECT(buf_path);
		return -1;
	}
	else 
	{
		close(fd);
	}	

	if(buf_path)
	{
		if(strstr(buf_path,buf_version) == NULL)
		{
			FREE_OBJECT(buf_path);
			return -2;
		}
	}

	count_onetime = atoi(count);
	
	dbus_error_init(&err);

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_UPDATE_PATH);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_UPDATE_PATH);*/
	
	dbus_message_append_args(query,
						DBUS_TYPE_STRING,&buf_model,
						DBUS_TYPE_STRING,&buf_version,
						DBUS_TYPE_STRING,&buf_path,
						DBUS_TYPE_BYTE,&count_onetime,
						DBUS_TYPE_INVALID);
	
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);

	dbus_message_unref(query);

	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		FREE_OBJECT(buf_path);
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == WID_NO_SURPORT_MODEL)
		retu=-3;
	else if(ret == UPDATE_PROCESS)
		retu=-4;
	else
		retu=-5;
	
	dbus_message_unref(reply);	
	
	FREE_OBJECT(buf_path);
	
	return retu; 

}

void free_wtp_show_ap_update_config(DCLI_WTP_API_GROUP_THREE *WTPINFO)
{
	void (*dcli_init_free_func)(DCLI_WTP_API_GROUP_THREE *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_ap_update_config_fun");	
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WTPINFO);
		}
	}
}

/*返回1时，调用free_wtp_show_ap_update_config()释放空间*/
int wtp_show_ap_update_config_func(dbus_parameter parameter, DBusConnection *connection,DCLI_WTP_API_GROUP_THREE **WTPINFO)
																							  /*返回0表示失败，返回1表示成功*/
																							  /*返回-1表示no update config information*/
																							  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret=0,retu;

	void *(*dcli_init_func)(
                        	int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int* ,
                        	unsigned int* ,
                        	unsigned int* ,
                        	unsigned char *,
                        	unsigned char *,
                        	int *,
                        //	DCLI_WTP_API_GROUP_THREE *,	
                        	DBusConnection *,
                        	char *
                        	);

    *WTPINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_three");
		if(NULL != dcli_init_func && connection)
		{
			*WTPINFO = (*dcli_init_func)(
				parameter.instance_id,
				EIGHTH,/*"show update config"*/
				0,
				0,
				0,
				&ret,/**/
				0,/*num2*/
				0,
				0,
				0,
				&(parameter.local_id),
			//	WTPINFO,
				connection,
				WID_DBUS_CONF_METHOD_SHOW_UPDATE_CONFIG
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else if((ret == 0)&&(*WTPINFO))
		retu = 1;
	else
		retu = -1;

	return retu;

}

int wtp_clear_ap_update_config_func(dbus_parameter parameter, DBusConnection *connection)/*返回0表示失败，返回1表示成功，返回-1表示no update config information*/
																								/*返回-2表示upgrade is in process,changement of configuration is not allowed now*/
																								/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	int ret=0,retu;

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_CLEAR_UPDATE_CONFIG);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_CLEAR_UPDATE_CONFIG);*/

	
	dbus_error_init(&err);	
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err)) 
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}

	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0 )
		retu=1;
	else if(ret == UPDATE_PROCESS)
		retu=-2;
	else
		retu=-1;

	dbus_message_unref(reply);	

	return retu;

}
void Free_show_update_wtp_list(DCLI_WTP_API_GROUP_ONE *WTPINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_ONE *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun");	
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_CONF_METHOD_WTPLIST_UPDATE,WTPINFO);
		}
	}
}

/*返回1时，调用Free_show_update_wtp_list()释放空间*/
int show_update_wtp_list_func(dbus_parameter parameter, DBusConnection *connection,DCLI_WTP_API_GROUP_ONE **WTPINFO)/*返回0表示失败，返回1表示成功，返回-1表示update wtp does not exist*/
																														 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret;
	int retu = 0;

	void *(*dcli_init_func)(
					int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int* ,
					unsigned int* ,
					unsigned int* ,
					unsigned char *,
					unsigned char *,
					int *,
					DBusConnection *,
					char *
					);

    *WTPINFO = NULL;	
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_one");
		if(NULL != dcli_init_func && connection)
		{
			*WTPINFO = (*dcli_init_func)
				(
					parameter.instance_id,
					SECOND,/*"show wtp (list|all)"*/
					0,
					0,
					0,
					0,/**/
					&ret,/*num2*/
					0,
					0,
					0,
					&(parameter.local_id),
					connection,
					WID_DBUS_CONF_METHOD_WTPLIST_UPDATE
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1){
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if((ret == 0)&&(*WTPINFO))
	{
		retu = 1;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -1;
	}

	return retu;	
}

int uplink_detect_cmd_func(dbus_parameter parameter, DBusConnection *connection,char *ip,char *WlanID,char *State)
																				  /*返回0表示失败，返回1表示成功*/
																				  /*返回-1表示unknown ip format*/
																				  /*返回-2表示unknown id format*/
																				  /*返回-3表示wlan id should be 1 to WLAN_NUM-1*/
				                                                                  /*返回-4表示wlan no exist*/
																				  /*返回-5表示illegal input:Input exceeds the maximum value of the parameter type*/
																				  /*返回-6表示unknown format,just be enable or disable*/
																				  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if((NULL == ip)||(NULL == WlanID)||(NULL == State))
		return 0;
	
	int ret;
	FILE *fp;
	unsigned char state = 0;
	int retu;
	
	ret = WID_Check_IP_Format((char*)ip);
	if(ret != WID_DBUS_SUCCESS){
		return -1;
	}
	char * addr = (char*)malloc(strlen(ip)+1);
	if(addr)
	{
		memset(addr, 0, strlen(ip)+1);
		memcpy(addr, ip, strlen(ip));
	}

	if(!strcmp(State,"enable"))
	{
		state = 1;
	}else if(!strcmp(State,"disable")){
		state = 0;
	}else{
		return -6;
	}

	unsigned char wlan_id = 0;

	ret = parse_char_ID((char*)WlanID, &wlan_id);
	
	if(ret != WID_DBUS_SUCCESS){
		if(ret == WID_ILLEGAL_INPUT){
			retu = -5;
		}
		else{
			retu = -2;
		}
		if(addr){
			free(addr);
			addr = NULL;
		}
		return retu;
	}	
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		if(addr){
			free(addr);
			addr = NULL;
		}
		return -3;
	}


	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_CHECK_WLANID);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_CHECK_WLANID);*/
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&wlan_id,
							 DBUS_TYPE_STRING,&addr,
							 DBUS_TYPE_BYTE,&state,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}	
		
		if(addr){
			free(addr);
			addr = NULL;
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == -1)
	{
		if(addr){
			free(addr);
			addr = NULL;
		}
		return -4;
	}


	char cmd[WTP_COMMAND_LEN];
	memset(cmd,0,WTP_COMMAND_LEN);

	char cmd1[WTP_COMMAND_LEN];
	memset(cmd1,0,WTP_COMMAND_LEN);

	sprintf(cmd1,"sudo chmod 777 /var/run/uplink_detect");

	//int status = 1;
	if(!strcmp(State,"disable"))
	{
		sprintf(cmd,"echo 0 > /var/run/uplink_detect");
	}
	else
	{
		fp = fopen("/var/run/uplink_detect","w");

		if(fp != NULL)
		{    
			fchmod(fp,777);
			fclose(fp);
		}		
		
		if(index == 0){
			sprintf(cmd,"sudo uplink_detect.sh %s %s &",ip,WlanID);
		}else{
			sprintf(cmd,"sudo uplink_detect.sh %s %s %d &",ip,WlanID,index);
		}
	}

	
	system(cmd1);

	system(cmd);
	if(addr != NULL){
		free(addr);
		addr = NULL;
	}
	dbus_message_unref(reply);	
	return 1;
}

void free_show_wtp_model_code_version(DCLI_WTP_API_GROUP_ONE *WTPINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_ONE *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun");	
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_WTP_METHOD_SHOW_WTP_MODEL_CODE_VERSION,WTPINFO);
		}
	}
}

/*未使用*/
/*返回1时，调用free_show_wtp_model_code_version()释放空间*/
int show_wtp_model_code_version_cmd_func(dbus_parameter parameter, DBusConnection *connection,int WtpID,DCLI_WTP_API_GROUP_ONE **WTPINFO)
																												/*返回0表示失败，返回1表示成功*/
																									  		 	/*返回-1表示wtp id does not exist*/
																									  		 	/*返回-2表示error，返回-3示WTP ID非法*/
																												/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
    if(NULL == connection)
        return 0;
        
	unsigned int wtp_id = 0;
	int ret,retu;
	
	wtp_id = WtpID;
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		syslog(LOG_DEBUG,"wtp id in show_wtp_model_code_version_cmd_func is %d\n",wtp_id);
		return -3;
	}

	void *(*dcli_init_func)(
					int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int ,
					unsigned int* ,
					unsigned int* ,
					unsigned int* ,
					unsigned char *,
					unsigned char *,
					int *,
					DBusConnection *,
					char *
					);

    *WTPINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_one");
		if(NULL != dcli_init_func && connection)
		{
			*WTPINFO = (*dcli_init_func)(
			   parameter.instance_id,
			   EIGHTH,/*"show wtp version"*/
			   wtp_id,
			   0,
			   0,
			   0,/**/
			   &ret,/*num2*/
			   0,
			   0,
			   0,
			   &(parameter.local_id),
			   connection,
			   WID_DBUS_WTP_METHOD_SHOW_WTP_MODEL_CODE_VERSION
			   );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else if((ret == 0)&&(*WTPINFO))
		retu = 1;
	else if(ret == WTP_ID_NOT_EXIST)
		retu = -1;
	else 
		retu = -2;

	return retu;
}

#if _GROUP_POLICY
void Free_update_wtp_img_cmd_func_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-6时，调用Free_update_wtp_img_cmd_func_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*time为"now"或"later"*/
int update_wtp_img_cmd_func_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *filename,char *version,char *time,struct WtpList **WtpList_Head)
																			/*返回0表示失败，返回1表示成功*/
																			/*返回-1表示set update failed due to system cann't find file*/
																			/*返回-2表示set update failed due to file version error*/
																			/*返回-3表示error，返回-4示WTP ID非法*/
																			/*返回-5表示Group ID非法，返回-6表示partial failure*/
																			/*返回-7表示group id does not exist*/
{	
    if(NULL == connection)
        return 0;
        
	if((NULL == filename)||(NULL == version)||(NULL == time))
	{
		*WtpList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	int retu = 0;	

	char *buf_version;
	char *buf_path;
	int fd;
	unsigned char commandmode;

	buf_path = (char*)malloc(strlen(filename)+1);
	if(buf_path)
	{
		memset(buf_path, 0, strlen(filename)+1);
		memcpy(buf_path, filename, strlen(filename));	
	}
	
	buf_version = (char*)malloc(strlen(version)+1);
	if(buf_version)
	{
		memset(buf_version, 0, strlen(version)+1);
		memcpy(buf_version, version, strlen(version));	
	}

	if (!strcmp(time,"now"))
	{
		commandmode = 1;	
	}
	else
	{
		commandmode = 0;	
	}
	
	char syscmd[WID_SYSTEM_CMD_LENTH];
	memset(syscmd,0,WID_SYSTEM_CMD_LENTH);
	if(buf_path)
	{
		sprintf(syscmd,"/mnt/wtp/%s",buf_path);
	}

	fd = open(syscmd, O_RDONLY);
	if(fd < 0)
	{
		FREE_OBJECT(buf_path);
		FREE_OBJECT(buf_version);
		return -1;
	}
	else 
	{
		close(fd);
	}	

	if((buf_path)&&(buf_version))
	{
		if(strstr(buf_path,buf_version) == NULL)
		{
			FREE_OBJECT(buf_path);
			FREE_OBJECT(buf_version);
			return -2;
		}
	}
	

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id == 0){
			syslog(LOG_DEBUG,"wtp id in update_wtp_img_cmd_func_group is %d\n",id);
			return -4;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in update_wtp_img_cmd_func_group is %d\n",id);
			return -5;
		}
	}

	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						char *,
						char *,
						unsigned char ,
						int *,
						unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"update_wtp_img_cmd_update_ap_img_file_version");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection,
					  type,
					  id,
					  buf_version,
					  buf_path,
					  commandmode,
					  &count,
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else
			retu = -3;
	
		FREE_OBJECT(buf_path);
		FREE_OBJECT(buf_version);
	}
	if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL))
			{
				retu = -6;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++)
				{
					if(Wtp_Show_Node == NULL)
					Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
					Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
					break;
				
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}
			
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -7;
	}
	return retu;
}
#endif

/*time为"now"或"later"*/
int update_wtp_img_cmd_func(dbus_parameter parameter, DBusConnection *connection,int WtpID,char *filename,char *version,char *time)
																									 /*返回0表示失败，返回1表示成功*/
																									 /*返回-1表示set update failed due to system cann't find file*/
																									 /*返回-2表示set update failed due to file version error*/
																									 /*返回-3表示error，返回-4示WTP ID非法*/
																									 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
    if(NULL == connection)
        return 0;
	
	if((NULL == filename)||(NULL == version)||(NULL == time))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = update_wtp_img_cmd_func_group(parameter, connection,0,WtpID,filename,version,time,&WtpList_Head);
	if(retu == -6)
	{
		Free_update_wtp_img_cmd_func_group(WtpList_Head);
	}
	return retu;
#else
	int ret,retu;
	DBusMessage *query, *reply;	
	DBusMessageIter  iter;
	DBusError err;
	char *buf_version;
	char *buf_path;
	int fd;
	unsigned char commandmode;
	unsigned int wtp_id = 0;
	//wtp_id = WtpID;
	
	buf_path = (char*)malloc(strlen(filename)+1);
	if(buf_path)
	{
		memset(buf_path, 0, strlen(filename)+1);
		memcpy(buf_path, filename, strlen(filename));	
	}
	
	buf_version = (char*)malloc(strlen(version)+1);
	if(buf_version)
	{
		memset(buf_version, 0, strlen(version)+1);
		memcpy(buf_version, version, strlen(version));	
	}

	if (!strcmp(time,"now"))
	{
		commandmode = 1;	
	}
	else
	{
		commandmode = 0;	
	}

	
	char syscmd[WID_SYSTEM_CMD_LENTH];
	memset(syscmd,0,WID_SYSTEM_CMD_LENTH);
	if(buf_path)
	{
		sprintf(syscmd,"/mnt/wtp/%s",buf_path);
	}

	fd = open(syscmd, O_RDONLY);
	if(fd < 0)
	{
		FREE_OBJECT(buf_path);
		FREE_OBJECT(buf_version);
		return -1;
	}
	else 
	{
		close(fd);
	}	

	if((buf_path)&&(buf_version))
	{
		if(strstr(buf_path,buf_version) == NULL)
		{		
			FREE_OBJECT(buf_path);
			FREE_OBJECT(buf_version);
			return -2;
		}
	}
	
	dbus_error_init(&err);

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
		
	wtp_id = WtpID;
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		syslog(LOG_DEBUG,"wtp id in update_wtp_img_cmd_func is %d\n",wtp_id);
		return -4;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_UPDATE_WTP_IMG);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_UPDATE_WTP_IMG);*/

	dbus_message_append_args(query,
							DBUS_TYPE_UINT32,&wtp_id,
							DBUS_TYPE_STRING,&buf_version,
							DBUS_TYPE_STRING,&buf_path,
							DBUS_TYPE_BYTE,&commandmode,
							DBUS_TYPE_INVALID);
		
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);

	dbus_message_unref(query);

	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		FREE_OBJECT(buf_path);
		FREE_OBJECT(buf_version);
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else
		retu=-3;

	
	dbus_message_unref(reply);	

	FREE_OBJECT(buf_path);
	FREE_OBJECT(buf_version);
	return retu; 
#endif
}

#if _GROUP_POLICY
void Free_clear_wtp_img_cmd_func_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-4时，调用Free_clear_wtp_img_cmd_func_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int clear_wtp_img_cmd_func_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,struct WtpList **WtpList_Head)
								/*返回0表示失败，返回1表示成功，返回-1表示error，返回-2表示WTP ID非法*/
								/*返回-3表示Group ID非法，返回-4表示partial failure，返回-5表示group id does not exist*/
{	    
    if(NULL == connection)
            return 0;

	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	int retu = 0;	

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id == 0){
			syslog(LOG_DEBUG,"wtp id in clear_wtp_img_cmd_func_group is %d\n",id);
			return -2;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in clear_wtp_img_cmd_func_group is %d\n",id);
			return -3;
		}
	}

	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						int *,
						unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"clear_wtp_img_cmd_clear_ap_img_info");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection,
					  type,
					  id,
					  &count,
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else
			retu = -1;
	}

	if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL))
			{
				retu = -4;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++)
				{
					if(Wtp_Show_Node == NULL)
					Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
					Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
					break;
				
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}			
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -5;
	}
	return retu;
}
#endif

int clear_wtp_img_cmd_func(dbus_parameter parameter, DBusConnection *connection,int WtpID)/*返回0表示失败，返回1表示成功，返回-1表示error，返回-2表示WTP ID非法*/
																								/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
    
    if(NULL == connection)
        return 0;
        
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = clear_wtp_img_cmd_func_group(parameter, connection,0,WtpID,&WtpList_Head);
	if(retu == -4)
	{
		Free_clear_wtp_img_cmd_func_group(WtpList_Head);
	}
	return retu;
#else
	int ret,retu;
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;

	unsigned int wtp_id = 0;
	//wtp_id = WtpID;
	
	dbus_error_init(&err);

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
		
	wtp_id = WtpID;
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		syslog(LOG_DEBUG,"wtp id in clear_wtp_img_cmd_func is %d\n",wtp_id);
		return -2;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_CLEAR_UPDATE_WTP_IMG);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_CLEAR_UPDATE_WTP_IMG);*/
	
	dbus_message_append_args(query,
							DBUS_TYPE_UINT32,&wtp_id,
							DBUS_TYPE_INVALID);

		
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);

	dbus_message_unref(query);

	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else
		retu=-1;

	
	dbus_message_unref(reply);	

	return retu; 
#endif	
}

#if _GROUP_POLICY
void Free_set_ap_networkaddr_command_cmd_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-9时，调用Free_set_ap_networkaddr_command_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_ap_networkaddr_command_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *ap_ip,char *ap_mask,char *ap_gateway,char *ap_dns1,char *ap_dns2,struct WtpList **WtpList_Head)
														/*返回0表示失败，返回1表示成功，返回-1表示unknown ip format*/
														/*返回-2表示unknown mask format，返回-3表示unknown gateway format*/
														/*返回-4表示unknown dns format，返回-5表示wtp id does not exist*/
														/*返回-6表示error，返回-7示WTP ID非法，返回-8表示Group ID非法*/
														/*返回-9表示partial failure，返回-10表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
	
	if((NULL == ap_ip)||(NULL == ap_mask)||(NULL == ap_gateway)||(NULL == ap_dns1)||(NULL == ap_dns2))
	{
		*WtpList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int ret1 = 0;
	int ret2 = 0;	
    unsigned int ip;
	unsigned int mask;
	unsigned int gateway;
	unsigned int fstdns;
	unsigned int snddns;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	int retu = 0;	
	
	ret1 = WID_Check_IP_Format((char*)ap_ip);
	if(ret1 != WID_DBUS_SUCCESS){
		return -1;
	}
	ip = dcli_ip2ulong((char*)ap_ip);


	ret1 = WID_Check_Mask_Format((char*)ap_mask);
	if(ret1 != WID_DBUS_SUCCESS){
		return -2;
	}
	mask = dcli_ip2ulong((char*)ap_mask);

	ret2 = WID_Check_IP_Format((char*)ap_gateway);
	if(ret2 != WID_DBUS_SUCCESS){
		return -3;
	}
	gateway = dcli_ip2ulong((char*)ap_gateway);

	ret2 = WID_Check_IP_Format((char*)ap_dns1);
	if(ret2 != WID_DBUS_SUCCESS){
		return -4;
	}
	fstdns = dcli_ip2ulong((char*)ap_dns1);

	ret2 = WID_Check_IP_Format((char*)ap_dns2);
	if(ret2 != WID_DBUS_SUCCESS){
		return -4;
	}
	snddns = dcli_ip2ulong((char*)ap_dns2);	
	
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id == 0){
			syslog(LOG_DEBUG,"wtp id in set_ap_networkaddr_command_cmd_group is %d\n",id);
			return -7;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_ap_networkaddr_command_cmd_group is %d\n",id);
			return -8;
		}
	}

	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						unsigned int ,
						unsigned int ,
						unsigned int ,
						unsigned int ,
						unsigned int ,
						int *,
						unsigned int *
						);
						
    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_ap_networkaddr_command_cmd_set_ap_network_address_mask_gateway_fstdns_snddns");
		if(NULL != dcli_init_func && connection)
		{
			
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection,
					  type,
					  id,
					  ip,
					  mask,
					  gateway,
					  fstdns,
					  snddns,
					  &count,
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -5;
		else
			retu = -6;
	}

	if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL))
			{
				retu = -9;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++)
				{
					if(Wtp_Show_Node == NULL)
					Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
					Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
					break;
				
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}			
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -10;
	}
	return retu;		
}
#endif

int set_ap_networkaddr_command_cmd(dbus_parameter parameter, DBusConnection *connection,int WtpID,char *ap_ip,char *ap_mask,char *ap_gateway,char *ap_dns1,char *ap_dns2)
														/*返回0表示失败，返回1表示成功，返回-1表示unknown ip format*/
														/*返回-2表示unknown mask format，返回-3表示unknown gateway format*/
														/*返回-4表示unknown dns format，返回-5表示wtp id does not exist*/
														/*返回-6表示error，返回-7示WTP ID非法*/
														/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if((NULL == ap_ip)||(NULL == ap_mask)||(NULL == ap_gateway)||(NULL == ap_dns1)||(NULL == ap_dns2))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_ap_networkaddr_command_cmd_group(parameter, connection,0,WtpID,ap_ip,ap_mask,ap_gateway,ap_dns1,ap_dns2,&WtpList_Head);
	if(retu == -9)
	{
		Free_set_ap_networkaddr_command_cmd_group(WtpList_Head);
	}
	return retu;
#else
	int ret,ret2;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
    unsigned int ip;
	unsigned int mask;
	unsigned int gateway;
	unsigned int fstdns;
	unsigned int snddns;	
	unsigned int wtp_id = 0;
	int retu;
	
	//wtp_id = (unsigned int)WtpID;
	
	ret = WID_Check_IP_Format((char*)ap_ip);
	if(ret != WID_DBUS_SUCCESS){
		return -1;
	}
	ip = dcli_ip2ulong((char*)ap_ip);


	ret = WID_Check_Mask_Format((char*)ap_mask);
	if(ret != WID_DBUS_SUCCESS){
		return -2;
	}

	mask = dcli_ip2ulong((char*)ap_mask);



	ret2 = WID_Check_IP_Format((char*)ap_gateway);
	if(ret2 != WID_DBUS_SUCCESS){
		return -3;
	}
	gateway = dcli_ip2ulong((char*)ap_gateway);

	ret2 = WID_Check_IP_Format((char*)ap_dns1);
	if(ret2 != WID_DBUS_SUCCESS){
		return -4;
	}
	fstdns = dcli_ip2ulong((char*)ap_dns1);

	ret2 = WID_Check_IP_Format((char*)ap_dns2);
	if(ret2 != WID_DBUS_SUCCESS){
		return -4;
	}
	snddns = dcli_ip2ulong((char*)ap_dns2);	
	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	
	wtp_id = (unsigned int)WtpID;
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		syslog(LOG_DEBUG,"wtp id in set_ap_networkaddr_command_cmd is %d\n",wtp_id);
		return -7;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_AP_IP_GATEWAY_DNS);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_AP_IP_GATEWAY_DNS);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_UINT32,&ip,
							 DBUS_TYPE_UINT32,&mask,
							 DBUS_TYPE_UINT32,&gateway,
							 DBUS_TYPE_UINT32,&fstdns,
							 DBUS_TYPE_UINT32,&snddns,							 
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		retu = 1;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -5;
	}
	else
	{
		retu = -6;
	}
		
	dbus_message_unref(reply);

	
	return retu;			
#endif	
}

void free_show_old_ap_img_data(DCLI_WTP_API_GROUP_THREE *WTPINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_THREE *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun_three");	
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_CONF_METHOD_SHOW_OLD_AP_IMG,WTPINFO);
		}
	}
}
/*retu = 1 调用释放函数free_show_old_ap_img_data(DCLI_WTP_API_GROUP_THREE *WTPINFO)*/
int show_old_ap_img_data_cmd(dbus_parameter parameter, DBusConnection *connection,DCLI_WTP_API_GROUP_THREE **WTPINFO )/*返回0表示失败，返回1表示成功*/
																															  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret = 0;
	int retu = 0;
	
	void *(*dcli_init_func)(
                        	int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int* ,
                        	unsigned int* ,
                        	unsigned int* ,
                        	unsigned char *,
                        	unsigned char *,
                        	int *,
                        //	DCLI_WTP_API_GROUP_THREE *,	
                        	DBusConnection *,
                        	char *
                        	);

    *WTPINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_three");
		if(NULL != dcli_init_func && connection)
		{
			*WTPINFO = (*dcli_init_func)(
                            			parameter.instance_id,
                            			NINTH,/*"show old_ap_img_data config"*/
                            			0,
                            			1,
                            			0,
                            			&ret,/**/
                            			0,/*num2*/
                            			0,
                            			0,
                            			0,
                            			&(parameter.local_id),
                            		//	WTPINFO,
                            			connection,
                            			WID_DBUS_CONF_METHOD_SHOW_OLD_AP_IMG
                            			);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
    if(-1 ==ret) {
        retu = SNMPD_CONNECTION_ERROR;
    }
	else if(*WTPINFO){
		retu = 1;
	}
	return retu;

}

/*state为"open"或"close"*/
int old_ap_img_data_cmd(dbus_parameter parameter, DBusConnection *connection,char *state)/*返回0表示失败，返回1表示成功*/
																							  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == state)
		return 0;
	
	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	int ret;
	int stat;
	if (!strcmp(state,"open"))
	{
		stat = 1;
	}
	else{
		stat = 0;
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_OLD_AP_IMG);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_OLD_AP_IMG);*/
	dbus_error_init(&err);
	
	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&stat,
							 DBUS_TYPE_INVALID);
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);	
	dbus_message_unref(query);
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	
	/*if(ret == 0)
	{
		vty_out(vty,"old_ap_img_data %s\n",state);
	}*/
	dbus_message_unref(reply);		
	return 1;

}

/*未使用*/
int set_update_img_file_name(dbus_parameter parameter, DBusConnection *connection,char *fpath,char *fversion,char *ftime,char *plist)
																					/*返回0表示失败，返回1表示成功，返回-1表示set update failed due to system cann't find file*/
																					/*返回-2表示set update failed due to file version error，返回-3表示set wtp list error，返回-4表示error*/
																					/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
    if(NULL == connection)
        return 0;
	
	if((NULL == fpath)||(NULL == fversion)||(NULL == ftime)||(NULL == plist))
		return 0;
	
	int ret,retu;
	DBusMessage *query, *reply;	
	DBusMessageIter  iter;
	DBusError err;
	char *buf_version;
	char *buf_path;
	int fd;
	unsigned char commandmode;
	unsigned int i = 0;
	update_wtp_list *wtplist;
	struct tag_wtpid *tmp = NULL;
	unsigned int num;	
	
	buf_path = (char*)malloc(strlen(fpath)+1);
	if(buf_path)
	{
		memset(buf_path, 0, strlen(fpath)+1);
		memcpy(buf_path, fpath, strlen(fpath)); 
	}
	
	buf_version = (char*)malloc(strlen(fversion)+1);
	if(buf_version)
	{
		memset(buf_version, 0, strlen(fversion)+1);
		memcpy(buf_version, fversion, strlen(fversion));	
	}

	if (!strcmp(ftime,"now"))
	{
		commandmode = 1;	
	}
	else
	{
		commandmode = 0;	
	}
	
	char syscmd[WID_SYSTEM_CMD_LENTH];
	memset(syscmd,0,WID_SYSTEM_CMD_LENTH);
	if(buf_path)
	{
		sprintf(syscmd,"/mnt/wtp/%s",buf_path);
	}

	fd = open(syscmd, O_RDONLY);
	if(fd < 0)
	{
		FREE_OBJECT(buf_path);
		FREE_OBJECT(buf_version);

		return -1;
	}
	else 
	{
		close(fd);
	}	

	if((buf_path)&&(buf_version))
	{
		if(strstr(buf_path,buf_version) == NULL)
		{
			FREE_OBJECT(buf_path);
			FREE_OBJECT(buf_version);
		
			return -2;
		}	
	}

	wtplist = (struct tag_wtpid_list*)malloc(sizeof(struct tag_wtpid_list));
	if(NULL == wtplist)
	{
		if(fd >= 0)
			close(fd);
		return 0;
	}
	wtplist->wtpidlist = NULL ;		
	wtplist->count = 0;
	ret = parse_wtpid_list((char*)plist,&wtplist);
	if(ret != 0)
	{
		FREE_OBJECT(buf_path);
		FREE_OBJECT(buf_version);
		destroy_input_wtp_list(wtplist);

		return -3;
	}
	else
	{
		delsame(wtplist);
		
		/*
		phead = wtplist->wtpidlist;
		
		while(phead != NULL)
		{	
			
			pnext = phead->next;
			vty_out(vty, "wtpid:%d\n",phead->wtpid);
			phead = pnext;

		}
		*/		
	}
	
	dbus_error_init(&err);	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_UPDATE_WTP_IMG_LIST);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_UPDATE_WTP_IMG_LIST);*/


	num = wtplist->count;
	dbus_message_iter_init_append (query, &iter);
			
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_STRING,
										 &buf_version);

	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_STRING,
										 &buf_path);

	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &commandmode);

		// Total slot count
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
	tmp = wtplist->wtpidlist;
	for(i = 0; i < num; i++){
		
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &(tmp->wtpid));
		tmp = tmp->next;

	}	
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);

	dbus_message_unref(query);

	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		FREE_OBJECT(buf_path);
		FREE_OBJECT(buf_version);
		destroy_input_wtp_list(wtplist);

		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else
		retu=-4;
	
	dbus_message_unref(reply);	

	FREE_OBJECT(buf_path);
	FREE_OBJECT(buf_version);
	destroy_input_wtp_list(wtplist);
	return retu; 

}

/*未使用*/
int clear_ap_img_info(dbus_parameter parameter, DBusConnection *connection,char *iflist)/*返回0表示失败，返回1表示成功，返回-1表示set wtp list error，返回-2表示error*/
																							/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
    if(NULL == connection)
        return 0;
	
	if(NULL == iflist)
		return 0;
	
	int ret,retu;
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;
	int i;
	update_wtp_list *wtplist;
	struct tag_wtpid *tmp = NULL;
	unsigned int num;	

	wtplist = (struct tag_wtpid_list*)malloc(sizeof(struct tag_wtpid_list));
	if(NULL == wtplist)
	{
		return 0;
	}
	wtplist->wtpidlist = NULL ;		
	wtplist->count = 0;
	
	if (!strcmp(iflist,"all"))
	{
		num = 0;
		ret = 0;
	}
	else
	{
		ret = parse_wtpid_list((char*)iflist,&wtplist);
	}
	
	if(ret != 0)
	{
		destroy_input_wtp_list(wtplist);

		return -1;
	}
	else
	{
		delsame(wtplist);
	}

	
	dbus_error_init(&err);
	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_CLEAR_UPDATE_WTP_IMG_LIST);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_CLEAR_UPDATE_WTP_IMG_LIST);*/


	num = wtplist->count;
	dbus_message_iter_init_append (query, &iter);
			
		// Total slot count
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
	tmp = wtplist->wtpidlist;
	for(i = 0; i < num; i++){
		
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &(tmp->wtpid));
		tmp = tmp->next;

	}	
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);

	dbus_message_unref(query);

	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		destroy_input_wtp_list(wtplist);
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else
		retu=-2;
	
	dbus_message_unref(reply);	

	destroy_input_wtp_list(wtplist);

	return retu;

}


void free_show_ac_access_wtp_info(DCLI_WTP_API_GROUP_ONE *WTPINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_ONE *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun");	
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_CONF_METHOD_AC_ACCESS_WTPLIST,WTPINFO);
		}
	}
}

/*未使用*/
/*返回1时，调用free_show_ac_access_wtp_info()释放空间*/
int show_ac_access_wtp_info_cmd(dbus_parameter parameter, DBusConnection *connection,DCLI_WTP_API_GROUP_ONE **WTPINFO)/*返回0表示失败，返回1表示成功*/
																															   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret;	
	int retu = 0;


	void *(*dcli_init_func)(
                        	int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int* ,
                        	unsigned int* ,
                        	unsigned int* ,
                        	unsigned char *,
                        	unsigned char *,
                        	int *,
                        	//DCLI_WTP_API_GROUP_ONE *,	
                        	DBusConnection *,
                        	char *
                        	);

    *WTPINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_one");
		if(NULL != dcli_init_func && connection)
		{	
			*WTPINFO = (*dcli_init_func)(
			   parameter.instance_id,
			   SEVENTH,/*"show ac-access-wtp-info list"*/
			   0,
			   0,
			   0,
			   0,/**/
			   &ret,/*num2*/
			   0,
			   0,
			   0,
			   &(parameter.local_id),
			//	 WTPINFO,
			   connection,
			   WID_DBUS_CONF_METHOD_AC_ACCESS_WTPLIST
			   );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	

	if(ret == -1){
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if((ret == 0)&&(*WTPINFO)){
		retu = 1;
	}
	return retu;
	
}


void free_show_update_fail_wtp_list(DCLI_WTP_API_GROUP_ONE *WTPINFO){
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_ONE *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun");	
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_CONF_METHOD_WTPLIST_UPDATE_FAIL_LIST,WTPINFO);
		}
	}
}

/*未使用*/
/*返回1时，调用free_show_update_fail_wtp_list()释放空间*/
int show_update_fail_wtp_list(dbus_parameter parameter, DBusConnection *connection,DCLI_WTP_API_GROUP_ONE **WTPINFO)/*返回0表示失败，返回1表示成功*/
																														/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret,retu = 0;

	void *(*dcli_init_func)(
                        	int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int ,
                        	unsigned int* ,
                        	unsigned int* ,
                        	unsigned int* ,
                        	unsigned char *,
                        	unsigned char *,
                        	int *,
                        	//DCLI_WTP_API_GROUP_ONE *,	
                        	DBusConnection *,
                        	char *
                        	);

    *WTPINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_one");
		if(NULL != dcli_init_func && connection)
		{
			*WTPINFO = (*dcli_init_func)(
			   parameter.instance_id,
			   SIXTH,/*"show update fail wtp (list|all)"*/
			   0,
			   0,
			   0,
			   0,/**/
			   &ret,/*num2*/
			   0,
			   0,
			   0,
			   &(parameter.local_id),
			 //  WTPINFO,
			   connection,
			   WID_DBUS_CONF_METHOD_WTPLIST_UPDATE_FAIL_LIST
			   );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	if(ret == -1){
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if((ret == 0)&&(*WTPINFO)){
		retu = 1;
	}
	return retu;
	
}

/*未使用*/
int clear_update_fail_wtp(dbus_parameter parameter, DBusConnection *connection,char *iflist)/*返回0表示失败，返回1表示成功，返回-1表示set wtp list error，返回-2表示error*/
																							  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
    if(NULL == connection)
        return 0;
	
	if(NULL == iflist)
		return 0;
	
	int ret,retu;
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;
	int i;
	update_wtp_list *wtplist;
	struct tag_wtpid *tmp = NULL;
	unsigned int num;	

	wtplist = (struct tag_wtpid_list*)malloc(sizeof(struct tag_wtpid_list));
	if(NULL == wtplist)
	{
		return 0;
	}
	wtplist->wtpidlist = NULL ;		
	wtplist->count = 0;
	
	if (!strcmp(iflist,"all"))
	{
		num = 0;
		ret = 0;
	}
	else
	{
		ret = parse_wtpid_list((char*)iflist,&wtplist);
	}
	
	if(ret != 0)
	{
		destroy_input_wtp_list(wtplist);

		return -1;
	}
	else
	{
		delsame(wtplist);
	}

	
	dbus_error_init(&err);

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_CLEAR_UPDATE_FAIL_WTP_LIST);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_CLEAR_UPDATE_FAIL_WTP_LIST);*/


	num = wtplist->count;
	dbus_message_iter_init_append (query, &iter);
			
		// Total slot count
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
	tmp = wtplist->wtpidlist;
	for(i = 0; i < num; i++){
		
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &(tmp->wtpid));
		tmp = tmp->next;

	}	
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);

	dbus_message_unref(query);

	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		destroy_input_wtp_list(wtplist);
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else
		retu=-2;
	
	dbus_message_unref(reply);	

	destroy_input_wtp_list(wtplist);
	return retu; 

}

#if _GROUP_POLICY
void Free_set_wtp_sn_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-6时，调用Free_set_wtp_sn_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_wtp_sn_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *wtpsn,struct WtpList **WtpList_Head)
								/*返回0表示失败，返回1表示成功，返回-1表示wtp sn is too long,should be 1 to 127*/
								/*返回-2表示wtp id does not exist，返回-3表示wtp be running，返回-4示WTP ID非法*/
								/*返回-5表示Group ID非法，返回-6表示partial failure，返回-7表示group id does not exist*/
{	
    if(NULL == connection)
        return 0;
        
	if(NULL == wtpsn)
	{
		*WtpList_Head = NULL;
		return 0;
	}
		
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	int retu = 0;	

	char *name = NULL;
	int len = 0;

	len = strlen(wtpsn);
	
	if(len > 128){		
		return -1;
	}
	name = (char*)malloc(strlen(wtpsn)+1);
	if(NULL == name)
	{
		return 0;
	}
	memset(name, 0, strlen(wtpsn)+1);
	memcpy(name, wtpsn, strlen(wtpsn));
	
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id == 0){
			syslog(LOG_DEBUG,"wtp id in set_wtp_sn_group is %d\n",id);
			return -4;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_wtp_sn_group is %d\n",id);
			return -5;
		}
	}

	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						char *,
						int *,
						unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_wtp_sn_cmd_set_wtp_sn_SN");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection,
					  type,
					  id,
					  name,
					  &count,
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type == 0)
	{
		if(ret == 0)
			retu = 1;
		else if (ret == WTP_ID_NOT_EXIST)
			retu = -2;
		else
			retu = -3;
		FREE_OBJECT(name);
	}
	if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL))
			{
				retu = -6;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++)
				{
					if(Wtp_Show_Node == NULL)
					Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
					Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
					break;
				
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}
			
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -7;
	}
	return retu;
}
#endif

/*未使用*/
int set_wtp_sn(dbus_parameter parameter, DBusConnection *connection,int id,char *wtpsn)
													 /*返回0表示失败，返回1表示成功，返回-1表示wtp sn is too long,should be 1 to 127*/
												     /*返回-2表示wtp id does not exist，返回-3表示wtp be running，返回-4示WTP ID非法*/
													 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
    if(NULL == connection)
        return 0;
	
	if(NULL == wtpsn)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_wtp_sn_group(parameter, connection,0,id,wtpsn,&WtpList_Head);
	if(retu == -6)
	{
		Free_set_wtp_sn_group(WtpList_Head);
	}
	return retu;
#else	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID = 0;
	int ret = WID_DBUS_SUCCESS,retu;
	char *name = NULL;
	int len = 0;
	//WTPID = (unsigned int)id;

	len = strlen(wtpsn);
	
	if(len >= 128){		
		return -1;
	}
	name = (char*)malloc(strlen(wtpsn)+1);
	if(NULL == name)
	{
		return 0;
	}
	memset(name, 0, strlen(wtpsn)+1);
	memcpy(name, wtpsn, strlen(wtpsn));
	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	
	WTPID = (unsigned int)id;
	if(WTPID >= WTP_NUM || WTPID == 0){
		syslog(LOG_DEBUG,"wtp id in set_wtp_sn is %d\n",WTPID);
		return -4;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTPSN);
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTPSN);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_STRING,&name,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		if(name)
		{
			free(name);
			name = NULL;
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
		
	dbus_message_unref(reply);
	if(ret == 0)
	{		
		retu=1;
	}
	else if (ret == WTP_ID_NOT_EXIST)
		retu=-2;
	else {
		retu=-3;
	}
	FREE_OBJECT(name);
	return retu;
#endif	
}

/*未使用*/
int clean_acaccess_wtpinfo_list(dbus_parameter parameter, DBusConnection *connection)/*返回0表示失败，返回1表示成功*/
																						 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	int ret;

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_CLEAN_AC_ACCESS_WTPLIST);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_CLEAN_AC_ACCESS_WTPLIST);*/
	dbus_error_init(&err);
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);	
	dbus_message_unref(query);
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	
	if(ret == 0)
	{
		//vty_out(vty,"clean ac-access-wtp-info list successfully\n");
	}

	dbus_message_unref(reply);	
	return 1;

}

/*未使用*/
/*state为"enable"或"disable"*/
/*wtp_list为"all"或like 1,8,9-20,33*/
int set_wtp_list_dhcp_snooping_enable_cmd(dbus_parameter parameter, DBusConnection *connection,char *state,char *wtp_list)
																							  /*返回0表示失败，返回1表示成功*/
																							  /*返回-1表示input patameter only with 'enable' or 'disable'*/
																							  /*返回-2表示set wtp list error,like 1,8,9-20,33*/
																							  /*返回-3表示error*/
																							  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
    if(NULL == connection)
        return 0;
	
	if((NULL == state)||(NULL == wtp_list))
		return 0;
	
	int ret;
	update_wtp_list *wtplist;
    int policy = 0;
	int retu;
	
	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -1;
	}

	wtplist = (struct tag_wtpid_list*)malloc(sizeof(struct tag_wtpid_list));
	if(NULL == wtplist)
	{
		return 0;
	}
	wtplist->wtpidlist = NULL ; 	
	wtplist->count = 0;
	
	if (!strcmp(wtp_list,"all"))
	{
		;	
	}else{
		ret = parse_wtpid_list((char*)wtp_list,&wtplist);
		if(ret != 0)
		{
			destroy_input_wtp_list(wtplist);
			return -2;
		}
		else
		{
			delsame(wtplist);		
		}
	}


	int(*dcli_init_func)(
							int ,
							int ,
							int ,
							struct tag_wtpid_list *,
							DBusConnection *
						);

	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_list_set_dhcp_snooping");
		if(NULL != dcli_init_func && connection)
		{
			ret =(*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 policy,
					 wtplist,
					 connection
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else if(ret == 0)
		retu = 1;
	else
		retu = -3;
	
	return retu; 
}

#if _GROUP_POLICY
void Free_set_wtp_dhcp_snooping_enable_cmd_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-5时，调用Free_set_wtp_dhcp_snooping_enable_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*state为"enable"或"disable"*/
int set_wtp_dhcp_snooping_enable_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *state,struct WtpList **WtpList_Head)
																	/*返回0表示失败，返回1表示成功*/
																	/*返回-1表示input patameter only with 'enable' or 'disable'*/
																	/*返回-2表示error，返回-3示WTP ID非法*/
																	/*返回-4表示Group ID非法，返回-5表示partial failure*/
																	/*返回-6表示group id does not exist*/
{	
    if(NULL == connection)
        return 0;
        
	if(NULL == state)
	{
		*WtpList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int policy = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	int retu = 0;	
	
	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -1;
	}

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id < 0){
			syslog(LOG_DEBUG,"wtp id in set_wtp_dhcp_snooping_enable_cmd_group is %d\n",id);
			return -3;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_wtp_dhcp_snooping_enable_cmd_group is %d\n",id);
			return -4;
		}
	}

	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						unsigned int ,
						int *,
						unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_wtp_dhcp_snooping_enable_cmd_set_wtp_dhcp_snooping");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection,
					  type,
					  id,
					  policy,
					  &count,
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}	

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else
			retu = -2;
	}

	if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL))
			{
				retu = -5;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++)
				{
					if(Wtp_Show_Node == NULL)
					Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
					Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
					break;
				
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}
			
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -6;
	}
	return retu;
}
#endif

/*未使用*/
/*state为"enable"或"disable"*/
int set_wtp_dhcp_snooping_enable_cmd(dbus_parameter parameter, DBusConnection *connection,int id,char *state)
																				  /*返回0表示失败，返回1表示成功*/
																				  /*返回-1表示input patameter only with 'enable' or 'disable'*/
																				  /*返回-2表示error，返回-3示WTP ID非法*/
																				  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == state)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_wtp_dhcp_snooping_enable_cmd_group(parameter, connection,0,id,state,&WtpList_Head);
	if(retu == -5)
	{
		Free_set_wtp_dhcp_snooping_enable_cmd_group(WtpList_Head);
	}
	return retu;
#else
	int ret;
	unsigned int wtp_id = 0;
    int policy = 0;
	int retu;
	
	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -1;
	}
			
	wtp_id = id;
	if(wtp_id >= WTP_NUM || wtp_id < 0){
		syslog(LOG_DEBUG,"wtp id in set_wtp_dhcp_snooping_enable_cmd is %d\n",wtp_id);
		return -3;
	}

	int(*dcli_init_func)(
							int ,
							int ,
							int ,
							unsigned int ,
							DBusConnection *
						);

	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_set_dhcp_snooping");
		if(NULL != dcli_init_func && connection)
		{
			ret =(*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 policy,
					 wtp_id,
					 connection
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else if(ret == 0)
		retu= 1;
	else
		retu = -2;
	
	return retu; 
#endif	
}

/*未使用*/
/*state为"enable"或"disable"*/
/*wtp_list为"all"或like 1,8,9-20,33*/
int set_wtp_list_sta_info_report_enable_cmd(dbus_parameter parameter, DBusConnection *connection,char *state,char *wtp_list)
																							  /*返回0表示失败，返回1表示成功*/
																							  /*返回-1表示input patameter only with 'enable' or 'disable'*/
																							  /*返回-2表示set wtp list error,like 1,8,9-20,33*/
																							  /*返回-3表示error*/
																							  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if((NULL == state)||(NULL == wtp_list))
		return 0;
	
	int ret;
	update_wtp_list *wtplist;
    int policy = 0;
	int retu;
	
	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -1;
	}

	wtplist = (struct tag_wtpid_list*)malloc(sizeof(struct tag_wtpid_list));
	if(NULL == wtplist)
        return 0;
	wtplist->wtpidlist = NULL ; 	
	wtplist->count = 0;
	
	if (!strcmp(wtp_list,"all"))
	{
		;	
	}else{
		ret = parse_wtpid_list((char*)wtp_list,&wtplist);
		if(ret != 0)
		{
			destroy_input_wtp_list(wtplist);
			return -2;
		}
		else
		{
			delsame(wtplist);		
		}
	}

	int(*dcli_init_func)(
							int ,
							int ,
							int ,
							struct tag_wtpid_list *,
							DBusConnection *
						);

	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_list_sta_info_report");
		if(NULL != dcli_init_func && connection)
		{
			ret =(*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 policy,
					 wtplist,
					 connection
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else if(ret == 0)
		retu = 1;
	else
		retu = -3;
	
	return retu; 
}

#if _GROUP_POLICY
void Free_set_wtp_sta_info_report_enable_cmd_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-5时，调用Free_set_wtp_sta_info_report_enable_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*state为"enable"或"disable"*/
int set_wtp_sta_info_report_enable_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *state,struct WtpList **WtpList_Head)
																	/*返回0表示失败，返回1表示成功*/
																	/*返回-1表示input patameter only with 'enable' or 'disable'*/
																	/*返回-2表示error，返回-3示WTP ID非法*/
																	/*返回-4表示Group ID非法，返回-5表示partial failure*/
																	/*返回-6表示group id does not exist*/
{	
    if(NULL == connection)
        return 0;
        
	if(NULL == state)
	{
		*WtpList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int policy = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	int retu = 0;	
	
	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -1;
	}


	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id < 0){
			syslog(LOG_DEBUG,"wtp id in set_wtp_sta_info_report_enable_cmd_group is %d\n",id);
			return -3;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_wtp_sta_info_report_enable_cmd_group is %d\n",id);
			return -4;
		}
	}

	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						unsigned int ,
						int *,
						unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_wtp_sta_info_report_enable_cmd_set_wtp_sta_info_report_enable");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection,
					  type,
					  id,
					  policy,
					  &count,
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else
			retu = -2;
	}

	if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL))
			{
				retu = -5;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++)
				{
					if(Wtp_Show_Node == NULL)
					Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
					Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
					break;
				
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}
			
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -6;
	}
	return retu; 		
}
#endif

/*未使用*/
/*state为"enable"或"disable"*/
int set_wtp_sta_info_report_enable_cmd(dbus_parameter parameter, DBusConnection *connection,int id,char *state)
																				  /*返回0表示失败，返回1表示成功*/
																				  /*返回-1表示input patameter only with 'enable' or 'disable'*/
																				  /*返回-2表示error，返回-3示WTP ID非法*/
																				  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
    if(NULL == connection)
        return 0;
        
	if(NULL == state)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_wtp_sta_info_report_enable_cmd_group(parameter, connection,0,id,state,&WtpList_Head);
	if(retu == -5)
	{
		Free_set_wtp_sta_info_report_enable_cmd_group(WtpList_Head);
	}
	return retu;
#else
	int ret;
	unsigned int wtp_id = 0;
    int policy = 0;
	int retu;
	
	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -1;
	}
			
	wtp_id = id;
	if(wtp_id >= WTP_NUM || wtp_id < 0){
		syslog(LOG_DEBUG,"wtp id in set_wtp_sta_info_report_enable_cmd is %d\n",wtp_id);
		return -3;
	}

	int(*dcli_init_func)(
							int ,
							int ,
							int ,
							unsigned int ,
							DBusConnection *
						);

	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_sta_info_report");
		if(NULL != dcli_init_func && connection)
		{
			ret =(*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 policy,
					 wtp_id,
					 connection
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else if(ret == 0)
		retu = 1;
	else
		retu = -2;
	
	return retu; 
#endif	
}

/*WtpID为0表示全局配置*/
/*trap_type为"rogueap","rogueterminal","cpu"或"memory"*/
/*cpu use threshold范围是0-100*/
/*ap memory use threshold范围是0-100*/
/*rogueap and rogueterminal 范围是0-50000*/
int set_wtp_trap_threshold_cmd(dbus_parameter parameter, DBusConnection *connection, int WtpID,char *trap_type,char *VALUE)
																						   /*返回0表示失败，返回1表示成功*/
																						   /*返回-1表示input patameter only with 'rogueap','rogueterminal','cpu' or 'memory'*/
																						   /*返回-2表示unknown id format，返回-3表示ap cpu use threshold parameters error,should be 0-100*/
																						   /*返回-4表示ap memory use threshold parameters error,should be 0-100*/
																						   /*返回-5表示wtp id does not run，返回-6表示error，返回-7示WTP ID非法*/
																						   /*返回-8表示parameters error, threshold should be less than 50000*/
																						   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
    if(NULL == connection)
        return 0;
	
	if((NULL == trap_type)||(NULL == VALUE))
		return 0;
	
	unsigned int value = 0;
	int ret = WID_DBUS_SUCCESS;
	unsigned int policy = 0;
	unsigned int wtp_id = 0;
	int retu;
		
	wtp_id = WtpID;
	if(wtp_id >= WTP_NUM || wtp_id < 0){
		syslog(LOG_DEBUG,"wtp id in set_wtp_trap_threshold_cmd is %d\n",wtp_id);
		return -7;
	}
	
	if (!strcmp(trap_type,"rogueap"))
	{
		policy = 1; 
	}
	else if (!strcmp(trap_type,"rogueterminal"))
	{
		policy = 2; 
	}
	else if (!strcmp(trap_type,"cpu"))
	{
		policy = 3; 
	}
	else if(!strcmp(trap_type,"memory"))
	{
		policy = 4; 
	}
	else
	{
		return -1;
	}

	ret = parse_int_ID((char*)VALUE, &value);
	if(ret != WID_DBUS_SUCCESS){
			return -2;
	}
	if((policy == 1)||(policy == 2))
	{
		if(value >50000/* || value < 0*/) {
			return -8;
		}
	}
	else if((policy == 3))
	{
		if(value > 100/* || value < 0*/){
			return -3;
		}
	}
	else if(policy == 4)
	{
		if(value > 100/* || value < 0*/){
			return -4;
		}
	}

	int(*dcli_init_func)(
							int ,
							int ,
							unsigned int ,
							unsigned int ,
							unsigned int ,
							DBusConnection *
						);

	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_set_ap_rogueap_rogueterminal_cpu_mem_threshold");
		if(NULL != dcli_init_func && connection)
		{
			ret =(*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 policy,
					 value,
					 wtp_id,
					 connection
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(ret == 0)
		retu = 1;
    else if (-1 == ret){
	    retu = SNMPD_CONNECTION_ERROR;
    }
	else if (ret == WTP_NOT_IN_RUN_STATE)
		retu = -5;
	else
		retu = -6;

	
	return retu; 		
}

void Free_show_ap_trap_threshold(WID_TRAP_THRESHOLD *INFIO)
{
	void (*dcli_init_free_func)(WID_TRAP_THRESHOLD *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun_trap_threshold");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(INFIO);
		}
	}
}

/*WtpID为0表示全局配置*/
/*只要调用函数，就调用Free_show_ap_trap_threshold()释放空间*/
int show_ap_trap_rogue_ap_ter_cpu_mem_threshold_cmd(dbus_parameter parameter, DBusConnection *connection,int WtpID,WID_TRAP_THRESHOLD **INFIO)/*返回0表示失败，返回1表示成功，返回-1表示error，返回-2表示WTP ID非法*/
																																							/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
	if(NULL == connection)
	    return 0;
	    
	int ret = WID_DBUS_SUCCESS;
	int retu;
	int wtpid = 0;		
			
	wtpid = WtpID;
	if(wtpid >= WTP_NUM || wtpid < 0){
		syslog(LOG_DEBUG,"wtp id in show_ap_trap_rogue_ap_ter_cpu_mem_threshold_cmd is %d\n",wtpid);
		return -2;
	}
	
	void*(*dcli_init_func)(
						int ,
						int ,
						unsigned int ,
						int *,
						DBusConnection *
						);

	*INFIO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_show_wtp_trap_threshod");
		if(NULL != dcli_init_func)
		{
			*INFIO =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  wtpid,
					  &ret,
					  connection
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;	
	else if(((ret == 0) || (ret == 5))&&(*INFIO))
		retu = 1;
	else if(ret == WID_DBUS_ERROR) 
		retu = -1;	
    else
		retu = -1;

	return retu;
}

#if _GROUP_POLICY
void Free_set_wtp_trap_switch_cmd_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-5时，调用Free_set_wtp_trap_switch_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*state为"enable"或"disable"*/
int set_wtp_trap_switch_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *state,struct WtpList **WtpList_Head)
																		/*返回0表示失败，返回1表示成功*/
																	    /*返回-1表示input patameter only with 'enable'or'disable'*/
																		/*返回-2表示error，返回-3示WTP ID非法*/
																		/*返回-4表示Group ID非法，返回-5表示partial failure*/
																		/*返回-6表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	if(NULL == state)
	{
		*WtpList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int policy = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	int retu = 0;	

	if (!strcmp(state,"enable"))
	{
		policy = 1; 
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 2; 
	}
	else
	{
		return -1;
	}

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id == 0){
			syslog(LOG_DEBUG,"wtp id in set_wtp_trap_switch_cmd_group is %d\n",id);
			return -3;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_wtp_trap_switch_cmd_group is %d\n",id);
			return -4;
		}
	}

	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						unsigned int ,
						int *,
						unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_wtp_trap_switch_cmd_set_wtp_trap_switch");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection,
					  type,
					  id,
					  policy,
					  &count,
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else
			retu = -2;
	}

	if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL))
			{
				retu = -5;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++)
				{
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
			
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}
		
			vty_out(vty," failed.\n");*/
		}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -6;
	}
	return retu; 		
}
#endif

/*未使用*/
/*state为"enable"或"disable"*/
int set_wtp_trap_switch_cmd(dbus_parameter parameter, DBusConnection *connection,int WtpID,char *state)
																		/*返回0表示失败，返回1表示成功*/
																	    /*返回-1表示input patameter only with 'enable'or'disable'*/
																		/*返回-2表示error，返回-3示WTP ID非法*/
																		/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
    if(NULL == connection)
        return 0;
	
	if(NULL == state)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_wtp_trap_switch_cmd_group(parameter, connection,0,WtpID,state,&WtpList_Head);
	if(retu == -5)
	{
		Free_set_wtp_trap_switch_cmd_group(WtpList_Head);
	}
	return retu;
#else
	int ret = WID_DBUS_SUCCESS;
	int policy = 0;
	int retu;
	unsigned int wtp_id = 0;
	//wtp_id = (unsigned int)vty->index;
	if (!strcmp(state,"enable"))
	{
		policy = 1; 
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 2; 
	}
	else
	{
		return -1;
	}
			
	wtp_id = WtpID;
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		syslog(LOG_DEBUG,"wtp id in set_wtp_trap_switch_cmd is %d\n",wtp_id);
		return -3;
	}

	int(*dcli_init_func)(
							int ,
							int ,
							unsigned int ,
							unsigned int ,
							DBusConnection *
						);

	
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_set_ap_trap_switch_able");
		if(NULL != dcli_init_func && connection)
		{
			ret =(*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 policy,
					 wtp_id,
					 connection
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
		
	if(ret == 0)
		retu = 1;
    else if(-1 == ret)
        retu = SNMPD_CONNECTION_ERROR;
	else 
		retu = -2;
		
	return retu; 		
#endif	
}

#if _GROUP_POLICY
void Free_set_ap_sta_wapi_info_report_enable_cmd_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-7时，调用Free_set_ap_sta_wapi_info_report_enable_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*state为"enable"或"disable"*/
int set_ap_sta_wapi_info_report_enable_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *state,struct WtpList **WtpList_Head)
						/*返回0表示失败，返回1表示成功，返回-1表示input patameter only with 'enable'or'disable'*/
						/*返回-2表示wtp id does not exist，返回-3表示wtp id does not run，返回-4表示error，返回-5示WTP ID非法*/
						/*返回-6表示Group ID非法，返回-7表示partial failure，返回-8表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	if(NULL == state)
	{
		*WtpList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	int policy = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	int retu = 0;	
	
	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -1;
	}


	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id < 0){
			syslog(LOG_DEBUG,"wtp id in set_ap_sta_wapi_info_report_enable_cmd_group is %d\n",id);
			return -5;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_ap_sta_wapi_info_report_enable_cmd_group is %d\n",id);
			return -6;
		}
	}

	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						int ,
						int *,
						unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_ap_sta_wapi_info_report_enable_cmd_set_ap_sta_wapi_info_report_switch");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection,
					  type,
					  id,
					  policy,
					  &count,
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == -1)
			retu = 0;
		else if(ret == 0)
			retu = 1;
		else if (ret == WTP_ID_NOT_EXIST)
			retu = -2;
		else if (ret == WTP_NOT_IN_RUN_STATE)
			retu = -3;
		else
			retu = -4;
	}

	if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL))
			{
				retu = -7;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++)
				{
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
			
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}			
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -8;
	}
	return retu;			
}
#endif

/*未使用*/
/*state为"enable"或"disable"*/
int set_ap_sta_wapi_info_report_enable_cmd(dbus_parameter parameter, DBusConnection *connection,int WtpID,char *state)
																						 /*返回0表示失败，返回1表示成功，返回-1表示input patameter only with 'enable'or'disable'*/
																						 /*返回-2表示wtp id does not exist，返回-3表示wtp id does not run，返回-4表示error，返回-5示WTP ID非法*/
																						 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == state)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_ap_sta_wapi_info_report_enable_cmd_group(parameter, connection,0,WtpID,state,&WtpList_Head);
	if(retu == -7)
	{
		Free_set_ap_sta_wapi_info_report_enable_cmd_group(WtpList_Head);
	}
	return retu;
#else
	int ret,retu;
    int policy = 0;
	//WTPID = (unsigned int)WtpID;
	
	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -1;
	}
	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_WAPI_INFO_SWITCH);
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (ccgi_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);*/
	int wtpid = 0;
	wtpid = WtpID;
	if(wtpid >= WTP_NUM || wtpid < 0){
		syslog(LOG_DEBUG,"wtp id in set_ap_sta_wapi_info_report_enable_cmd is %d\n",wtpid);
		return -5;
	}
	
	int(*dcli_init_func)(
							int ,
							int ,
							unsigned int ,
							unsigned int ,
							DBusConnection *
						);

	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_set_ap_sta_wapi_info_report_able");
		if(NULL != dcli_init_func)
		{
			ret =(*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 policy,
					 wtpid,
					 connection
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	/*if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return 0;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);*/

	
	if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else if(ret == 0)
		retu = 1;
	else if (ret == WTP_ID_NOT_EXIST)
		retu = -2;
	else if (ret == WTP_NOT_IN_RUN_STATE)
		retu = -3;
	else
		retu = -4;
		
	//dbus_message_unref(reply);
	
	return retu;			
#endif	
}

#if _GROUP_POLICY
void Free_set_ap_sta_wapi_info_reportinterval_cmd_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-9时，调用Free_set_ap_sta_wapi_info_reportinterval_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*para的范围是1-120*/
int set_ap_sta_wapi_info_reportinterval_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *para,struct WtpList **WtpList_Head)
											/*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
											/*返回-2表示ap sta infomation reportinterval error，返回-3表示wtp is not in run state*/
											/*返回-4表示wtp id does not exist，返回-5表示error，返回-6示WTP ID非法*/
											/*返回-7表示illegal input:Input exceeds the maximum value of the parameter type*/
											/*返回-8表示Group ID非法，返回-9表示partial failure，返回-10表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	if(NULL == para)
	{
		*WtpList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned char interval = 0;
	int retu = 0;	
    
	
	ret = parse_char_ID((char*)para, &interval);
	if(ret != WID_DBUS_SUCCESS){
        if(ret == WID_ILLEGAL_INPUT){
			retu = -7;
        }
		else{
			retu = -1;
		}
		return retu;
	}	
	if(interval > 120 || interval == 0){
		return -2;
	}


	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id < 0){
			syslog(LOG_DEBUG,"wtp id in set_ap_sta_wapi_info_reportinterval_cmd_group is %d\n",id);
			return -6;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_ap_sta_wapi_info_reportinterval_cmd_group is %d\n",id);
			return -8;
		}
	}

	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						unsigned char ,
						int *,
						unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_ap_sta_wapi_info_reportinterval_cmd_set_ap_sta_wapi_info_reportinterval");
		if(NULL != dcli_init_func && connection)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection,
					  type,
					  id,
					  interval,
					  &count,
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}	

	if(type==0)
	{
		if(ret == -1)
			retu = 0;
		else if(ret == 0)
			retu = 1;
		else if (ret == WTP_NOT_IN_RUN_STATE)
			retu = -3;
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -4;
		else
			retu = -5;
	}

	if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL))
			{
				retu = -9;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++)
				{
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
			
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}			
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -10;
	}
	return retu;			
}
#endif

/*未使用*/
/*para的范围是1-32767*/
int set_ap_sta_wapi_info_reportinterval_cmd(dbus_parameter parameter, DBusConnection *connection,int WtpID,char *para)
																					   /*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
																					   /*返回-2表示ap sta infomation reportinterval error,should be 1-32767，返回-3表示wtp is not in run state*/
																					   /*返回-4表示wtp id does not exist，返回-5表示error，返回-6示WTP ID非法*/
																					   /*返回-7表示illegal input:Input exceeds the maximum value of the parameter type*/
																					   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == para)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_ap_sta_wapi_info_reportinterval_cmd_group(parameter, connection,0,WtpID,para,&WtpList_Head);
	if(retu == -9)
	{
		Free_set_ap_sta_wapi_info_reportinterval_cmd_group(WtpList_Head);
	}
	return retu;
#else
	int ret = 0;
	int retu;
    unsigned int interval = 0;
	//wtp_id = (unsigned int)WtpID;
	
	ret = parse_int_ID((char*)para, &interval);
	if(ret != WID_DBUS_SUCCESS){
		if(ret == WID_ILLEGAL_INPUT){
			retu = -7;
		}
		else{
			retu = -1;
		}
		return retu;
	}	
	if(interval > 32767 || interval == 0){
		return -2;
	}
	
	
	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_WAPI_INFO_REPORTINTERVAL);
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,	
							 DBUS_TYPE_BYTE,&interval,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (ccgi_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return 0;
	}*/
	

	int wtpid = 0;			
	wtpid = WtpID;
	if(wtpid >= WTP_NUM || wtpid < 0){
		syslog(LOG_DEBUG,"wtp id in set_ap_sta_wapi_info_reportinterval_cmd is %d\n",wtpid);
		return -6;
	}
		
	int(*dcli_init_func)(
							int ,
							int ,
							unsigned int ,
							unsigned int ,
							DBusConnection *
						);

	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_set_ap_sta_wapi_info_report_reportinterval");
		if(NULL != dcli_init_func && connection)
		{
			ret =(*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 interval,
					 wtpid,
					 connection
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	//dbus_message_iter_init(reply,&iter);
	//dbus_message_iter_get_basic(&iter,&ret);

	if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else if(ret == 0)
		retu = 1;
	else if (ret == WTP_NOT_IN_RUN_STATE)
		retu = -3;
	else if(ret == WTP_ID_NOT_EXIST)
		retu = -4;
	else
		retu = -5;

	//dbus_message_unref(reply);
	
	return retu;			
#endif	
}

void Free_show_all_wtp_the_radio_para_information_cmd(struct WtpRadioParaInfo *WtpHead)
{
	void (*dcli_init_free_func)(struct WtpRadioParaInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_wtp_WtpRadioParaInfo");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpHead);
		}
	}
}

/*只要调用，就通过Free_show_all_wtp_the_radio_para_information_cmd()释放空间*/
int show_all_wtp_the_radio_para_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct WtpRadioParaInfo **WtpHead)
																										   /*返回0表示失败，返回1表示成功*/
																										   /*返回-1表示There is no WTP now*/
																										   /*返回-2表示error*/
																										   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int wtp_num = 0;
	int retu;
	
	
	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *, 
							unsigned int *, 
							unsigned int *
						);

	*WtpHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_WtpRadioParaInfo_of_all_wtp");
		if(NULL != dcli_init_func)
		{
			*WtpHead = (*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 connection, 
					 &wtp_num, 
					 &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if((*WtpHead!=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if (ret == WID_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -1;
	}
	else
	{
		retu = -2;
	}
	
	return retu;
}


void Free_show_all_wtp_radio_stats_information_cmd(struct RadioStatsInfo *WtpHead)
{
	void (*dcli_init_free_func)(struct RadioStatsInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_wtp_RadioStatsInfo");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpHead);
		}
	}
}

/*只要调用，就通过Free_show_all_wtp_radio_stats_information_cmd()释放空间*/
int show_all_wtp_radio_stats_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct RadioStatsInfo **WtpHead)
																									 /*返回0表示失败，返回1表示成功*/
																								     /*返回-1表示There is no WTP now*/
																								     /*返回-2表示error*/
																									 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int wtp_num = 0;
	int retu;
	
	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *, 
							unsigned int *, 
							unsigned int *
						);

	*WtpHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_RadioStatsInfo_of_all_wtp");
		if(NULL != dcli_init_func)
		{
			*WtpHead = (*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 connection, 
					 &wtp_num, 
					 &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if((*WtpHead!=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if (ret == WID_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -1;
	}
	else
	{
		retu = -2;
	}

	return retu;
}

void Free_show_all_wtp_rogue_ap_info_information_cmd(struct RogueAPInfo *WtpHead)
{
	void (*dcli_init_free_func)(struct RogueAPInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_wtp_RogueAPInfo_Info");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpHead);
		}
	}
}

/*只要调用，就通过Free_show_all_wtp_rogue_ap_info_information_cmd()释放空间*/
int show_all_wtp_rogue_ap_info_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct RogueAPInfo **WtpHead)
																									 /*返回0表示失败，返回1表示成功*/
																								     /*返回-1表示There is no WTP now*/
																								     /*返回-2表示ap scanning disable ,please enable it*/
																									 /*返回-3表示no ap has neighbor ap*/
																									 /*返回-4表示error*/
																									 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int num = 0;
	int retu;
	
	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *, 
							unsigned int *, 
							unsigned int *
						);

	*WtpHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_RogueAPInfo_of_all_wtp");
		if(NULL != dcli_init_func)
		{
			*WtpHead = (*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 connection, 
					 &num, 
					 &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if((*WtpHead!=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if (ret == WID_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -1;
	}
	else if(ret == WID_AP_SCANNING_DISABLE)
	{
		retu = -2;
	}
	else if(ret == WTP_NO_NEIGHBORAP)
	{
		retu = -3;
	}
	else
	{
		retu = -4;
	}
		
	return retu;
}

void Free_show_all_wtp_user_link_information_cmd(struct UsrLinkInfo *WtpHead)
{
	void (*dcli_init_free_func)(struct UsrLinkInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_UsrLinkInfo");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpHead);
		}
	}
}

/*只要调用，就通过Free_show_all_wtp_user_link_information_cmd()释放空间*/
int show_all_wtp_user_link_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct UsrLinkInfo **WtpHead)
																								/*返回0表示失败，返回1表示成功*/
																						        /*返回-1表示There is no WTP now*/
																							    /*返回-2表示error*/
																								/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int num = 0;
	int retu;

	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *, 
							unsigned int *, 
							unsigned int *
						);

	*WtpHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_UsrLinkInfo_of_all_wtp");
		if(NULL != dcli_init_func)
		{
			*WtpHead = (*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 connection, 
					 &num, 
					 &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if((*WtpHead!=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if (ret == ASD_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == ASD_WTP_NOT_EXIST)
	{
		retu = -1;
	}
	else
	{
		retu = -2;
	}
	
	return retu;	
}

void Free_show_all_wtp_data_pkts_information_cmd(struct WtpDataPktsInfo *WtpHead)
{
	void (*dcli_init_free_func)(struct WtpDataPktsInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_wtp_data_pkts_Info");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpHead);
		}
	}
}

/*只要调用，就通过Free_show_all_wtp_data_pkts_information_cmd()释放空间*/
int show_all_wtp_data_pkts_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct WtpDataPktsInfo **WtpHead)
																									/*返回0表示失败，返回1表示成功*/
																							        /*返回-1表示There is no WTP now*/
																								    /*返回-2表示error*/
																									/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int num = 0;
	int retu;

	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *, 
							unsigned int *, 
							unsigned int *
						);

	*WtpHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_WtpDataPktsInfo_of_all_wtp");
		if(NULL != dcli_init_func)
		{
			*WtpHead = (*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 connection, 
					 &num, 
					 &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if((*WtpHead!=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if (ret == WID_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -1;
	}
	else
	{
		retu = -2;
	}
	
	return retu;
}

void Free_show_all_wtp_device_information_cmd(struct WtpDeviceInfo *WtpHead)
{
	void (*dcli_init_free_func)(struct WtpDeviceInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_wtp_device_Info");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpHead);
		}
	}
}

/*只要调用，就通过Free_show_all_wtp_device_information_cmd()释放空间*/
int show_all_wtp_device_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct WtpDeviceInfo **WtpHead)
																							   /*返回0表示失败，返回1表示成功*/
																						       /*返回-1表示There is no WTP now*/
																							   /*返回-2表示error*/
																							   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int num = 0;
	int retu;
	
	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *, 
							unsigned int *, 
							unsigned int *
						);

	*WtpHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_WtpDeviceInfo_of_all_wtp");
		if(NULL != dcli_init_func)
		{
			*WtpHead = (*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 connection, 
					 &num, 
					 &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if((*WtpHead!=NULL)&&(ret == 0))
	{
		retu  = 1;
	}
	else if (ret == WID_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -1;
	}
	else
	{
		retu = -2;
	}
	
	return retu;
}

void Free_show_all_wtp_terminal_information_cmd(struct WtpTerminalInfo *WtpHead)
{
	void (*dcli_init_free_func)(struct WtpTerminalInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_wtp_terminalinfo_head");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpHead);
		}
	}
}

/*返回1时，调用Free_show_all_wtp_terminal_information_cmd()释放空间*/
int show_all_wtp_terminal_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct WtpTerminalInfo **WtpHead)
																								  /*返回0表示失败，返回1表示成功*/
																						          /*返回-1表示There is no WTP now*/
																							      /*返回-2表示error*/
																								  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int num = 0;
	int retu;

	
	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *, 
							unsigned int *, 
							unsigned int *
						);

    *WtpHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_terminal_info_of_all_wtp");
		if(NULL != dcli_init_func)
		{
			*WtpHead = (*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 connection, 
					 &num, 
					 &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if((*WtpHead!=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if (ret == ASD_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == ASD_WTP_NOT_EXIST)
	{
		retu = -1;
	}
	else
	{
		retu = -2;
	}
	return retu;
}

void Free_show_all_wtp_eth_port_information_cmd(struct WtpEthPortInfo *WtpHead)
{
	void (*dcli_init_free_func)(struct WtpEthPortInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpEthPortInfo");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpHead);
		}
	}
}

/*只要调用，就通过Free_show_all_wtp_eth_port_information_cmd()释放空间*/
int show_all_wtp_eth_port_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct WtpEthPortInfo **WtpHead)
																								  /*返回0表示失败，返回1表示成功*/
																						          /*返回-1表示There is no WTP now*/
																							      /*返回-2表示error*/
																								  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int num = 0;
	int retu;

	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *, 
							unsigned int *, 
							unsigned int *
						);

	*WtpHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_WtpEthPortInfo_of_all_wtp");
		if(NULL != dcli_init_func)
		{
			*WtpHead = (*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 connection, 
					 &num, 
					 &ret
				  );	
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if((*WtpHead!=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if (ret == WID_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -1;
	}
	else
	{
		retu = -2;
	}
	
	return retu;	
}

void Free_show_all_wtp_ifname_information_cmd(struct WtpIfnameInfo *WtpHead)
{
	void (*dcli_init_free_func)(struct WtpIfnameInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpIfnameInfo");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpHead);
		}
	}
}

/*只要调用，就通过Free_show_all_wtp_ifname_information_cmd()释放空间*/
int show_all_wtp_ifname_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct WtpIfnameInfo **WtpHead)
																								  /*返回0表示失败，返回1表示成功*/
																						          /*返回-1表示There is no WTP now*/
																							      /*返回-2表示error*/
																								  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int num = 0;
	int retu;

	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *, 
							unsigned int *, 
							unsigned int *
						);

	*WtpHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_WtpIfnameInfo_of_all_wtp");
		if(NULL != dcli_init_func)
		{
			*WtpHead = (*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 connection, 
					 &num, 
					 &ret
				  );	
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if((*WtpHead!=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if (ret == WID_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -1;
	}
	else
	{
		retu = -2;
	}
		
	return retu;	
}

void Free_show_all_wtp_information_cmd(struct WtpInfor *WtpHead)
{
	void (*dcli_init_free_func)(struct WtpInfor *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpInfo");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpHead);
		}
	}
}

/*只要调用，就通过Free_show_all_wtp_information_cmd()释放空间*/
int show_all_wtp_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct WtpInfor **WtpHead)
																				  /*返回0表示失败，返回1表示成功*/
																		          /*返回-1表示There is no WTP now*/
																			      /*返回-2表示error*/
																				  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int num = 0;
	int retu;

	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *, 
							unsigned int *, 
							unsigned int *
						);

	*WtpHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_infor_of_all_wtp");
		if(NULL != dcli_init_func)
		{
			*WtpHead = (*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 connection, 
					 &num, 
					 &ret
				  );	
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if((*WtpHead!=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if (ret == WID_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -1;
	}
	else
	{
		retu = -2;
	}

	return retu;
}

void Free_show_all_wtp_para_information_cmd(struct WtpParaInfo *WtpHead)
{
	void (*dcli_init_free_func)(struct WtpParaInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpParaInfo");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpHead);
		}
	}
}

/*只要调用，就通过Free_show_all_wtp_para_information_cmd()释放空间*/
int show_all_wtp_para_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct WtpParaInfo **WtpHead)
																						   /*返回0表示失败，返回1表示成功*/
																				           /*返回-1表示There is no WTP now*/
																					       /*返回-2表示error*/
																						   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int num = 0;
	int retu;

	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *, 
							unsigned int *, 
							unsigned int *
						);

	*WtpHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_para_info_of_all_wtp");
		if(NULL != dcli_init_func)
		{
			*WtpHead = (*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 connection, 
					 &num, 
					 &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if((*WtpHead!=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if (ret == WID_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -1;
	}
	else
	{
		retu = -2;
	}

	return retu;
}

void Free_show_all_wtp_station_information_cmd(struct WtpStaInfo *StaHead)
{
	void (*dcli_init_free_func)(struct WtpStaInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_wtp_sta_info_head");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(StaHead);
		}
	}
}

/*返回1时，调用Free_show_all_wtp_station_information_cmd()释放空间*/
int show_all_wtp_station_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct WtpStaInfo **StaHead)
																							/*返回0表示失败，返回1表示成功*/
																				            /*返回-1表示There is no sta now*/
																				            /*返回-2表示There is no WTP now，返回-3表示error*/
																							/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int wtp_num;
	int retu;
	
	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *, 
							unsigned int *, 
							unsigned int *
						);

    *StaHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_sta_info_of_all_wtp");
		if(NULL != dcli_init_func)
		{
			*StaHead = (*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 connection, 
					 &wtp_num, 
					 &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if((*StaHead !=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if (ret == 0)
	{
		retu = -1;
	}
	else if (ret == ASD_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == ASD_WTP_NOT_EXIST)
	{
		retu = -2;
	}
	else
	{
		retu = -3;
	}

	return retu;
}

void Free_show_all_wtp_stats_information_cmd(struct WtpStatsInfo *WtpHead)
{
	void (*dcli_init_free_func)(struct WtpStatsInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_wtp_stats_Info");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpHead);
		}
	}
}

/*只要调用，就通过Free_show_all_wtp_stats_information_cmd()释放空间*/
int show_all_wtp_stats_information_cmd(dbus_parameter parameter, DBusConnection *connection, struct WtpStatsInfo **WtpHead)
																							/*返回0表示失败，返回1表示成功*/
																				            /*返回-1表示There is no WTP now*/
																				            /*返回-2表示error，返回-3表示WTPID is larger than MAX*/
																							/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int num = 0;
	int retu;

	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *, 
							unsigned int *, 
							unsigned int *
						);

	*WtpHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_WtpStatsInfo_of_all_wtp");
		if(NULL != dcli_init_func)
		{
			*WtpHead = (*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 connection, 
					 &num, 
					 &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if((*WtpHead!=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if (ret == WID_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -1;
	}
	else if(ret == ASD_WTP_ID_LARGE_THAN_MAX)
	{
		retu = -3;
	}
	else
	{
		retu = -2;
	}
	
	return retu;
}

void Free_show_all_wtp_wired_ifstats_information_cmd(struct WtpWiredIfStatsInfo *WtpHead)
{
	void (*dcli_init_free_func)(struct WtpWiredIfStatsInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_wtp_WiredIfStats_Info");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpHead);
		}
	}
}

/*只要调用，就通过Free_show_all_wtp_wired_ifstats_information_cmd()释放空间*/
int show_all_wtp_wired_ifstats_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct WtpWiredIfStatsInfo **WtpHead)
																											/*返回0表示失败，返回1表示成功*/
																								            /*返回-1表示There is no WTP now*/
																								            /*返回-2表示error*/
																											/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int num = 0;
	int retu;

	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *, 
							unsigned int *, 
							unsigned int *
						);

	*WtpHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_WtpWiredIfStatsInfo_of_all_wtp");
		if(NULL != dcli_init_func)
		{
			*WtpHead = (*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 connection, 
					 &num, 
					 &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if((*WtpHead!=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if (ret == WID_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -1;
	}
	else
	{
		retu = -2;
	}
	
	return retu;
}

void Free_show_all_wtp_wireless_if_information_cmd(struct WtpWirelessIfInfo *WtpHead)
{
	void (*dcli_init_free_func)(struct WtpWirelessIfInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_wtp_WtpWirelessIf_Info");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpHead);
		}
	}
}

/*只要调用，就通过Free_show_all_wtp_wireless_if_information_cmd()释放空间*/
int show_all_wtp_wireless_if_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct WtpWirelessIfInfo **WtpHead)
																											/*返回0表示失败，返回1表示成功*/
																								            /*返回-1表示There is no WTP now*/
																								            /*返回-2表示error*/
																											/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int num = 0;
	int retu;
	
	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *, 
							unsigned int *, 
							unsigned int *
						);

	*WtpHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_WtpWirelessIfStatsInfo_of_all_wtp");
		if(NULL != dcli_init_func)
		{
			*WtpHead = (*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 connection, 
					 &num, 
					 &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if((*WtpHead!=NULL)&&(ret == 0))
	{
		retu = 1;	
	}
	else if (ret == WID_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -1;
	}
	else
	{
		retu = -2;
	}
	
	return retu;
}

void Free_show_all_wtp_wirelessifstats_information_cmd(struct WtpWirelessIfstatsInfo *WtpHead)
{
	void (*dcli_init_free_func)(struct WtpWirelessIfstatsInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_wtp_wireless_ifstats_Info");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpHead);
		}
	}
}

/*只要调用，就通过Free_show_all_wtp_wirelessifstats_information_cmd()释放空间*/
int show_all_wtp_wirelessifstats_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct WtpWirelessIfstatsInfo **WtpHead)
																												/*返回0表示失败，返回1表示成功*/
																									            /*返回-1表示There is no WTP now*/
																									            /*返回-2表示error*/
																												/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int wtp_num = 0;
	int retu;
	
	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *, 
							unsigned int *, 
							unsigned int *
						);

	*WtpHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_wirelessifstatsInfo_info_of_all_wtp");
		if(NULL != dcli_init_func)
		{
			*WtpHead = (*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 connection, 
					 &wtp_num, 
					 &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if((*WtpHead!=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if (ret == WID_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -1;
	}
	else
	{
		retu = -2;
	}

	return retu;
}

void Free_show_all_wtp_wlan_data_pkts_information_cmd(struct WtpWlanDataPktsInfo *WtpHead)
{
	void (*dcli_init_free_func)(struct WtpWlanDataPktsInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_wtp_wlan_data_pktsinfo_head");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpHead);
		}
	}
}

/*返回1时，调用Free_show_all_wtp_wlan_data_pkts_information_cmd()释放空间*/
int show_all_wtp_wlan_data_pkts_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct WtpWlanDataPktsInfo **WtpHead)
																								/*返回0表示失败，返回1表示成功*/
																					            /*返回-1表示There is no WTP now*/
																					            /*返回-2表示error*/
																								/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int wtp_num;
	int retu;
	
	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *, 
							unsigned int *, 
							unsigned int *
						);

    *WtpHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_WlanDataPkts_Info_of_all_wtp");
		if(NULL != dcli_init_func)
		{
			*WtpHead = (*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 connection, 
					 &wtp_num, 
					 &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if((*WtpHead!=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if (ret == WID_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = 1;
	}
	else
	{
		retu = -2;
	}
	
	return retu;
}


void Free_show_all_wlan_stats_information_cmd(struct WtpWlanStatsInfo *WtpHead)
{
	void (*dcli_init_free_func)(struct WtpWlanStatsInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_wlan_stats_Info");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpHead);
		}
	}
}

/*只要调用，就通过Free_show_all_wlan_stats_information_cmd()释放空间*/
int show_all_wlan_stats_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct WtpWlanStatsInfo **WtpHead)
																								 /*返回0表示失败，返回1表示成功*/
																					             /*返回-1表示There is no WTP now*/
																					             /*返回-2表示error*/
																								 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int num = 0;
	int retu;

	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *, 
							unsigned int *, 
							unsigned int *
						);

	*WtpHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_WtpWlanStatsInfo_of_all_wtp");
		if(NULL != dcli_init_func)
		{
			*WtpHead = (*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 connection, 
					 &num, 
					 &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if((*WtpHead!=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if (ret == WID_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -1;
	}
	else
	{
		retu = -2;
	}
	
	return retu;
}

void Free_show_all_wtp_radio_config_information_cmd(struct WtpConfigRadioInfo *WtpHead)
{
	void (*dcli_init_free_func)(struct WtpConfigRadioInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpConfigRadioInfo");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpHead);
		}
	}
}

/*只要调用，就通过Free_show_all_wtp_radio_config_information_cmd()释放空间*/
int show_all_wtp_radio_config_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct WtpConfigRadioInfo **WtpHead)
																										   /*返回0表示失败，返回1表示成功*/
																							               /*返回-1表示There is no WTP now*/
																							               /*返回-2表示error*/
																										   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int wtp_num = 0;
	int retu;
	
	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *, 
							unsigned int *, 
							unsigned int *
						);

	*WtpHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_WtpConfigRadioInfo_of_all_wtp");
		if(NULL != dcli_init_func)
		{
			*WtpHead = (*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 connection, 
					 &wtp_num, 
					 &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if((*WtpHead!=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if (ret == WID_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -1;
	}
	else
	{
		retu = -2;
	}

	return retu;
}

void Free_show_all_wtp_basic_information_cmd(struct WtpBasicInfo *WtpHead)
{
	void (*dcli_init_free_func)(struct WtpBasicInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpBasicInfo");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpHead);
		}
	}
}

/*只要调用，就通过Free_show_all_wtp_basic_information_cmd()释放空间*/
int show_all_wtp_basic_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct WtpBasicInfo **WtpHead)
																							   /*返回0表示dbus error，返回1表示成功*/
																				               /*返回-1表示There is no WTP now*/
																				               /*返回-2表示error*/
																							   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int num = 0;
	int retu;

	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *, 
							unsigned int *, 
							unsigned int *
						);

	*WtpHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_basic_info_of_all_wtp");
		if(NULL != dcli_init_func && connection)
		{
			*WtpHead = (*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 connection, 
					 &num, 
					 &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if((*WtpHead!=NULL)&&(ret == 0))
	{
		retu = 1;	
	}
	else if (ret == WID_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -1;
	}
	else
	{
		retu = -2;
	}
		
	return retu;	
}

void Free_show_all_wtp_new_wtp_wireless_ifinfo_information_cmd(struct NewWtpWirelessIfInfo *RadioHead)
{
	void (*dcli_init_free_func)(struct NewWtpWirelessIfInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_NewWtpWirelessIfInfo");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioHead);
		}
	}
}

/*只要调用，就通过Free_show_all_wtp_new_wtp_wireless_ifinfo_information_cmd()释放空间*/
int show_all_wtp_new_wtp_wireless_ifinfo_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct NewWtpWirelessIfInfo **RadioHead)
																								   /*返回0表示失败，返回1表示成功*/
																					               /*返回-1表示There is no WTP now*/
																					               /*返回-2表示error*/
																								   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int radio_num = 0;
	int retu;
	
	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *, 
							unsigned int *, 
							unsigned int *
						);

	*RadioHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_NewWtpWirelessIfInfo_of_all_wtp");
		if(NULL != dcli_init_func)
		{
			*RadioHead = (*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 connection, 
					 &radio_num, 
					 &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if((*RadioHead!=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if (ret == WID_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -1;
	}
	else
	{
		retu = -2;
	}
	
	return retu;
}

void Free_show_all_wlan_ssid_stats_information_cmd(struct SSIDStatsInfo *WtpHead)
{
	void (*dcli_init_free_func)(struct SSIDStatsInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_ssid_stats_Info");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpHead);
		}
	}
}

/*只要调用，就通过Free_show_all_wlan_ssid_stats_information_cmd()释放空间*/
int show_all_wlan_ssid_stats_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct SSIDStatsInfo **WtpHead)
																									/*返回0表示失败，返回1表示成功*/
																					                /*返回-1表示There is no WTP now*/
																					                /*返回-2表示error*/
																									/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int num = 0;
	int retu;

	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *, 
							unsigned int *, 
							unsigned int *
						);

	*WtpHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_wtp_wlan_SSIDStatsInfo_of_all_wtp");
		if(NULL != dcli_init_func)
		{
			*WtpHead = (*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 connection, 
					 &num, 
					 &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if((*WtpHead!=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if (ret == WID_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -1;
	}
	else
	{
		retu = -2;
	}

	return retu;
}

void Free_show_all_wlan_ssid_stats_information_cmd_wlannode_v2(struct SSIDStatsInfo_sub_wlan_v2 *wlanHead_v2)
{
	struct SSIDStatsInfo_sub_wlan_v2 *f1=NULL,*f2=NULL;
	if(wlanHead_v2 == NULL)
	{
		return;
	}
	f1=wlanHead_v2->next;
	if(f1 != NULL)
	{
		f2=f1->next;
		while(f2!=NULL)
		{
			FREE_OBJECT(f1->wtpSSIDName);
			FREE_OBJECT(f1->wtpSSIDESSID);
			free(f1);
			f1=f2;
			f2=f2->next;
		}
		FREE_OBJECT(f1->wtpSSIDName);
		FREE_OBJECT(f1->wtpSSIDESSID);
		free(f1);
	}
}

void Free_show_all_wlan_ssid_stats_information_cmd_v2(struct SSIDStatsInfo_v2 *WtpHead_v2)
{
	struct SSIDStatsInfo_v2 *f1=NULL,*f2=NULL;
	if(WtpHead_v2 == NULL)
	{
		return;
	}
	f1=WtpHead_v2->next;
	if(f1 != NULL)
	{
		f2=f1->next;
		while(f2!=NULL)
		{
			FREE_OBJECT(f1->wtpMacAddr);
			Free_show_all_wlan_ssid_stats_information_cmd_wlannode_v2(f1->SSIDStatsInfo_sub_wlan_head);
			FREE_OBJECT(f1->SSIDStatsInfo_sub_wlan_head);
			free(f1);
			f1=f2;
			f2=f2->next;
		}
		FREE_OBJECT(f1->wtpMacAddr);
		Free_show_all_wlan_ssid_stats_information_cmd_wlannode_v2(f1->SSIDStatsInfo_sub_wlan_head);
		FREE_OBJECT(f1->SSIDStatsInfo_sub_wlan_head);
		free(f1);
	}
	free(WtpHead_v2);
}

/*返回1时，调用Free_show_all_wlan_ssid_stats_information_cmd_v2()释放空间*/
int show_all_wlan_ssid_stats_information_cmd_v2(dbus_parameter parameter, DBusConnection *connection,struct SSIDStatsInfo_v2 **WtpHead_v2)
																											  /*返回0表示失败，返回1表示成功*/
																							                  /*返回-1表示There is no WTP now*/
																							                  /*返回-2表示error*/
																											  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	struct SSIDStatsInfo *WtpHead = NULL;
	struct SSIDStatsInfo *WtpShowNode = NULL;
	struct SSIDStatsInfo_v2 *WtpShowNode_v2 = NULL,*WtpShowNode_tail = NULL;
	struct SSIDStatsInfo_sub_wlan_v2 *sub_wlan_tail = NULL;
	int i=0;
	int j=0;
	int k=0;

	unsigned int ret=0;
	unsigned int num = 0;
	int retu;
	
	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *, 
							unsigned int *, 
							unsigned int *
						);

    WtpHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_wtp_wlan_SSIDStatsInfo_of_all_wtp");
		if(NULL != dcli_init_func)
		{
			WtpHead = (*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 connection, 
					 &num, 
					 &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

    *WtpHead_v2=(struct SSIDStatsInfo_v2 *)malloc(sizeof(struct SSIDStatsInfo_v2));
    if(*WtpHead_v2 == NULL)
    {
        return 0;
    }
	memset(*WtpHead_v2,0,sizeof(struct SSIDStatsInfo_v2));
	WtpShowNode_tail=*WtpHead_v2;
	if((WtpHead!=NULL)&&(ret == 0))
	{
		WtpShowNode_v2 = NULL;
		for (i = 0,WtpShowNode = WtpHead->SSIDStatsInfo_list;
			 ((i < num)&&(NULL != WtpShowNode)); 
			 i++,WtpShowNode = WtpShowNode->next) 
		{	
			WtpShowNode_v2=(struct SSIDStatsInfo_v2 *)malloc(sizeof(struct SSIDStatsInfo_v2));			
			if(WtpShowNode_v2 != NULL)
			{
				memset(WtpShowNode_v2,0,sizeof(struct SSIDStatsInfo_v2));
				WtpShowNode_v2->wtpCurrID = WtpShowNode->wtpCurrID;
				WtpShowNode_v2->wtpMacAddr = (char*)malloc(MAC_LEN+1);		
				if(WtpShowNode_v2->wtpMacAddr)
				{
					memset(WtpShowNode_v2->wtpMacAddr, 0, MAC_LEN+1);
					WtpShowNode_v2->wtpMacAddr[0] = WtpShowNode->wtpMacAddr[0];
					WtpShowNode_v2->wtpMacAddr[1] = WtpShowNode->wtpMacAddr[1];
					WtpShowNode_v2->wtpMacAddr[2] = WtpShowNode->wtpMacAddr[2];
					WtpShowNode_v2->wtpMacAddr[3] = WtpShowNode->wtpMacAddr[3];
					WtpShowNode_v2->wtpMacAddr[4] = WtpShowNode->wtpMacAddr[4];
					WtpShowNode_v2->wtpMacAddr[5] = WtpShowNode->wtpMacAddr[5]; 			
				}
				WtpShowNode_v2->SSIDTxSignalPkts = WtpShowNode->SSIDTxSignalPkts;
				WtpShowNode_v2->SSIDRxSignalPkts = WtpShowNode->SSIDRxSignalPkts;
				WtpShowNode_v2->wtpBwlanRadioNum = WtpShowNode->wtpBwlanRadioNum;
				WtpShowNode_v2->SSIDStatsInfo_sub_wlan_head = (struct SSIDStatsInfo_sub_wlan_v2 *)malloc(sizeof(struct SSIDStatsInfo_sub_wlan_v2));
				if(WtpShowNode_v2->SSIDStatsInfo_sub_wlan_head != NULL)
				{
					memset(WtpShowNode_v2->SSIDStatsInfo_sub_wlan_head,0,sizeof(struct SSIDStatsInfo_sub_wlan_v2));
					sub_wlan_tail = WtpShowNode_v2->SSIDStatsInfo_sub_wlan_head;
									
					struct SSIDStatsInfo_Radioid_info *Radioid_info_node = NULL;

					for(j=0,Radioid_info_node=WtpShowNode->SSIDStatsInfo_Radioid_info_head;
						((j<WtpShowNode->wtpBwlanRadioNum)&&(NULL != Radioid_info_node));
						j++,Radioid_info_node=Radioid_info_node->next)
					{
						WtpShowNode_v2->wtpSupportRadioId[j] = WtpShowNode->wtpSupportRadioId[j];
		                struct SSIDStatsInfo_sub_wlan *sub_wlan = NULL;
						struct SSIDStatsInfo_sub_wlan_v2 *sub_wlan_v2 = NULL;
						struct SSIDStatsInfo_sub_wlan_v2 *search_node = NULL;
						for(k=0,sub_wlan = Radioid_info_node->SSIDStatsInfo_sub_wlan_head;
							((k<Radioid_info_node->radioBwlanNum)&&(NULL != sub_wlan));
							k++,sub_wlan = sub_wlan->next)
						{
							int is_exist = 0;
							if(j > 0)	/*从第二个radio开始查找*/
							{
								if(WtpShowNode_v2->SSIDStatsInfo_sub_wlan_head != NULL)
								{
									search_node = WtpShowNode_v2->SSIDStatsInfo_sub_wlan_head->next;
									while(search_node != NULL)
									{
										if(search_node->wlanCurrID == Radioid_info_node->RadioidSupportSSID[k])/*如果已经有radio绑定该wlan*/
										{
											is_exist = 1;
											break;
										}
										else
										{
											search_node = search_node->next;
										}
									}
								}
							}
							if(is_exist == 1)/*如果已经有radio绑定该wlan，以下数据进行累加*/
							{
								search_node->SSIDChStatsDwlinkTotRetryPkts += sub_wlan->SSIDChStatsDwlinkTotRetryPkts;
								search_node->SSIDChStatsUplinkUniFrameCnt += sub_wlan->SSIDChStatsUplinkUniFrameCnt;
								search_node->SSIDChStatsDwlinkUniFrameCnt += sub_wlan->SSIDChStatsDwlinkUniFrameCnt;
								search_node->SSIDUpChStatsFrameNonUniFrameCnt += sub_wlan->SSIDUpChStatsFrameNonUniFrameCnt;
								search_node->SSIDDownChStatsFrameNonUniFrameCnt += sub_wlan->SSIDDownChStatsFrameNonUniFrameCnt;
								search_node->SSIDDwlinkTotFrameCnt += sub_wlan->SSIDDwlinkTotFrameCnt;
								search_node->SSIDUplinkTotFrameCnt += sub_wlan->SSIDUplinkTotFrameCnt;
								search_node->SSIDRxCtrlFrameCnt += sub_wlan->SSIDRxCtrlFrameCnt;
								search_node->SSIDRxDataFrameCnt += sub_wlan->SSIDRxDataFrameCnt;
								search_node->SSIDRxAuthenFrameCnt += sub_wlan->SSIDRxAuthenFrameCnt;
								search_node->SSIDRxAssociateFrameCnt += sub_wlan->SSIDRxAssociateFrameCnt;
								search_node->SSIDTxCtrlFrameCnt += sub_wlan->SSIDTxCtrlFrameCnt;
								search_node->SSIDTxDataFrameCnt += sub_wlan->SSIDTxDataFrameCnt;
								search_node->SSIDTxAuthenFrameCnt += sub_wlan->SSIDTxAuthenFrameCnt;
								search_node->SSIDTxAssociateFrameCnt += sub_wlan->SSIDTxAssociateFrameCnt;
								search_node->SSIDApChStatsNumStations += sub_wlan->SSIDApChStatsNumStations;
								search_node->wtpSSIDMaxLoginUsr += sub_wlan->wtpSSIDMaxLoginUsr;
								search_node->SSIDDwErrPkts += sub_wlan->SSIDDwErrPkts;
								search_node->SSIDDwDropPkts += sub_wlan->SSIDDwDropPkts;
								search_node->SSIDDwTotErrFrames += sub_wlan->SSIDDwTotErrFrames;
								search_node->SSIDUpErrPkts += sub_wlan->SSIDUpErrPkts;
								search_node->SSIDUpDropPkts += sub_wlan->SSIDUpDropPkts;
								search_node->SSIDUpTotErrFrames += sub_wlan->SSIDUpTotErrFrames;
								search_node->SSIDAccessTimes += sub_wlan->SSIDAccessTimes;
							}
							else/*否则，建立新的节点*/
							{
								sub_wlan_v2=(struct SSIDStatsInfo_sub_wlan_v2 *)malloc(sizeof(struct SSIDStatsInfo_sub_wlan_v2));			
								if(sub_wlan_v2 != NULL)
								{
									memset(sub_wlan_v2,0,sizeof(struct SSIDStatsInfo_sub_wlan_v2));
									sub_wlan_v2->wlanCurrID = Radioid_info_node->RadioidSupportSSID[k];
									sub_wlan_v2->SSIDChStatsDwlinkTotRetryPkts = sub_wlan->SSIDChStatsDwlinkTotRetryPkts;
									sub_wlan_v2->SSIDChStatsUplinkUniFrameCnt = sub_wlan->SSIDChStatsUplinkUniFrameCnt;
									sub_wlan_v2->SSIDChStatsDwlinkUniFrameCnt = sub_wlan->SSIDChStatsDwlinkUniFrameCnt;
									sub_wlan_v2->SSIDUpChStatsFrameNonUniFrameCnt = sub_wlan->SSIDUpChStatsFrameNonUniFrameCnt;
									sub_wlan_v2->SSIDDownChStatsFrameNonUniFrameCnt = sub_wlan->SSIDDownChStatsFrameNonUniFrameCnt;
									sub_wlan_v2->SSIDDwlinkTotFrameCnt = sub_wlan->SSIDDwlinkTotFrameCnt;
									sub_wlan_v2->SSIDUplinkTotFrameCnt = sub_wlan->SSIDUplinkTotFrameCnt;
									sub_wlan_v2->SSIDRxCtrlFrameCnt = sub_wlan->SSIDRxCtrlFrameCnt;
									sub_wlan_v2->SSIDRxDataFrameCnt = sub_wlan->SSIDRxDataFrameCnt;
									sub_wlan_v2->SSIDRxAuthenFrameCnt = sub_wlan->SSIDRxAuthenFrameCnt;
									sub_wlan_v2->SSIDRxAssociateFrameCnt = sub_wlan->SSIDRxAssociateFrameCnt;
									sub_wlan_v2->SSIDTxCtrlFrameCnt = sub_wlan->SSIDTxCtrlFrameCnt;
									sub_wlan_v2->SSIDTxDataFrameCnt = sub_wlan->SSIDTxDataFrameCnt;
									sub_wlan_v2->SSIDTxAuthenFrameCnt = sub_wlan->SSIDTxAuthenFrameCnt;
									sub_wlan_v2->SSIDTxAssociateFrameCnt = sub_wlan->SSIDTxAssociateFrameCnt;
									sub_wlan_v2->SSIDApChStatsNumStations = sub_wlan->SSIDApChStatsNumStations;
									sub_wlan_v2->wtpSSIDMaxLoginUsr = sub_wlan->wtpSSIDMaxLoginUsr;
									sub_wlan_v2->wtpSSIDState = sub_wlan->wtpSSIDState;
									sub_wlan_v2->wtpSSIDSecurityPolicyID = sub_wlan->wtpSSIDSecurityPolicyID;
									sub_wlan_v2->wtpSSIDLoadBalance = sub_wlan->wtpSSIDLoadBalance;
									if(sub_wlan->wtpSSIDESSID)
									{
										sub_wlan_v2->wtpSSIDESSID = (char*)malloc(strlen(sub_wlan->wtpSSIDESSID)+1);						 
										if(sub_wlan_v2->wtpSSIDESSID)
										{
											memset(sub_wlan_v2->wtpSSIDESSID, 0, strlen(sub_wlan->wtpSSIDESSID)+1);
											strcpy(sub_wlan_v2->wtpSSIDESSID,sub_wlan->wtpSSIDESSID);
										}
									}
									sub_wlan_v2->wtpSSIDName = (char*)malloc(MAC_LEN + 1);						 
									if(sub_wlan_v2->wtpSSIDName)
									{
										memset(sub_wlan_v2->wtpSSIDName, 0, (MAC_LEN + 1));
										sub_wlan_v2->wtpSSIDName[0] = sub_wlan->wtpSSIDName[0];
										sub_wlan_v2->wtpSSIDName[1] = sub_wlan->wtpSSIDName[1];
										sub_wlan_v2->wtpSSIDName[2] = sub_wlan->wtpSSIDName[2];
										sub_wlan_v2->wtpSSIDName[3] = sub_wlan->wtpSSIDName[3];
										sub_wlan_v2->wtpSSIDName[4] = sub_wlan->wtpSSIDName[4];
										sub_wlan_v2->wtpSSIDName[5] = sub_wlan->wtpSSIDName[5];
									}

									sub_wlan_v2->vlanid = sub_wlan->vlanid;
									sub_wlan_v2->SSIDDwErrPkts = sub_wlan->SSIDDwErrPkts;
									sub_wlan_v2->SSIDDwDropPkts = sub_wlan->SSIDDwDropPkts;
									sub_wlan_v2->SSIDDwTotErrFrames = sub_wlan->SSIDDwTotErrFrames;
									sub_wlan_v2->SSIDUpErrPkts = sub_wlan->SSIDUpErrPkts;
									sub_wlan_v2->SSIDUpDropPkts = sub_wlan->SSIDUpDropPkts;
									sub_wlan_v2->SSIDUpTotErrFrames = sub_wlan->SSIDUpTotErrFrames;
									sub_wlan_v2->SSIDAccessTimes = sub_wlan->SSIDAccessTimes;
									
									sub_wlan_v2->next=NULL;
									if(sub_wlan_tail)
									{
										sub_wlan_tail->next=sub_wlan_v2;
										sub_wlan_tail=sub_wlan_v2;
									}
								}					
							}
						}
					}
				}
				WtpShowNode_v2->next=NULL;
				if(WtpShowNode_tail)
				{
					WtpShowNode_tail->next=WtpShowNode_v2;
					WtpShowNode_tail=WtpShowNode_v2;
				}
			}
		}
		retu = 1;
	}
	else if (ret == WID_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -1;
	}
	else
	{
		retu = -2;
	}
	Free_show_all_wlan_ssid_stats_information_cmd(WtpHead);
	return retu;
}


void Free_show_all_wtp_collect_information_cmd(struct WtpCollectInfo *WtpHead)
{
	void (*dcli_init_free_func)(struct WtpCollectInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpCollectInfo");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpHead);
		}
	}
}

/*只要调用，就通过Free_show_all_wtp_collect_information_cmd()释放空间*/
int show_all_wtp_collect_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct WtpCollectInfo **WtpHead)
																								/*返回0表示失败，返回1表示成功*/
																				                /*返回-1表示There is no WTP now*/
																				                /*返回-2表示error*/
																								/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int num = 0;
	int retu;

	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *, 
							unsigned int *, 
							unsigned int *
						);

	*WtpHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_collect_info_of_all_wtp");
		if(NULL != dcli_init_func)
		{
			*WtpHead = (*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 connection, 
					 &num, 
					 &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if((*WtpHead!=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if (ret == WID_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -1;
	}
	else
	{	
		retu = -2;
	}
	
	return retu;
}

void Free_show_ath_statistics_info_of_all_wtp_cmd(struct WtpAthStatisticInfo *WtpHead)
{
	void (*dcli_init_free_func)(struct WtpAthStatisticInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpAthStatisticInfo");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpHead);
		}
	}
}

/*返回1时，调用Free_show_ath_statistics_info_of_all_wtp_cmd()释放空间*/
int show_ath_statistics_info_of_all_wtp_cmd(dbus_parameter parameter, DBusConnection *connection,struct WtpAthStatisticInfo **WtpHead)
																									   /*返回0表示失败，返回1表示成功*/
																					                   /*返回-1表示there is no ath interface*/
																					                   /*返回-2表示WID can't find wtp*/
																									   /*返回-3表示ASD can't find bss*/
																									   /*返回-4表示error*/
																									   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret =0;
	unsigned int wtp_num=0;
	int retu;

	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *, 
							unsigned int *, 
							unsigned int *
						);

    *WtpHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_ath_statistics_info_of_all_wtp");
		if(NULL != dcli_init_func)
		{
			*WtpHead = (*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 connection, 
					 &wtp_num, 
					 &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if((*WtpHead) && (ret==0))
	{
		retu = 1;
	}
	else if(ret == 0 && (*WtpHead) == NULL)
	{
		retu = -1;
	}
	else if(ret == WID_DBUS_ERROR ||ret == ASD_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -2;
	}
	else if(ret == ASD_BSS_NOT_EXIST)
	{
		retu = -3;
	}
	else
	{
		retu = -4;
	}

	return retu;
}

/*state为"enable"或"disable"*/
int set_ap_moment_infomation_enable_cmd(dbus_parameter parameter, DBusConnection *connection,int WtpID,char *state)
																						/*返回0表示失败，返回1表示成功*/
																						/*返回-1表示input patameter only with 'enable' or 'disable'*/
																						/*返回-2表示WTP ID非法，返回-3表示wtp id does not exist*/
																						/*返回-4表示wtp id does not run，返回-5表示The switch is already state*/
																						/*返回-6表示error*/
																						/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == state)
		return 0;
	
	int ret;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID = 0;
    int policy = 0;
	int retu;
	
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	
	if (!strcmp(state,"enable")){
		policy = 1;	
	}
	else if (!strcmp(state,"disable")){
		policy = 0;	
	}
	else{
		return -1;
	}
	/*for applying hansi node by nl  */
	/*================================================= */
	/*if((vty->node == CONFIG_NODE)||(vty->node == HANSI_NODE))
	{
		WTPID = 0;
		printf("wtpid in hansi  %d\n",WTPID);
	}
	else if(vty->node == WTP_NODE)
	{
		WTPID = (unsigned int)vty->index;
		printf("wtpid %d\n",WTPID);
	}
	else if(vty->node ==  HANSI_WTP_NODE)
	{
		WTPID = (unsigned int)vty->index_sub;
		printf("wtpid in hansi wtp %d\n",WTPID);
	}*/
	WTPID = WtpID;	
	if(WTPID >= WTP_NUM || WTPID == 0){
		syslog(LOG_DEBUG,"wtp id in set_ap_moment_infomation_enable_cmd is %d\n",WTPID);
		return -2;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);

	query = dbus_message_new_method_call(BUSNAME,OBJPATH,\
						INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_MOMENT_INFOMATION_SWITCH);
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply){
		if (dbus_error_is_set(&err)){
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu = 1;
	else if (ret == WTP_ID_NOT_EXIST)
		retu = -3;
	else if (ret == WTP_NOT_IN_RUN_STATE)
		retu = -4;
	else if (ret == VALUE_IS_NONEED_TO_CHANGE)
		retu = -5;
	else
		retu = -6;
		
	dbus_message_unref(reply);	
	return retu;			
}

/*value的范围是2-32767*/
int set_ap_moment_infomation_reportinterval_cmd(dbus_parameter parameter, DBusConnection *connection,char *value)
																					 /*返回0表示失败，返回1表示成功*/
																					 /*返回-1表示ap moment infomation reportinterval error*/
																					 /*返回-2表示The value is no need to change，返回-3表示error*/
																					 /*返回-4表示unknown id format*/
																					 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == value)
		return 0;
	
	int ret;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
    unsigned int interval = 0;
	int retu;
	
	
	/*fengwenchao modify 20110412*/
	ret = parse_int_ID((char*)value, &interval);
	if(ret != WID_DBUS_SUCCESS){
		return -4;
	}	
	//interval = atoi(argv[0]);
	/*fengwenchao modify end*/
	
	if(interval > 32767 || interval < 2){
		return -1;
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,\
						INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_MOMENT_INFOMATION_REPORTINTERVAL);
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&interval,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply){
		if (dbus_error_is_set(&err)){
			dbus_error_free(&err);
		}		
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		retu = 1;
	}
	else if(ret == VALUE_IS_NONEED_TO_CHANGE)
	{
		retu = -2;
	}
	else
	{
		retu = -3;
	}
		
	dbus_message_unref(reply);	
	return retu;			
}

/*value的范围是2-32767*/
int set_ap_sample_infomation_reportinterval_cmd(dbus_parameter parameter, DBusConnection *connection,char *value)
																					/*返回0表示失败，返回1表示成功*/
																					/*返回-1表示ap sample infomation reportinterval error*/
																					/*返回-2表示The value is no need to change，返回-3表示error*/
																					/*返回-4表示unknown id format*/
																					/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	if(NULL == value)
		return 0;
	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	int ret;
    unsigned int interval = 0;	
	int retu;

	ret = parse_int_ID((char*)value, &interval);
	if(ret != WID_DBUS_SUCCESS){
		return -4;
	}	
	//interval = atoi(argv[0]);
	/*fengwenchao modify end*/
	
	
	if(interval > 32767 || interval < 2){
		return -1;
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,\
						INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_SAMPLE_INFOMATION_REPORTINTERVAL);
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&interval,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply){
		if (dbus_error_is_set(&err)){
			dbus_error_free(&err);
		}		
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		retu = 1;
	}
	else if(ret == VALUE_IS_NONEED_TO_CHANGE)
	{
		retu = -2;
	}
	else
	{
		retu = -3;
	}
		
	dbus_message_unref(reply);	
	return retu;			
}

/*value的范围是10-32767*/
int set_ap_routine_infomation_reportinterval_cmd(dbus_parameter parameter, DBusConnection *connection,char *value)
																					/*返回0表示失败，返回1表示成功*/
																					/*返回-1表示ap routine infomation reportinterval error*/
																					/*返回-2表示The value is no need to change，返回-3表示error*/
																					/*返回-4表示unknown id format*/
																					/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == value)
		return 0;
	
	int ret;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
    unsigned int interval = 0;
	int retu;

	ret = parse_int_ID((char*)value, &interval);
	if(ret != WID_DBUS_SUCCESS){
		return -4;
	}	
	//interval = atoi(argv[0]);
	/*fengwenchao modify end*/
	
	
	if(interval > 32767 || interval < 10){
		return -1;
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,\
						INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_ROUTINE_INFOMATION_REPORTINTERVAL);
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&interval,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply){
		if (dbus_error_is_set(&err)){
			dbus_error_free(&err);
		}		
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		retu = 1;
	}
	else if(ret == VALUE_IS_NONEED_TO_CHANGE)
	{
		retu = -2;
	}
	else
	{
		retu = -3;
	}
		
	dbus_message_unref(reply);	
	return retu;			
}

int show_ap_moment_information_reportinterval_cmd(dbus_parameter parameter, DBusConnection *connection,struct ap_reportinterval_profile *reportinterval_info)/*返回0表示失败，返回1表示成功，返回-1表示error*/
																																										/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == reportinterval_info)
		return 0;

	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;

	int ret=0;
	unsigned int moment_report_value = 0;
	unsigned int routine_report_value = 0;
	unsigned char moment_report_switch = 0;
	int collect_time = 3500;
	unsigned int sample_time = 5;
	int retu;

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,\
						INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_MOMENT_INFOMATION_REPORTINTERVAL);
	
	dbus_error_init(&err);	
	
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);

	if (NULL == reply){
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0 )
	{
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(moment_report_value));	

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(routine_report_value));	

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(moment_report_switch));	

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(collect_time));	

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(sample_time));	
 		
		reportinterval_info->moment_report_value = moment_report_value;
		reportinterval_info->routine_report_value = routine_report_value;
		reportinterval_info->moment_report_switch = moment_report_switch;
		reportinterval_info->collect_time = collect_time;
		reportinterval_info->sample_time = sample_time;
		
		retu = 1;
	}	
	else
	{
		retu = -1;
	}

	dbus_message_unref(reply);	
	return retu;
}

int set_trap_ignore_wtp_cmd(dbus_parameter parameter, DBusConnection *connection,int WtpID,char *percent)
																		 /*返回0表示失败，返回1表示成功*/
																		 /*返回-1表示WTP ID非法，返回-2表示input patameter error*/
																		 /*返回-3表示input patameter must be number*/
																		 /*返回-4表示input patameter must between 0 and 100，返回-5表示error*/
																		 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == percent)
		return 0;
	
    int ret;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	
	unsigned int wtpid;
	int retu;
	
	/*if((vty->node == CONFIG_NODE)||(vty->node == ENABLE_NODE))
	{
		wtpid = 0;
	}else if(vty->node == WTP_NODE)
	{
		wtpid = (unsigned int)vty->index;
	}*/
	wtpid = WtpID;
	if(wtpid >= WTP_NUM || wtpid == 0){
		syslog(LOG_DEBUG,"wtp id in set_trap_ignore_wtp_cmd is %d\n",wtpid);
		return -1;
	}
	
	if ( NULL == percent ) {
		return -2;
	}
	int i = 0;
	for( i = 0; i < strlen(percent); i++ ){
	    if(percent[i] < '0' || percent[i] > '9'){
		    return -3;
	    }
	}
    int trap_percent = atoi(percent);
    if( trap_percent > 100 || trap_percent < 0 ){
		return -4;
    }

    ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_INTERFACE,INTERFACE);

    query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SET_WTP_TRAP_IGNORE_PERCENT);
	dbus_error_init(&err);

	dbus_message_append_args(query,
	                    DBUS_TYPE_UINT32,&wtpid,
						DBUS_TYPE_UINT32,&trap_percent,						
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);

	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		retu = 1;
	}
	else
	{
		retu = -5;
	}

	dbus_message_unref(reply);
    return retu;
}

int show_hide_quit_wtp_cmd(dbus_parameter parameter, DBusConnection *connection,int *value)
															/*返回0表示失败，返回1表示成功*/
															/*返回-1表示the value of hide_quit_wtp_in is invalid*/
															/*返回-2表示error*/
															/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	int retu = 1;
	
	int switch_val =0;

	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_INTERFACE,INTERFACE);
	
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SHOW_HIDE_QUIT_WTP_INFOR_IN_MIB_SHOWING);
	
	dbus_error_init(&err);
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	dbus_message_unref(query);

	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == WID_DBUS_SUCCESS)
	{	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&switch_val);

		*value = switch_val;
		if(1 == switch_val)
			;
		else if(0 == switch_val)
			;
		else 
			retu = -1;
	}
	else
	{
		retu = -2;
	}
	
	dbus_message_unref(reply);	
	return retu;	
}

/*type为"neighborchannelrssi"或"samechannelrssi"*/
/*Value的范围是-120到0*/
int set_wtp_trap_neighbor_same_channelrssithreshold_cmd(dbus_parameter parameter, DBusConnection *connection,int WtpID,char *type,char *Value)
																									 /*返回0表示失败，返回1表示成功*/
																									 /*返回-1表示WTP ID非法*/
																									 /*返回-2表示input patameter only with 'neighborchannelrssi' or 'samechannelrssi'*/
																									 /*返回-3表示unknown id format，返回-4表示input patameter should be -120 to 0*/
																									 /*返回-5表示wtp id does not run，返回-6表示error*/
																									 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if (NULL == connection)
        return 0;
	
	if((NULL == type)||(NULL == Value))
		return 0;
	
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;
	int value;
	int ret = WID_DBUS_SUCCESS;
	int policy = 0;
	unsigned int wtp_id = 0;
	char BUSNAME[PATH_LEN];
    char OBJPATH[PATH_LEN];
    char INTERFACE[PATH_LEN];
	int retu;
	
	wtp_id = WtpID;
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		syslog(LOG_DEBUG,"wtp id in set_wtp_trap_neighbor_same_channelrssithreshold_cmd is %d\n",wtp_id);
		return -1;
	}
	
	if (!strcmp(type,"neighborchannelrssi"))
	{
		policy = 1; 
	}
	else if (!strcmp(type,"samechannelrssi"))
	{
		policy = 2; 
	}
	
   else
	{
		return -2;
	}
  
  
    ret = parse_signedint_ID((char*)Value,&value);


    if(ret != WID_DBUS_SUCCESS)
    {
    	return -3;
    }
    if (value < -120 || value > 0)
    {	
     	return -4;
    }

    ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
    ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_OBJPATH,OBJPATH);
    ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_INTERFACE,INTERFACE);

	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SET_NEIGHBOR_SAME_CHANNELRSSI_THRESHOLD);
	dbus_error_init(&err);
	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_UINT32,&value,
							 DBUS_TYPE_INVALID);
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	dbus_message_unref(query);
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	
	if(ret == 0)
	{
		retu = 1;
	}	
	else if (ret == WTP_NOT_IN_RUN_STATE)
	{
		retu = -5;
	}
	else
	{
		retu = -6;
	}
	dbus_message_unref(reply);
	return retu; 		
}

/*config节点下WtpID为0*/
/*value的范围是5-900*/
int set_ap_cpu_collect_time_cmd(dbus_parameter parameter, DBusConnection *connection,int WtpID,char *Value) 
																			 /*返回0表示失败，返回1表示成功*/
																			 /*返回-1表示WTP ID非法，返回-2表示error*/
																			 /*返回-3表示unknown id format*/
																			 /*返回-4表示input collect time should be 5~900*/
																			 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == Value)
		return 0;
		
	int ret;
	DBusMessage *query, *reply;	
	DBusMessageIter  iter;
	DBusError err;
	unsigned int wtpid;
	dbus_error_init(&err);
	
	int collect_time = 300;
	int retu = 0;
	
	/*if((vty->node == CONFIG_NODE)||(vty->node == ENABLE_NODE)||(vty->node == HANSI_NODE))
	{
		wtpid = 0;
		printf("wtpid in hansi  %d\n",wtpid);
	}
	else if(vty->node == WTP_NODE)
	{
		wtpid = (unsigned int)vty->index;
		printf("wtpid %d\n",wtpid);
	}
	else if(vty->node ==  HANSI_WTP_NODE)
	{
		wtpid = (unsigned int)vty->index_sub;
		printf("wtpid in hansi wtp %d\n",wtpid);
	}*/
	wtpid = WtpID;
	if(wtpid >= WTP_NUM || wtpid < 0){
		syslog(LOG_DEBUG,"wtp id in set_ap_cpu_collect_time_cmd is %d\n",wtpid);
		return -1;
	}
	
	ret = parse_int_ID((char*)Value, &collect_time);
	if(ret != WID_DBUS_SUCCESS){
		return -3;
	}	
	//collect_time = atoi(argv[0]);
	if((collect_time < 5)||(collect_time > 900))
	{
		return -4;
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_AP_COLLECT_TIME);
	
	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpid,
						DBUS_TYPE_UINT32,&collect_time,
						DBUS_TYPE_INVALID);
	
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);

	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu = 1;
	else
		retu = -2;
	
	dbus_message_unref(reply);	

	return retu; 
}

#if _GROUP_POLICY
void Free_set_ap_terminal_distrub_infomation_switch_cmd_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-7时，调用Free_set_ap_terminal_distrub_infomation_switch_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*state为"enable"或"disable"*/
int set_ap_terminal_distrub_infomation_switch_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *state,struct WtpList **WtpList_Head)
							/*返回0表示失败，返回1表示成功，返回-1表示input patameter only with 'enable' or 'disable'*/
							/*返回-2表示WTP ID非法，返回-3表示wtp id does not exist，返回-4表示wtp id does not run*/
							/*返回-5表示error，返回-6表示Group ID非法，返回-7表示partial failure*/
							/*返回-8表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	if(NULL == state)
	{
		*WtpList_Head = NULL;
		return 0;
	}
	
    int policy = 0;
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	int retu = 0;	

	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -1;
	}

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id < 0){
			syslog(LOG_DEBUG,"wtp id in set_ap_terminal_distrub_infomation_switch_cmd_group is %d\n",id);
			return -2;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_ap_terminal_distrub_infomation_switch_cmd_group is %d\n",id);
			return -6;
		}
	}

	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						int ,
						int *,
						unsigned int *
						);
						
    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_ap_terminal_distrub_infomation_switch_cmd_set_ap_switch");
		if(NULL != dcli_init_func)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id, 
					  parameter.local_id,
					  connection, 
					  type, 
					  id, 
					  policy, 
					  &count, 
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if (ret == WTP_ID_NOT_EXIST)
			retu = -3;
		else if (ret == WTP_NOT_IN_RUN_STATE)
			retu = -4;
		else
			retu = -5;
	}
	
	if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL))
			{
				retu = -7;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++)
				{
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);
					vty_out(vty,"%c",Wtp_Show_Node->FailReason);
				}	
				
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -8;
		}
	return retu;			
}
#endif

/*state为"enable"或"disable"*/
int set_ap_terminal_distrub_infomation_switch_cmd(dbus_parameter parameter, DBusConnection *connection,int WtpID,char *state)
																								/*返回0表示失败，返回1表示成功，返回-1表示input patameter only with 'enable' or 'disable'*/
																								/*返回-2表示WTP ID非法，返回-3表示wtp id does not exist，返回-4表示wtp id does not run*/
																								/*返回-5表示error*/
																								/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == state)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_ap_terminal_distrub_infomation_switch_cmd_group(parameter, connection,0,WtpID,state,&WtpList_Head);
	if(retu == -7)
	{
		Free_set_ap_terminal_distrub_infomation_switch_cmd_group(WtpList_Head);
	}
	return retu;
#else
	int ret;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID = 0;
    int policy = 0;
	int retu = 0;
	
	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -1;
	}

	//WTPID = (unsigned int)vty->index;


	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
		
	WTPID = WtpID;
	if(WTPID >= WTP_NUM || WTPID < 0){
		syslog(LOG_DEBUG,"wtp id in set_ap_terminal_distrub_infomation_switch_cmd is %d\n",WTPID);
		return -2;
	}
		
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);

	query = dbus_message_new_method_call(BUSNAME,OBJPATH,\
						INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_TERMINAL_DISTRUB_INFOMATION_SWITCH);
						
	dbus_error_init(&err);
	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		retu = 1;
	}
	else if (ret == WTP_ID_NOT_EXIST)
	{
		retu = -3;
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
	{
		retu = -4;
	}
	else
	{
		retu = -5;
	}
		
	dbus_message_unref(reply);
	return retu;			
#endif	
}

#if _GROUP_POLICY
void Free_set_ap_terminal_distrub_infomation_pkt_cmd_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-7时，调用Free_set_ap_terminal_distrub_infomation_pkt_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*value的范围是0-50000*/
int set_ap_terminal_distrub_infomation_pkt_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *value,struct WtpList **WtpList_Head)
							/*返回0表示失败，返回1表示成功，返回-1表示ap terminal distrub infomation reportpkt error*/
							/*返回-2表示WTP ID非法，返回-3表示wtp id does not exist，返回-4表示wtp id does not run*/
							/*返回-5表示error，返回-6表示Group ID非法，返回-7表示partial failure*/
							/*返回-8表示group id does not exist，返回-9表示unknown id format*/
{
    if(NULL == connection)
        return 0;
        
	if(NULL == value)
	{
		*WtpList_Head = NULL;
		return 0;
	}
	
	int count = 0;
	int pkt = 0;
	int ret = WID_DBUS_SUCCESS;
	unsigned int type = 0;
	unsigned int id = 0;
	int retu = 0;	
	
	ret = parse_int_ID((char*)value, &pkt);
	if(ret != WID_DBUS_SUCCESS){
		return -9;
	}
	//pkt = atoi(argv[0]);
	
	
	if(pkt > 50000 || pkt < 0){
		return -1;
	}

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id < 0){
			syslog(LOG_DEBUG,"wtp id in set_ap_terminal_distrub_infomation_pkt_cmd_group is %d\n",id);
			return -2;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_ap_terminal_distrub_infomation_pkt_cmd_group is %d\n",id);
			return -6;
		}
	}

	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						int ,
						int *,
						unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_ap_terminal_distrub_infomation_pkt_cmd_set_ap_terminal_distrub_infomation_reportpkt");
		if(NULL != dcli_init_func)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection, 
					  type, 
					  id, 
					  pkt, 
					  &count, 
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if (ret == WTP_ID_NOT_EXIST)
			retu = -3;
		else if (ret == WTP_NOT_IN_RUN_STATE)
			retu = -4;
		else
			retu = -5;
	}
	if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL))
			{
				retu = -7;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++)
				{
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);
					vty_out(vty,"%c",Wtp_Show_Node->FailReason);
				}					
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -8;
	}
	return retu;			
}
#endif

/*value的范围是0-50000*/
int set_ap_terminal_distrub_infomation_pkt_cmd(dbus_parameter parameter, DBusConnection *connection,int WtpID,char *value)
																							/*返回0表示失败，返回1表示成功，返回-1表示ap terminal distrub infomation reportpkt error*/
																							/*返回-2表示WTP ID非法，返回-3表示wtp id does not exist，返回-4表示wtp id does not run*/
																							/*返回-5表示error，返回-9表示unknown id format*/
																							/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == value)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_ap_terminal_distrub_infomation_pkt_cmd_group(parameter, connection,0,WtpID,value,&WtpList_Head);
	if(retu == -7)
	{
		Free_set_ap_terminal_distrub_infomation_pkt_cmd_group(WtpList_Head);
	}
	return retu;
#else
	int ret;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID = 0;
    int pkt = 0;
	int retu = 0;
		
	ret = parse_int_ID((char*)value, &pkt);
	if(ret != WID_DBUS_SUCCESS){
		return -9;
	}
	//pkt = atoi(argv[0]);
	if(pkt > 50000 || pkt < 0){
		return -1;
	}


	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
			
	WTPID = WtpID;
	if(WTPID >= WTP_NUM || WTPID < 0){
		syslog(LOG_DEBUG,"wtp id in set_ap_terminal_distrub_infomation_pkt_cmd is %d\n",WTPID);
		return -2;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,\
						INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_TERMINAL_DISTRUB_INFOMATION_PKT);
						
	dbus_error_init(&err);
	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_UINT32,&pkt,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		retu = 1;
	}
	else if (ret == WTP_ID_NOT_EXIST)
	{
		retu = -3;
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
	{
		retu = -4;
	}
	else
	{
		retu = -5;
	}
		
	dbus_message_unref(reply);
	return retu;			
#endif	
}

#if _GROUP_POLICY
void Free_set_ap_terminal_distrub_infomation_sta_num_cmd_group(struct WtpList *WtpList_Head)
{
	void (*dcli_init_free_func)(struct WtpList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpList_Head);
		}
	}
}

/*返回-7时，调用Free_set_ap_terminal_distrub_infomation_sta_num_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*value的范围是1-50000*/
int set_ap_terminal_distrub_infomation_sta_num_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *value,struct WtpList **WtpList_Head) 
							/*返回0表示失败，返回1表示成功，返回-1表示ap terminal distrub infomation report sta_num error*/
							/*返回-2表示WTP ID非法，返回-3表示wtp id does not exist，返回-4表示wtp id does not run*/
							/*返回-5表示error，返回-6表示Group ID非法，返回-7表示partial failure*/
							/*返回-8表示group id does not exist，返回-9表示unknown id format*/
{
    if(NULL == connection)
        return 0;
        
	if(NULL == value)
	{
		*WtpList_Head = NULL;
		return 0;
	}
	
	int count = 0;
	int ret = WID_DBUS_SUCCESS;
	unsigned int type = 0;
	unsigned int id = 0;
	unsigned int sta_num = 0;
	int retu = 0;	
	
	ret = parse_int_ID((char*)value, &sta_num);
	if(ret != WID_DBUS_SUCCESS){
		return -9;
	}
	//sta_num = atoi(argv[0]);	
	
	if(sta_num > 50000 || sta_num <= 0){
		return -1;
	}

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id >= WTP_NUM || id < 0){
			syslog(LOG_DEBUG,"wtp id in set_ap_terminal_distrub_infomation_sta_num_cmd_group is %d\n",id);
			return -2;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_ap_terminal_distrub_infomation_sta_num_cmd_group is %d\n",id);
			return -6;
		}
	}

	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *,
						unsigned int ,
						unsigned int ,
						unsigned int ,
						int *,
						unsigned int *
						);

    *WtpList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_ap_terminal_distrub_infomation_sta_num_cmd_sta_num");
		if(NULL != dcli_init_func)
		{
			*WtpList_Head =(*dcli_init_func)
				  (
					  parameter.instance_id,
					  parameter.local_id,
					  connection, 
					  type, 
					  id, 
					  sta_num, 
					  &count, 
					  &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if (ret == WTP_ID_NOT_EXIST)
			retu = -3;
		else if (ret == WTP_NOT_IN_RUN_STATE)
			retu = -4;
		else
			retu = -5;
	}
	if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*WtpList_Head!=NULL))
			{
				retu = -7;
				/*vty_out(vty,"wtp ");					
				for(i=0; i<count; i++)
				{
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;
	
					if(Wtp_Show_Node == NULL)
						break;
						
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);
					vty_out(vty,"%c",Wtp_Show_Node->FailReason);
				}						
				vty_out(vty," failed.\n");*/
			}
			}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -8;
	}		
	return retu;			
}
#endif

/*value的范围是1-50000*/
int set_ap_terminal_distrub_infomation_sta_num_cmd(dbus_parameter parameter, DBusConnection *connection,int WtpID,char *value) 
																									/*返回0表示失败，返回1表示成功，返回-1表示ap terminal distrub infomation report sta_num error*/
																									/*返回-2表示WTP ID非法，返回-3表示wtp id does not exist，返回-4表示wtp id does not run*/
																									/*返回-5表示error，返回-9表示unknown id format*/
																									/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == value)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct WtpList *WtpList_Head = NULL;

	retu = set_ap_terminal_distrub_infomation_sta_num_cmd_group(parameter, connection,0,WtpID,value,&WtpList_Head);
	if(retu == -7)
	{
		Free_set_ap_terminal_distrub_infomation_sta_num_cmd_group(WtpList_Head);
	}
	return retu;
#else
	int ret;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID = 0;
    int sta_num = 0;
	int retu = 0;
	
	ret = parse_int_ID((char*)value, &sta_num);
	if(ret != WID_DBUS_SUCCESS){
		return -9;
	}
	//sta_num = atoi(argv[0]);	
	
	if(sta_num > 50000 || sta_num <= 0){
		return -1;
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	
	WTPID = WtpID;
	if(WTPID >= WTP_NUM || WTPID < 0){
		syslog(LOG_DEBUG,"wtp id in set_ap_terminal_distrub_infomation_sta_num_cmd is %d\n",WTPID);
		return -2;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);

	query = dbus_message_new_method_call(BUSNAME,OBJPATH,\
						INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_TERMINAL_DISTRUB_INFOMATION_STA_NUM);
						
	dbus_error_init(&err);
	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_UINT32,&sta_num,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		retu = 1;
	}
	else if (ret == WTP_ID_NOT_EXIST)
	{
		retu = -3;
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
	{
		retu = -4;
	}
	else
	{
		retu = -5;
	}
		
	dbus_message_unref(reply);
	return retu;			
#endif	
}

void Free_show_wlan_radio_information_cmd(struct WtpWlanRadioInfo *WtpHead)
{
	void (*dcli_init_free_func)(struct WtpWlanRadioInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_wtp_wlan_radio_info_head");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpHead);
		}
	}
}

/*返回1时，调用Free_show_wlan_radio_information_cmd()释放空间*/
int show_wlan_radio_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct WtpWlanRadioInfo **WtpHead)
																							  /*返回0表示失败，返回1表示成功*/
																							  /*返回-1表示there is no wlan，返回-2表示Malloc Error*/
																							  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
    int ret = 0;
	unsigned int wlan_num = 0;
	int retu = 0;

	void *(*dcli_init_func)(
							DBusConnection *, 
							unsigned int *, 
							unsigned int *,
							int ,
							int 
						);

    *WtpHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_Wlan_Radio_Info_of_all_Wtp");
		if(NULL != dcli_init_func)
		{
			*WtpHead = (*dcli_init_func)
				  (
					 connection,
					 &wlan_num,
					 &ret,
					 parameter.instance_id,
					 parameter.local_id
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if((*WtpHead!=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if ((NULL == *WtpHead) && (MALLOC_ERROR != ret)) {
        retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret==WLAN_ID_NOT_EXIST)
	{
		retu = -1;
	}
	else if(ret==MALLOC_ERROR)
	{
		retu = -2;
    }
	
	return retu;
}

void Free_show_all_wtp_network_info_cmd(struct WtpNetworkInfo *WtpHead)
{
	void (*dcli_init_free_func)(struct WtpNetworkInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpNetworkInfo");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpHead);
		}
	}
}

/*只要调用，就通过Free_show_all_wtp_network_info_cmd()释放空间*/
int show_all_wtp_network_info_cmd(dbus_parameter parameter, DBusConnection *connection,struct WtpNetworkInfo **WtpHead)
																						 /*返回0表示失败，返回1表示成功*/
																						 /*返回-1表示error*/
																						 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
    if(NULL == connection)
        return 0;    

	int ret = 0;
	unsigned int num = 0;
	int retu = 0;	

	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *, 
							unsigned int *, 
							unsigned int *
						);

    *WtpHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle, "show_all_wtp_network_info");
		if(NULL != dcli_init_func)
		{
			*WtpHead = (*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 connection, 
					 &num, 
					 &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if((*WtpHead!=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if ((NULL == *WtpHead) && (0 == ret)) {
        retu = SNMPD_CONNECTION_ERROR;
	}
	else
	{
		retu = -1;
	}

	return retu;
}

void Free_show_all_wtp_security_mech_information_cmd(struct SecurityMechInfo *WtpHead)
{
	void (*dcli_init_free_func)(struct SecurityMechInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_SecurityMechInfo");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpHead);
		}
	}
}

/*只要调用，就通过Free_show_all_wtp_security_mech_information_cmd()释放空间*/
int show_all_wtp_security_mech_information_cmd(dbus_parameter parameter, DBusConnection *connection,struct SecurityMechInfo **WtpHead)
																										   /*返回0表示失败，返回1表示成功*/
																										   /*返回-1表示There is no WTP now，返回-2表示error*/
																										   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret=0;
	unsigned int wtp_num = 0;
	int retu = 0;
	
	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *, 
							unsigned int *, 
							unsigned int *
						);

    *WtpHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_SecurityMechInfo_of_all_wtp");
		if(NULL != dcli_init_func)
		{
			*WtpHead = (*dcli_init_func)
				  (
					 parameter.instance_id,
					 parameter.local_id,
					 connection, 
					 &wtp_num, 
					 &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if((*WtpHead!=NULL)&&(ret == 0))
	{
		retu = 1;
	}	
	else if (ret == ASD_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == ASD_WTP_NOT_EXIST)
	{
		retu = -1;
	}
	else
	{
		retu = -2;
	}
	
	return retu;
}

void Free_show_wtp_config_of_all_cmd(struct WTP_CONFIG_INFORMATION *WTPconfig)
{
	void (*dcli_init_free_func)(struct WTP_CONFIG_INFORMATION *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_all_wtp_config_info");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WTPconfig);
		}
	}
}

/*只要调用，就通过Free_show_all_wtp_security_mech_information_cmd()释放空间*/
int show_wtp_config_of_all_cmd(dbus_parameter parameter, DBusConnection *connection,struct WTP_CONFIG_INFORMATION **WTPconfig)
																								/*返回0表示失败，返回1表示成功*/
																								/*返回-1表示error*/
																								/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
        return 0;
        
	int ret = 0.;
	int wtp_num = 0;
	int retu = 0;

	void *(*dcli_init_func)(
							DBusConnection *,
							int ,
							int ,
							int* ,
							int* 
						);

    *WTPconfig = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_wtp_config_all_wtp");
		if(NULL != dcli_init_func)
		{
			*WTPconfig = (*dcli_init_func)
				  (
					 connection,
					 parameter.instance_id,
					 parameter.local_id,
					 &ret,
					 &wtp_num
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if((ret == 0)&&(wtp_num != 0)&&(*WTPconfig))
		retu = 1;
	else if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else
		retu = -1;

	return retu;	
}


void Free_show_wtp_list_byinterface_cmd(DCLI_WTP_API_GROUP_ONE *WTPINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_WTP_API_GROUP_ONE *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_wtp_free_fun");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_CONF_METHOD_WTPLIST_NEW_BYINTERFACE,WTPINFO);
		}
	}
}

/*返回1时，调用Free_show_all_wtp_security_mech_information_cmd()释放空间*/
int show_wtp_list_byinterface_cmd(dbus_parameter parameter, DBusConnection *connection,DCLI_WTP_API_GROUP_ONE **WTPINFO)/*返回0表示失败，返回1表示成功*/
																															  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret;
	int retu = 0;
	
	void *(*dcli_init_func)(
							int ,
							unsigned int ,
							unsigned int ,
							unsigned int ,
							unsigned int ,
							unsigned int* ,
							unsigned int* ,
							unsigned int* ,
							unsigned char *,
							unsigned char *,
							int *,
							DBusConnection *,
							char *
						);

    *WTPINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wtp_show_api_group_one");
		if(NULL != dcli_init_func)
		{
			*WTPINFO = (*dcli_init_func)
				  (
				 	parameter.instance_id,
					TENTH,/*"show wtp list by interface"*/
					0,
					0,
					0,
					0,/**/
					&ret,/*num2*/
					0,
					0,
					0,
					&(parameter.local_id),
					connection,
					WID_DBUS_CONF_METHOD_WTPLIST_NEW_BYINTERFACE
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(ret == -1)
		return SNMPD_CONNECTION_ERROR;
	else if((ret == 0)&&(*WTPINFO))
		retu = 1;

	return retu;	
}

void Free_count_ap_num_by_interface_head(AP_NUM_INF *head)
{
  AP_NUM_INF *f1,*f2;
  if(head)
  {
	  f1=head->next; 
	  if(f1 != NULL)
	  {
		  f2=f1->next;
		  while(f2!=NULL)
		  {
			FREE_OBJECT(f1);
			f1=f2;
			f2=f2->next;
		  }
		  FREE_OBJECT(f1);
	  }
  }
}

/*返回1时，调用Free_count_ap_num_by_interface_head()释放空间*/
int count_ap_num_by_interface(dbus_parameter parameter, DBusConnection *connection,AP_NUM_INF *ANIF_head)/*返回0表示失败，返回1表示成功*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == ANIF_head)
		return 0;
	
	int result = 0;
	DCLI_WTP_API_GROUP_ONE *WTPINFO;
	WID_WTP *head = NULL;
	int i = 0;
	AP_NUM_INF *q,*tail;
	AP_NUM_INF *fq;
	int is_exist = 0;	

	ANIF_head->next = NULL;
	tail=ANIF_head;
	
	result = show_wtp_list_byinterface_cmd(parameter, connection,&WTPINFO);
	if(result == 1)
	{
		if((WTPINFO)&&(WTPINFO->WTP_INFO)&&(WTPINFO->WTP_INFO->WTP_LIST))
		{
			head = WTPINFO->WTP_INFO->WTP_LIST; 
			for(i = 0; i < WTPINFO->WTP_INFO->list_len; i++)
			{	
				if(i == 0)
				{
					q=(AP_NUM_INF*)malloc(sizeof(AP_NUM_INF));
					if(q)
					{
						memset(q->if_name,0,255);
						if(head->apply_interface_name)
						{
							strcpy(q->if_name,head->apply_interface_name);
						}
						q->ap_num = 1;
						if(tail)
						{
							q->next=NULL;
							tail->next=q;
							tail=q;
						}
					}
				}
				else
				{
					fq=ANIF_head->next;
					while(fq!=NULL)
					{
						if((head->apply_interface_name)&&(strcmp(head->apply_interface_name,fq->if_name)==0))/*接口已存在*/
						{
							fq->ap_num++;
							is_exist = 1;
							break;
						}
						else
						{							
							fq=fq->next;
						}
					}	
					if(is_exist == 0)
					{
						q=(AP_NUM_INF*)malloc(sizeof(AP_NUM_INF));
						if(q)
						{
							memset(q->if_name,0,255);
							if(head->apply_interface_name)
							{
								strcpy(q->if_name,head->apply_interface_name);
							}
							q->ap_num = 1;
							q->next=NULL;
							if(tail)
							{
								tail->next=q;
								tail=q;
							}
						}
					}
				}						
				head = head->next;
				is_exist = 0;
			}
		}
	}
	if(result == 1)
	{
		Free_show_wtp_list_byinterface_cmd(WTPINFO);
	}
	
	return result;
}

void Free_show_statistcs_information_of_all_wtp_whole_cmd(struct WtpAthStatisticInfo *WtpHead)
{
	void (*dcli_init_free_func)(struct WtpAthStatisticInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_WtpAthStatisticInfo");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpHead);
		}
	}
}

/*返回1时，调用Free_show_statistcs_information_of_all_wtp_whole_cmd()释放空间*/
int show_statistcs_information_of_all_wtp_whole_cmd(dbus_parameter parameter, DBusConnection *connection,struct WtpAthStatisticInfo **WtpHead)
																	/*返回0表示失败，返回1表示成功*/
																	/*返回-1表示there is no ath interface*/
																	/*返回-2表示WID can't find wtp*/
																	/*返回-3表示error*/
																	/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
        return 0;

	int ret =0;
	unsigned int wtp_num=0;
	int retu = 0;
		
	void *(*dcli_init_func)(
							 int ,
							 int ,
							 DBusConnection *, 
							 unsigned int *, 
							 unsigned int *
						   );

    *WtpHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_statistcs_information_of_all_wtp_whole");
		if(NULL != dcli_init_func)
		{
			*WtpHead = (*dcli_init_func)
				  (
				 	parameter.instance_id,
				 	parameter.local_id,
				 	connection,
				 	&wtp_num,
				 	&ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(*WtpHead && (ret==0))
	{
		retu = 1;
	}
	else if(ret == 0 && *WtpHead == NULL)
	{
		retu = -1;
	}
	else if(ret == WID_DBUS_ERROR ||ret == ASD_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -2;
	}
	else
	{
		retu = -3;
	}	

	return retu;
}


void Free_show_all_wtp_station_statistic_information_cmd(struct WtpStationinfo *StaHead)
{
	void (*dcli_init_free_func)(struct WtpStationinfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_wtp_sta_info");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(StaHead);
		}
	}
}

/*返回1时，调用Free_show_all_wtp_station_statistic_information_cmd()释放空间*/
int show_all_wtp_station_statistic_information_cmd(dbus_parameter parameter, DBusConnection *connection, struct WtpStationinfo **StaHead)
																			/*返回0表示失败，返回1表示成功*/
																            /*返回-1表示There is no sta now*/
																            /*返回-2表示There is no WTP now，返回-3表示error*/
																			/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	
	int ret=0;
	unsigned int wtp_num;
	int retu = 0;
	
	void *(*dcli_init_func)(
							 int ,
							 int ,
							 DBusConnection *, 
							 unsigned int *, 
							 unsigned int *
						   );

    *StaHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_station_information_of_all_wtp");
		if(NULL != dcli_init_func)
		{
			*StaHead = (*dcli_init_func)
				  (
				 	parameter.instance_id,
				 	parameter.local_id,
				 	connection,
				 	&wtp_num,
				 	&ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(((*StaHead) !=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if (ret == 0)
	{
		retu = -1;
	}
	else if (ret == ASD_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == ASD_WTP_NOT_EXIST)
	{
		retu = -2;
	}
	else
	{
		retu = -3;
	}
	
	return retu;
}


void Free_show_ac_sta_information_cmd(struct WtpStationinfo *StaNode)
{
	void (*dcli_init_free_func)(struct WtpStationinfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_wtp_sta_info");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(StaNode);
		}
	}
}

/*返回1时，调用Free_show_all_wtp_station_statistic_information_cmd()释放空间*/
int show_ac_sta_information_cmd(dbus_parameter parameter, DBusConnection *connection, struct WtpStationinfo **StaNode)
																			/*返回0表示失败，返回1表示成功*/
																            /*返回-1表示There is no sta now*/
																            /*返回-2表示There is no BSS now，返回-3表示error*/
																			/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	int ret=0;
	unsigned int bss_num;
	int retu = 0;	

	void *(*dcli_init_func)(
							 int ,
							 int ,
							 DBusConnection *, 
							 unsigned int *, 
							 unsigned int *
						   );

    *StaNode = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_ac_station_information_of_all");
		if(NULL != dcli_init_func)
		{
			*StaNode = (*dcli_init_func)
				  (
				 	parameter.instance_id,
				 	parameter.local_id,
				 	connection,
				 	&bss_num,
				 	&ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	if(((*StaNode) !=NULL)&&(ret == 0))
	{
		retu = 1;
	}
	else if (ret == 0)
	{
		retu = -1;
	}
	else if (ret == ASD_DBUS_ERROR)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == ASD_BSS_NOT_EXIST)
	{
		retu = -2;
	}
	else
	{
		retu = -3;
	}

	return retu;
}

/*tar_file表示版本压缩文件名称，压缩格式是.tar.bz2*/
int bind_ap_model_with_file_config(dbus_parameter parameter, DBusConnection *connection,char *model,char *tar_file)
																						/*返回0表示失败，返回1表示成功*/
																						/*返回-1表示buf malloc failed*/
																						/*返回-2表示bind failed due to system cann't find file*/
																						/*返回-3表示wireless-control does not surport model*/
																						/*返回-4表示update is process,please wait several minutes*/
																						/*返回-5表示free memory is not enough*/
																						/*返回-6表示this model has been bound ever,please delete the bind relationship first*/
																						/*返回-7表示error*/
																						/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	int ret,retu = 0;
	DBusMessage *query, *reply;	
	DBusMessageIter  iter;
	DBusError err;

	char *buf_model;
	char *buf_name;
	int fd;

	if((NULL == model)||(NULL == tar_file))
		return 0;

	buf_model = (char*)malloc(strlen(model)+1);
	if(buf_model == NULL)
	{		
		return -1;
	}
	memset(buf_model, 0, strlen(model)+1);
	memcpy(buf_model, model, strlen(model));
	str2higher(&buf_model);

	buf_name = (char*)malloc(strlen(tar_file)+1);
	if(buf_name == NULL)
	{		
		FREE_OBJECT(buf_model);
		return -1;
	}
	memset(buf_name, 0, strlen(tar_file)+1);
	memcpy(buf_name, tar_file, strlen(tar_file));

	char syscmd[WID_SYSTEM_CMD_LENTH];
	memset(syscmd,0,WID_SYSTEM_CMD_LENTH);
	sprintf(syscmd,"/mnt/wtp/%s",buf_name);

	fd = open(syscmd, O_RDONLY);
	if(fd < 0){
		FREE_OBJECT(buf_model);
		FREE_OBJECT(buf_name);
		return -2;
	}
	else{
		close(fd);
	}

	dbus_error_init(&err);
	
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	ccgi_ReInitDbusPath_v2(parameter.local_id,parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id,parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id,parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_BIND_MODEL_WITH_FILE);

	dbus_message_append_args(query,
						DBUS_TYPE_STRING,&buf_model,
						DBUS_TYPE_STRING,&buf_name,
						DBUS_TYPE_INVALID);
	
	//vty_out(vty,"bind operation  running.......\n");
	reply = dbus_connection_send_with_reply_and_block (connection,query,300000, &err);

	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		FREE_OBJECT(buf_model);
		FREE_OBJECT(buf_name);
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu = 1;
	else if(ret == MODEL_NO_EXIST)
		retu = -3;
	else if(ret == UPDATE_PROCESS)
		retu = -4;
	else if(ret == MALLOC_ERROR)
		retu = -5;
	else if(ret == MODEL_BIND_EVER)
		retu = -6;
	else
		retu = -7;
	
	dbus_message_unref(reply);	
	
	FREE_OBJECT(buf_model);
	FREE_OBJECT(buf_name);	
	return retu; 
}

/*Count_onetime表示同时升级的AP个数，范围是1-50*/
int wtp_set_ap_update_base_model_config(dbus_parameter parameter, DBusConnection *connection,char *model)
																								/*返回0表示失败，返回1表示成功*/
																								/*返回-1表示malloc failed*/
																								/*返回-2表示wireless-control does not surport model*/
																								/*返回-3表示update is process,please wait several minutes*/
																							    /*返回-4表示model has been set ever, there's no need to set again*/
																								/*返回-5表示error*/
																								/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	int ret,retu = 0;
	DBusMessage *query, *reply;	
	DBusMessageIter  iter;
	DBusError err;

	char *buf_model = NULL;
	//int fd;
	
	if(NULL == model)
		return 0;	
	
	buf_model = (char*)malloc(strlen(model)+1);
	if(buf_model == NULL){		
		return -1;
	}
	memset(buf_model, 0, strlen(model)+1);
	memcpy(buf_model, model, strlen(model));	
	str2higher(&buf_model);

	dbus_error_init(&err);
	
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	ccgi_ReInitDbusPath_v2(parameter.local_id,parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id,parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id,parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_AP_UPDATE_BASE_MODEL);
	
	dbus_message_append_args(query,
						DBUS_TYPE_STRING,&buf_model,
						DBUS_TYPE_INVALID);
	
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);

	dbus_message_unref(query);

	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		FREE_OBJECT(buf_model);
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu = 1;
	else if(ret == WID_NO_SURPORT_MODEL)
		retu = -2;
	else if(ret == MODEL_BIND_EVER)
		retu = -4;
	else if(ret == UPDATE_PROCESS)
		retu = -3;
	else
		retu = -5;
	
	dbus_message_unref(reply);	

	FREE_OBJECT(buf_model);
	return retu; 
}

void Free_show_model_tar_file_bind_info(struct model_tar_file *head)
{
	struct model_tar_file *f1 = NULL,*f2 = NULL;
	if(head)
	{
		f1=head->next;
		if(f1)
		{
			f2=f1->next;
			while(f2!=NULL)
			{
			  free(f1->apmodel);
			  free(f1->filename);
			  free(f1);
			  f1=f2;
			  f2=f2->next;
			}
			free(f1->apmodel);
			free(f1->filename);
			free(f1);
		}
	}
}

/*返回1且model_tar_file_num>0时，调用Free_show_model_tar_file_bind_info()释放空间*/
int show_model_tar_file_bind_info(dbus_parameter parameter, DBusConnection *connection,struct model_tar_file *head,int *model_tar_file_num)
																/*返回0表示失败，返回1表示成功，返回-1表示error*/
																/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	int ret,retu = 1;
	int i=0,num=0;
	DBusMessage *query, *reply;	
	DBusMessageIter  iter;
	DBusMessageIter	 iter_array;		
	DBusError err;
	struct model_tar_file *q = NULL,*tail = NULL;

	dbus_error_init(&err);
	
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	ccgi_ReInitDbusPath_v2(parameter.local_id,parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id,parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id,parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SHOW_MODEL_BIND_INFO);
	
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);

	dbus_message_unref(query);

	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	char *apmodel = NULL;
	char *filename = NULL;

	head->next = NULL;
	tail=head;
	if(ret == 0 ){
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&num);
	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_recurse(&iter,&iter_array);

		fprintf(stderr,"num=%d\n",num);
		*model_tar_file_num = num;
		for (i = 0; i < num; i++) {
			DBusMessageIter iter_struct;
			
			dbus_message_iter_recurse(&iter_array,&iter_struct);
			dbus_message_iter_get_basic(&iter_struct,&(apmodel));	
			
			dbus_message_iter_next(&iter_struct);
			dbus_message_iter_get_basic(&iter_struct,&(filename));
				
			dbus_message_iter_next(&iter_array);
			
			q=(struct model_tar_file*)malloc(sizeof(struct model_tar_file));
			
			q->apmodel=(char *)malloc(strlen(apmodel)+1);
			memset(q->apmodel,0,strlen(apmodel)+1);
			memcpy(q->apmodel,apmodel,strlen(apmodel));
			
			q->filename=(char *)malloc(strlen(filename)+1);
			memset(q->filename,0,strlen(filename)+1);
			memcpy(q->filename,filename,strlen(filename));

			q->next=NULL;
			tail->next=q;
			tail=q;
			
		}
	}
	else
		retu = -1;
	
	dbus_message_unref(reply);
	return retu; 
}

int delete_model_bind_info_config(dbus_parameter parameter, DBusConnection *connection,char *model)
																	/*返回0表示失败，返回1表示成功*/
																	/*返回-1表示buf malloc failed*/
																	/*返回-2表示wireless-control does not surport model*/
																	/*返回-3表示update is process,please wait several minutes*/
																	/*返回-4表示this model hasn't been bound ever,please make sure that first*/
																	/*返回-5表示error*/
																	/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	int ret,retu = 0;
	DBusMessage *query, *reply;	
	DBusMessageIter  iter;
	DBusError err;
	
	if(NULL == model)
		return 0;

	char *buf_model;

	buf_model = (char*)malloc(strlen(model)+1);
	if(buf_model == NULL){		
		return -1;
	}
	memset(buf_model, 0, strlen(model)+1);
	memcpy(buf_model, model, strlen(model));
	str2higher(&buf_model);

	dbus_error_init(&err);
	
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	ccgi_ReInitDbusPath_v2(parameter.local_id,parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id,parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id,parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_DELETE_MODEL_BIND_INFO);

	dbus_message_append_args(query,
						DBUS_TYPE_STRING,&buf_model,
						DBUS_TYPE_INVALID);
	
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);

	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		FREE_OBJECT(buf_model);
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu = 1;
	else if(ret == MODEL_NO_EXIST)
		retu = -2;
	else if(ret == UPDATE_PROCESS)
		retu = -3;
	else if(ret == MODEL_BIND_NEVER)
		retu = -4;
	else
		retu = -5;
	
	dbus_message_unref(reply);	
	
	FREE_OBJECT(buf_model);	
	return retu; 
}

int wtp_clear_ap_one_model_update_config(dbus_parameter parameter, DBusConnection *connection,char *model)
																			  /*返回0表示失败，返回1表示成功*/
																			  /*返回-1表示buf malloc failed*/
																			  /*返回-2表示upgrade is in process,changement of configuration is not allowed now*/
																			  /*返回-3表示no update config information of model*/
																			  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;		

	int ret=0;
	int retu = 0;
	
	if(NULL == model)
		return 0;
	
	char *buf_model;

	buf_model = (char*)malloc(strlen(model)+1);
	if(buf_model == NULL){		
		return -1;
	}
	memset(buf_model, 0, strlen(model)+1);
	memcpy(buf_model, model, strlen(model));
	str2higher(&buf_model);

	dbus_error_init(&err);	
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	ccgi_ReInitDbusPath_v2(parameter.local_id,parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id,parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id,parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_CLEAR_ONE_MODEL_UPDATE_CONFIG);

	dbus_message_append_args(query,
						DBUS_TYPE_STRING,&buf_model,
						DBUS_TYPE_INVALID);
	
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err)) 
		{
			dbus_error_free(&err);
		}
		FREE_OBJECT(buf_model);
		return SNMPD_CONNECTION_ERROR;
	}

	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0 )
		retu = 1;
	else if(ret == UPDATE_PROCESS)
		retu = -2;
	else
		retu = -3;

	dbus_message_unref(reply);	

	FREE_OBJECT(buf_model);
	return retu;
}

/*Count_onetime表示同时升级的AP个数，范围是1-50*/
int wtp_set_ap_update_count_config(dbus_parameter parameter, DBusConnection *connection,char *Count_onetime)
																			  /*返回0表示失败，返回1表示成功*/
																			  /*返回-1表示unknown id format*/
																			  /*返回-2表示upgrade has already started,it's not allowed to set the value unless upgrade is stopped*/
																			  /*返回-3表示error*/
																			  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	int ret;
	DBusMessage *query, *reply;	
	DBusMessageIter  iter;
	DBusError err;
	int retu = 0;
	
	if(NULL == Count_onetime)
		return 0;

	unsigned char count_onetime;
	ret = wid_wtp_parse_char_ID((char*)Count_onetime, &count_onetime);
	if(ret != WID_DBUS_SUCCESS){
		return -1;
	}
	
	dbus_error_init(&err);
	
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	ccgi_ReInitDbusPath_v2(parameter.local_id,parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id,parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id,parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_AP_UPDATE_COUNT_ONETIME);
	
	dbus_message_append_args(query,
						DBUS_TYPE_BYTE,&count_onetime,
						DBUS_TYPE_INVALID);
	
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);

	dbus_message_unref(query);

	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu = 1;
	else if(ret == UPDATE_PROCESS)
		retu = -2;
	else
		retu = -3;
	
	dbus_message_unref(reply);	

	return retu; 
}
/*state的范围是"start"或"stop"*/
int wtp_set_ap_update_control_config(dbus_parameter parameter, DBusConnection *connection,char *state)
																	   /*返回0表示失败，返回1表示成功*/
																	   /*返回-1表示input parameter can only be 'start' or 'stop'*/
																	   /*返回-2表示there's no upgrade configuration,it should be configured first*/
																	   /*返回-3表示error*/
																	   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	int ret;
	DBusMessage *query, *reply;	
	DBusMessageIter  iter;
	DBusError err;
	unsigned char policy = 0;
	int retu = 0;

	if (!strcmp(state,"start"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"stop"))
	{
		policy = 2;	
	}
	else
	{
		return -1;
	}

	dbus_error_init(&err);
	
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	ccgi_ReInitDbusPath_v2(parameter.local_id,parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id,parameter.instance_id,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id,parameter.instance_id,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_AP_UPDATE_CONTROL);
	
	dbus_message_append_args(query,
						DBUS_TYPE_BYTE,&policy,
						DBUS_TYPE_INVALID);
	
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);

	dbus_message_unref(query);

	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu = 1;
	else if(ret == WID_NO_SURPORT_MODEL)
		retu = -2;
	else
		retu = -3;
	
	dbus_message_unref(reply);	

	return retu; 
}


/*dcli_radio.c V1.148*/
/*author qiaojie*/
/*update time 10-03-30*/


void Radio_Type(int RType,char *r)
{
  strcat(r,"11");
  if(((RType&IEEE80211_11A) > 0)
  	&&((RType&IEEE80211_11N) > 0)
  	&&((RType&IEEE80211_11AN) > 0)
  	&&(!(RType&IEEE80211_11B))
  	&&(!(RType&IEEE80211_11G)))
  {
	  strcat(r,"a/an");	
  }  
  else if(((RType&IEEE80211_11GN) > 0)
	  &&((RType&IEEE80211_11N)> 0)
	  &&((RType&IEEE80211_11G)>0)
	  &&(!(RType&IEEE80211_11B))
	  &&(!(RType&IEEE80211_11A)))
  {   
	  strcat(r,"g/gn");	
  } 			  
  else
  {
	  if((RType&IEEE80211_11A) > 0)
		strcat(r,"a");			
	  if((RType&IEEE80211_11B) > 0)
		strcat(r,"b");		  
	  if((RType&IEEE80211_11G) > 0)
		strcat(r,"g");		  
	  if((RType&IEEE80211_11N) > 0)
		strcat(r,"n");
  }
}



int parse_rate_list(char* ptr,int* count,int rate[])
{
	char* endPtr = NULL;
	int   i=0;
	endPtr = ptr;
	rate_list_state state = check_rate;

	while(1){
		switch(state)
		{
			
		case check_rate: 
			
				rate[i] = strtoul(endPtr,&endPtr,10);
			
				if(rate[i]>=10&&rate[i]<=540)
				{
            		state=check_comma;	
				}
				else
					state=check_fail;
				
				break;
		
		case check_comma: 
			
			if (RATE_SPLIT_COMMA == endPtr[0]){
				endPtr = (char*)endPtr + 1;
				state = check_rate;
			
				i++;
				if(i>=20) return -1;
				}
			else
				state = check_end;
			break;
				
		
		case check_fail:
	
			return -1;
			break;

		case check_end: 
	
			if ('\0' == endPtr[0]) {
				state = check_success;
				i++;
				if(i>=20) return -1;
				}
			else
				state = check_fail;
				break;
			
		case check_success: 

			*count = i;
			return 0;
			break;
			
		default: break;
		}
		
		}
		
}



int process_rate_list(int iArray[],int num) 
{ 

	int iTemp,i,j,iCount=1; 
	//排序 
	for(i=1;i<num;i++)
	{
		for(j=0;j<i;j++) 
		{ 
			if(iArray[i]<iArray[j]) 
			{ 
				iTemp=iArray[i]; 
				iArray[i]=iArray[j]; 
				iArray[j]=iTemp; 

			} 
		} 
	}
	//for(i=0;i<num;i++)
	//{
	//	printf("%d ",iArray[i]); 
	//}
	//printf("\n"); 
	//去重复 
	i=0; 
	j=1; 
	while(j<num) 
	{ 
		if(iArray[i]==iArray[j]) 
		{ 

			j++; 
		} 
		else 
		{ 
			iArray[++i]=iArray[j]; 
			j++; 
			iCount++; 

		} 


	} 
	
	//for(i=0;i<iCount;i++)
	//{
	//	printf("%d %d \n",i,iArray[i]); 
	//}
	return iCount;
}

int parse_mcs_list(char* ptr,update_mcs_list **mcslist)
{
	char* endPtr = NULL;
	int   mcsid1 = 0;
	int   mcsid2 = 0;
	int   min = 0;
	int	  max = 0;
	endPtr = ptr;
	mcs_list_state state = dcli_mcs_check_mcsid;
	struct tag_mcsid *mcs_id = NULL;
	
	while(1)
	{
		switch(state)
		{
			case dcli_mcs_check_mcsid: 
				mcsid1 = strtoul(endPtr,&endPtr,10);
				if(mcsid1>=0&&mcsid1<= 31)
				{
            				state=dcli_mcs_check_comma;
				}
				else
					state=dcli_mcs_check_fail;
				break;
		
			case dcli_mcs_check_comma: 
				
				if(MCS_LIST_SPLIT_COMMA == endPtr[0])
				{
					endPtr = (char*)endPtr + 1;
					state = dcli_mcs_check_mcsid;
					//save mcsid1
					mcs_id = (struct tag_mcsid*)malloc(sizeof(struct tag_mcsid));
					mcs_id->mcsid = mcsid1;
					mcs_id->next = NULL;

					//insert to list
					mcs_id->next = (*mcslist)->mcsidlist;
					(*mcslist)->mcsidlist = mcs_id;
					(*mcslist)->count++;
															
				}
				else if(MCS_LIST_SPLIT_BAR == endPtr[0])
				{
					endPtr = (char*)endPtr + 1;
					mcsid2 = strtoul(endPtr,&endPtr,10);
					if(mcsid2>=0&&mcsid2<= 31)
					{
	            		//save mcsid1
						min = (mcsid2 > mcsid1)?mcsid1:mcsid2;
						max = (mcsid2 > mcsid1)?mcsid2:mcsid1;
						while(min <= max)
						{
							mcs_id = (struct tag_mcsid*)malloc(sizeof(struct tag_mcsid));
							mcs_id->mcsid = min;
							mcs_id->next = NULL;

							//insert to list
							mcs_id->next = (*mcslist)->mcsidlist;
							(*mcslist)->mcsidlist = mcs_id;
							(*mcslist)->count++;	
								
							min++;
						}
						if('\0' == endPtr[0])
						{
							return 0;
						}
						else
						{											
							endPtr = (char*)endPtr + 1;
							state=dcli_mcs_check_mcsid;
						}
					}
					else
					{
						state = dcli_mcs_check_fail;
					}
					
				}
				else
					state = dcli_mcs_check_end;
				//printf("state2 = %d\n",state);
				//printf("mcsid = %d\n",mcsid1);
				//printf("mcsid = %d\n",mcsid2);
				break;
				
		
			case dcli_mcs_check_fail:
                //printf("state3 = %d\n",state);
				//printf("mcsid = %d\n",mcsid1);
				//printf("mcsid = %d\n",mcsid2);
				return -1;
				break;

			case dcli_mcs_check_end: 
				
				if ('\0' == endPtr[0]) 
				{
					state = dcli_mcs_check_success;
				}
				else
					state = dcli_mcs_check_fail;
			    //printf("state4 = %d\n",state);
				//printf("mcsid = %d\n",mcsid1);
				//printf("mcsid = %d\n",mcsid2);
				break;
			
			case dcli_mcs_check_success: 
				
				//save mcsid1
				mcs_id = (struct tag_mcsid*)malloc(sizeof(struct tag_mcsid));
				mcs_id->mcsid = mcsid1;
				mcs_id->next = NULL;

				//insert to list
				mcs_id->next = (*mcslist)->mcsidlist;
				(*mcslist)->mcsidlist = mcs_id;
				(*mcslist)->count++;
				//printf("state5 = %d\n",state);
				//printf("mcsid = %d\n",mcsid1);
				//printf("mcsid = %d\n",mcsid2);
				return 0;
				break;
			
			default:
                //printf("state6 = %d\n",state);
				//printf("mcsid = %d\n",mcsid1);
				//printf("mcsid = %d\n",mcsid2);
				break;
		}
		
	}
	
}

static int free_mcs_list(update_mcs_list *mcslist){
	if (mcslist == NULL)
		return 0;
	int i = 0;
	struct tag_mcsid *tmp= NULL;
	for( i = 0; (i < mcslist->count)&&(mcslist->mcsidlist); i++ )
	{
		tmp = mcslist->mcsidlist;
		mcslist->mcsidlist = mcslist->mcsidlist->next;
		tmp->next = NULL;
		free(tmp);
		tmp = NULL;
	}
	if(mcslist){
		free(mcslist);
		mcslist = NULL;
	}
	return i+1;
}



void Free_radio_head(DCLI_RADIO_API_GROUP_ONE *RADIOINFO)
{ 
	void (*dcli_init_free_func)(char *,DCLI_RADIO_API_GROUP_ONE *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_radio_free_fun");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_CONF_METHOD_RADIOLIST,RADIOINFO);
		}
	}
}

/*返回1时，调用Free_radio_head()释放空间*/
int show_radio_list(dbus_parameter parameter, DBusConnection *connection,DCLI_RADIO_API_GROUP_ONE **RADIOINFO)/*返回0表示失败，返回1表示成功*/
																												/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret = 0;
	int retu;	

	void*(*dcli_init_func)(
						int ,
						unsigned int ,
						unsigned int* ,
						unsigned int* ,
						unsigned char *,	
						DBusConnection *,
						char *
						);

    *RADIOINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_radio_show_api_group_one");
		if(NULL != dcli_init_func)
		{
			*RADIOINFO = (*dcli_init_func)
					(
					parameter.instance_id,
					0,/*"show radio (list|all)"*/
					&(parameter.local_id),
					&ret,
					0,
					connection,
					WID_DBUS_CONF_METHOD_RADIOLIST
					);	
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	if(ret == -1)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	if((ret == 0)&&(*RADIOINFO))
	{
		retu = 1;
	}
	if(ret == 8)
	{
		retu = -1;
	}
	
	return retu;		
}


void Free_radio_one_head(DCLI_RADIO_API_GROUP_ONE *RADIOINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_RADIO_API_GROUP_ONE *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_radio_free_fun");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_CONF_METHOD_SHOWRADIO,RADIOINFO);
		}
	}
}

/*返回1时，调用Free_radio_one_head()释放空间*/
int show_radio_one(dbus_parameter parameter, DBusConnection *connection,int radio_id,DCLI_RADIO_API_GROUP_ONE **RADIOINFO)
																						 /*返回0表示失败，返回1表示成功*/
																						 /*返回-1表示radio id does not exist*/
																						 /*返回-2表示radio id should be 1 to G_RADIO_NUM*/
																						 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
    int ret = 0;
	int retu = 0;;	

	void*(*dcli_init_func)(
						int ,
						unsigned int ,
						unsigned int* ,
						unsigned int* ,
						unsigned char *,	
						DBusConnection *,
						char *
						);

    *RADIOINFO = NULL;	
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_radio_show_api_group_one");
		if(NULL != dcli_init_func)
		{
			*RADIOINFO = (*dcli_init_func)(
					parameter.instance_id,
					radio_id,/*"show radio RADIOID"*/
					&(parameter.local_id),
					&ret,
					0,
					connection,
					WID_DBUS_CONF_METHOD_SHOWRADIO
					);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(ret == -1)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if ((ret == 0)&&(*RADIOINFO))
	{	
		retu = 1;
	}
    else if (ret == RADIO_ID_NOT_EXIST)
    {
        retu = -1;
    }
	else if(ret == RADIO_ID_LARGE_THAN_MAX)	
	{
		retu = -2;
	}
	
	return retu;
}

#if _GROUP_POLICY
void Free_config_radio_channel_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-17时，调用Free_config_radio_channel_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int config_radio_channel_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char* channel_value,struct RadioList **RadioList_Head)
												/*返回0表示失败，返回1表示成功，返回-1表示radio id 不存在*/
											    /*返回-2表示Radio is disable,  please enable it first，返回-3表示error*/
											    /*返回-4表示channel  is invalid in CHINA，返回-5表示channel  is invalid in EUROPE*/
												/*返回-6表示channel  is invalid in USA，返回-7表示channel  is invalid in JAPAN*/
											 	/*返回-8表示channel  is invalid in FRANCE，返回-9表示channel  is invalid in SPAIN*/
											    /*返回-10表示input parameter error，返回-11表示11a receive channel list is:  36 ..;149 153 157 161*/
											    /*返回-12表示radio type doesn,t support this channel，返回-13表示error，返回-14表示Radio ID非法*/
												/*返回-15表示illegal input:Input exceeds the maximum value of the parameter type*/
												/*返回-16表示Group ID非法，返回-17表示partial failure，返回-18表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	if(NULL == channel_value)
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int ret1 = 0;
	int ret2 = CHANNEL_CWMODE_SUCCESS;
	unsigned short cwmode = 0;
	char channel_offset = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned char channel = 0;	
	int retu = 0;

	if (!strcmp(channel_value,"auto"))
	{
    	channel = 0;
	}
	else 
	{
		ret = parse_char_ID((char *)channel_value,&channel);
		if (ret != WID_DBUS_SUCCESS)
		{	
           if(ret == WID_ILLEGAL_INPUT){
		   		retu = -15;
            }
			else{
				retu = -10;
			}
			return retu;
		}
		if ((channel <= 0)||(channel > 14)) 
		{
			if (!((channel == 36)||(channel == 40)||(channel == 44)||(channel == 46)||(channel == 48)\
				||(channel == 52)||(channel == 56)||(channel == 60)||(channel == 64)||(channel == 100)\
				||(channel == 104)||(channel == 108)||(channel == 112)||(channel == 116)||(channel == 120)\
				||(channel == 124)||(channel == 128)||(channel == 132)||(channel == 136)||(channel == 140)\
				||(channel == 149)||(channel == 153)||(channel == 157)||(channel == 161)||(channel == 165)\
				||(channel == 184)||(channel == 188)||(channel == 192)||(channel == 196)\
				)) 
			{
				return -11;
			}
		}
	}
	
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in config_radio_channel_group is %d\n",id);
			return -14;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in config_radio_channel_group is %d\n",id);
			return -16;
		}
	}

	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *,
							unsigned int ,
							unsigned int ,
							unsigned char ,
							int *,
							int *,
							int *,
							int *,
							unsigned short *,
							char *
						);

    *RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_channel_cmd_channel");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 channel,
								 &count,
								 &ret,
								 &ret1,
								 &ret2,
								 &cwmode,
								 &channel_offset
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
		

	if(type == 0)
	{
		if(ret == 0)
		{
			switch(ret1)
			{		
				case COUNTRY_CHINA_CN : retu = -4;
										break;
				case COUNTRY_EUROPE_EU : retu = -5;
										break;
        		case COUNTRY_USA_US : retu = -6;
										break;
				case COUNTRY_JAPAN_JP : retu = -7;
										break;
				case COUNTRY_FRANCE_FR : retu = -8;
										break;
				case COUNTRY_SPAIN_ES : retu = -9;
										break;
				case COUNTRY_CODE_SUCCESS : break;
				default : break;
			}
			if(ret2 != CHANNEL_CWMODE_SUCCESS)
			{
				retu = -13;
			}
			else if(ret2 == CHANNEL_CWMODE_SUCCESS)
			{
				if (ret1 == COUNTRY_CODE_SUCCESS)
				{
					retu = 1;
				}
			}
		}
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -1;
		else if(ret == RADIO_IS_DISABLE)
			retu = -2;
		else if(ret == WTP_NO_SURPORT_CHANNEL)
			retu = -12;
		else
			retu = -3;
	}
	else if(type==1)
	{
		if(ret == 0)
		{	
			if(channel == 0)
				retu = 1;
			else
				retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);
				}
				vty_out(vty," failed.\n");*/
				retu = -17;
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -18;

	}	
	return retu;

}
#endif


int config_radio_channel(dbus_parameter parameter, DBusConnection *connection,int id,char* channel_value)
																		/*返回0表示失败，返回1表示成功，返回-1表示radio id 不存在*/
 																	    /*返回-2表示Radio is disable,  please enable it first，返回-3表示error*/
 																	    /*返回-4表示channel  is invalid in CHINA，返回-5表示channel  is invalid in EUROPE*/
																		/*返回-6表示channel  is invalid in USA，返回-7表示channel  is invalid in JAPAN*/
																	 	/*返回-8表示channel  is invalid in FRANCE，返回-9表示channel  is invalid in SPAIN*/
 																	    /*返回-10表示input parameter error，返回-11表示11a receive channel list is:  36 ..;149 153 157 161*/
 																	    /*返回-12表示radio type doesn,t support this channel，返回-13表示error，返回-14表示Radio ID非法*/
																		/*返回-15表示illegal input:Input exceeds the maximum value of the parameter type*/
																		/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == channel_value)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = config_radio_channel_group(parameter, connection,0,id,channel_value,&RadioList_Head);
	if(retu == -17)
	{
		Free_config_radio_channel_group(RadioList_Head);
	}
	return retu;
#else	
	unsigned char channel; 
	unsigned int radio_id;
	int ret=0,retu=1;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;		
	int ret1 = 0;
	int ret2 = CHANNEL_CWMODE_SUCCESS;
	unsigned short cwmode = 0;
	char channel_offset = 0;

	
	if (!strcmp(channel_value,"auto"))
	{
    	channel = 0;
	}
	else 
	{
		ret = parse_char_ID(channel_value,&channel);
		if (ret != WID_DBUS_SUCCESS)
		{				
			if(ret == WID_ILLEGAL_INPUT){
				 retu = -15;
			 }
			 else{
			 	 retu = -10;
			 }
			return retu;
		}
		if ((channel <= 0)||(channel > 14)) 
		{
			if (!((channel == 36)||(channel == 40)||(channel == 44)||(channel == 46)||(channel == 48)\
				||(channel == 52)||(channel == 56)||(channel == 60)||(channel == 64)||(channel == 100)\
				||(channel == 104)||(channel == 108)||(channel == 112)||(channel == 116)||(channel == 120)\
				||(channel == 124)||(channel == 128)||(channel == 132)||(channel == 136)||(channel == 140)\
				||(channel == 149)||(channel == 153)||(channel == 157)||(channel == 161)||(channel == 165)\
				||(channel == 184)||(channel == 188)||(channel == 192)||(channel == 196)\
				)) 
			{
				return -11;
			}
		}
	}
	
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radio_id = id;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in config_radio_channel is %d\n",radio_id);
		return -14;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_CHAN);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_CHAN);*/
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radio_id,
							 DBUS_TYPE_BYTE,&channel,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	
	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&ret1);
	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&ret2);
	if(ret2 != CHANNEL_CWMODE_SUCCESS){
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&cwmode);
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&channel_offset);
	}
    
	if(ret==0)	
		{
	   		switch(ret1)
	   		{
	   			case COUNTRY_CHINA_CN :
							retu = -4;
	   						break;
	   			case COUNTRY_EUROPE_EU : 
							retu = -5;
	   						break;
	   			case COUNTRY_USA_US :
							retu = -6;
							break;
	   			case COUNTRY_JAPAN_JP :
							retu = -7;
							break;
	   			case COUNTRY_FRANCE_FR :
							retu = -8;
							break;
	   			case COUNTRY_SPAIN_ES :
							retu = -9;
							break;
	   			case COUNTRY_CODE_SUCCESS : 

							break;
	   			default : break;
	   	      }
			  
			  if(ret2 != CHANNEL_CWMODE_SUCCESS)
			  {
				  retu = -13;								  
			  }
			  else if(ret2 == CHANNEL_CWMODE_SUCCESS)
			  {
					if (ret1 == COUNTRY_CODE_SUCCESS)
					{
						retu = 1;
					}
			  }
		}
		else if(ret == RADIO_ID_NOT_EXIST)
		  retu=-1;		
		else if(ret == RADIO_IS_DISABLE)
		  retu=-2;		
		else if(ret == WTP_NO_SURPORT_CHANNEL)
		  retu=-12;
		else
		  retu=-3;
	dbus_message_unref(reply);
	return retu;
#endif
}


#if _GROUP_POLICY
void Free_config_radio_txpower_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-10时，调用Free_config_radio_txpower_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*txpower为100表示"auto"*/
int config_radio_txpower_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,int txpower,struct RadioList **RadioList_Head)    
																	/*返回0表示失败，返回1表示成功，返回-1表示txpower conflict with country-code，返回-2表示radio id does not exist*/
																	/*返回-3表示radio is disable, please enable it first，返回-4表示radio mode is 11n,not allow to set txpower，返回-5表示this radio max txpower is 20*/
																	/*返回-6表示this radio max txpower is 27，返回-7表示出错，返回-8表示Radio ID非法，返回-9表示Group ID非法*/
																	/*返回-10表示partial failure，返回-11表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	u_int16_t	txp;
	int ret1 = COUNTRY_CODE_SUCCESS;
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	int retu = 0;
	
	//struct RadioList *Radio_Show_Node = NULL;
		

	/*if (!strcmp(argv[0],"auto"))
	{
    	txp = 100;
		
	}else{
	ret = parse_short_ID((char *)argv[0],&txp);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
       if(ret == WID_ILLEGAL_INPUT){
            	vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
       }
	   else{
		vty_out(vty,"<error> input parameter %s error\n",argv[0]);
	   }
		return CMD_SUCCESS;
	}
	if ((txp <= 0)||(txp > 27)) 
	{
		vty_out(vty,"<error> input parameter %s error\n",argv[0]);
		return CMD_SUCCESS;
	}
	}*/	
	txp = txpower;
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in config_radio_txpower_group is %d\n",id);
			return -8;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in config_radio_txpower_group is %d\n",id);
			return -9;
		}
	}

	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *,
							unsigned int ,
							unsigned int ,
							u_int16_t ,
							int *,
							int *,
							int *
						);

    *RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_txpower_cmd_txpower");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 txp,
								 &count,
								 &ret,
								 &ret1
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
		{
			if (ret1 == COUNTRY_CODE_SUCCESS)
			{
				retu = 1;
			}
			else if (ret1 == COUNTRY_CODE_ERROR)
			{
				retu = -1;
			}
		}
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -2;
		else if(ret == RADIO_IS_DISABLE)
			retu = -3;
		else if(ret == RADIO_MODE_IS_11N)
			retu = -4;
		else if(ret == TXPOWER_OVER_TW)
			retu = -5;
		else if(ret == TXPOWER_OVER_TW_THREE)
			retu = -6;
		else
			retu = -7;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -10;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
					{
						if(Radio_Show_Node == NULL)
							Radio_Show_Node = RadioList_Head->RadioList_list;
						else 
							Radio_Show_Node = Radio_Show_Node->next;
						if(Radio_Show_Node == NULL)
							break;
						vty_out(vty,"%d ",Radio_Show_Node->RadioId);
					}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -11;
	}	
	return retu;

}
#endif

/*txpower为100表示"auto"*/
int config_radio_txpower(dbus_parameter parameter, DBusConnection *connection,int id,int txpower)    
																	/*返回0表示失败，返回1表示成功，返回-1表示txpower conflict with country-code，返回-2表示radio id does not exist*/
																	/*返回-3表示radio is disable, please enable it first，返回-4表示radio mode is 11n,not allow to set txpower，返回-5表示this radio max txpower is 20*/
																	/*返回-6表示this radio max txpower is 27，返回-7表示出错，返回-8表示Radio ID非法*/
																	/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = config_radio_txpower_group(parameter, connection,0,id,txpower,&RadioList_Head);
	if(retu == -10)
	{
		Free_config_radio_txpower_group(RadioList_Head);
	}
	return retu;
#else
	unsigned int radio_id; 
	u_int16_t	txp;
	int ret,retu;
	int ret1 = COUNTRY_CODE_SUCCESS;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;	
    txp = txpower;    /*1--27*/
	//radio_id = id;
	
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radio_id = id;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in config_radio_txpower is %d\n",radio_id);
		return -8;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_TXP);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_TXP);*/
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radio_id,
							 DBUS_TYPE_UINT16,&txp,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		if (ret1 == COUNTRY_CODE_SUCCESS)
		{
			retu=1;
		}
		else if (ret1 == COUNTRY_CODE_ERROR)
		{
			retu=-1;
		}
	}
	else if(ret == RADIO_ID_NOT_EXIST)
		retu=-2;
	else if(ret == RADIO_IS_DISABLE)
		retu=-3;	
	else if(ret == RADIO_MODE_IS_11N)
		retu=-4;
	else if(ret == TXPOWER_OVER_TW)
		retu=-5;
	else if(ret == TXPOWER_OVER_TW_THREE)
		retu=-6;
	else
		retu=-7;

	dbus_message_unref(reply);
	return retu;
#endif
}

#if _GROUP_POLICY
void Free_config_radio_rate_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-15时，调用Free_config_radio_rate_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*rate list:10,20,55,60,90,110,120,180,240,360,480,540*/
int config_radio_rate_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char* radioRate,struct RadioList **RadioList_Head) 
																/*返回0表示失败，返回1表示成功，返回-1表示radio id does not exist，返回-2表示mode 11b support rate list:10 20 55 110*/
					                                            /*返回-3表示mode 11a support rate list:60 90 120 180 240 360 480 540，返回-4表示mode 11g support rate list:60 90 120 180 240 360 480 540*/
																/*返回-5表示mode 11b/g support rate list:10 20 55 60 90 110 120 180 240 360 480 540，返回-6表示wtp radio does not support this rate,please check first*/	
																/*返回-7表示radio is disable, please enable it first，返回-8表示radio list is empty，返回-9表示radio mode is 11n,not allow to set rate*/
																/*返回-10表示radio support rate does not exist，返回-11表示radio type is conflict, please check it first，返回-12表示出错，返回-13表示Radio ID非法*/
																/*返回-14表示Group ID非法，返回-15表示partial failure，返回-16表示group id does not exist*/
																/*返回-17表示mode 11an support rate list:60 90 120 180 240 360 480 540，返回-18表示mode 11gn support rate list:60 90 120 180 240 360 480 540*/
																/*返回-19表示mode 11a/an support rate list:60 90 120 180 240 360 480 540，返回-20表示mode 11g/gn support rate list:60 90 120 180 240 360 480 540*/
																/*返回-21表示mode 11b/g/n support rate list:10 20 60 90 110 120 180 240 360 480 540*/
{
    if(NULL == connection)
        return 0;
        
	if(NULL == radioRate)
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int n=0;
	int num=0;
	int list[RADIO_RATE_LIST_LEN];
	int ret = 0;
	int ret1 = 0;
	int count = 0;
	int mode = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	int retu = 1;

	/*parse the rate list*/
	ret = parse_rate_list((char *)radioRate,&n,list);

	if (ret != WID_DBUS_SUCCESS)
	{
		return 0;
	}
		
	/*remove the repeat rate,process the order*/
	num = process_rate_list(list,n);/*the num in the rate list*/
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in config_radio_rate_group is %d\n",id);
			return -13;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in config_radio_rate_group is %d\n",id);
			return -14;
		}
	}
		
	void *(*dcli_init_func)(
							int ,
							int ,
							DBusConnection *,
							unsigned int ,
							unsigned int ,
							int ,
							int *,
							int *,
							int *,
							int *,
							int *
						);

    *RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_ratelist_cmd_set_support_ratelist");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 num,
								 &count,
								 &ret,
								 &ret1,
								 list,
								 &mode
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(type==0)
	{
		if(ret==0)
		{
			if(ret1 == -1)
				retu = 0;
			else
			{
				retu = 1;
			}				
		}		
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -1;
		else if(ret == WTP_NO_SURPORT_Rate)
		{
			if (mode == 1)
			{
				retu = -2;
			}
			else if (mode == 2)
			{
				retu = -3;
			}
			else if (mode == 4)
			{
				retu = -4;
			}
			else if (mode == 10)
			{
				retu = -17;
			}
			else if (mode == 12)
			{
				retu = -18;
			}
			else if (mode == 26)
			{
				retu = -19;
			}
			else if (mode == 44)
			{
				retu = -20;
			}
			else if (mode == 5)
			{
				retu = -5;
			}
			else if (mode == 13)
			{
				retu = -21;
			}
			else
			{
				retu = -6;
			}
		}
		else if(ret == RADIO_IS_DISABLE)
			retu = -7;
		else if(ret == RADIO_SUPPORT_RATE_EMPTY)
			retu = -8;
		else if(ret == RADIO_MODE_IS_11N)
			retu = -9;
		else if(ret == RADIO_SUPPORT_RATE_NOT_EXIST)/*use in delete support ratelist,maybe later*/
			retu = -10;
		else if((ret == WTP_NO_SURPORT_TYPE)||(ret == RADIO_SUPPORT_RATE_CONFLICT))
			retu = -11;
		else
			retu = -12;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
					{
						if(Radio_Show_Node == NULL)
							Radio_Show_Node = RadioList_Head->RadioList_list;
						else 
							Radio_Show_Node = Radio_Show_Node->next;
						if(Radio_Show_Node == NULL)
							break;
						vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
					}
				vty_out(vty," failed.\n");*/
				retu = -15;
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -16;

	}		
	return retu;
}
#endif

/*rate list:10,20,55,60,90,110,120,180,240,360,480,540*/
int config_radio_rate(dbus_parameter parameter, DBusConnection *connection,int id,char* radioRate) 
																/*返回0表示失败，返回1表示成功，返回-1表示radio id does not exist，返回-2表示mode 11b support rate list:10 20 55 110*/
					                                            /*返回-3表示mode 11a support rate list:60 90 120 180 240 360 480 540，返回-4表示mode 11g support rate list:60 90 120 180 240 360 480 540*/
																/*返回-5表示mode 11b/g support rate list:10 20 55 60 90 110 120 180 240 360 480 540，返回-6表示wtp radio does not support this rate,please check first*/	
																/*返回-7表示radio is disable, please enable it first，返回-8表示radio list is empty，返回-9表示radio mode is 11n,not allow to set rate*/
																/*返回-10表示radio support rate does not exist，返回-11表示radio type is conflict, please check it first，返回-12表示出错，返回-13表示Radio ID非法*/
																/*返回-14表示mode 11an support rate list:60 90 120 180 240 360 480 540，返回-15表示mode 11gn support rate list:60 90 120 180 240 360 480 540*/
																/*返回-16表示mode 11a/an support rate list:60 90 120 180 240 360 480 540，返回-17表示mode 11g/gn support rate list:60 90 120 180 240 360 480 540*/
																/*返回-18表示mode 11b/g/n support rate list:10 20 60 90 110 120 180 240 360 480 540*/
																/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == radioRate)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = config_radio_rate_group(parameter, connection,0,id,radioRate,&RadioList_Head);
	if(retu == -15)
	{
		Free_config_radio_rate_group(RadioList_Head);
	}
	return retu;
#else
	int radio_id = 0;
	int mode = 0;
	int ret=0;
	int n=0;
	int num=0;
	int i = 0;
	int list[RADIO_RATE_LIST_LEN];
	int list1[RADIO_RATE_LIST_LEN];
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;	
	dbus_error_init(&err);
	int retu=0;

	//parse the rate list
	ret = parse_rate_list(radioRate,&n,list);

	if (ret != WID_DBUS_SUCCESS)
	{
		return 0;
	}
		
	//remove the repeat rate,process the order
	num = process_rate_list(list,n);//the num in the rate list
		
	
	//for (i=0;i<num;i++)
	//{
	//	printf("%d radiorate %d\n",i,list[i]);
	//}
	//radio_id = (int)id;
	
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	
	radio_id = (int)id;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in config_radio_rate is %d\n",radio_id);
		return -13;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_SUPPORT_RATELIST);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_SUPPORT_RATELIST);*/
	
		
	dbus_message_iter_init_append (query, &iter);

	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&radio_id);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&num);
		


	for(i = 0; i < num; i++)
	{
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&list[i]);
	}
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
		
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
	    return SNMPD_CONNECTION_ERROR;
    }
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	
	
	
	
	dbus_message_iter_next(&iter);
	dbus_message_iter_get_basic(&iter,&mode);


	if(ret == 0)
	{
		dbus_message_iter_next(&iter);
		dbus_message_iter_get_basic(&iter,&num);
	if(num > 20)
		{
			return 0;
		}
		for(i=0;i<num;i++)
		{
			dbus_message_iter_next(&iter);
			dbus_message_iter_get_basic(&iter,&list1[i]);
		}
		retu =1;
	}
	else if(ret == RADIO_ID_NOT_EXIST)
		retu =-1;
	
	else if(ret == WTP_NO_SURPORT_Rate)
	{
		if (mode == 1)
		{
			retu=-2;
		}				
		else if (mode == 2)
		{
			retu=-3;
		}
		else if (mode == 4)
		{
			retu=-4;
		}
		else if (mode == 10)
		{
			retu = -14;
		}
		else if (mode == 12)
		{
			retu = -15;
		}
		else if (mode == 26)
		{
			retu = -16;
		}
		else if (mode == 44)
		{
			retu = -17;
		}		
		else if (mode == 5)
		{
			retu = -5;
		}
		else if (mode == 13)
		{
			retu = -18;
		}
		else
		{
			retu = -6;
		}
	}
	else if(ret == RADIO_IS_DISABLE)
		retu = -7;
	else if(ret == RADIO_SUPPORT_RATE_EMPTY)
		retu = -8;
	else if(ret == RADIO_MODE_IS_11N)
		retu = -9;
	else if(ret == RADIO_SUPPORT_RATE_NOT_EXIST)//use in delete support ratelist,maybe later
		retu = -10;
	else if((ret == WTP_NO_SURPORT_TYPE)||(ret == RADIO_SUPPORT_RATE_CONFLICT))
		retu = -11;
	else
		retu = -12;		

	dbus_message_unref(reply);
		
	return retu;	
#endif
}

#if _GROUP_POLICY
void Free_config_radio_txpower_offset_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-13时，调用Free_config_radio_txpower_offset_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int config_radio_txpower_offset_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,int txpower_off,struct RadioList **RadioList_Head)
																	/*返回0表示失败，返回1表示成功，返回-1表示input parameter txpower error，返回-2表示txpower conflict with country-code*/
																	/*返回-3表示radio id does not exist，返回-4表示radio is disable, please enable it first，返回-5表示radio mode is 11n,not allow to set txpower*/
																	/*返回-6表示this radio max txpower is 20，返回-7表示this radio max txpower is 27，返回-8表示this wtp is not in run state*/
																	/*返回-9表示this radio is not binding wlan,binding wlan first.，返回-10表示error，返回-11表示Radio ID非法，返回-12表示Group ID非法*/
																	/*返回-13表示partial failure，返回-14表示group id does not exist，返回-15表示txpoweroffset is larger than max txpower!Please checkout txpowerstep!*/
{
    if(NULL == connection)
        return 0;
        
	u_int16_t	txpof;
	unsigned int txpwer = 0;
	int ret1 = COUNTRY_CODE_SUCCESS;
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	int retu = 0;
		
	/*ret = parse_int_ID((char *)argv[0],&txpwer);
	txpof = (u_int16_t)txpwer;
	vty_out(vty,"txpof = %d \n",txpof);
	vty_out(vty,"txpwer = %d \n",txpwer);
	if (ret != WID_DBUS_SUCCESS)
	{	
		vty_out(vty,"<error> input parameter %s error\n",argv[0]);
		return CMD_SUCCESS;
	}
	if ((txpof > 27)) 
	{
		vty_out(vty,"<error> input parameter %s error\n",argv[0]);
		return CMD_SUCCESS;
	}*/
	txpwer = txpower_off;
	txpof = (u_int16_t)txpwer;
	
	if ((txpof > 27))	 
	{
		return -1;
	}

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in config_radio_txpower_offset_group is %d\n",id);
			return -11;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in config_radio_txpower_offset_group is %d\n",id);
			return -12;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								u_int16_t ,
								int *,
								int *,
								int *
							);
							
	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_txpowerof_cmd_txpoweroffset");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
							     parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 txpof,
								 &count,
								 &ret,
								 &ret1
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
		{
			if (ret1 == COUNTRY_CODE_SUCCESS)
			{
				retu = 1;
			}
			else if (ret1 == COUNTRY_CODE_ERROR)
			{
				retu = -2;
			}
		}
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -3;
		else if(ret == RADIO_IS_DISABLE)
			retu = -4;
		else if(ret == RADIO_MODE_IS_11N)
			retu = -5;
		else if(ret == TXPOWER_OVER_TW)
			retu = -6;
		else if(ret == TXPOWER_OVER_TW_THREE)
			retu = -7;
		else if(ret == WTP_NOT_IN_RUN_STATE)
			retu = -8;
		else if(ret == RADIO_NO_BINDING_WLAN)
			retu = -9;
		else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
			retu = -9;
		else if(ret == TXPOWEROFF_LARGER_THAN_MAX)
			retu = -15;
		else
			retu = -10;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -13;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -14;
	
	}	
	return retu;

}
#endif

int config_radio_txpower_offset(dbus_parameter parameter, DBusConnection *connection,int id,int txpower_off)
																		   /*返回0表示失败，返回1表示成功，返回-1表示input parameter txpower error，返回-2表示txpower conflict with country-code*/
																		   /*返回-3表示radio id does not exist，返回-4表示radio is disable, please enable it first，返回-5表示radio mode is 11n,not allow to set txpower*/
																		   /*返回-6表示this radio max txpower is 20，返回-7表示this radio max txpower is 27，返回-8表示this wtp is not in run state*/
																		   /*返回-9表示this radio is not binding wlan,binding wlan first.，返回-10表示error，返回-11表示Radio ID非法*/
																		   /*返回SNMPD_CONNECTION_ERROR表示connection error，返回-15表示xpoweroffset is larger than max txpower!Please checkout txpowerstep!*/
{
    if(NULL == connection)
        return 0;
        
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = config_radio_txpower_offset_group(parameter, connection,0,id,txpower_off,&RadioList_Head);
	if(retu == -13)
	{
		Free_config_radio_txpower_offset_group(RadioList_Head);
	}
	return retu;
#else
	unsigned int radio_id; 
	u_int16_t	txpof;
	unsigned int txpwer = 0;
	int ret=0;
	int ret1 = COUNTRY_CODE_SUCCESS;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;	
	int retu;
	
	txpwer = txpower_off;
	txpof = (u_int16_t)txpwer;
	
	if ((txpof > 27)) 	 
	{
		return -1;
	}
	//radio_id = id;
	
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radio_id = id;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in config_radio_txpower_offset is %d\n",radio_id);
		return -11;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_TXPOF);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_TXPOF);*/

	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radio_id,
							 DBUS_TYPE_UINT16,&txpof,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);

	dbus_message_unref(query);

	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}

	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	dbus_message_iter_next(&iter);
	dbus_message_iter_get_basic(&iter,&ret1);

	if(ret == 0)
	{
		if (ret1 == COUNTRY_CODE_SUCCESS)
		{
			retu=1;
		}
		else if (ret1 == COUNTRY_CODE_ERROR)
		{
			retu=-2;
		}
	}
	else if(ret == RADIO_ID_NOT_EXIST)
		retu=-3;
	else if(ret == RADIO_IS_DISABLE)
		retu=-4;
	else if(ret == RADIO_MODE_IS_11N)
		retu=-5;
	else if(ret == TXPOWER_OVER_TW)
		retu=-6;
	else if(ret == TXPOWER_OVER_TW_THREE)
		retu=-7;
	else if(ret == WTP_NOT_IN_RUN_STATE)
		retu=-8;		
	else if(ret == RADIO_NO_BINDING_WLAN)
		retu=-9;
	else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
		retu = -9;
	else if(ret == TXPOWEROFF_LARGER_THAN_MAX)
		retu = -15;
	else
		retu=-10;

	dbus_message_unref(reply);
	return retu;
#endif
}

#if _GROUP_POLICY
void Free_config_radio_mode_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-8时，调用Free_config_radio_mode_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*mode list:11a,11b,11g,11n,11b/g,11b/g/n,11a/n*/
int config_radio_mode_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *radioMode,struct RadioList **RadioList_Head)
											/*返回0表示失败，返回1表示成功，返回-1表示mode非法*/
											/*返回-2表示radio id 不存在，返回-3表示Radio is disable,  please enable it first*/
											/*返回-4表示radio mode not allow to set with 11n，返回-5表示出错*/
											/*返回-6表示Radio ID非法，返回-7表示Group ID非法*/
											/*返回-8表示partial failure，返回-9表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	if(NULL == radioMode)
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	unsigned int modetmp, mode = 0;
	int list1[RADIO_RATE_LIST_LEN];
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	int retu = 0;

	/*make robust code*/
	if(!strcmp(radioMode,"11b"))
	{
		mode |= 0x01;	
	}
	else if(!strcmp(radioMode,"11a"))
	{
		mode |= 0x02;
	}
	else if(!strcmp(radioMode,"11g"))
	{
		mode |= 0x04;
	}
	else if(!strcmp(radioMode,"11n"))
	{
		mode |= 0x08;
	}
	else if(!strcmp(radioMode,"11b/g"))
	{
		mode |= 0x01;
		mode |= 0x04;
	}
	else if(!strcmp(radioMode,"11b/g/n"))
	{
		mode |= 0x01;
		mode |= 0x04;
		mode |= 0x08;
	}
	else if(!strcmp(radioMode,"11a/n"))
	{
		mode |= 0x02;
		mode |= 0x08;
	}
	else
	{
		modetmp = 0;
		modetmp = atoi(radioMode);
		if((modetmp == 1)||(modetmp == 2)||(modetmp == 4)||(modetmp == 5)||(modetmp == 8)||(modetmp == 10)||(modetmp == 13))
		{
			mode |= modetmp;
		}
		else
		{
			return -1;
		}
	}

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in config_radio_mode_group is %d\n",id);
			return -6;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in config_radio_mode_group is %d\n",id);
			return -7;
		}
	}
		
	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned int ,
								int *,
								int *,
								int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_mode_cmd_11a_11b_11g_11bg_11bgn_11an");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 mode,
								 list1,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
		{
			retu = 1;
		}
		else if(ret == -1)
		{
			retu = 0;
		}
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -2;
		else if(ret == WTP_NO_SURPORT_TYPE)
		{
			retu = -1;
		}
		else if(ret == RADIO_IS_DISABLE)
			retu = -3;
		else if(ret == RADIO_MODE_IS_11N)
			retu = -4;
		else
			retu = -5;
	}	
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -8;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -9;	
	}
	return retu;
}
#endif

/*mode list:11a,11b,11g,11gn,11g/gn,11b/g,11b/g/n,11a/an,11an*/
int config_radio_mode(dbus_parameter parameter, DBusConnection *connection,int id,char *radioMode)
																	/*返回0表示失败，返回1表示成功，返回-1表示mode非法*/
																	/*返回-2表示radio id 不存在，返回-3表示Radio is disable,  please enable it first*/
																	/*返回-4表示radio mode not allow to set with 11n，返回-5表示出错*/
																	/*返回-6表示Radio ID非法*/
																    /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == radioMode)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = config_radio_mode_group(parameter, connection,0,id,radioMode,&RadioList_Head);
	if(retu == -8)
	{
		Free_config_radio_mode_group(RadioList_Head);
	}
	return retu;
#else
	unsigned int radio_id; 
	unsigned int	modetmp, mode = 0;
	int ret,retu;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;		
	int num=0;
	int i = 0;
	int list1[RADIO_RATE_LIST_LEN];
	
	if(!strcmp(radioMode,"11b"))
	{
		mode |= 0x01;	
	}
	else if(!strcmp(radioMode,"11a"))
	{
		mode |= 0x02;
	}
	else if(!strcmp(radioMode,"11g"))
	{
		mode |= 0x04;
	}
	else if(!strcmp(radioMode,"11n"))
	{
		mode |= 0x08;
	}
	else if(!strcmp(radioMode,"11b/g"))
	{
		mode |= 0x01;
		mode |= 0x04;
	}
	else if(!strcmp(radioMode,"11b/g/n"))
	{
		mode |= 0x01;
		mode |= 0x04;
		mode |= 0x08;
	}
	else if(!strcmp(radioMode,"11an"))
	{
		mode |= 0x02;
		mode |= 0x08;
	}
	else if(!strcmp(radioMode,"11gn"))
	{
		mode |= 0x04;
		mode |= 0x08;
	}
	else if(!strcmp(radioMode,"11a/an"))
	{
		mode |= 0x02;
		mode |= 0x08;
		mode |= 0x10;
	}	
	else if(!strcmp(radioMode,"11g/gn"))
	{
		mode |= 0x04;
		mode |= 0x08;
		mode |= 0x20;
	}
	else
	{
	    modetmp = 0;
		modetmp = atoi(radioMode);		
		if((modetmp == 1)||(modetmp == 2)||(modetmp == 4)||(modetmp == 5)||(modetmp == 8)||(modetmp == 10)||(modetmp == 13)
		||(modetmp == 12)||(modetmp == 26)||(modetmp == 44))
		{
			mode |= modetmp;
		}
		else
		{
			return -1;
		}
	}

	//radio_id = id;
	
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radio_id = id;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in config_radio_mode is %d\n",radio_id);
		return -6;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_MODE);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_MODE);*/
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radio_id,
							 DBUS_TYPE_UINT32,&mode,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
		if(ret == 0)
		    {
				dbus_message_iter_next(&iter);
				dbus_message_iter_get_basic(&iter,&num);
				if(num > 20)
				{
					return 0;
				}
				for(i=0;i<num;i++)
				{
					dbus_message_iter_next(&iter);
					dbus_message_iter_get_basic(&iter,&list1[i]);
				}
				retu=1;
			}
		else if(ret == RADIO_ID_NOT_EXIST)
			retu=-2;
		else if(ret == WTP_NO_SURPORT_TYPE)
			retu=-1;		
		else if(ret == RADIO_IS_DISABLE)
			retu=-3;
		else if(ret == RADIO_MODE_IS_11N)
			retu=-4;
		else
			retu=-5;
	dbus_message_unref(reply);
	return retu;
#endif
}

#if _GROUP_POLICY
void Free_config_radio_beaconinterval_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-6时，调用Free_config_radio_beaconinterval_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*注意判断BeaconInterval的范围，默认是100，设定范围是25-1000，单位ms*/
int config_radio_beaconinterval_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,int BeaconInterval,struct RadioList **RadioList_Head)    
										/*返回0表示失败，返回1表示成功，返回-1表示radio id 不存在*/
										/*返回-2表示Radio is disable,  please enable it first，返回-3表示出错*/
										/*返回-4表示Radio ID非法，返回-6表示partial failure，返回-7表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned short beaconinterval= 0;
	int retu = 0;
		
	
	/*ret = parse_short_ID((char *)argv[0],&beaconinterval);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
		   if(ret == WID_ILLEGAL_INPUT){
					vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
		   }
		   else{
		vty_out(vty,"<error> input parameter %s error\n",argv[0]);
		   }
		return CMD_SUCCESS;
	}
	if ((beaconinterval < 25)||(beaconinterval > 1000)) 
	{
		vty_out(vty,"<error> input parameter %s error\n",argv[0]);
		return CMD_SUCCESS;
	}

	if((beaconinterval< 25)||(beaconinterval> 1000))
	{
		vty_out(vty,"<error> input parameter should be 25 to 1000\n");
		return CMD_SUCCESS;
	}*/
	beaconinterval= (unsigned short)BeaconInterval;

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in config_radio_beaconinterval_group is %d\n",id);
			return -4;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in config_radio_beaconinterval_group is %d\n",id);
			return -5;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned short ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_beaconinterval_cmd_beaconinterval");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								parameter.local_id,
								parameter.instance_id,
								connection,
								type,
								id,
								beaconinterval,
								&count,
								&ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -1;
		else if(ret == RADIO_IS_DISABLE)
			retu = -2;
		else
			retu = -3;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -6;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
					{
						if(Radio_Show_Node == NULL)
							Radio_Show_Node = RadioList_Head->RadioList_list;
						else 
							Radio_Show_Node = Radio_Show_Node->next;
						if(Radio_Show_Node == NULL)
							break;
						vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
					}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -7;	
	}

	return retu;
}
#endif
/*注意判断BeaconInterval的范围，默认是100，设定范围是25-1000，单位ms*/
int config_radio_beaconinterval(dbus_parameter parameter, DBusConnection *connection,int id,int BeaconInterval)    /*返回0表示失败，返回1表示成功，返回-1表示radio id 不存在，返回-2表示Radio is disable,  please enable it first，返回-3表示出错，返回-4表示Radio ID非法*/
																														/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = config_radio_beaconinterval_group(parameter, connection,0,id,BeaconInterval,&RadioList_Head);
	if(retu == -6)
	{
		Free_config_radio_beaconinterval_group(RadioList_Head);
	}
	return retu;
#else
	unsigned int radio_id; 
	unsigned short beaconinterval;
	int ret,retu;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;	
    beaconinterval= (unsigned short)BeaconInterval;
	
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radio_id = id;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in config_radio_beaconinterval is %d\n",radio_id);
		return -4;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_BEACON);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_BEACON);*/
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radio_id,
							 DBUS_TYPE_UINT16,&beaconinterval,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

		if(ret == 0)
		    retu=1;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu=-1;
		else if(ret == RADIO_IS_DISABLE)
			retu=-2;
		else
			retu=-3;
	dbus_message_unref(reply);
	return retu;
#endif
}

#if _GROUP_POLICY
void Free_config_radio_fragmentation_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-6时，调用Free_config_radio_fragmentation_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*注意判断Fragmente的范围，默认是2346，设定范围是256-2346，单位byte*/
int config_radio_fragmentation_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,int Fragmente,struct RadioList **RadioList_Head)    
											/*返回0表示失败，返回1表示成功，返回-1表示radio id 不存在*/
											/*返回-2表示Radio is disable,  please enable it first，返回-3表示出错*/
											/*返回-4表示Radio ID非法，返回-5表示Group ID非法*/
											/*返回-6表示partial failure，返回-7表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned short fragmentation= 0;
	int retu = 0;
		

	/*ret = parse_short_ID((char *)argv[0],&fragmentation);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
	   if(ret == WID_ILLEGAL_INPUT){
				vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
	   }
	   else{
		vty_out(vty,"<error> input parameter %s error\n",argv[0]);
	   }
		return CMD_SUCCESS;
	}
	if ((fragmentation < 256)||(fragmentation > 2346)) 
	{
		vty_out(vty,"<error> input parameter %s error\n",argv[0]);
		return CMD_SUCCESS;
	}

	if((fragmentation< 256)||(fragmentation> 2346))
	{
		vty_out(vty,"<error> input parameter should be 256-2346\n");
		return CMD_SUCCESS;
	}*/
	fragmentation= (unsigned short)Fragmente;
	
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in config_radio_fragmentation_group is %d\n",id);
			return -4;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in config_radio_fragmentation_group is %d\n",id);
			return -5;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned short ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_fragmentation_cmd_fragmentation");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								parameter.local_id,
								parameter.instance_id,
								connection,
								type,
								id,
								fragmentation,
								&count,
								&ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -1;
		else if(ret == RADIO_IS_DISABLE)
			retu = -2;
		else
			retu = -3;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -6;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -7;	
	}	
	return retu;
}
#endif

/*注意判断Fragmente的范围，默认是2346，设定范围是256-2346，单位byte*/
int config_radio_fragmentation(dbus_parameter parameter, DBusConnection *connection,int id,int Fragmente)    /*返回0表示失败，返回1表示成功，返回-1表示radio id 不存在，返回-2表示Radio is disable,  please enable it first，返回-3表示出错，返回-4表示Radio ID非法*/
																												/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = config_radio_fragmentation_group(parameter, connection,0,id,Fragmente,&RadioList_Head);
	if(retu == -6)
	{
		Free_config_radio_fragmentation_group(RadioList_Head);
	}
	return retu;
#else
	unsigned int radio_id; 
	unsigned short fragmentation;
	int ret,retu;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;	
    fragmentation= (unsigned short)Fragmente;

	//radio_id = id;	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radio_id = id;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in config_radio_fragmentation is %d\n",radio_id);
		return -4;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_FRAGMENTATION);
	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_FRAGMENTATION);*/
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radio_id,
							 DBUS_TYPE_UINT16,&fragmentation,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	    retu=1;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu=-1;
	else if(ret == RADIO_IS_DISABLE)
	    retu=-2;
	else
	    retu=-3;
	dbus_message_unref(reply);
	return retu;
#endif
}

#if _GROUP_POLICY
void Free_config_radio_dtim_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-6时，调用Free_config_radio_dtim_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*注意判断Dtim的范围，默认是1 ，取值范围是1-15*/
int config_radio_dtim_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,int Dtim,struct RadioList **RadioList_Head)    
													/*返回0表示失败，返回1表示成功，返回-1表示radio id 不存在*/
													/*返回-2表示Radio is disable,  please enable it first，返回-3表示出错*/
													/*返回-4表示Radio ID非法，返回-6表示partial failure*/
													/*返回-7表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned char dtim = 0;
	int retu = 0;
		
	/*ret = parse_char_ID((char *)argv[0],&dtim);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
	   if(ret == WID_ILLEGAL_INPUT){
			vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
	   }
	   else{
		vty_out(vty,"<error> input parameter %s error\n",argv[0]);
	   }
		return CMD_SUCCESS;
	}

	if((dtim< 1)||(dtim> 15))
	{
		vty_out(vty,"<error> input parameter should be 1 to 15\n");
		return CMD_SUCCESS;
	}*/
	dtim= Dtim;
	
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in config_radio_dtim_group is %d\n",id);
			return -4;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in config_radio_dtim_group is %d\n",id);
			return -5;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_dtim_cmd_dtim");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								parameter.local_id,
								parameter.instance_id,
								connection,
								type,
								id,
								dtim,
								&count,
								&ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -1;
		else if(ret == RADIO_IS_DISABLE)
			retu = -2;
		else
			retu = -3;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -6;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -7;
	}	
	return retu;
}
#endif

/*注意判断Dtim的范围，默认是1 ，取值范围是1-15*/
int config_radio_dtim(dbus_parameter parameter, DBusConnection *connection,int id,int Dtim)    /*返回0表示失败，返回1表示成功，返回-1表示radio id 不存在，返回-2表示Radio is disable,  please enable it first，返回-3表示出错，返回-4表示Radio ID非法*/
																								 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = config_radio_dtim_group(parameter, connection,0,id,Dtim,&RadioList_Head);
	if(retu == -6)
	{
		Free_config_radio_dtim_group(RadioList_Head);
	}
	return retu;
#else
	unsigned int radio_id; 
	unsigned char dtim;
	int ret,retu;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;	
    dtim= Dtim;
	//radio_id = id;
	
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	
	radio_id = id;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in config_radio_dtim is %d\n",radio_id);
		return -4;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_DTIM);
	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_DTIM);*/
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radio_id,
							 DBUS_TYPE_BYTE,&dtim,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	    retu=1;
	else if(ret == RADIO_ID_NOT_EXIST)
	    retu=-1;
	else if(ret == RADIO_IS_DISABLE)
	    retu=-2;
	else
		retu=-3;
	
	dbus_message_unref(reply);
	return retu;
#endif
}

#if _GROUP_POLICY
void Free_config_radio_rtsthreshold_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-6时，调用Free_config_radio_rtsthreshold_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*注意判断TRS的范围，默认是2346 ，取值范围是256 - 2347*/
int config_radio_rtsthreshold_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,int RTS,struct RadioList **RadioList_Head)    
										/*返回0表示失败，返回1表示成功，返回-1表示radio id 不存在*/
										/*返回-2表示Radio is disable,  please enable it first，返回-3表示出错*/
										/*返回-4表示Radio ID非法，返回-5表示Group ID非法*/
										/*返回-6表示partial failure，返回-7表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned short rtsthre = 0;
	int retu = 0;		

	/*ret = parse_short_ID((char *)argv[0],&rtsthre);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
	   if(ret == WID_ILLEGAL_INPUT){
				vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
	   }
	   else{
		vty_out(vty,"<error> input parameter %s error\n",argv[0]);
	   }
		return CMD_SUCCESS;
	}


	if((rtsthre < 256)||(rtsthre > 2346))
	{
		vty_out(vty,"<error> input parameter should be 256 to 2346\n");
		return CMD_SUCCESS;
	}*/
	rtsthre= (unsigned short)RTS;
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in config_radio_rtsthreshold_group is %d\n",id);
			return -4;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in config_radio_rtsthreshold_group is %d\n",id);
			return -5;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned short ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_rtsthreshold_cmd_rtsthreshold");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								parameter.local_id,
								parameter.instance_id,
								connection,
								type,
								id,
								rtsthre,
								&count,
								&ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -1;
		else if(ret == RADIO_IS_DISABLE)
			retu = -2;
		else
			retu = -3;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -6;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
					{
						if(Radio_Show_Node == NULL)
							Radio_Show_Node = RadioList_Head->RadioList_list;
						else 
							Radio_Show_Node = Radio_Show_Node->next;
						if(Radio_Show_Node == NULL)
							break;
						vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
					}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -7;
	}	
	return retu;
}
#endif

/*注意判断TRS的范围，默认是2346 ，取值范围是256 - 2347*/
int config_radio_rtsthreshold(dbus_parameter parameter, DBusConnection *connection,int id,int RTS)    /*返回0表示失败，返回1表示成功，返回-1表示radio id 不存在，返回-2表示Radio is disable,  please enable it first，返回-3表示出错，返回-4表示Radio ID非法*/
																										 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = config_radio_rtsthreshold_group(parameter, connection,0,id,RTS,&RadioList_Head);
	if(retu == -6)
	{
		Free_config_radio_rtsthreshold_group(RadioList_Head);
	}
	return retu;
#else
	unsigned int radio_id; 
	unsigned short rtsthre;
	int ret,retu;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;	
	
    rtsthre= (unsigned short)RTS;

	//radio_id = id;

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radio_id = id;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in config_radio_rtsthreshold is %d\n",radio_id);
		return -4;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_RTSTHROLD);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_RTSTHROLD);*/
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radio_id,
							 DBUS_TYPE_UINT16,&rtsthre,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu=-1;
	else if(ret == RADIO_IS_DISABLE)
		retu=-2;
	else
		retu=-3;
	dbus_message_unref(reply);
	return retu;
#endif
}

#if _GROUP_POLICY
void Free_config_radio_service_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-7时，调用Free_config_radio_service_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*state为"enable"或"disable"*/
int config_radio_service_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *state,struct RadioList **RadioList_Head)
													/*返回0表示失败，返回1表示成功，返回-1表示radio id 不存在*/
													/*返回-2表示wtp not in run state，返回-3表示出错，返回-4表示Radio ID非法*/
													/*返回-5表示input patameter should only be 'enable' or 'disable'，返回-6表示Group ID非法*/
													/*返回-7表示partial failure，返回-8表示group id does not exist*/
{
	if(NULL == connection)
        return 0;
	
	if(NULL == state)
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned char status = 0;
	int retu = 0;

	if (!strcmp(state,"enable"))
	{
		status = 1; 
	}		
	else if (!strcmp(state,"disable"))
	{
		status = 2;
	}
	else
	{
		return -5;
	}

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in config_radio_service_group is %d\n",id);
			return -4;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in config_radio_service_group is %d\n",id);
			return -6;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_service_cmd_radio_enable_disable");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								parameter.local_id,
								parameter.instance_id,
								connection,
								type,
								id,
								status,
								&count,
								&ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -1;
		else if(ret ==	WTP_NOT_IN_RUN_STATE)
			retu = -2;
		else
			retu = -3;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -7;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -8;
	}	
	return retu;
}
#endif

/*state为"enable"或"disable"*/
int config_radio_service(dbus_parameter parameter, DBusConnection *connection,int id,char *state)/*返回0表示失败，返回1表示成功，返回-1表示radio id 不存在，返回-2表示wtp not in run state，返回-3表示出错，返回-4表示Radio ID非法*/
																									/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == state)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = config_radio_service_group(parameter, connection,0,id,state,&RadioList_Head);
	if(retu == -7)
	{
		Free_config_radio_service_group(RadioList_Head);
	}
	return retu;
#else
	unsigned int radio_id; 
	unsigned char status;
	int ret,retu;
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;	
	
	if (!strcmp(state,"enable"))
	{
		status = 1;	
	}		
	else if (!strcmp(state,"disable"))
	{
		status = 2;
	}

	//radio_id = id;

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radio_id = id;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in config_radio_service is %d\n",radio_id);
		return -4;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_STATUS);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_STATUS);*/
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radio_id,
							 DBUS_TYPE_BYTE,&status,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

		if(ret == 0)
		    retu=1;
		else if(ret == RADIO_ID_NOT_EXIST)
		    retu=-1;		
		else if(ret ==	WTP_NOT_IN_RUN_STATE)
			retu=-2;
		else
			retu=-3;
	dbus_message_unref(reply);
	return retu;
#endif
}


#if _GROUP_POLICY
void Free_config_radio_preamble_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-7时，调用Free_config_radio_preamble_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*Type为"short"或"long"*/
int config_radio_preamble_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *Type,struct RadioList **RadioList_Head)
										/*返回0表示失败，返回1表示成功，返回-1表示radio id 不存在*/
										/*返回-2表示Radio is disable,  please enable it first，返回-3表示出错*/
										/*返回-4表示Radio ID非法，返回-5表示input parameter should only be 'long' or 'short'*/
										/*返回-6表示Group ID非法	，返回-7表示partial failure，返回-8表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	if(NULL == Type)
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned char preamble = 0;
	int retu = 0;		
	
	if (!strcmp(Type,"short"))
	{
		preamble = 1;	
	}		
	else if(!strcmp(Type,"long"))
	{
		preamble = 0;
	}
	else
	{
		return -5;
	}

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in config_radio_preamble_group is %d\n",id);
			return -4;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in config_radio_preamble_group is %d\n",id);
			return -6;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								int *,
								unsigned int *
							);

	*RadioList_Head  = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_preamble_cmd_preamble");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								parameter.local_id,
								parameter.instance_id,
								connection,
								type,
								id,
								preamble,
								&count,
								&ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -1;
		else if(ret == RADIO_IS_DISABLE)
			retu = -2;
		else
			retu = -3;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -7;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -8;
	}	
	return retu;
}
#endif

/*Type为"short"或"long"*/
int config_radio_preamble(dbus_parameter parameter, DBusConnection *connection,int id,char *Type)/*返回0表示失败，返回1表示成功，返回-1表示radio id 不存在，返回-2表示Radio is disable,  please enable it first，返回-3表示出错，返回-4表示Radio ID非法*/
																									 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == Type)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = config_radio_preamble_group(parameter, connection,0,id,Type,&RadioList_Head);
	if(retu == -7)
	{
		Free_config_radio_preamble_group(RadioList_Head);
	}
	return retu;
#else
	unsigned int radio_id; 
	unsigned char preamble;
	int ret,retu;
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;	
	
	if (!strcmp(Type,"short"))
	{
		preamble = 1;	
	}		
	else if (!strcmp(Type,"long"))
	{
		preamble = 0;
	}

	//radio_id = id;
	
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radio_id = id;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in config_radio_preamble is %d\n",radio_id);
		return -4;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_PREAMBLE);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_PREAMBLE);*/
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radio_id,
							 DBUS_TYPE_BYTE,&preamble,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu=-1;
	else if(ret == RADIO_IS_DISABLE)
		retu=-2;
	else
		retu=-3;
	dbus_message_unref(reply);
	return retu;
#endif
}

#if _GROUP_POLICY
void Free_config_radio_longretry_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-6时，调用Free_config_radio_longretry_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*注意判断Lretry的范围，默认值是4， 取值范围是 1 -15*/
int config_radio_longretry_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,int Lretry,struct RadioList **RadioList_Head) 
										/*返回0表示失败，返回1表示成功，返回-1表示radio id 不存在*/
										/*返回-2表示Radio is disable,  please enable it first，返回-3表示出错*/
										/*返回-4表示Radio ID非法，返回-5表示Group ID非法*/
									 	/*返回-6表示partial failure，返回-7表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned char longretry = 0;
	int retu = 0;

	/*ret = parse_char_ID((char *)argv[0],&longretry);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
	   if(ret == WID_ILLEGAL_INPUT){
				vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
	   }
	   else{
		vty_out(vty,"<error> input parameter %s error\n",argv[0]);
	   }
		return CMD_SUCCESS;
	}

	if((longretry < 1)||(longretry > 15))
	{
		vty_out(vty,"<error> input parameter should be 1 to 15\n");
		return CMD_SUCCESS;
	}*/
	longretry= Lretry;

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in config_radio_longretry_group is %d\n",id);
			return -4;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in config_radio_longretry_group is %d\n",id);
			return -5;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_longretry_cmd_longretry");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								parameter.local_id,
								parameter.instance_id,
								connection,
								type,
								id,
								longretry,
								&count,
								&ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -1;
		else if(ret == RADIO_IS_DISABLE)
			retu = -2;
		else
			retu = -3;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -6;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -7;
	}	
	return retu;
}
#endif

/*注意判断Lretry的范围，默认值是4， 取值范围是 1 -15*/
int config_radio_longretry(dbus_parameter parameter, DBusConnection *connection,int id,int Lretry) /*返回0表示失败，返回1表示成功，返回-1表示radio id 不存在，返回-2表示Radio is disable,  please enable it first，返回-3表示出错，返回-4表示Radio ID非法*/
																									  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = config_radio_longretry_group(parameter, connection,0,id,Lretry,&RadioList_Head);
	if(retu == -6)
	{
		Free_config_radio_longretry_group(RadioList_Head);
	}
	return retu;
#else
	unsigned int radio_id; 
	unsigned char longretry;
	int ret,retu;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;	
	
    longretry= Lretry;

	//radio_id = id;	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radio_id = id;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in config_radio_longretry is %d\n",radio_id);
		return -4;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_LONGRETRY);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_LONGRETRY);*/
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radio_id,
							 DBUS_TYPE_BYTE,&longretry,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu=-1;
	else if(ret == RADIO_IS_DISABLE)
		retu=-2;
	else
		retu=-3;
	dbus_message_unref(reply);
	return retu;
#endif
}

#if _GROUP_POLICY
void Free_config_radio_shortretry_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-6时，调用Free_config_radio_shortretry_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*注意判断Sretry的范围，默认值是7， 取值范围是 1 -15*/
int config_radio_shortretry_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,int Sretry,struct RadioList **RadioList_Head)
										/*返回0表示失败，返回1表示成功，返回-1表示radio id 不存在*/
										/*返回-2表示Radio is disable,  please enable it first，返回-3表示出错*/
										/*返回-4表示Radio ID非法，返回-6表示partial failure*/
										/*返回-7表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned char shortretry = 0;
	int retu = 0;

	/*shortretry= atoi(argv[0]);*/
	/*ret = parse_char_ID((char *)argv[0],&shortretry);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
	   if(ret == WID_ILLEGAL_INPUT){
				vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
	   }
	   else{
		vty_out(vty,"<error> input parameter %s error\n",argv[0]);
	   }
		return CMD_SUCCESS;
	}

	if((shortretry < 1)||(shortretry > 15))
	{
		vty_out(vty,"<error> input parameter should be 1 to 15\n");
		return CMD_SUCCESS;
	}*/
	shortretry= Sretry;
	
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in config_radio_shortretry_group is %d\n",id);
			return -4;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in config_radio_shortretry_group is %d\n",id);
			return -5;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_shortretry_cmd_shortretry");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								parameter.local_id,
								parameter.instance_id,
								connection,
								type,
								id,
								shortretry,
								&count,
								&ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -1;
		else if(ret == RADIO_IS_DISABLE)
			retu = -2;
		else
			retu = -3;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -6;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -7;
	}	
	return retu;
}
#endif

/*注意判断Sretry的范围，默认值是7， 取值范围是 1 -15*/
int config_radio_shortretry(dbus_parameter parameter, DBusConnection *connection,int id,int Sretry) /*返回0表示失败，返回1表示成功，返回-1表示radio id 不存在，返回-2表示Radio is disable,  please enable it first，返回-3表示出错，返回-4表示Radio ID非法*/
																									  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = config_radio_shortretry_group(parameter, connection,0,id,Sretry,&RadioList_Head);
	if(retu == -6)
	{
		Free_config_radio_shortretry_group(RadioList_Head);
	}
	return retu;
#else
	unsigned int radio_id; 
	unsigned char shortretry;
	int ret,retu;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;	
	
    shortretry= Sretry;

	//radio_id = id;	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radio_id = id;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in config_radio_shortretry is %d\n",radio_id);
		return -4;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_SHORTRETRY);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_SHORTRETRY);*/
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radio_id,
							 DBUS_TYPE_BYTE,&shortretry,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu=-1;
	else if(ret == RADIO_IS_DISABLE)
		retu=-2;
	else
		retu=-3;
	dbus_message_unref(reply);
	return retu;
#endif
}

#if _GROUP_POLICY
void Free_config_max_rate_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-15时，调用Free_config_max_rate_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int config_max_rate_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char*rad_rate,struct RadioList **RadioList_Head)
															/*返回0表示失败，返回1返回成功，返回-1表示radio id does not exist，返回-2表示mode 11b support rate list:10 20 55 110*/
															/*返回-3表示mode 11a support rate list:60 90 120 180 240 360 480 540，返回-4表示mode 11g support rate list:60 90 120 180 240 360 480 540*/	 
															/*返回-5表示mode 11b/g support rate list:10 20 55 60 90 110 120 180 240 360 480 540，返回-6表示wtp radio does not support this rate,please check first*/
															/*返回-7表示radio is disable, please enable it first，返回-8表示radio mode is 11n,not allow to set rate，返回-9表示radio list is empty*/
															/*返回-10表示radio support rate does not exist，返回-11表示radio type is conflict, please check it first，返回-12表示error，返回-13表示Radio ID非法*/
															/*返回-14表示Group ID非法	，返回-15表示partial failure，返回-16表示group id does not exist*/
															/*返回-17表示mode 11an support rate list:60 90 120 180 240 360 480 540，返回-18表示mode 11gn support rate list:60 90 120 180 240 360 480 540*/
															/*返回-19表示mode 11a/an support rate list:60 90 120 180 240 360 480 540，返回-20表示mode 11g/gn support rate list:60 90 120 180 240 360 480 540*/
															/*返回-21表示mode 11b/g/n support rate list:10 20 60 90 110 120 180 240 360 480 540*/
{
    if(NULL == connection)
        return 0;
        
	if(NULL == rad_rate)
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int num=0;
	int list1[RADIO_RATE_LIST_LEN];
	int ret = 0;
	int ret1 = 0;
	int count = 0;
	int mode = 0;
	int rate = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	int retu = 0;
		
	/*parse the rate */
	ret = parse_int_ID((char *)rad_rate,&rate);
	if (ret != WID_DBUS_SUCCESS)
	{
		return 0;
	}	
	
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in config_max_rate_group is %d\n",id);
			return -13;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in config_max_rate_group is %d\n",id);
			return -14;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								int ,
								int *,
								int *,
								int *,
								int *,
								int *,
								int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_max_rate_cmd_set_max_rate");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 rate,
								 &count,
								 &ret,
								 &ret1,
								 &num,
								 &mode,
								 list1
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(type==0)
	{
		if(ret==0)
		{
			if(ret1==-1)
			{
				retu = 0;
			}
			else
			{
				retu = 1;
			}
		}
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -1;
		else if(ret == WTP_NO_SURPORT_Rate)
		{
			if (mode == 1)
			{
				retu = -2;
			}
			else if (mode == 2)
			{
				retu = -3;
			}
			else if (mode == 4)
			{
				retu = -4;
			}
			else if (mode == 10)
			{
				retu = -17;
			}
			else if (mode == 12)
			{
				retu = -18;
			}
			else if (mode == 26)
			{
				retu = -19;
			}
			else if (mode == 44)
			{
				retu = -20;
			}
			else if (mode == 5)
			{
				retu = -5;
			}
			else if (mode == 13)
			{
				retu = -21;
			}
			else
			{
				retu = -6;
			}
		}
		else if(ret == RADIO_IS_DISABLE)
			retu = -7;
		else if(ret == RADIO_MODE_IS_11N)
			retu = -8;
		else if(ret == RADIO_SUPPORT_RATE_EMPTY)
			retu = -9;
		else if(ret == RADIO_SUPPORT_RATE_NOT_EXIST)/*use in delete support ratelist,maybe later*/
			retu = -10;
		else if((ret == WTP_NO_SURPORT_TYPE)||(ret == RADIO_SUPPORT_RATE_CONFLICT))
			retu = -11;
		else
			retu = -12;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -15;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
					{
						if(Radio_Show_Node == NULL)
							Radio_Show_Node = RadioList_Head->RadioList_list;
						else 
							Radio_Show_Node = Radio_Show_Node->next;
						if(Radio_Show_Node == NULL)
							break;
						vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
					}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -16;
	
	}	
	return retu;
}
#endif

/*Radio rate value: 11b/g: (10,20,55,60,90,110,120,180,240,360,480,540) */
/*11n: (65,130,135,150,195,260,270,300,390,405,450,520,540,585,600,650,780,810,900,1040,1080,1170,1200,1215,1300,1350,1500,1620,1800,2160,2400,2430,2700,3000)*/
int config_max_rate(dbus_parameter parameter, DBusConnection *connection,int id,char*rad_rate,struct RadioList **RadioList_Head)
															/*返回0表示失败，返回1返回成功，返回-1表示Radio rate illegal*/
															/*返回-2表示radio id does not exist，返回-3表示mode 11b support rate list:10 20 55 110*/
															/*返回-4表示mode 11a support rate list:60 90 120 180 240 360 480 540*/
															/*返回-5表示mode 11g support rate list:60 90 120 180 240 360 480 540*/	 
															/*返回-6表示mode 11b/g support rate list:10 20 55 60 90 110 120 180 240 360 480 540*/
															/*返回-7表示mode 11b/g/n support rate list:10 20 60 90 110 120 180 240 360 480 540*/
															/*返回-8表示wtp radio does not support this rate,please check first*/
															/*返回-9表示radio is disable, please enable it first*/
															/*返回-10表示wtp is not binding wlan，返回-11表示radio list is empty*/
															/*返回-12表示radio support rate does not exist，返回-13表示radio type is conflict, please check it first*/
															/*返回-14表示error，返回-15表示Radio ID非法*/
															/*返回-16表示mode 11an support rate list:60 90 120 180 240 360 480 540*/
															/*返回-17表示mode 11gn support rate list:60 90 120 180 240 360 480 540*/
															/*返回-18表示mode 11a/an support rate list:60 90 120 180 240 360 480 540*/
															/*返回-19表示mode 11g/gn support rate list:60 90 120 180 240 360 480 540*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == rad_rate)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = config_max_rate_group(parameter, connection,0,id,rad_rate,&RadioList_Head);
	if(retu == -15)
	{
		Free_config_max_rate_group(RadioList_Head);
	}
	return retu;
#else
	int mode,rate; 
	unsigned int radio_id = 0;
	int ret = 0;
	int num=0;
	int i = 0;
	int list1[RADIO_RATE_LIST_LEN];	
	int index = 0;
	int localid = 1;
    int ret1 = 0;
    struct dcli_n_rate_info nRateInfo;
    unsigned char channel = 0;
    //int result = 0;
	//struct RadioList *Radio_Show_Node = NULL;
    int retu = 0;	
	
	ret = parse_int_ID((char *)rad_rate,&rate);
	if (ret != WID_DBUS_SUCCESS)
	{
		//vty_out(vty,"<error> input parameter should be <10-540>\n");
		//vty_out(vty,"You should choose Radio rate value:\n 11b/g: (10,20,55,60,90,110,120,180,240,360,480,540)\n 11n: (65,130,135,150,195,260,270,300,390,405,450,520,540,585,600,650,780,810,900, \n\t1040,1080,1170,1200,1215,1300,1350,1500,1620,1800,2160,2400,2430,2700,3000)\n");
		return -1;
	}		
	/*if(vty->node == RADIO_NODE){
		index = 0;			
		radio_id = (int)vty->index;
	}else if(vty->node == HANSI_RADIO_NODE){
		index = vty->index; 
		localid = vty->local;
        slot_id = vty->slotindex;
		radio_id = (int)vty->index_sub;
	}else if (vty->node == LOCAL_HANSI_RADIO_NODE){
        index = vty->index;
        localid = vty->local;
        slot_id = vty->slotindex;
		radio_id = (int)vty->index_sub;
    }*/
	radio_id = id;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in config_max_rate is %d\n",radio_id);
		return -15;
	}

	void *(*dcli_init_func)(
								int , 
								int ,
								DBusConnection *,
								unsigned ,
								int ,
								int *,
								int *,
								int *,
								int *,
								int *,
								struct dcli_n_rate_info *, 
								unsigned char *,
								int
							);

	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_max_rate_cmd_set_max_rate_v1");
		if(NULL != dcli_init_func)
		{
			(*dcli_init_func)
			  (
				 parameter.local_id,
				 parameter.instance_id,
				 connection,
				 radio_id,
				 rate,
				 &ret,
				 &ret1,
				 &num,
				 &mode,
				 list1,
				 &nRateInfo,
				 &channel,
				 1
			  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
			
	if(ret == 0)
	{
	    if(mode<8)
	    {
			if(ret1==-1)
			{
				retu = 0;
			}
			else 
			{
				retu = 1;
			}
		}
		else
		{
			retu = 1;
		    /*if((nRateInfo.mcs<0) || (nRateInfo.cwmode<0) || (nRateInfo.guard_interval<0))
		    {
		        result = 1;
		    }
		    if(result == 1)
		    {
			    char sel[PATH_LEN] = {0};
    			//fflush(stdin);
    			vty_out(vty,"Setting of rate need change parameters shown below:\n");
    			if(nRateInfo.mcs < 0)
    			    vty_out(vty,"mcs : %d\n", nRateInfo.mcs+1000);    
    			if(nRateInfo.cwmode < 0)
    			    vty_out(vty,"cwmode : %s\n", ((nRateInfo.cwmode+1000) == 0)?"ht20":"ht40");
    			if(nRateInfo.guard_interval < 0)
    			    vty_out(vty,"guard interval : %d\n", nRateInfo.guard_interval+1000);
    			if(channel != 0)
    			    vty_out(vty,"channel : %d\n", channel);
    			vty_out(vty,"Do you steel want to set rate? [yes/no]:\n");
    			fscanf(stdin, "%s", sel);
    			while(1){
    				if(!strncasecmp("yes", sel, strlen(sel))){
    			        result = set_11n_rate_paras(localid,index,dcli_dbus_connection,nRateInfo.mcs,nRateInfo.cwmode,nRateInfo.guard_interval,radio_id,channel);
    			        if(result == 0)
    			            vty_out(vty,"set radio rate successful!!!\n");
    			        else
    			            vty_out(vty,"failed to set radio rate\n");
    					break;
    				}
    				else if(!strncasecmp("no", sel, strlen(sel))){
    				    vty_out(vty,"user stop setting radio rate\n");
    					break;
    				}
    				else{
    					vty_out(vty,"% Please answer 'yes' or 'no'.\n");
    					vty_out(vty,"Do you steel want to set rate? [yes/no]:\n");
    					memset(sel, 0, PATH_LEN);
    					fscanf(stdin, "%s", sel);
    				}
    			}
    	    }*/
		}
	}
	else if(ret == RADIO_ID_NOT_EXIST)
		retu = -2;
	else if(ret == WTP_NO_SURPORT_Rate)
	{
		if (mode == 1)
		{
			retu = -3;
		}
		else if (mode == 2)
		{
			retu = -4;
		}
		else if (mode == 4)
		{
			retu = -5;
		}
		else if (mode == 10)
		{
			retu = -16;
		}
		else if (mode == 12)
		{
			retu = -17;
		}
		else if (mode == 26)
		{
			retu = -18;
		}
		else if (mode == 44)
		{
			retu = -19;
		}
		else if (mode == 5)
		{
			retu = -6;
		}
		else if (mode == 13)
		{
			retu = -7;
		}
		else
		{
			retu = -8;
		}
	}
	else if(ret == RADIO_IS_DISABLE)
		retu = -9;
	else if(ret == RADIO_MODE_IS_11N)
		retu = -8;
	else if(ret == WTP_IS_NOT_BINDING_WLAN_ID)
		retu = -10;
	else if(ret == RADIO_SUPPORT_RATE_EMPTY)
		retu = -11;
	else if(ret == RADIO_SUPPORT_RATE_NOT_EXIST)/*use in delete support ratelist,maybe later*/
		retu = -12;
	else if((ret == WTP_NO_SURPORT_TYPE)||(ret == RADIO_SUPPORT_RATE_CONFLICT))
		retu = -13;
	else
		retu = -14;

	return retu;
	
#endif
}

#if _GROUP_POLICY
void Free_set_bss_max_sta_num_group(struct RadioList *RadioList_Head)
{
	if(RadioList_Head != NULL)
	{
		free(RadioList_Head);
		RadioList_Head =NULL;
	}
}

/*返回-9时，调用Free_set_bss_max_sta_num_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_bss_max_sta_num_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *Wlan_id,char*bss_num,struct RadioList **RadioList_Head)
									/*返回0表示失败，返回1表示成功，返回-1表示input parameter error*/
                                    /*返回-2表示wlanid should be 1 to WLAN_NUM，返回-3表示max station number should be greater than 0,and not cross 32767*/
                                    /*返回-4表示bss not exist，返回-5表示more sta(s) has accessed before you set max sta num */
                                    /*返回-6表示operation fail!，返回-7表示Radio ID非法，返回-8表示Group ID非法*/
									/*返回-9表示partial failure，返回-10表示group id does not exist，返回-11表示wlan is not binded radio*/
									/*返回-12表示bss is not exist*/
{
    if(NULL == connection)
        return 0;
        
	if((NULL == Wlan_id)||(NULL == bss_num))
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int ret2 = 0;
	int count = 0;
	int failnum = 0;
	int max_sta_num = 0;   //fengwenchao add 20110512
	unsigned int wlanid = 0;     //fengwenchao add 20110512
	unsigned char wlan_wid = 0; //fengwenchao add 20110512
	unsigned int type=1;
	unsigned int bssid = 0;
	unsigned int id = 0;
	unsigned int TYPE = 0;
	int retu = 0 ;		

	ret = parse_int_ID((char *)Wlan_id,&wlanid);	
	if (ret != WID_DBUS_SUCCESS)
	{	
		return -1;
	}

	ret = parse_int_ID((char *)bss_num,&max_sta_num);
	if (ret != WID_DBUS_SUCCESS)
	{	
		return -1;
	}

	if((wlanid < 1)||(wlanid > WLAN_NUM))							 //fengwenchao modify 20110512
	{
		return -2;
	}

	if((max_sta_num< 0)||(max_sta_num > 32767))
	{
		return -3;
	}

	id = group_id;
	TYPE = group_type;
	if(TYPE == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_bss_max_sta_num_group is %d\n",id);
			return -7;
		}
	}
	else if(TYPE == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_bss_max_sta_num_group is %d\n",id);
			return -8;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned int ,
								unsigned int ,
								unsigned int ,
								int *,
								int *,
								int *,
								int *
							);
	
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_bss_max_num_cmd_set_bss_max_sta_num");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 TYPE,
								 id,
								 type,
								 max_sta_num,
								 wlanid,
								 &count,
								 &ret,
								 &ret2,
								 &failnum
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(TYPE==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret==WLAN_ID_NOT_EXIST)
			retu = -4;
		else if(ret==WID_DBUS_ERROR)
			retu = -6;
		else if(ret==SET_MAX_STANUM_SMALLER_THAN_CURRENT_STANUM)
			retu = -5;
		else if(ret == Wlan_IF_NOT_BE_BINDED)
			retu = -11;
		else if(ret == BSS_NOT_EXIST)
 			retu = -12;
	}
	else if(TYPE==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(TYPE == 1)&&(*RadioList_Head!=NULL)&&(failnum !=0))
			{
				retu = -9;
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -10;
	}	
	return retu;
}
#endif

/*bss_num的范围是0-32767*/
int set_bss_max_sta_num(dbus_parameter parameter, DBusConnection *connection,int id,char *Wlan_id,char*bss_num)
																			   /*返回0表示失败，返回1表示成功，返回-1表示input parameter error*/
				                                                               /*返回-2表示wlanid should be 1 to WLAN_NUM，返回-3表示max station number should be greater than 0,and not cross 32767*/
				                                                               /*返回-4表示bss not exist，返回-5表示more sta(s) has accessed before you set max sta num */
				                                                               /*返回-6表示operation fail!，返回-7表示Radio ID非法，返回-11表示wlan is not binded radio*/
																			   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if((NULL == Wlan_id)||(NULL == bss_num))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_bss_max_sta_num_group(parameter, connection,0,id,Wlan_id,bss_num,&RadioList_Head);
	if(retu == -9)
	{
		Free_set_bss_max_sta_num_group(RadioList_Head);
	}
	return retu;
#else
	int ret=0,retu=0;
	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	unsigned int radio_id=0;	
	int max_sta_num = 0;
	unsigned int type=1;
	int stanum=0;
	unsigned int wlanid = 0;
	unsigned char wlan_wid = 0;
	//radio_id = (int)id;

	ret = parse_int_ID((char *)Wlan_id,&wlanid);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
		return -1;
	}

	ret = parse_int_ID((char *)bss_num,&max_sta_num);

	if (ret != WID_DBUS_SUCCESS)
	{	
		return -1;
	}

	if((wlanid < 1)||(wlanid > WLAN_NUM))
	{
		return -2;
	}

	if((max_sta_num< 0)||(max_sta_num > 32767))
	{
		return -3;
	}
	
	dbus_error_init(&err);

	/*compare max_sta_num  with  current sta num*/	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radio_id = id;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in set_bss_max_sta_num is %d\n",radio_id);
		return -7;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,ASD_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,ASD_DBUS_STA_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,ASD_DBUS_STA_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,ASD_DBUS_STA_METHOD_GET_STA_INFO);

	//bssid=radio_id*L_BSS_NUM+bss_index-1;
	
	/*query = dbus_message_new_method_call(ASD_DBUS_BUSNAME,ASD_DBUS_STA_OBJPATH,\
						ASD_DBUS_STA_INTERFACE,ASD_DBUS_STA_METHOD_GET_STA_INFO);*/
	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&type,
							 DBUS_TYPE_UINT32,&wlanid,
							 DBUS_TYPE_UINT32,&radio_id,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
		
	dbus_message_unref(query);
		
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&stanum);
	dbus_message_unref(reply);

	if(stanum==-1){
		retu = -4;
	}
	
	if(max_sta_num< stanum){
		return -5;
	}

/*	int index;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == RADIO_NODE){
		index = 0;			
		radio_id = (int)vty->index;
	}else if(vty->node == HANSI_RADIO_NODE){
		index = vty->index; 		
		radio_id = (int)vty->index_sub;
	}	*/
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_BSS_MAX_STA);

	
	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_BSS_MAX_STA);*/
	wlan_wid = (unsigned char)wlanid;	 //fengwenchao add 20110512	

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radio_id,							 
							 DBUS_TYPE_BYTE,&wlan_wid,				 
							 DBUS_TYPE_UINT32,&max_sta_num,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret==WLAN_ID_NOT_EXIST)
		retu=-4;
	else if(ret==WID_DBUS_ERROR)
		retu=-6;
	else if(ret == Wlan_IF_NOT_BE_BINDED)
		retu=-11;	

	dbus_message_unref(reply);
	return retu;
#endif
}

#if _GROUP_POLICY
void Free_set_radio_bss_l3_policy_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}


/*返回-17时，调用Free_set_radio_bss_l3_policy_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_radio_bss_l3_policy_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *wlan_id,char *bss_policy,struct RadioList **RadioList_Head) 
													/*返回0表示失败，返回1表示成功，返回-1表示input parameter error*/
                                                    /*返回-2表示BSS is enable, if you want to operate this, please disable it first*/
												    /*返回-3表示BSS l3 interface is exist,you should delete this interface first*/
												    /*返回-4表示BSS create l3 interface fail，返回-5表示BSS delete l3 interface fail*/
												    /*返回-6表示WLAN policy is NO_INTERFACE,can not use this command*/
												    /*返回-7表示 BSS is not exist，返回-8表示can not use this command*/
												    /*返回-9表示RADIO is not exist，返回-10表示WTP is not exist*/
												    /*返回-11表示WTP is not binding wlan，返回-12表示WLAN br is not exist*/
												    /*返回-13表示add bss interface to wlan br fail，返回-14表示remove bss interface from wlan br fail*/
												    /*返回-15表示Radio ID非法，返回-16表示Group ID非法*/
												    /*返回-17表示partial failure，返回-18表示group id does not exist*/
													/*返回-19表示input parameter should be 1 to WLAN_NUM，返回-20表示wlan id is not exist*/
													/*返回-21表示this wlan id is not binding radio*/
{
    if(NULL == connection)
        return 0;
        
	if((NULL == wlan_id)||(NULL == bss_policy))
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned int bsspolicy = 0;
	unsigned char wlanid = 0;
	int retu = 0;

	//radio_id = (int)vty->index;
	
	ret = parse_char_ID((char *)wlan_id,&wlanid);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
		return -1;
	}
	if((wlanid < 1)||(wlanid > WLAN_NUM))
	{
		return -19;		
	}

	if (!strcmp(bss_policy,"no"))/*bss use local mac mode*/
	{
    	bsspolicy = 0;
	}
	else if (!strcmp(bss_policy,"wlan"))/*create a interface ,add it to the br*/
	{
    	bsspolicy = 1;
	}
	else if (!strcmp(bss_policy,"bss"))/*use bss split mac mode*/
	{
		
    	bsspolicy = 2;
	}
	else
	{
		return -1;
	}
	
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_radio_bss_l3_policy_group is %d\n",id);
			return -15;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_radio_bss_l3_policy_group is %d\n",id);
			return -16;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								unsigned int ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_bss_l3_policy_cmd_bss_no_wlan_bss_interface");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 wlanid,
								 bsspolicy,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == BSS_BE_ENABLE)
			retu = -2;
		else if(ret == BSS_IF_NEED_DELETE)
			retu = -3;
		else if(ret == BSS_CREATE_L3_INTERFACE_FAIL)
			retu = -4;
		else if(ret == BSS_DELETE_L3_INTERFACE_FAIL)
			retu = -5;
		else if(ret == IF_POLICY_CONFLICT)
			retu = -6;
		else if(ret == BSS_NOT_EXIST)
			retu = -7;
		else if(ret == UNKNOWN_ERROR)
			retu = -8;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -9;
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -10;
		else if(ret == WTP_IS_NOT_BINDING_WLAN_ID)
			retu = -11;
		else if(ret == WLAN_CREATE_BR_FAIL)
			retu = -12;
		else if(ret == BSS_L3_INTERFACE_ADD_BR_FAIL)
			retu = -13;
		else if(ret == BSS_L3_INTERFACE_DEL_BR_FAIL)
			retu = -14;
		else if(ret == WLAN_ID_NOT_EXIST)
			retu = -20;
		else if(ret == Wlan_IF_NOT_BE_BINDED)
		  	retu = -21;
		else
			retu = 0;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -17;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -18;
	}	
	return retu;
}
#endif

int set_radio_bss_l3_policy(dbus_parameter parameter, DBusConnection *connection,int rid,char *wlan_id,char *bss_policy) 
																					   /*返回0表示失败，返回1表示成功，返回-1表示input parameter error*/
						                                                               /*返回-2表示BSS is enable, if you want to operate this, please disable it first*/
					                												   /*返回-3表示BSS l3 interface is exist,you should delete this interface first*/
																					   /*返回-4表示BSS create l3 interface fail，返回-5表示BSS delete l3 interface fail*/
																					   /*返回-6表示WLAN policy is NO_INTERFACE,can not use this command*/
																					   /*返回-7表示 BSS is not exist，返回-8表示can not use this command*/
																					   /*返回-9表示RADIO is not exist，返回-10表示WTP is not exist*/
																					   /*返回-11表示WTP is not binding wlan，返回-12表示WLAN br is not exist*/
																					   /*返回-13表示add bss interface to wlan br fail，返回-14表示remove bss interface from wlan br fail*/
																					   /*返回-15表示Radio ID非法，返回-19表示input parameter should be 1 to WLAN_NUM*/
																					   /*返回-20表示wlan id is not exist，返回-21表示this wlan id is not binding radio*/
																					   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if((NULL == wlan_id)||(NULL == bss_policy))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_radio_bss_l3_policy_group(parameter, connection,0,rid,wlan_id,bss_policy,&RadioList_Head);
	if(retu == -17)
	{
		Free_set_radio_bss_l3_policy_group(RadioList_Head);
	}
	return retu;
#else
	int ret=0,retu;
	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	unsigned int radio_id=0;
	unsigned int bsspolicy = 0;   	
	unsigned char wlanid = 0;
   
   	//radio_id = (int)rid;
   	
	ret = parse_char_ID((char *)wlan_id,&wlanid);
   	
   	if (ret != WID_DBUS_SUCCESS)
   	{	
   		return -1;
   	}
	if((wlanid < 1)||(wlanid > WLAN_NUM))
	{
		return -19;		
	}
   
   	if (!strcmp(bss_policy,"no"))//bss use local mac mode
   	{
   		
       	bsspolicy = 0;
   	}
   	else if (!strcmp(bss_policy,"wlan"))//create a interface ,add it to the br
   	{
   		
       	bsspolicy = 1;
   	}
   	else if (!strcmp(bss_policy,"bss"))//use bss split mac mode
   	{
   		
       	bsspolicy = 2;
   	}
   	else
   	{
   		return -1;
   	}
	
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radio_id = rid;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in set_radio_bss_l3_policy is %d\n",radio_id);
		return -15;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_BSS_L3_POLICY);

   	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
   						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_BSS_L3_POLICY);*/
   	
   	dbus_error_init(&err);
   
   	dbus_message_append_args(query,
   							 DBUS_TYPE_UINT32,&radio_id,
							 DBUS_TYPE_BYTE,&wlanid,
   							 DBUS_TYPE_UINT32,&bsspolicy,
   							 DBUS_TYPE_INVALID);
   
   	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
   	
   	dbus_message_unref(query);
   	
   	if (NULL == reply) {
   		if (dbus_error_is_set(&err)) {
   			dbus_error_free(&err);
   		}
   		return SNMPD_CONNECTION_ERROR;
   	}
   	
   	dbus_message_iter_init(reply,&iter);
   	dbus_message_iter_get_basic(&iter,&ret);
   	dbus_message_unref(reply);
	
	if(ret == 0)
		retu=1;
	else if(ret == BSS_BE_ENABLE)
		retu=-2;
	else if(ret == BSS_IF_NEED_DELETE)
		retu=-3;
	else if(ret == BSS_CREATE_L3_INTERFACE_FAIL)
		retu=-4;
	else if(ret == BSS_DELETE_L3_INTERFACE_FAIL)
		retu=-5;
	else if(ret == IF_POLICY_CONFLICT)
		retu=-6;
	else if(ret == BSS_NOT_EXIST)
		retu=-7;
	else if(ret == UNKNOWN_ERROR)
		retu=-8;		
	else if(ret == RADIO_ID_NOT_EXIST)
		retu=-9;
	else if(ret == WTP_ID_NOT_EXIST)
		retu=-10;
	else if(ret == WTP_IS_NOT_BINDING_WLAN_ID)
		retu=-11;		
	else if(ret == WLAN_CREATE_BR_FAIL)
		retu=-12;
	else if(ret == BSS_L3_INTERFACE_ADD_BR_FAIL)
		retu=-13;
	else if(ret == BSS_L3_INTERFACE_DEL_BR_FAIL)
		retu=-14;
	else if(ret == WLAN_ID_NOT_EXIST)
		retu=-20;
	else if(ret == Wlan_IF_NOT_BE_BINDED)
		retu=-21;
	else
		retu=0;
   	
   	return retu;
#endif
}

#if _GROUP_POLICY
void Free_radio_apply_wlan_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}


/*返回-16时，调用Free_radio_apply_wlan_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int radio_apply_wlan_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *wlan_id,struct RadioList **RadioList_Head)  
											/*返回0表示失败，返回1表示成功，返回-1表示input parameter error*/
                                            /*返回-2表示WLAN ID非法，返回-3表示radio is not exist，返回-4表示WLAN is not exist*/
											/*返回-5表示bss num is already L_BSS_NUM，返回-6表示wtp wlan binding interface not match*/
											/*返回-7表示wtp not bind interface，返回-8表示wlan not bind interface*/
											/*返回-9表示wlan create wlan bridge fail，返回-10表示add bss if to wlan bridge fail*/
											/*返回-11表示wtp over max wep wlan count 4，返回-12表示Radio ID非法*/
											/*返回-13表示illegal input:Input exceeds the maximum value of the parameter type*/
											/*返回-14表示radio apply bingding securityindex is same with other*/
											/*返回-15表示Group ID非法，返回-16表示partial failure*/
											/*返回-17表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	if(NULL == wlan_id)
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned char wlanid = 0;
	int retu = 0;
	
	ret = parse_char_ID((char *)wlan_id,&wlanid);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
       if(ret == WID_ILLEGAL_INPUT){
	   		retu = -13;
       }
	   else{
	   		retu = -1;
	   }
		return retu;
	}
	
	if((wlanid < 1)||(wlanid >(WLAN_NUM-1)))
	{
		return -2;
	}

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in radio_apply_wlan_group is %d\n",id);
			return -12;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in radio_apply_wlan_group is %d\n",id);
			return -15;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_apply_wlan_cmd_radio_apply_wlan");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 wlanid,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret==RADIO_ID_NOT_EXIST)
			retu = -3;
		else if(ret==WLAN_ID_NOT_EXIST)
			retu = -4;
		else if(ret==WTP_OVER_MAX_BSS_NUM)
			retu = -5;
		else if(ret==WTP_WLAN_BINDING_NOT_MATCH)
			retu = -6;
		else if(ret==WTP_IF_NOT_BE_BINDED)
			retu = -7;
		else if(ret==Wlan_IF_NOT_BE_BINDED)
			retu = -8;
		else if(ret==WLAN_CREATE_L3_INTERFACE_FAIL)
			retu = -9;
		else if(ret==BSS_L3_INTERFACE_ADD_BR_FAIL)
			retu = -10;
		else if(ret == WTP_WEP_NUM_OVER)
			retu = -11;
		else 
			retu = 0;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -16;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -17;
	}
	return retu;

}

#endif

int radio_apply_wlan(dbus_parameter parameter, DBusConnection *connection,int rid,char *wlan_id)  
																/*返回0表示失败，返回1表示成功，返回-1表示input parameter error*/
					                                            /*返回-2表示WLAN ID非法，返回-3表示radio is not exist，返回-4表示WLAN is not exist*/
																/*返回-5表示bss num is already L_BSS_NUM，返回-6表示wtp wlan binding interface not match*/
																/*返回-7表示wtp not bind interface，返回-8表示wlan not bind interface*/
																/*返回-9表示wlan create wlan bridge fail，返回-10表示add bss if to wlan bridge fail*/
																/*返回-11表示wtp over max wep wlan count 4，返回-12表示Radio ID非法*/
																/*返回-13表示illegal input:Input exceeds the maximum value of the parameter type*/
																/*返回-14表示radio apply bingding securityindex is same with other*/
																/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == wlan_id)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = radio_apply_wlan_group(parameter, connection,0,rid,wlan_id,&RadioList_Head);
	if(retu == -16)
	{
		Free_radio_apply_wlan_group(RadioList_Head);
	}
	return retu;
#else
   	int ret=0,retu;
   	DBusMessage *query, *reply;
   	DBusError err;
   	DBusMessageIter	 iter;
   	unsigned int radio_id=0;
   	unsigned char wlanid = 0;
   	//radio_id = (int)rid;
   	
   	ret = parse_char_ID((char *)wlan_id,&wlanid);
   	
   	if (ret != WID_DBUS_SUCCESS)
   	{	   		
		if(ret == WID_ILLEGAL_INPUT){
			retu = -13;
		}
		else{
			retu = -1;
		}
   		return retu;
   	}
   	
	if((wlanid < 1)||(wlanid >(WLAN_NUM-1)))
   	{
   		return -2;
   	}	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radio_id = rid;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in radio_apply_wlan is %d\n",radio_id);
		return -12;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_APPLY_WLAN);
    
   	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
   						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_APPLY_WLAN);*/
   	
   	dbus_error_init(&err);
   
   	dbus_message_append_args(query,
   							 DBUS_TYPE_UINT32,&radio_id,
   							 DBUS_TYPE_BYTE,&wlanid,
   							 DBUS_TYPE_INVALID);
   
   	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
   	
   	dbus_message_unref(query);
   	
   	if (NULL == reply) {
   		if (dbus_error_is_set(&err)) {
   			dbus_error_free(&err);
   		}
   		return SNMPD_CONNECTION_ERROR;
   	}
   	
   	dbus_message_iter_init(reply,&iter);
   	dbus_message_iter_get_basic(&iter,&ret);
   	dbus_message_unref(reply);
	if(ret == 0)
		retu=1;
	else if(ret==RADIO_ID_NOT_EXIST)
		retu=-3;
	else if(ret==WLAN_ID_NOT_EXIST)
		retu=-4;		
	else if(ret==WTP_OVER_MAX_BSS_NUM)
		retu=-5;
	else if(ret==WTP_WLAN_BINDING_NOT_MATCH)
		retu=-6;
	else if(ret==WTP_IF_NOT_BE_BINDED)
		retu=-7;
	else if(ret==Wlan_IF_NOT_BE_BINDED)
		retu=-8;
	else if(ret==WLAN_CREATE_L3_INTERFACE_FAIL)
		retu=-9;
	else if(ret==BSS_L3_INTERFACE_ADD_BR_FAIL)
		retu=-10;
	else if(ret == WTP_WEP_NUM_OVER)
		retu=-11;
	else if(ret == SECURITYINDEX_IS_SAME)
		retu=-14;
	else 
		retu=0;
	
   	return retu;
#endif
}

#if _GROUP_POLICY
void Free_radio_apply_qos_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}


/*返回-7时，调用Free_radio_apply_qos_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*qos_id范围1-15*/
int radio_apply_qos_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *qos_id,struct RadioList **RadioList_Head) 
												/*返回0表示失败，返回1表示成功，返回-1表示input parameter error*/
												/*返回-2表示QOS ID非法，返回-3表示radio is not exist*/
												/*返回-4表示QOS is not exist，返回-5表示Radio ID非法*/
												/*返回-6表示Group ID非法，返回-7表示partial failure*/
												/*返回-8表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	if(NULL == qos_id)
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned int qosid = 0;
	int retu = 0;
	
	ret = parse_int_ID((char *)qos_id,&qosid);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
		return -1;
	}
	
	if((qosid < 1)||(qosid >15))
	{
		return -2;
	}

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in radio_apply_qos_group is %d\n",id);
			return -5;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in radio_apply_qos_group is %d\n",id);
			return -6;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned int ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_apply_qos_cmd_radio_apply_qos");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 qosid,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -3;
		else if(ret == WID_QOS_NOT_EXIST)
			retu = -4;
		else 
			retu = 0;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -7;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -8;
	}	
	return retu;
}
#endif

/*qos_id范围1-15*/
int radio_apply_qos(dbus_parameter parameter, DBusConnection *connection,int rid,char *qos_id) 
															 /*返回0表示失败，返回1表示成功，返回-1表示input parameter error*/
					   										 /*返回-2表示QOS ID非法，返回-3表示radio is not exist*/
					   										 /*返回-4表示QOS is not exist，返回-5表示Radio ID非法*/
															 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == qos_id)
		return 0;
	
#if _GROUP_POLICY
		int retu = 0;
		struct RadioList *RadioList_Head = NULL;
	
		retu = radio_apply_qos_group(parameter, connection,0,rid,qos_id,&RadioList_Head);
		if(retu == -7)
		{
			Free_radio_apply_qos_group(RadioList_Head);
		}
		return retu;
#else
	   int ret=0,retu;
	   DBusMessage *query, *reply;
	   DBusError err;
	   DBusMessageIter	iter;
	   unsigned int radio_id=0;
	   int qosid = 0;
	   //radio_id = (int)rid;
	   
	   ret = parse_int_ID((char *)qos_id,&qosid);
	   
	   if (ret != WID_DBUS_SUCCESS)
	   {   
		   return -1;
	   }
	   
	   if((qosid < 1)||(qosid >15))
	   {
		   return -2;
	   }
	   
	   char BUSNAME[PATH_LEN];
	   char OBJPATH[PATH_LEN];
	   char INTERFACE[PATH_LEN];

	   radio_id = rid;
	   if(radio_id > G_RADIO_NUM || radio_id == 0){
			syslog(LOG_DEBUG,"radio id in radio_apply_qos is %d\n",radio_id);
			return -5;
	   }
	   
	   ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	   ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	   ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	   query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_APPLY_QOS);

	   /*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						   WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_APPLY_QOS);*/
	   
	   dbus_error_init(&err);
   
	   dbus_message_append_args(query,
								DBUS_TYPE_UINT32,&radio_id,
								DBUS_TYPE_UINT32,&qosid,
								DBUS_TYPE_INVALID);
   
	   reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	   
	   dbus_message_unref(query);
	   
	   if (NULL == reply) {
		   if (dbus_error_is_set(&err)) {
			   dbus_error_free(&err);
		   }
		   return SNMPD_CONNECTION_ERROR;
	   }
	   
	   dbus_message_iter_init(reply,&iter);
	   dbus_message_iter_get_basic(&iter,&ret);
	   dbus_message_unref(reply);
	   if(ret == 0)
	   	   retu=1;
	   else if(ret == RADIO_ID_NOT_EXIST)
	   	   retu=-3;
	   else if(ret == WID_QOS_NOT_EXIST)
	   	   retu=-4;
	   else 
	   	   retu=0;
 	   
	   return retu;
#endif	  
}

#if _GROUP_POLICY
void Free_radio_delete_qos_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}


/*返回-8时，调用Free_radio_delete_qos_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*qos_id范围1-15*/
int radio_delete_qos_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *qos_id,struct RadioList **RadioList_Head)   
													/*返回0表示失败，返回1表示成功，返回-1表示input parameter error*/
													/*返回-2表示QOS ID非法，返回-3表示radio is not exist，返回-4表示QOS is not exist*/
													/*返回-5表示radio is enable,please disable it first，返回-6表示Radio ID非法*/
													/*返回-7表示Group ID非法，返回-8表示partial failure，返回-9表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	if(NULL == qos_id)
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned int qosid = 0;
	int retu = 0;
	
	ret = parse_int_ID((char *)qos_id,&qosid);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
		return -1;
	}
	
	if((qosid < 1)||(qosid >15))
	{
		return -2;
	}

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in radio_delete_qos_group is %d\n",id);
			return -6;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in radio_delete_qos_group is %d\n",id);
			return -7;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned int ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_delete_qos_cmd_radio_delete_qos");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 qosid,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -3;
		else if(ret == WID_QOS_NOT_EXIST)
			retu = -4;
		else if(ret == WID_QOS_RADIO_SHOULD_BE_DISABLE)
			retu = -5;
		else 
			retu = 0;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -8;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -9;
	}
	return retu;
}
#endif

/*qos_id范围1-15*/
int radio_delete_qos(dbus_parameter parameter, DBusConnection *connection,int rid,char *qos_id)   
																/*返回0表示失败，返回1表示成功，返回-1表示input parameter error*/
																/*返回-2表示QOS ID非法，返回-3表示radio is not exist，返回-4表示QOS is not exist*/
																/*返回-5表示radio is enable,please disable it first，返回-6表示Radio ID非法*/
																/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == qos_id)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = radio_delete_qos_group(parameter, connection,0,rid,qos_id,&RadioList_Head);
	if(retu == -8)
	{
		Free_radio_delete_qos_group(RadioList_Head);
	}
	return retu;
#else
   int ret=0,retu;
   DBusMessage *query, *reply;
   DBusError err;
   DBusMessageIter	iter;
   unsigned int radio_id=0;
   int qosid = 0;
   //radio_id = (int)rid;
   
   ret = parse_int_ID((char *)qos_id,&qosid);
   
   if (ret != WID_DBUS_SUCCESS)
   {   
	   return -1;
   }
   
   if((qosid < 1)||(qosid >15))
   {
	   return -2;
   }
   	   
   char BUSNAME[PATH_LEN];
   char OBJPATH[PATH_LEN];
   char INTERFACE[PATH_LEN];

   radio_id = rid;
   if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in radio_delete_qos is %d\n",radio_id);
		return -6;
   }
   
   ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
   ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
   ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
   query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_DELETE_QOS);

   /*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
					   WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_DELETE_QOS);*/
   
   dbus_error_init(&err);

   dbus_message_append_args(query,
							DBUS_TYPE_UINT32,&radio_id,
							DBUS_TYPE_UINT32,&qosid,
							DBUS_TYPE_INVALID);

   reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
   
   dbus_message_unref(query);
   
   if (NULL == reply) {
	   if (dbus_error_is_set(&err)) {
		   dbus_error_free(&err);
	   }
	   return SNMPD_CONNECTION_ERROR;
   }
	   
   dbus_message_iter_init(reply,&iter);
   dbus_message_iter_get_basic(&iter,&ret);
   dbus_message_unref(reply);
   
   if(ret == 0)
   	   retu=1;
   else if(ret == RADIO_ID_NOT_EXIST)
   	   retu=-3;
   else if(ret == WID_QOS_NOT_EXIST)
   	   retu=-4;
   else if(ret == WID_QOS_RADIO_SHOULD_BE_DISABLE)
   	   retu=-5;
   else
   	   retu=0;
   
   return retu;
#endif	   
}

#if _GROUP_POLICY
void Free_set_bss_max_throughput_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}


/*返回-7时，调用Free_set_bss_max_throughput_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_bss_max_throughput_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *WLAN_ID,char *value,struct RadioList **RadioList_Head)   
										/*返回0表示失败，返回1表示成功，返回-1表示BSS is not exist*/
										/*返回-2表示WTP is not exist，返回-3表示RADIO is not exist，返回-4表示error*/
										/*返回-5表示Radio ID非法，返回-6表示Group ID非法*/
										/*返回-7表示partial failure，返回-8表示group id does not exist*/
										/*返回-9表示input parameter error，返回-10表示input parameter should be 1 to WLAN_NUM*/
										/*返回-11表示input parameter should be 1-30，返回-12表示wlan id is not exist*/
{
    if(NULL == connection)
        return 0;
        
	if((NULL == WLAN_ID)||(NULL == value))
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0; 
	unsigned int throughput = 0;	
	unsigned char wlanid = 0;	
	int retu = 0;
	
	ret = parse_char_ID((char *)WLAN_ID,&wlanid);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
		return -9;
	}
	if((wlanid < 1)||(wlanid > WLAN_NUM))
	{
		return -10;		
	}
	throughput = atoi(value);	
	if((throughput < 1)||(throughput > 30))
	{
		return -11;	
	}

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_bss_max_throughput_group is %d\n",id);
			return -5;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_bss_max_throughput_group is %d\n",id);
			return -6;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								unsigned int ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_bss_max_throughput_cmd_set_bss_max_throughput");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 wlanid,
								 throughput,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == BSS_NOT_EXIST)
			retu = -1;
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -2;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -3;
		else if(ret == WLAN_ID_NOT_EXIST)
			retu = -12;
		else
			retu = -4;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -7;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -8;
	}	
	return retu;
}
#endif

int set_bss_max_throughput(dbus_parameter parameter, DBusConnection *connection,int RadioID,char *WLAN_ID,char *value)   
												/*返回0表示失败，返回1表示成功，返回-1表示BSS is not exist*/
												/*返回-2表示WTP is not exist，返回-3表示RADIO is not exist*/
												/*返回-4表示error，返回-5表示Radio ID非法*/
												/*返回-9表示input parameter error，返回-10表示input parameter should be 1 to WLAN_NUM*/
												/*返回-11表示input parameter should be 1-30，返回-12表示wlan id is not exist*/
												/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if((NULL == WLAN_ID)||(NULL == value))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_bss_max_throughput_group(parameter, connection,0,RadioID,WLAN_ID,value,&RadioList_Head);
	if(retu == -7)
	{
		Free_set_bss_max_throughput_group(RadioList_Head);
	}
	return retu;
#else
	int ret=0,retu;
	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	unsigned int radio_id=0;
	unsigned int throughput = 0;	
	unsigned char wlanid = 0;

	//radio_id = RadioID;
	ret = parse_char_ID((char *)WLAN_ID,&wlanid);
	if (ret != WID_DBUS_SUCCESS)
	{	
		return -9;
	}
	if((wlanid < 1)||(wlanid > WLAN_NUM))
	{
		return -10;		
	}
	throughput = atoi(value);
	if((throughput < 1)||(throughput > 30))
	{
		return -11;	
	}
	
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radio_id = RadioID;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in set_bss_max_throughput is %d\n",radio_id);
		return -5;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_BSS_MAX_THROUGHPUT);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_BSS_MAX_THROUGHPUT);*/
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radio_id,							 
							 DBUS_TYPE_BYTE,&wlanid,			 
							 DBUS_TYPE_UINT32,&throughput,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	dbus_message_unref(reply);
	
	if(ret == 0)
		retu=1;
	else if(ret == BSS_NOT_EXIST)
		retu=-1;
	else if(ret == WTP_ID_NOT_EXIST)
		retu=-2;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu=-3;
	else if(ret == WLAN_ID_NOT_EXIST)
		retu=-12;
	else
		retu=-4;
	
	return retu;
#endif
}

void Free_radio_bss_max_throughput_head(DCLI_RADIO_API_GROUP_ONE *RADIO)
{
	void (*dcli_init_free_func)(char *,DCLI_RADIO_API_GROUP_ONE *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_radio_free_fun");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_RADIO_METHOD_SHOW_BSS_MAX_THROUGHPUT,RADIO);
		}
	}
}

/*返回1时，调用Free_radio_bss_max_throughput_head()释放空间*/
int show_radio_bss_max_throughput(dbus_parameter parameter, DBusConnection *connection,int radio_id ,DCLI_RADIO_API_GROUP_ONE **RADIO)
																										 /*返回0表示失败，返回1表示成功*/
																										 /*返回-1表示RADIO is not exist*/
																										 /*返回-2表示WTP is not exist*/
																										 /*返回-3表示error，返回-4表示Radio ID非法*/
																										 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret = 0;
	int retu;	

	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in show_radio_bss_max_throughput is %d\n",radio_id);
		return -4;
    }
	
	void*(*dcli_init_func)(
						int ,
						unsigned int ,
						unsigned int* ,
						unsigned int* ,
						unsigned char *,	
						DBusConnection *,
						char *
						);

    *RADIO=NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_radio_show_api_group_one");
		if(NULL != dcli_init_func)
		{
			*RADIO= (*dcli_init_func) (
                        				parameter.instance_id,
                        				radio_id,/*"show radio max throughput"*/
                        				&(parameter.local_id),
                        				&ret,
                        				0,
                        				//RADIOINFO,
                        				connection,
                        				WID_DBUS_RADIO_METHOD_SHOW_BSS_MAX_THROUGHPUT
                        				);	
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	if(ret == -1)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	if((ret == 0)&&(*RADIO))
	{
		retu = 1;
	}
	else if(ret == RADIO_ID_NOT_EXIST)
	{
	 	retu = -1;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -2;
	}
	else
	{
		retu = -3;
	}
	
	return retu;
 }

#if _GROUP_POLICY
void Free_set_radio_delete_wlan_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}


/*返回-9时，调用Free_set_radio_delete_wlan_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_radio_delete_wlan_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *wlan_id,struct RadioList **RadioList_Head)   
												/*返回0表示失败，返回1表示成功，返回-1表示input parameter error*/
												/*返回-2表示input parameter should be 1 to WLAN_NUM-1，返回-3表示radio not exist*/
												/*返回-4表示wlan not exist，返回-5表示radio delete wlan fail，返回-6表示Radio ID非法*/
												/*返回-7表示illegal input:Input exceeds the maximum value of the parameter type*/
												/*返回-8表示Group ID非法，返回-9表示partial failure，返回-10表示group id does not exist*/
												/*返回-11表示bss is enable*/
{

    if(NULL == connection)
        return 0;
        
	if(NULL == wlan_id)
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0; 
	unsigned char wlanid = 0;
	int retu = 0;
	
	ret = parse_char_ID((char *)wlan_id,&wlanid);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
       if(ret == WID_ILLEGAL_INPUT){
	   		retu = -7;
       }
	   else{
	   		retu = -1;
	   }
		return retu;
	}
	
	if((wlanid < 1)||(wlanid >(WLAN_NUM-1)))
	{
		return -2;
	}

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_radio_delete_wlan_cmd_group is %d\n",id);
			return -6;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_radio_delete_wlan_cmd_group is %d\n",id);
			return -8;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_delete_wlan_cmd_radio_delete_wlan");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 wlanid,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret==RADIO_ID_NOT_EXIST)
			retu = -3;
		else if(ret==WLAN_ID_NOT_EXIST)
			retu = -4;
		else if(ret == BSS_BE_ENABLE)
			retu = -11;
		else 
			retu = -5;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -9;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -10;
	}	
	return retu;
}
#endif

int set_radio_delete_wlan_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *wlan_id)  
																			/*返回0表示失败，返回1表示成功，返回-1表示input parameter error*/
																			/*返回-2表示input parameter should be 1 to WLAN_NUM-1，返回-3表示radio not exist*/
																			/*返回-4表示wlan not exist，返回-5表示radio delete wlan fail，返回-6表示Radio ID非法*/
																			/*返回-7表示illegal input:Input exceeds the maximum value of the parameter type，返回-11表示bss is enable*/
																			/*返回-12表示radio interface is in ebr,please delete it from ebr first*/
																			/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == wlan_id)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_radio_delete_wlan_cmd_group(parameter, connection,0,RID,wlan_id,&RadioList_Head);
	if(retu == -9)
	{
		Free_set_radio_delete_wlan_cmd_group(RadioList_Head);
	}
	return retu;
#else
	int ret=0,retu;
	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	unsigned int radio_id=0;
	unsigned char wlanid = 0;
	//radio_id = RID;
	
	ret = parse_char_ID((char *)wlan_id,&wlanid);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
		if(ret == WID_ILLEGAL_INPUT){
			retu = -7;
		}
		else{
			retu = -1;
		}
		return retu;
	}
	
	if((wlanid < 1)||(wlanid >(WLAN_NUM-1)))
	{
		return -2;
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radio_id = RID;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in set_radio_delete_wlan_cmd is %d\n",radio_id);
		return -6;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_DELETE_WLAN);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_DELETE_WLAN);*/
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radio_id,
							 DBUS_TYPE_BYTE,&wlanid,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	dbus_message_unref(reply);
	
	if(ret == 0)
		retu=1;
	else if(ret==RADIO_ID_NOT_EXIST)
		retu=-3;
	else if(ret==WLAN_ID_NOT_EXIST)
		retu=-4;		
	//else if(ret == BSS_BE_ENABLE)
		//retu=-11;
	else if(ret == RADIO_IN_EBR)
		retu=-12;
	else 
		retu=-5;
	
	return retu;
#endif
}

#if _GROUP_POLICY
void Free_set_radio_enable_wlan_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}


/*返回-14时，调用Free_set_radio_enable_wlan_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_radio_enable_wlan_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *wlan_id,struct RadioList **RadioList_Head)  
												/*返回0表示失败，返回1表示成功，返回-1表示input parameter error*/
												/*返回-2表示input parameter should be 1 to WLAN_NUM-1，返回-3表示radio not exist*/
												/*返回-4表示wlan not exist， 返回-5表示wtp over max wep wlan count 4*/
												/*返回-6表示radio is already enable this wlan，返回-7表示wtp binding interface not match wlan binding interface*/
												/*返回-8表示radio is not binding this wlan，返回-9表示wlan is disable ,you should enable it first*/
												/*返回-10表示radio enable wlan fail，返回-11表示Radio ID非法*/
												/*返回-12表示illegal input:Input exceeds the maximum value of the parameter type*/
												/*返回-13表示Group ID非法，返回-14表示partial failure，返回-15表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	if(NULL == wlan_id)
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0; 
	unsigned char wlanid = 0;
	int retu = 0;	
	
	ret = parse_char_ID((char *)wlan_id,&wlanid);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
       if(ret == WID_ILLEGAL_INPUT){
	   		retu = -12;
       }
	   else{
	   		retu = -1;
	   }
		return retu;
	}
	
	if((wlanid < 1)||(wlanid >(WLAN_NUM-1)))
	{
		return -2;
	}
	
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_radio_enable_wlan_cmd_group is %d\n",id);
			return -11;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_radio_enable_wlan_cmd_group is %d\n",id);
			return -13;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_enable_wlan_cmd_radio_enable_wlan");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 wlanid,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret==RADIO_ID_NOT_EXIST)
			retu = -3;
		else if(ret==WLAN_ID_NOT_EXIST)
			retu = -4;
		else if(ret == WTP_WEP_NUM_OVER)
			retu = -5;
		else if(ret == VALUE_IS_NONEED_TO_CHANGE)
			retu = -6;
		else if(ret == WTP_WLAN_BINDING_NOT_MATCH)
			retu = -7;
		else if(ret == WTP_IS_NOT_BINDING_WLAN_ID)
			retu = -8;
		else if(ret == WLAN_BE_DISABLE)
			retu = -9;
		else 
			retu = -10;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -14;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -15;
	}	
	return retu;
}
#endif

int set_radio_enable_wlan_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *wlan_id)  
																			/*返回0表示失败，返回1表示成功，返回-1表示input parameter error*/
																			/*返回-2表示input parameter should be 1 to WLAN_NUM-1，返回-3表示radio not exist*/
																			/*返回-4表示wlan not exist， 返回-5表示wtp over max wep wlan count 4*/
																			/*返回-6表示radio is already enable this wlan，返回-7表示wtp binding interface not match wlan binding interface*/
																			/*返回-8表示radio is not binding this wlan，返回-9表示wlan is disable ,you should enable it first*/
																			/*返回-10表示radio enable wlan fail，返回-11表示Radio ID非法*/
																			/*返回-12表示illegal input:Input exceeds the maximum value of the parameter type*/
																			/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == wlan_id)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_radio_enable_wlan_cmd_group(parameter, connection,0,RID,wlan_id,&RadioList_Head);
	if(retu == -14)
	{
		Free_set_radio_enable_wlan_cmd_group(RadioList_Head);
	}
	return retu;
#else
	int ret=0,retu;
	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	unsigned int radio_id=0;
	unsigned char wlanid = 0;
	//radio_id = RID;
	
	ret = parse_char_ID((char *)wlan_id,&wlanid);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
		if(ret == WID_ILLEGAL_INPUT){
			retu = -12;
		}
		else{
			retu = -1;
		}
		return retu;
	}
	
	if((wlanid < 1)||(wlanid >(WLAN_NUM-1)))
	{
		return -2;
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radio_id = RID;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in set_radio_enable_wlan_cmd is %d\n",radio_id);
		return -11;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_ENABLE_WLAN);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_ENABLE_WLAN);*/
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radio_id,
							 DBUS_TYPE_BYTE,&wlanid,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	dbus_message_unref(reply);
	
	if(ret == 0)
		retu=1;
	else if(ret==RADIO_ID_NOT_EXIST)
		retu=-3;
	else if(ret==WLAN_ID_NOT_EXIST)
		retu=-4;
	else if(ret == WTP_WEP_NUM_OVER)
		retu=-5;
	else if(ret == VALUE_IS_NONEED_TO_CHANGE)
		retu=-6;
	else if(ret == WTP_WLAN_BINDING_NOT_MATCH)
		retu=-7;
	else if(ret == WTP_IS_NOT_BINDING_WLAN_ID)
		retu=-8;
	else if(ret == WLAN_BE_DISABLE)
		retu=-9;
	else 
		retu=-10;		
	
	return retu;
#endif
}

#if _GROUP_POLICY
void Free_set_radio_disable_wlan_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}


/*返回-9时，调用Free_set_radio_disable_wlan_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_radio_disable_wlan_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *wlan_id,struct RadioList **RadioList_Head) 
													/*返回0表示失败，返回1表示成功，返回-1表示input parameter error*/
													/*返回-2表示input parameter should be 1 to WLAN_NUM-1，返回-3表示radio not exist*/
													/*返回-4表示wlan not exist，返回-5表示radio disable wlan fail，返回-6表示Radio ID非法*/
													/*返回-7表示illegal input:Input exceeds the maximum value of the parameter type*/
													/*返回-8表示Group ID非法，返回-9表示partial failure，返回-10表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	if(NULL == wlan_id)
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0; 
	unsigned char wlanid = 0;
	int retu = 0;
	
	ret = parse_char_ID((char *)wlan_id,&wlanid);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
       if(ret == WID_ILLEGAL_INPUT){
	   		retu = -7;
       }
	   else{
	   		retu = -1;
	   }
		return retu;
	}
	
	if((wlanid < 1)||(wlanid >(WLAN_NUM-1)))
	{
		return -2;
	}


	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_radio_enable_wlan_cmd_group is %d\n",id);
			return -6;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_radio_enable_wlan_cmd_group is %d\n",id);
			return -8;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_disable_wlan_cmd_radio_disable_wlan_ID");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 wlanid,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret==RADIO_ID_NOT_EXIST)
			retu = -3;
		else if(ret==WLAN_ID_NOT_EXIST)
			retu = -4;
		else 
			retu = -5;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -9;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -10;
	}		
	return retu;
}
#endif

int set_radio_disable_wlan_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *wlan_id)
																			/*返回0表示失败，返回1表示成功，返回-1表示input parameter error*/
																			/*返回-2表示input parameter should be 1 to WLAN_NUM-1，返回-3表示radio not exist*/
																			/*返回-4表示wlan not exist，返回-5表示radio disable wlan fail，返回-6表示Radio ID非法*/
																			/*返回-7表示illegal input:Input exceeds the maximum value of the parameter type*/
																			/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == wlan_id)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_radio_disable_wlan_cmd_group(parameter, connection,0,RID,wlan_id,&RadioList_Head);
	if(retu == -9)
	{
		Free_set_radio_disable_wlan_cmd_group(RadioList_Head);
	}
	return retu;
#else
	int ret=0,retu;
	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	unsigned int radio_id=0;
	unsigned char wlanid = 0;
	//radio_id = RID;
	
	ret = parse_char_ID((char *)wlan_id,&wlanid);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
		if(ret == WID_ILLEGAL_INPUT){
			retu = -7;
		}
		else{
		 retu = -1;
		}
		return retu;
	}
	
	if((wlanid < 1)||(wlanid >(WLAN_NUM-1)))
	{
		return -2;
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radio_id = RID;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in set_radio_disable_wlan_cmd is %d\n",radio_id);
		return -6;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_DISABLE_WLAN);

	/*ery = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_DISABLE_WLAN);*/
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radio_id,
							 DBUS_TYPE_BYTE,&wlanid,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	dbus_message_unref(reply);
	
	if(ret == 0)
		retu=1;
	else if(ret==RADIO_ID_NOT_EXIST)
		retu=-3;
	else if(ret==WLAN_ID_NOT_EXIST)
		retu=-4;
	else 
		retu=-5;
		
	return retu;
#endif
}

void Free_radio_channel_change(DCLI_RADIO_API_GROUP_ONE *RADIO)
{
	void (*dcli_init_free_func)(char *,DCLI_RADIO_API_GROUP_ONE *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_radio_free_fun");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_RADIO_METHOD_SHOW_CHANNEL_CHANGE,RADIO);
		}
	}
}

/*返回1时，调用Free_radio_channel_change()释放空间*/
int show_radio_channel_change_func(dbus_parameter parameter, DBusConnection *connection,int rad_id,DCLI_RADIO_API_GROUP_ONE **RADIO)/*返回0表示失败，返回1表示成功，返回-1表示RADIO is not exist，返回-2表示WTP is not exist，返回-3表示error，返回-4表示Radio ID非法*/
																																			/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret = 0;
	int retu;	

	if(rad_id > G_RADIO_NUM || rad_id == 0){
		syslog(LOG_DEBUG,"radio id in show_radio_channel_change_func is %d\n",rad_id);
		return -4;
    }
	
	void*(*dcli_init_func)(
						int ,
						unsigned int ,
						unsigned int* ,
						unsigned int* ,
						unsigned char *,	
						DBusConnection *,
						char *
						);

    *RADIO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_radio_show_api_group_one");
		if(NULL != dcli_init_func)
		{
			*RADIO = (*dcli_init_func)
					(
					parameter.instance_id,
					rad_id,/*"show radio (list|all)"*/
					&(parameter.local_id),
					&ret,
					0,
					//RADIOINFO,
					connection,
					WID_DBUS_RADIO_METHOD_SHOW_CHANNEL_CHANGE
					);	
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(ret == -1)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	if((ret == 0)&&(*RADIO))
	{
		retu = 1;
	}
	else if(ret == RADIO_ID_NOT_EXIST)
	{
		retu = -1;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		retu = -2;
	}
	else
	{
		retu = -3;
	}
	
	return retu;	
}

#if _GROUP_POLICY
void Free_radio_apply_wlan_base_vlan_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}


/*返回-20时，调用Free_radio_apply_wlan_base_vlan_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int radio_apply_wlan_base_vlan_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *WlanID,char *VlanID,struct RadioList **RadioList_Head)
													/*返回0表示失败，返回1表示成功，返回-1表示input parameter error*/
													/*返回-2表示wlan id should be 1 to WLAN_NUM-1，返回-3表示vlan id should be 1 to VLANID_RANGE_MAX*/
													/*返回-4表示radio id does not exist，返回-5表示wtp is in use, you should unused it first*/
													/*返回-6表示binding wlan does not exist，返回-7表示wlan does not bind interface*/
													/*返回-8表示wtp does not bind interface，返回-9表示wlan and wtp bind interface did not match*/
													/*返回-10表示clear wtp binding wlan list successfully，返回-11表示wlan is enable,you should disable it first*/
													/*返回-12表示wtp over max bss count，返回-13表示bss is enable, you should disable it first*/
													/*返回-14表示wtp over max wep wlan count 4，返回-15表示error，返回-16表示Radio ID非法*/
													/*返回-17表示illegal input:Input exceeds the maximum value of the parameter type*/
													/*返回-18表示radio apply bingding securityindex is same with other*/
													/*返回-19表示Group ID非法，返回-20表示partial failure，返回-21表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	if((NULL == WlanID)||(NULL == VlanID))
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0; 
	unsigned int vlan_id = 0;
	unsigned char wlan_id = 0;
	int retu = 0;
		
	ret = parse_char_ID((char*)WlanID, &wlan_id);
	if (ret != WID_DBUS_SUCCESS)
	{	
       if(ret == WID_ILLEGAL_INPUT){
	   		retu = -17;
       }
	   else{
	   		retu = -1;
	   }		
		return retu;
	}
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		return -2;
	}
	ret = parse_int_ID((char*)VlanID, &vlan_id);
	if(ret != WID_DBUS_SUCCESS){
		return -1;
	}	
	if(vlan_id > VLANID_RANGE_MAX|| vlan_id == 0){
		return -3;
	}
	
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in radio_apply_wlan_base_vlan_cmd_group is %d\n",id);
			return -16;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in radio_apply_wlan_base_vlan_cmd_group is %d\n",id);
			return -19;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"radio_apply_wlan_base_vlan_cmd_radio_apply_wlan_base_vlan");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 vlan_id,
								 wlan_id,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -4;
		else if(ret == WTP_ID_BE_USED)
			retu = -5;
		else if(ret == WLAN_ID_NOT_EXIST)
			retu = -6;
		else if(ret == Wlan_IF_NOT_BE_BINDED)
			retu = -7;
		else if(ret == WTP_IF_NOT_BE_BINDED)
			retu = -8;
		else if(ret == WTP_WLAN_BINDING_NOT_MATCH)
			retu = -9;
		else if(ret == WTP_CLEAR_BINDING_WLAN_SUCCESS)
			retu = -10;
		else if(ret == WLAN_BE_ENABLE)
			retu = -11;
		else if(ret == WTP_OVER_MAX_BSS_NUM)
			retu = -12;
		else if(ret == BSS_BE_ENABLE)
			retu = -13;
		else if(ret == WTP_WEP_NUM_OVER)
			retu = -14;
		else
			retu = -15;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -20;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -21;
	}
	return retu;
}
#endif

int radio_apply_wlan_base_vlan_cmd(dbus_parameter parameter, DBusConnection *connection,int RadioID,char *WlanID,char *VlanID)
																								/*返回0表示失败，返回1表示成功，返回-1表示input parameter error*/
																								/*返回-2表示wlan id should be 1 to WLAN_NUM-1，返回-3表示vlan id should be 1 to VLANID_RANGE_MAX*/
																								/*返回-4表示radio id does not exist，返回-5表示wtp is in use, you should unused it first*/
																								/*返回-6表示binding wlan does not exist，返回-7表示wlan does not bind interface*/
																								/*返回-8表示wtp does not bind interface，返回-9表示wlan and wtp bind interface did not match*/
																								/*返回-10表示clear wtp binding wlan list successfully，返回-11表示wlan is enable,you should disable it first*/
																								/*返回-12表示wtp over max bss count，返回-13表示bss is enable, you should disable it first*/
																								/*返回-14表示wtp over max wep wlan count 4，返回-15表示error，返回-16表示Radio ID非法*/
																								/*返回-17表示illegal input:Input exceeds the maximum value of the parameter type*/
																								/*返回-18表示radio apply bingding securityindex is same with other*/
																								/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if((NULL == WlanID)||(NULL == VlanID))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = radio_apply_wlan_base_vlan_cmd_group(parameter, connection,0,RadioID,WlanID,VlanID,&RadioList_Head);
	if(retu == -20)
	{
		Free_radio_apply_wlan_base_vlan_cmd_group(RadioList_Head);
	}
	return retu;
#else
	int ret,retu;
	unsigned int radio_id;
	unsigned int vlan_id;
	unsigned char wlan_id;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	//radio_id = RadioID;	
	
	ret = parse_char_ID((char*)WlanID, &wlan_id);	
	if (ret != WID_DBUS_SUCCESS)
	{	
       if(ret == WID_ILLEGAL_INPUT){
	   		retu = -17;
       }
	   else{
	   		retu = -1;
	   }		
		return retu;
	}
	
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		return -2;
	}
	ret = parse_int_ID((char*)VlanID, &vlan_id);
	if(ret != WID_DBUS_SUCCESS){
		return -1;
	}	
	if(vlan_id > VLANID_RANGE_MAX|| vlan_id == 0){
		return -3;
	}
	
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radio_id = RadioID;	
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in radio_apply_wlan_base_vlan_cmd is %d\n",radio_id);
		return -16;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_RADIO_APPLY_WLANID_BASE_VLANID);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_RADIO_APPLY_WLANID_BASE_VLANID);*/

	dbus_error_init(&err);

	dbus_message_append_args(query,					
						DBUS_TYPE_UINT32,&radio_id,
						DBUS_TYPE_BYTE,&wlan_id,	
						DBUS_TYPE_UINT32,&vlan_id,
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	dbus_message_unref(query);
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu=-4;
	else if(ret == WTP_ID_BE_USED)
		retu=-5;
	else if(ret == WLAN_ID_NOT_EXIST)
		retu=-6;
	else if(ret == Wlan_IF_NOT_BE_BINDED)
		retu=-7;
	else if(ret == WTP_IF_NOT_BE_BINDED)
		retu=-8;
	else if(ret == WTP_WLAN_BINDING_NOT_MATCH)
		retu=-9;
	else if(ret == WTP_CLEAR_BINDING_WLAN_SUCCESS)
		retu=-10;
	else if(ret == WLAN_BE_ENABLE)
		retu=-11;
	else if(ret == WTP_OVER_MAX_BSS_NUM)
		retu=-12;
	else if(ret == BSS_BE_ENABLE)
		retu=-13;
	else if(ret == WTP_WEP_NUM_OVER)
		retu=-14;
	else if(ret == SECURITYINDEX_IS_SAME)
		retu=-18;
	else
		retu=-15;

	dbus_message_unref(reply);

	return retu;	
#endif
}

#if _GROUP_POLICY
void Free_set_radio_default_config_cmd_func_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}


/*返回-4时，调用Free_set_radio_default_config_cmd_func_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_radio_default_config_cmd_func_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,struct RadioList **RadioList_Head)
									/*返回0表示失败，返回1表示成功，返回-1表示recover default config fail*/
									/*返回-2表示Radio ID非法，返回-3表示Group ID非法*/
									/*返回-4表示partial failure，返回-5表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0; 
	unsigned char reserved = 0;
	int retu = 0;

	/*if(vty->node == RADIO_NODE){
		index = 0;			
		id = (unsigned)vty->index;
	}else if(vty->node == HANSI_RADIO_NODE){
		index = vty->index; 		
		id = (unsigned)vty->index_sub;
	}else if(vty->node == AP_GROUP_RADIO_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_RADIO_NODE){
		index = vty->index; 		
		id = (unsigned)vty->index_sub;
		type= 1;
	}*/
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_radio_default_config_cmd_func_group is %d\n",id);
			return -2;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_radio_default_config_cmd_func_group is %d\n",id);
			return -3;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								int *,
								unsigned int *
							);
	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_default_config_cmd_recover_default_config");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 reserved,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else 
			retu = -1;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -4;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -5;
	}	
	
	return retu;
}
#endif

int set_radio_default_config_cmd_func(dbus_parameter parameter, DBusConnection *connection,int rad_id)/*返回0表示失败，返回1表示成功，返回-1表示recover default config fail，返回-2表示Radio ID非法*/
																											/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_radio_default_config_cmd_func_group(parameter, connection,0,rad_id,&RadioList_Head);
	if(retu == -4)
	{
		Free_set_radio_default_config_cmd_func_group(RadioList_Head);
	}
	return retu;
#else
    
	int ret=0,retu;
	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	unsigned int radio_id=0;
	unsigned char reserved = 0;

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radio_id = rad_id;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in set_radio_default_config_cmd_func is %d\n",radio_id);
		return -2;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id, WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id, WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id, WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_REVOVER_DEFAULT_CONFIG);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_REVOVER_DEFAULT_CONFIG);*/
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radio_id,
							 DBUS_TYPE_BYTE,&reserved,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	dbus_message_unref(reply);
	
	if(ret == 0)
		retu=1;
	else 
		retu=-1;
	
	return retu;
#endif
}

#if _GROUP_POLICY
void Free_set_radio_max_throughout_func_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}


/*返回-8时，调用Free_set_radio_max_throughout_func_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_radio_max_throughout_func_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *value,struct RadioList **RadioList_Head)
												/*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
												/*返回-2表示max throughout should be 1 to 108，返回-3表示WTP id does not exist*/
												/*返回-4表示radio id does not exist，返回-5表示error，返回-6表示Radio ID非法*/
												/*返回-7表示Group ID非法，返回-8表示partial failure，返回-9表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	if(NULL == value)
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int ret1 = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0; 
	unsigned char bandwidth = 0;
	int retu = 0;		
	
	ret1 = parse_char_ID((char*)value, &bandwidth);
	if(ret1 != WID_DBUS_SUCCESS){
        if(ret1 == WID_ILLEGAL_INPUT){
			retu = -2;
        }
		else{
			retu = -1;
		}
		return retu;
	}
	if(bandwidth > 108 || bandwidth == 0){
		return -2;
	}
	
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_radio_max_throughout_func_group is %d\n",id);
			return -6;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_radio_max_throughout_func_group is %d\n",id);
			return -7;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_max_throughout_cmd_set_radio_max_throughout");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 bandwidth,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -3;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -4;
		else
			retu = -5;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -8;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -9;
	}		
	return retu; 		
}
#endif

int set_radio_max_throughout_func(dbus_parameter parameter, DBusConnection *connection,int rad_id,char *value)
																				/*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
																				/*返回-2表示max throughout should be 1 to 108，返回-3表示WTP id does not exist*/
																				/*返回-4表示radio id does not exist，返回-5表示error，返回-6表示Radio ID非法*/
																				/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if(NULL == value)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_radio_max_throughout_func_group(parameter, connection,0,rad_id,value,&RadioList_Head);
	if(retu == -8)
	{
		Free_set_radio_max_throughout_func_group(RadioList_Head);
	}
	return retu;
#else
	int ret,ret1,retu;
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;
	unsigned char bandwidth = 0;
	unsigned int radioid = 0;
	//radioid = rad_id;
	
	ret1 = parse_char_ID((char*)value, &bandwidth);
	if(ret1 != WID_DBUS_SUCCESS){
		if(ret1 == WID_ILLEGAL_INPUT){
			retu = -2;
		}
		else{
			retu = -1;
		}
		return retu;
	}	
	if(bandwidth > 108 || bandwidth == 0){
		return -2;
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	
	radioid = rad_id;
	if(radioid > G_RADIO_NUM || radioid == 0){
		syslog(LOG_DEBUG,"radio id in set_radio_max_throughout_func is %d\n",radioid);
		return -6;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_MAX_THROUGHOUT);	
	
	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_MAX_THROUGHOUT);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radioid,	
							 DBUS_TYPE_BYTE,&bandwidth,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == WTP_ID_NOT_EXIST)
		retu=-3;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu=-4;
	else
		retu=-5;
		
	dbus_message_unref(reply);
	
	return retu; 		
#endif
}

void Free_show_radio_qos(DCLI_RADIO_API_GROUP_ONE *RADIO)
{
	void (*dcli_init_free_func)(char *,DCLI_RADIO_API_GROUP_ONE *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_radio_free_fun");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_RADIO_METHOD_SHOW_RADIO_QOS,RADIO);
		}
	}
}

/*返回1时，调用Free_show_radio_qos()释放空间*/
int show_radio_qos_cmd_func(dbus_parameter parameter, DBusConnection *connection,DCLI_RADIO_API_GROUP_ONE **RADIO)/*返回0表示失败，返回1表示成功，返回-1表示there is no radio exist*/
																														 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret = 0;
	int retu;	

	void*(*dcli_init_func)(
						int ,
						unsigned int ,
						unsigned int* ,
						unsigned int* ,
						unsigned char *,	
						DBusConnection *,
						char *
						);

    *RADIO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_radio_show_api_group_one");
		if(NULL != dcli_init_func)
		{
			*RADIO =(*dcli_init_func) 
				(
				parameter.instance_id,
				0,/*"show radio qos list"*/
				&(parameter.local_id),
				&ret,
				0,
				//RADIOINFO,
				connection,
				WID_DBUS_RADIO_METHOD_SHOW_RADIO_QOS
				);	
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(ret == -1)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	if((ret == 0)&&(*RADIO))
	{
		retu = 1;
	}
	else if(ret == RADIO_ID_NOT_EXIST)
	{
		retu = -1;
	}

	return retu;
}

void Free_radio_bss_head(DCLI_RADIO_API_GROUP_ONE *RADIO)
{
	void (*dcli_init_free_func)(char *,DCLI_RADIO_API_GROUP_ONE *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_radio_free_fun");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_RADIO_METHOD_SHOW_BSS_LIST,RADIO);
		}
	}
}

/*返回1时，调用Free_radio_bss_head()释放空间*/
int show_radio_bss_cmd(dbus_parameter parameter, DBusConnection *connection,int radio_id,DCLI_RADIO_API_GROUP_ONE **RADIO)/*返回0表示失败，返回1表示成功，返回-1表示Radio ID非法*/
																																/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
        
	int ret = 0;
	int retu;	
	
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in show_radio_bss_cmd is %d\n",radio_id);
		return -1;
    }
	void*(*dcli_init_func)(
						int ,
						unsigned int ,
						unsigned int* ,
						unsigned int* ,
						unsigned char *,	
						DBusConnection *,
						char *
						);

    *RADIO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_radio_show_api_group_one");
		if(NULL != dcli_init_func)
		{
			*RADIO = (*dcli_init_func)
					(
					parameter.instance_id,
					radio_id,/*"show radio bss list"*/
					&(parameter.local_id),
					&ret,
					0,
					connection,
					WID_DBUS_RADIO_METHOD_SHOW_BSS_LIST
					);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	if((ret == 0)&&(*RADIO))
	{
		retu = 1;		
	}
	
	return retu;
}

#if _GROUP_POLICY
void Free_set_radio_l2_isolation_func_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}


/*返回-12时，调用Free_set_radio_l2_isolation_func_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_radio_l2_isolation_func_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *wlan_id,char *state,struct RadioList **RadioList_Head)  
												/*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
												/*返回-2表示wlan id should be 1 to WLAN_NUM-1，返回-3表示input patameter only with 'enable' or 'disable'*/
												/*返回-4表示wlan not exist，返回-5表示wtp not binding wlan，返回-6表示wtp id does not run*/
												/*返回-7表示binding wlan error，返回-8表示error，返回-9表示Radio ID非法*/
												/*返回-10表示illegal input:Input exceeds the maximum value of the parameter type*/
												/*返回-11表示Group ID非法，返回-12表示partial failure，返回-13表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	if((NULL == wlan_id)||(NULL == state))
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0; 
	unsigned char wlanid = 0;
    unsigned int policy = 0;
	int retu = 0;

	ret = parse_char_ID((char*)wlan_id, &wlanid);
	if(ret != WID_DBUS_SUCCESS){
        if(ret == WID_ILLEGAL_INPUT){
			retu = -10;
        }
		else{
			retu = -1;
		}
		return retu;
	}	
	if(wlanid >= WLAN_NUM || wlanid == 0){
		return -2;
	}
	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -3;
	}
	
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_radio_l2_isolation_func_group is %d\n",id);
			return -9;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_radio_l2_isolation_func_group is %d\n",id);
			return -11;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								unsigned int ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_l2_isolation_cmd_set_wlan_ID_l2_isolation");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 wlanid,
								 policy,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if (ret == WLAN_ID_NOT_EXIST)
			retu = -4;
		else if (ret == WTP_IS_NOT_BINDING_WLAN_ID)
			retu = -5;
		else if (ret == WTP_NOT_IN_RUN_STATE)
			retu = -6;
		else if (ret == WTP_OVER_MAX_BSS_NUM)
			retu = -7;
		else
			retu = -8;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -12;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -13;
	}
	return retu;			
}
#endif

int set_radio_l2_isolation_func(dbus_parameter parameter, DBusConnection *connection,int radio_id,char *wlan_id,char *state) 
																							/*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
																							/*返回-2表示wlan id should be 1 to WLAN_NUM-1，返回-3表示input patameter only with 'enable' or 'disable'*/
																							/*返回-4表示wlan not exist，返回-5表示wtp not binding wlan，返回-6表示wtp id does not run*/
																							/*返回-7表示binding wlan error，返回-8表示error，返回-9表示Radio ID非法*/
																							/*返回-10表示illegal input:Input exceeds the maximum value of the parameter type*/
																							/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if((NULL == wlan_id)||(NULL == state))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_radio_l2_isolation_func_group(parameter, connection,0,radio_id,wlan_id,state,&RadioList_Head);
	if(retu == -12)
	{
		Free_set_radio_l2_isolation_func_group(RadioList_Head);
	}
	return retu;
#else	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int radioID = 0;
	unsigned char wlanid = 0;
	int ret = WID_DBUS_SUCCESS;
	int retu;
	//radioID = radio_id;
    int policy = 0;

	ret = parse_char_ID((char*)wlan_id, &wlanid);
	if(ret != WID_DBUS_SUCCESS){
		if(ret == WID_ILLEGAL_INPUT){
			retu = -10;
		}
		else{
			retu = -1;
		}
		return retu;
	}	
	if(wlanid >= WLAN_NUM || wlanid == 0){
		return -2;
	}
	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -3;
	}
	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radioID = radio_id;
	if(radioID > G_RADIO_NUM || radioID == 0){
		syslog(LOG_DEBUG,"radio id in set_radio_l2_isolation_func is %d\n",radioID);
		return -9;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_RADIO_L2_ISOLATION_ABLE);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_RADIO_L2_ISOLATION_ABLE);*/
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radioID,
							 DBUS_TYPE_BYTE,&wlanid,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		retu=1;
	}
	else if (ret == WLAN_ID_NOT_EXIST)
	{
		retu=-4;
	}
	else if (ret == WTP_IS_NOT_BINDING_WLAN_ID)
	{
		retu=-5;
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
	{
		retu=-6;
	}
	else if (ret == WTP_OVER_MAX_BSS_NUM)
	{
		retu=-7;
	}
	else
	{
		retu=-8;
	}
		
	dbus_message_unref(reply);
	
	return retu;			
#endif	
}

#if _GROUP_POLICY
void Free_set_radio_11n_cwmmode_func_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}


/*返回-12时，调用Free_set_radio_11n_cwmmode_func_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_radio_11n_cwmmode_func_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *wlan_id,char *cwmmode,struct RadioList **RadioList_Head)
													/*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
													/*返回-2表示wlan id should be 1 to WLAN_NUM-1，返回-3表示input patameter only with 'enable' or 'disable'*/
													/*返回-4表示wlan not exist，返回-5表示wtp not binding wlan，返回-6表示wtp id does not run*/
													/*返回-7表示binding wlan error，返回-8表示error，返回-9表示Radio ID非法*/
													/*返回-10表示illegal input:Input exceeds the maximum value of the parameter type*/
													/*返回-11表示Group ID非法，返回-12表示partial failure，返回-13表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	if((NULL == wlan_id)||(NULL == cwmmode))
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0; 
	unsigned char wlanid = 0;
    unsigned char policy = 0;
	int retu = 0;

	ret = parse_char_ID((char*)wlan_id, &wlanid);
	if(ret != WID_DBUS_SUCCESS){
        if(ret == WID_ILLEGAL_INPUT){
			retu = -10;
        }
		else{
			retu = -1;
		}
		return retu;
	}	
	if(wlanid >= WLAN_NUM || wlanid == 0){
		return -2;
	}
	
	if (!strcmp(cwmmode,"1"))
	{
		policy = 1;	
	}
	else if (!strcmp(cwmmode,"0"))
	{
		policy = 0;	
	}
	else
	{
		return -3;
	}	

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_radio_11n_cwmmode_func_group is %d\n",id);
			return -9;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_radio_11n_cwmmode_func_group is %d\n",id);
			return -11;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								unsigned char ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_11n_cwmmode_cmd_set_11n_wlan_ID_cwmmode");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 wlanid,
								 policy,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if (ret == WLAN_ID_NOT_EXIST)
			retu = -4;
		else if (ret == WTP_IS_NOT_BINDING_WLAN_ID)
			retu = -5;
		else if (ret == WTP_NOT_IN_RUN_STATE)
			retu = -6;
		else if (ret == WTP_OVER_MAX_BSS_NUM)
			retu = -7;
		else
			retu = -8;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -12;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -13;
	}		
	return retu;			
}
#endif

/*未使用*/
int set_radio_11n_cwmmode_func(dbus_parameter parameter, DBusConnection *connection,int radio_id,char *wlan_id,char *cwmmode)
																								/*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
																								/*返回-2表示wlan id should be 1 to WLAN_NUM-1，返回-3表示input patameter only with 'enable' or 'disable'*/
																								/*返回-4表示wlan not exist，返回-5表示wtp not binding wlan，返回-6表示wtp id does not run*/
																								/*返回-7表示binding wlan error，返回-8表示error，返回-9表示Radio ID非法*/
																								/*返回-10表示illegal input:Input exceeds the maximum value of the parameter type*/
																								/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if((NULL == wlan_id)||(NULL == cwmmode))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_radio_11n_cwmmode_func_group(parameter, connection,0,radio_id,wlan_id,cwmmode,&RadioList_Head);
	if(retu == -12)
	{
		Free_set_radio_11n_cwmmode_func_group(RadioList_Head);
	}
	return retu;
#else		
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int radioID = 0;
	unsigned char wlanid = 0;
	int ret = WID_DBUS_SUCCESS;
	int retu;
	//radioID = (unsigned int)radio_id;
    unsigned char policy = 0;

	ret = parse_char_ID((char*)wlan_id, &wlanid);
	if(ret != WID_DBUS_SUCCESS){
		if(ret == WID_ILLEGAL_INPUT){
			retu = -10;
		}
		else{
			retu = -1;
		}
		return retu;
	}	
	if(wlanid >= WLAN_NUM || wlanid == 0){
		return -2;
	}
	
	if (!strcmp(cwmmode,"1"))
	{
		policy = 1;	
	}
	else if (!strcmp(cwmmode,"0"))
	{
		policy = 0;	
	}
	else
	{
		return -3;
	}
	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radioID = radio_id;
	if(radioID > G_RADIO_NUM || radioID == 0){
		syslog(LOG_DEBUG,"radio id in set_radio_11n_cwmmode_func is %d\n",radioID);
		return -9;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_11N_SET_RADIO_CWMMODE);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_11N_SET_RADIO_CWMMODE);*/
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radioID,
							 DBUS_TYPE_BYTE,&wlanid,
							 DBUS_TYPE_BYTE,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}	

		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		retu=1;
	}
	else if (ret == WLAN_ID_NOT_EXIST)
	{
		retu=-4;
	}
	else if (ret == WTP_IS_NOT_BINDING_WLAN_ID)
	{
		retu=-5;
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
	{
		retu=-6;
	}
	else if (ret == WTP_OVER_MAX_BSS_NUM)
	{
		retu=-7;
	}
	else
	{
		retu=-8;
	}
		
	dbus_message_unref(reply);
	
	return retu;			
#endif	
}

#if _GROUP_POLICY
void Free_set_wds_service_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-12时，调用Free_set_wds_service_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_wds_service_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *WlanId,char *state,struct RadioList **RadioList_Head)
									/*返回0表示失败，返回1表示成功，返回-1表示input patameter should only be 'enable' or 'disable'*/
									/*返回-2表示wlan isn't existed，返回-3表示radio doesn't bind wlan argv[0]，返回-4表示radio id does not exist*/
									/*返回-5表示wtp is not in run state，返回-6表示another wds mode be used，返回-7表示error*/
									/*返回-8表示Radio ID非法，返回-9表示illegal input:Input exceeds the maximum value of the parameter type*/
									/*返回-10表示unknown id format，返回-11表示Group ID非法，返回-12表示partial failure*/
									/*返回-13表示group id does not exist*/
{
    if(NULL == connection)
        return 0;
        
	if((NULL == WlanId)||(NULL == state))
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned char status = 0;
	unsigned char wlanid = 0;
	int retu = 0;
	
	ret = parse_char_ID((char *)WlanId,&wlanid);
	if(ret != WID_DBUS_SUCCESS){
        if(ret == WID_ILLEGAL_INPUT){
			retu = -9;
        }
		else{
			retu = -10;
		}
		return retu;
	}	
	if (!strcmp(state,"enable"))
	{
		status = 1;	
	}		
	else if (!strcmp(state,"disable"))
	{
		status = 0;
	}
	else
	{
		return -1;
	}

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_wds_service_cmd_group is %d\n",id);
			return -8;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_wds_service_cmd_group is %d\n",id);
			return -11;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								unsigned char ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_wds_service_cmd_wlan_wds");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 wlanid,
								 status,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret==WLAN_ID_NOT_EXIST)
			retu = -2;
		else if(ret==RADIO_NO_BINDING_WLAN)
			retu = -3;
		else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
			retu = -3;
		else if(ret == 0)
			retu = 1;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -4;
		else if(ret ==	WTP_NOT_IN_RUN_STATE)
			retu = -5;
		else if(ret == WDS_MODE_BE_USED)
			retu = -6;
		else
			retu = -7;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -12;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -13;
	}	
	return retu;
}
#endif
/*type为"wds"或"mesh"*/
/*state为"enable"或"disable"*/
int set_wds_service_cmd(dbus_parameter parameter, DBusConnection *connection,int RadID,char *WlanId,char *type,char *state)
																				/*返回0表示失败，返回1表示成功，返回-1表示input patameter should only be 'enable' or 'disable'*/
																				/*返回-2表示wlan isn't existed，返回-3表示radio doesn't bind wlan argv[0]，返回-4表示radio id does not exist*/
																				/*返回-5表示wtp is not in run state，返回-6表示another wds mode be used，返回-7表示error*/
																				/*返回-8表示Radio ID非法，返回-9表示illegal input:Input exceeds the maximum value of the parameter type*/
																				/*返回-10表示unknown id format，返回-11表示input patameter should only be 'wds' or 'mesh'*/
																				/*返回-12表示another mesh mode be used*/
																				/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
    if(NULL == connection)
        return 0;
	
	if((NULL == WlanId)||(NULL == type)||(NULL == state))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_wds_service_cmd_group(parameter, connection,0,RadID,WlanId,state,&RadioList_Head);
	if(retu == -12)
	{
		Free_set_wds_service_cmd_group(RadioList_Head);
	}
	return retu;
#else
	unsigned int radio_id; 
	unsigned char status;
	int ret,retu;
	unsigned char wlanid;
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;	
	
	ret = parse_char_ID((char *)WlanId,&wlanid);
	if(ret != WID_DBUS_SUCCESS){
        if(ret == WID_ILLEGAL_INPUT){
			retu = -9;
        }
		else{
			retu = -10;
		}
		return retu;
	}	
	if (!strcmp(state,"enable"))
	{
		status = 1;	
	}		
	else if (!strcmp(state,"disable"))
	{
		status = 0;
	}
	else
	{
		return -1;
	}

	if(!strcmp(type,"wds")){
		
		if (!strcmp(state,"enable"))
		{
			status = 1;	
		}		
		else if (!strcmp(state,"disable"))
		{
			status = 0;
		}
		else
		{
			return -1;
		}
	}
	else	if(!strcmp(type,"mesh")){
		
		if (!strcmp(state,"enable"))
		{
			status = 3;	
		}		
		else if (!strcmp(state,"disable"))
		{
			status = 2;
		}
		else
		{
			return -1;
		}
	}
	else{
			return -11;
	}

	//radio_id = RadID;

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radio_id = RadID;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in set_wds_service_cmd is %d\n",radio_id);
		return -8;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_WDS_STATUS);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_WDS_STATUS);*/
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&wlanid,
							 DBUS_TYPE_UINT32,&radio_id,
							 DBUS_TYPE_BYTE,&status,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
		
	if(ret == WLAN_ID_NOT_EXIST)
		retu = -2;
	else if(ret == RADIO_NO_BINDING_WLAN)
		retu = -3;
	else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
		retu = -3;
	else if(ret == 0)
		retu = 1;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu = -4;
	else if(ret ==	WTP_NOT_IN_RUN_STATE)
		retu = -5;
	else if(ret == WDS_MODE_BE_USED){
		if((status&0x02) == 0){
			retu = -6;
		}
		else{
			retu = -12;
		}
	}else
		retu = -7;

	dbus_message_unref(reply);
	return retu;
#endif
}

#if _GROUP_POLICY
void Free_radio_wlan_wds_bssid_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-10时，调用Free_radio_wlan_wds_bssid_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int radio_wlan_wds_bssid_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *WlanId,char *oper_type,char *MAC,struct RadioList **RadioList_Head)
										/*返回0表示失败，返回1表示成功，返回-1表示wlan id should be 1 to WLAN_NUM-1*/
										/*返回-2表示input patameter should only be 'add' or 'delelte'，返回-3表示Unknown mac addr format*/
										/*返回-4表示wlan isn't existed，返回-5表示radio doesn't bind wlan argv[0]*/
										/*返回-6表示another WDS mode be used, disable first，返回-7表示WDS op failed，返回-8表示Radio ID非法*/
										/*返回-9表示Group ID非法，返回-10表示partial failure，返回-11表示group id does not exist*/
{
	if(NULL == connection)
			return 0;

	if((NULL == WlanId)||(NULL == oper_type)||(NULL == MAC))
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;

	unsigned int id = 0;
	unsigned int type = 0; 
	unsigned char mac[6];
	int retu = 0;
	unsigned char wlan_id = 0;
	unsigned char list_type=0;   /*1--add list*/
								/* 2--delete list*/
	
	wlan_id = atoi(WlanId);
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		return -1;
	}

	str2lower(&oper_type);
	
	if (!strcmp(oper_type,"add")){
		list_type=1;		
	}else if (!strcmp(oper_type,"delete")){
		list_type=2;		
	}else{
		return -2;
	}
	
	ret = wid_parse_mac_addr((char *)MAC,&mac);
	if (CMD_FAILURE == ret) {
		return -3;
	}
	
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in radio_wlan_wds_bssid_cmd_group is %d\n",id);
			return -8;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in radio_wlan_wds_bssid_cmd_group is %d\n",id);
			return -9;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char * ,
								unsigned char ,
								unsigned char ,
								int *,
								unsigned int *
							);
	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"radio_wlan_wds_bssid_cmd_wlan_wds_bssid_MAC");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 mac,
								 wlan_id,
								 list_type,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret==WLAN_ID_NOT_EXIST)
			retu = -4;
		else if(ret==RADIO_NO_BINDING_WLAN)
			retu = -5;
		else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
			retu = -5;
		else if(ret == WID_DBUS_SUCCESS)
			retu = 1;
		else if(ret == WDS_MODE_BE_USED)
			retu = -6;
		else
			retu = -7;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -10;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -11;
	}
	return retu; 
}
#endif
/*type为"add"或"delete"*/
/*Ltype为"wds_bssid"或"mesh_bssid"*/
int radio_wlan_wds_bssid_cmd(dbus_parameter parameter, DBusConnection *connection,int RadID,char *WlanId,char *type,char *Ltype,char *MAC)
																								/*返回0表示失败，返回1表示成功，返回-1表示wlan id should be 1 to WLAN_NUM-1*/
																								/*返回-2表示input patameter should only be 'add' or 'delelte'，返回-3表示Unknown mac addr format*/
																								/*返回-4表示wlan isn't existed，返回-5表示radio doesn't bind wlan argv[0]*/
																								/*返回-6表示another WDS mode be used, disable first，返回-7表示WDS op failed*/
																								/*返回-8表示Radio ID非法，返回-9表示input patameter should only be 'wds_bssid' or 'mesh_bssid'*/
																								/*返回-10表示another Mesh mode be used, disable first，返回-11表示Mesh op faild*/
																								/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
			return 0;
	
	if((NULL == WlanId)||(NULL == type)||(NULL == Ltype)||(NULL == MAC))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = radio_wlan_wds_bssid_cmd_group(parameter,connection,0,RadID,WlanId,type,MAC,&RadioList_Head);
	if(retu == -10)
	{
		Free_radio_wlan_wds_bssid_cmd_group(RadioList_Head);
	}
	return retu;
#else
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned char mac[6];
	unsigned int ret;
	unsigned int RadioID;
	unsigned char wlan_id = 0;
	unsigned char list_type=0;   //1--add list
								// 2--delete list
	int retu;
	
	//RadioID = RadID;
	wlan_id = atoi(WlanId);
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		return -1;
	}

	str2lower(&type);
	
	if (!strcmp(type,"add")){
		if(!strcmp(Ltype,"wds_bssid")){
			list_type=1;	
		}
		else if(!strcmp(Ltype,"mesh_bssid")){
			list_type = 5;
		}
		else{
			return -9;
		}
	}else if (!strcmp(type,"delete")){
		if(!strcmp(Ltype,"wds_bssid")){
			list_type=2;	
		}
		else if(!strcmp(Ltype,"mesh_bssid")){
			list_type = 6;
		}
		else{
			return -9;
		}	
	}else{
		return -2;
	}
	
	ret = parse_mac_addr((char *)MAC,&mac);
	if (CMD_FAILURE == ret) {
		return -3;
	}
	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	RadioID = RadID;
	if(RadioID > G_RADIO_NUM || RadioID == 0){
		syslog(LOG_DEBUG,"radio id in radio_wlan_wds_bssid_cmd is %d\n",RadioID);
		return -8;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_WDS_WLAN_SET);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_WDS_WLAN_SET);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							DBUS_TYPE_UINT32,&RadioID,
							DBUS_TYPE_BYTE,&wlan_id,
							DBUS_TYPE_BYTE,&list_type,
							DBUS_TYPE_BYTE,&mac[0],
							DBUS_TYPE_BYTE,&mac[1],
							DBUS_TYPE_BYTE,&mac[2],
							DBUS_TYPE_BYTE,&mac[3],
							DBUS_TYPE_BYTE,&mac[4],
							DBUS_TYPE_BYTE,&mac[5],
							DBUS_TYPE_INVALID);

	
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	
	if(ret==WLAN_ID_NOT_EXIST)
		retu = -4;
	else if(ret==RADIO_NO_BINDING_WLAN)
		retu = -5;
	else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
		retu = -5;
	else if(ret == WID_DBUS_SUCCESS)
		retu = 1;
	else if(ret == WDS_MODE_BE_USED){
		if((list_type&0x04) == 0){
			retu = -6;
		}
		else{
			retu = -10;
		}
	}	
	else{
		if((list_type&0x04) == 0){
			retu = -7;
		}
		else{
			retu = -11;
		}
	}

	dbus_message_unref(reply);

	return retu; 
#endif	
}

void Free_wlan_wds_bssid_list_head(DCLI_RADIO_API_GROUP_ONE *RADIOINFO)
{
	void (*dcli_init_free_func)(char *,DCLI_RADIO_API_GROUP_ONE *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_radio_free_fun");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WID_DBUS_RADIO_METHOD_SHOW_WDS_BSSID_INFO,RADIOINFO);
		}
	}
}

/*type为"wds_bssid_list"或"mesh_bssid_list"*/
/*返回1时，调用Free_wlan_wds_bssid_list_head()释放空间*/
int show_wlan_wds_bssid_list_cmd(dbus_parameter parameter, DBusConnection *connection,int RadID,char *WlanId,char *type,DCLI_RADIO_API_GROUP_ONE **RADIOINFO)
																									/*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
																									/*返回-2表示wlan id should be 1 to WLAN_NUM-1，返回-3表示wlan id does not exist*/
																									/*返回-4表示error，返回-5表示Radio ID非法*/
																									/*返回-6表示illegal input:Input exceeds the maximum value of the parameter type*/
																									/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
			return 0;

	if((NULL == WlanId)||(NULL == type))
	{
		*RADIOINFO = NULL;
		return 0;
	}
	
	int ret;
	unsigned char wlan_id;
	unsigned int radioID;
	unsigned int wds_mesh = 0;
	int retu;

	ret = parse_char_ID((char*)WlanId, &wlan_id);
	if(ret != WID_DBUS_SUCCESS){
        if(ret == WID_ILLEGAL_INPUT){
			retu = -6;
        }
		else{
			retu = -1;
		}
		return retu;
	}	
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		return -2;
	}
	

	radioID = RadID;
	if(radioID > G_RADIO_NUM || radioID == 0){
		syslog(LOG_DEBUG,"radio id in show_wlan_wds_bssid_list_cmd is %d\n",radioID);
		return -5;
    }

	if(!strcmp(type,"wds_bssid_list")){
		wds_mesh = 0;
	}
	else if(!strcmp(type,"mesh_bssid_list")){
		wds_mesh = 1;
	}
	else
	{
		//vty_out(vty,"you should only 'wds_bssid_list' or 'mesh_bssid_list'\n");
	}

	void*(*dcli_init_func)(
					int ,
					unsigned int ,
					unsigned int* ,
					unsigned int* ,
					unsigned char *,
					DBusConnection *,
					char *
					);

	*RADIOINFO = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_radio_show_api_group_one");
		if(NULL != dcli_init_func)
		{
			*RADIOINFO =(*dcli_init_func)
				  (
					parameter.instance_id,
					radioID,/*"show wlan WLANID wds_bssid_list"*/
					&parameter.local_id,
					&ret,
					&wlan_id,
					connection,
					WID_DBUS_RADIO_METHOD_SHOW_WDS_BSSID_INFO
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1)
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	if((ret == 0)&&(*RADIOINFO))
	{
		retu = 1;
	}
	else if (ret == WLAN_ID_NOT_EXIST)
	{
		retu = -3;
	}
	else
	{
		retu = -4;
	}
	
	return retu;
}

#if _GROUP_POLICY
void Free_set_ap_radio_auto_channel_func_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-7时，调用Free_set_ap_radio_auto_channel_func_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_ap_radio_auto_channel_func_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *state,struct RadioList **RadioList_Head)
								/*返回0表示失败，返回1表示成功，返回-1表示input patameter only with 'enable' or 'disable'*/
							    /*返回-2表示wtp id does not exist，返回-3表示radio id does not exist，返回-4表示error*/
							    /*返回-5表示Radio ID非法，返回-6表示Group ID非法，返回-7表示partial failure*/
							    /*返回-8表示group id does not exist*/
{
	if(NULL == connection)
			return 0;

	if(NULL == state)
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned int policy =0;  
	int retu = 0;
		
	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -1;
	}
	

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_ap_radio_auto_channel_func_group is %d\n",id);
			return -5;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_ap_radio_auto_channel_func_group is %d\n",id);
			return -6;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned int ,
								int *,
								unsigned int *
							);
	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_ap_radio_auto_channel_cmd_set_radio_auto_channel");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 policy,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -2;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -3;
		else
			retu = -4;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -7;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -8;
	}
	return retu;		
}
#endif

int set_ap_radio_auto_channel_func(dbus_parameter parameter, DBusConnection *connection,int RID,char *state)
																			 /*返回0表示失败，返回1表示成功，返回-1表示input patameter only with 'enable' or 'disable'*/
																			 /*返回-2表示wtp id does not exist，返回-3表示radio id does not exist，返回-4表示error，返回-5表示Radio ID非法*/
																			 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
		return 0;
	
	if(NULL == state)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_ap_radio_auto_channel_func_group(parameter,connection,0,RID,state,&RadioList_Head);
	if(retu == -7)
	{
		Free_set_ap_radio_auto_channel_func_group(RadioList_Head);
	}
	return retu;
#else
	int ret = 0,retu;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int radio_id = 0;
	unsigned int policy = 0;
	//radio_id = RID;

	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -1;
	}
	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radio_id = RID;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in set_ap_radio_auto_channel_func is %d\n",radio_id);
		return -5;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_WTP_RADIO_AUTO_CHANNEL);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_WTP_RADIO_AUTO_CHANNEL);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radio_id,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == WTP_ID_NOT_EXIST)
		retu=-2;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu=-3;
	else
		retu=-4;
		
	dbus_message_unref(reply);

	return retu;		
#endif	
}

#if _GROUP_POLICY
void Free_set_ap_radio_auto_channel_cont_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-7时，调用Free_set_ap_radio_auto_channel_cont_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_ap_radio_auto_channel_cont_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *state,struct RadioList **RadioList_Head) 
																	/*返回0表示失败，返回1表示成功*/
																	/*返回-1表示input patameter only with 'enable' or 'disable'*/
																	/*返回-2表示wtp id does not exist*/
																	/*返回-3表示radio id does not exist，返回-4表示error*/
																	/*返回-5表示Radio ID非法，返回-6表示Group ID非法*/
																	/*返回-7表示partial failure，返回-8表示group id does not exist*/
{
	if(NULL == connection)
			return 0;

	if(NULL == state)
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned int policy =0;  
	int retu = 0;

	if (!strcmp(state,"enable"))
	{
		policy = 0;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 1;	
	}
	else
	{
		return -1;
	}

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_ap_radio_auto_channel_cont_cmd_group is %d\n",id);
			return -5;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_ap_radio_auto_channel_cont_cmd_group is %d\n",id);
			return -6;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned int ,
								int *,
								unsigned int *
							);
    *RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_ap_radio_auto_channel_cont_cmd_set_radio_auto");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 policy,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -2;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -3;
		else
			retu = -4;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -7;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
					{
						if(Radio_Show_Node == NULL)
							Radio_Show_Node = RadioList_Head->RadioList_list;
						else 
							Radio_Show_Node = Radio_Show_Node->next;
						if(Radio_Show_Node == NULL)
							break;
						vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
					}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -8;
	}
	return retu;		
}
#endif

/*state为enable或disable*/
int set_ap_radio_auto_channel_cont_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *state) 
																					/*返回0表示失败，返回1表示成功*/
																					/*返回-1表示input patameter only with 'enable' or 'disable'*/
																					/*返回-2表示wtp id does not exist*/
																					/*返回-3表示radio id does not exist，返回-4表示error*/
																					/*返回-5表示Radio ID非法*/
																					/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
		return 0;
	
	if(NULL == state)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_ap_radio_auto_channel_cont_cmd_group(parameter,connection,0,RID,state,&RadioList_Head);
	if(retu == -7)
	{
		Free_set_ap_radio_auto_channel_cont_cmd_group(RadioList_Head);
	}
	return retu;
#else
	int ret = 0;
	int retu;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int radio_id = 0;
	unsigned int policy = 0;
	//radio_id = (unsigned int)RID;

	if (!strcmp(state,"enable"))
	{
		policy = 0;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 1;	
	}
	else
	{
		return -1;
	}
	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radio_id = RID;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in set_ap_radio_auto_channel_cont_cmd is %d\n",radio_id);
		return -5;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_WTP_RADIO_AUTO_CHANNEL_CONT);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_WTP_RADIO_AUTO_CHANNEL_CONT);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radio_id,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		

		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		retu = 1;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{	
		retu = -2;
	}
	else if(ret == RADIO_ID_NOT_EXIST)
	{	
		retu = -3;
	}
	else
	{
		retu = -4;
	}
		
	dbus_message_unref(reply);

	return retu;		
#endif	
}

#if _GROUP_POLICY
void Free_set_ap_radio_diversity_func_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-9时，调用Free_set_ap_radio_diversity_func_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_ap_radio_diversity_func_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *state,struct RadioList **RadioList_Head)
							/*返回0表示失败，返回1表示成功，返回-1表示input patameter only with 'enable' or 'disable'*/
							/*返回-2表示wtp id does not exist，返回-3表示radio id does not exist*/
							/*返回-4表示radio model not petmit to set diversity，返回-5表示error，返回-6表示Radio ID非法*/
							/*返回-7表示Group ID非法，返回-8表示to enable this function, you should restart wtp*/
							/*返回-9表示partial failure，返回-10表示group id does not exist*/
{
	if(NULL == connection)
			return 0;

	if(NULL == state)
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned int policy =0;  
	int retu = 0;

	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -1;
	}	

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_ap_radio_diversity_func_group is %d\n",id);
			return -6;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_ap_radio_diversity_func_group is %d\n",id);
			return -7;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned int ,
								int *,
								unsigned int *
							);
	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_ap_radio_diversity_cmd_set_radio_diversity");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 policy,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(type==0)
	{
		if(ret == 0)
		{
			retu = 1;
			if(policy == 1)
			{
				retu = -8;
			}
		}
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -2;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -3;
		else if(ret == MODEL_NO_EXIST)
			retu = -4;
		else
			retu = -5;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -9;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -10;
	}
	return retu;		
}
#endif

int set_ap_radio_diversity_func(dbus_parameter parameter, DBusConnection *connection,int RID,char *state)
																		/*返回0表示失败，返回1表示成功，返回-1表示input patameter only with 'enable' or 'disable'*/
																		/*返回-2表示wtp id does not exist，返回-3表示radio id does not exist*/
																		/*返回-4表示radio model not petmit to set diversity，返回-5表示error，返回-6表示Radio ID非法*/
																		/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
			return 0;
	
	if(NULL == state)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_ap_radio_diversity_func_group(parameter,connection,0,RID,state,&RadioList_Head);
	if(retu == -9)
	{
		Free_set_ap_radio_diversity_func_group(RadioList_Head);
	}
	return retu;
#else
	int ret = 0,retu;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int radio_id = 0;
	unsigned int policy = 0;
	//radio_id = RID;

	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -1;
	}
	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radio_id = RID;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in set_ap_radio_diversity_func is %d\n",radio_id);
		return -6;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_WTP_RADIO_DIVERSITY);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_WTP_RADIO_DIVERSITY);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radio_id,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		

		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		retu=1;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{	
		retu=-2;
	}
	else if(ret == RADIO_ID_NOT_EXIST)
	{	
		retu=-3;
	}
	else if(ret == MODEL_NO_EXIST)
	{	
		retu=-4;
	}
	else
	{
		retu=-5;
	}
		
	dbus_message_unref(reply);

	return retu;		
#endif	
}

#if _GROUP_POLICY
void Free_set_ap_radio_txantenna_func_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-7时，调用Free_set_ap_radio_txantenna_func_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_ap_radio_txantenna_func_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *txan_type,struct RadioList **RadioList_Head)
						/*返回0表示失败，返回1表示成功，返回-1表示input patameter only with 'auto' 'main' or 'vice'*/
					    /*返回-2表示wtp id does not exist，返回-3表示radio id does not exist，返回-4表示error，返回-5表示Radio ID非法*/
						/*返回-6表示Group ID非法，返回-7表示partial failure，返回-8表示group id does not exist*/
{
	if(NULL == connection)
			return 0;

	if(NULL == txan_type)
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned int policy =0;  
	int retu = 0;

	if (!strcmp(txan_type,"auto"))
	{
		policy = 0;	
	}
	else if (!strcmp(txan_type,"main"))
	{
		policy = 1;	
	}
	else if (!strcmp(txan_type,"vice"))
	{
		policy = 2;	
	}
	else
	{
		return -1;
	}
	

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_ap_radio_txantenna_func_group is %d\n",id);
			return -5;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_ap_radio_txantenna_func_group is %d\n",id);
			return -6;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned int ,
								int *,
								unsigned int *
							);
	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_ap_radio_txantenna_cmd_set_radio_txantenna");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 policy,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -2;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -3;
		else
			retu = -4;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -7;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -8;
	}
	return retu;		
}
#endif

int set_ap_radio_txantenna_func(dbus_parameter parameter, DBusConnection *connection,int RID,char *txan_type)
																			 /*返回0表示失败，返回1表示成功，返回-1表示input patameter only with 'auto' 'main' or 'vice'*/
																			 /*返回-2表示wtp id does not exist，返回-3表示radio id does not exist，返回-4表示error，返回-5表示Radio ID非法*/
																			 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
		return 0;
	
	if(NULL == txan_type)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_ap_radio_txantenna_func_group(parameter,connection,0,RID,txan_type,&RadioList_Head);
	if(retu == -7)
	{
		Free_set_ap_radio_txantenna_func_group(RadioList_Head);
	}
	return retu;
#else
	int ret = 0,retu;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int radio_id = 0;
	unsigned int policy = 0;
	//radio_id = RID;

	if (!strcmp(txan_type,"auto"))
	{
		policy = 0;	
	}
	else if (!strcmp(txan_type,"main"))
	{
		policy = 1;	
	}
	else if (!strcmp(txan_type,"vice"))
	{
		policy = 2;	
	}
	else
	{
		return -1;
	}
	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radio_id = RID;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in set_ap_radio_txantenna_func is %d\n",radio_id);
		return -5;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_WTP_RADIO_TXANTENNA);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_WTP_RADIO_TXANTENNA);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radio_id,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		retu=1;
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{	
		retu=-2;
	}
	else if(ret == RADIO_ID_NOT_EXIST)
	{	
		retu=-3;
	}
	else
	{
		retu=-4;
	}
		
	dbus_message_unref(reply);

	return retu;		
#endif	
}

#if _GROUP_POLICY
void Free_radio_bss_traffic_limit_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-10时，调用Free_radio_bss_traffic_limit_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*state为"enable"或"disable"*/
int radio_bss_traffic_limit_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *WlanID,char *state,struct RadioList **RadioList_Head)
															/*返回0表示失败，返回1表示成功*/
														    /*返回-1表示wlan id should be 1 to WLAN_NUM-1*/
														    /*返回-2表示input patameter only with 'enable' or 'disable'*/
														    /*返回-3表示wlan isn't existed，返回-4表示wtp isn't existed*/
														    /*返回-5表示radio isn't existed*/
														    /*返回-6表示radio doesn't bind wlan argv[0]，返回-7表示error*/
															/*返回-8表示Radio ID非法，返回-9表示Group ID非法*/
															/*返回-10表示partial failure，返回-11表示group id does not exist*/
{
	if(NULL == connection)
			return 0;

	if((NULL == WlanID)||(NULL == state))
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned char wlan_id = 0;
	unsigned char policy =0;  
	int retu = 0;

	wlan_id = atoi(WlanID);
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		return -1;
	}

	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -2;
	}
	

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in radio_bss_traffic_limit_cmd_group is %d\n",id);
			return -8;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in radio_bss_traffic_limit_cmd_group is %d\n",id);
			return -9;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								unsigned char ,
								int *,
								unsigned int *
							);
	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"radio_bss_taffic_limit_cmd_wlan_ID_traffic_limit");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 wlan_id,
								 policy,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret==WLAN_ID_NOT_EXIST)
			retu = -3;
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -4;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -5;
		else if(ret==RADIO_NO_BINDING_WLAN)
			retu = -6;
		else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
			retu = -6;
		else if(ret == WID_DBUS_SUCCESS)
			retu = 1;
		else
			retu = -7;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -10;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -11;
	}
	return retu;
}
#endif

/*state为"enable"或"disable"*/
int radio_bss_traffic_limit_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *WlanID,char *state)
																				 	/*返回0表示失败，返回1表示成功*/
																				    /*返回-1表示wlan id should be 1 to WLAN_NUM-1*/
																				    /*返回-2表示input patameter only with 'enable' or 'disable'*/
																				    /*返回-3表示wlan isn't existed，返回-4表示wtp isn't existed*/
																				    /*返回-5表示radio isn't existed*/
																				    /*返回-6表示radio doesn't bind wlan argv[0]，返回-7表示error*/
																					/*返回-8表示Radio ID非法*/
																					/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
		return 0;
	
	if((NULL == WlanID)||(NULL == state))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = radio_bss_traffic_limit_cmd_group(parameter,connection,0,RID,WlanID,state,&RadioList_Head);
	if(retu == -10)
	{
		Free_radio_bss_traffic_limit_cmd_group(RadioList_Head);
	}
	return retu;
#else
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int ret;
	unsigned int RadioID;
	unsigned char wlan_id = 0;
	unsigned char policy =0;   
	int retu;
	
	//RadioID = RID;
	wlan_id = atoi(WlanID);
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		return -1;
	}

	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -2;
	}
	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	RadioID = RID;
	if(RadioID > G_RADIO_NUM || RadioID == 0){
		syslog(LOG_DEBUG,"radio id in radio_bss_traffic_limit_cmd is %d\n",RadioID);
		return -8;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_TRAFFIC_LIMIT_ABLE);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_TRAFFIC_LIMIT_ABLE);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							DBUS_TYPE_UINT32,&RadioID,
							DBUS_TYPE_BYTE,&wlan_id,
							DBUS_TYPE_BYTE,&policy,
							DBUS_TYPE_INVALID);

	
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	
	if(ret==WLAN_ID_NOT_EXIST)
		retu=-3;
	else if(ret == WTP_ID_NOT_EXIST)
		retu=-4;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu=-5;
	else if(ret==RADIO_NO_BINDING_WLAN)
		retu=-6;
	else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
		retu=-6;
	else if(ret == WID_DBUS_SUCCESS)
		retu=1;
	else
		retu=-7;

	dbus_message_unref(reply);

	return retu; 
#endif	
}

#if _GROUP_POLICY
void Free_radio_bss_traffic_limit_value_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-11时，调用Free_radio_bss_traffic_limit_value_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*VALUE的范围是1-884736*/
int radio_bss_traffic_limit_value_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *WlanID,char *VALUE,struct RadioList **RadioList_Head)
													/*返回0表示失败，返回1表示成功*/
												    /*返回-1表示wlan id should be 1 to WLAN_NUM-1*/
												    /*返回-2表示input parameter argv[1] error*/
												    /*返回-3表示wlan isn't existed，返回-4表示wtp isn't existed*/
												    /*返回-5表示radio isn't existed*/
												    /*返回-6表示radio doesn't bind wlan argv[0]，返回-7表示error*/
												    /*返回-8表示Radio ID非法，返回-9表示input value should be 1 to 884736*/
													/*返回-10表示Group ID非法，返回-11表示partial failure*/
													/*返回-12表示group id does not exist*/
{
	if(NULL == connection)
		return 0;

	if((NULL == WlanID)||(NULL == VALUE))
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned char wlan_id = 0;
	unsigned int value = 0;  
	int retu = 0;

	wlan_id = atoi(WlanID);
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		return -1;
	}

	ret = parse_int_ID((char *)VALUE,&value);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
		return -2;
	} 	

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in radio_bss_traffic_limit_value_cmd_group is %d\n",id);
			return -8;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in radio_bss_traffic_limit_value_cmd_group is %d\n",id);
			return -10;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								unsigned int ,
								int *,
								unsigned int *
							);
	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"radio_bss_taffic_limit_value_cmd_wlan_ID_traffic_limit_value");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 wlan_id,
								 value,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret==WLAN_ID_NOT_EXIST)
			retu = -3;
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -4;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -5;
		else if(ret==RADIO_NO_BINDING_WLAN)
			retu = -6;
		else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
			retu = -6;
		else if(ret == WID_DBUS_SUCCESS)
			retu = 1;
		else
			retu = -7;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -11;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -12;
	}
	return retu; 
}
#endif

/*VALUE的范围是1-884736*/
int radio_bss_traffic_limit_value_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *WlanID,char *VALUE)
																						   /*返回0表示失败，返回1表示成功*/
																						   /*返回-1表示wlan id should be 1 to WLAN_NUM-1*/
																						   /*返回-2表示input parameter argv[1] error*/
																						   /*返回-3表示wlan isn't existed，返回-4表示wtp isn't existed*/
																						   /*返回-5表示radio isn't existed*/
																						   /*返回-6表示radio doesn't bind wlan argv[0]，返回-7表示error*/
																						   /*返回-8表示Radio ID非法，返回-9表示input value should be 1 to 884736*/
																						   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
		return 0;
	
	if((NULL == WlanID)||(NULL == VALUE))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = radio_bss_traffic_limit_value_cmd_group(parameter,connection,0,RID,WlanID,VALUE,&RadioList_Head);
	if(retu == -11)
	{
		Free_radio_bss_traffic_limit_value_cmd_group(RadioList_Head);
	}
	return retu;
#else
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int ret;
	unsigned int RadioID;
	unsigned char wlan_id = 0;
	unsigned int value = 0;   
	int retu;
	
	//RadioID = RID;
	wlan_id = atoi(WlanID);
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		return -1;
	}

	ret = parse_int_ID((char *)VALUE,&value);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
		return -2;
	} 	
	if((value > 884736)||(value < 1))
	{
		return -9;
	}
	
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	RadioID = RID;
	if(RadioID > G_RADIO_NUM || RadioID == 0){
		syslog(LOG_DEBUG,"radio id in radio_bss_traffic_limit_value_cmd is %d\n",RadioID);
		return -8;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_TRAFFIC_LIMIT_VALUE);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_TRAFFIC_LIMIT_VALUE);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							DBUS_TYPE_UINT32,&RadioID,
							DBUS_TYPE_BYTE,&wlan_id,
							DBUS_TYPE_UINT32,&value,
							DBUS_TYPE_INVALID);

	
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	
	if(ret==WLAN_ID_NOT_EXIST)
		retu=-3;
	else if(ret == WTP_ID_NOT_EXIST)
		retu=-4;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu=-5;
	else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
		retu=-6;
	else if(ret == WID_DBUS_SUCCESS)
		retu=1;
	else
		retu=-7;

	dbus_message_unref(reply);

	return retu; 
#endif	
}

#if _GROUP_POLICY
void Free_radio_bss_traffic_limit_average_value_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-11时，调用Free_radio_bss_traffic_limit_average_value_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int radio_bss_traffic_limit_average_value_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *WlanID,char *VALUE,struct RadioList **RadioList_Head)
													/*返回0表示失败，返回1表示成功*/
													/*返回-1表示wlan id should be 1 to WLAN_NUM-1*/
													/*返回-2表示input parameter argv[1] error*/
													/*返回-3表示wlan isn't existed，返回-4表示wtp isn't existed*/
													/*返回-5表示radio isn't existed，返回-6表示radio doesn't bind wlan argv[0]*/
													/*返回-7表示station traffic limit value is more than bss traffic limit value*/
													/*返回-8表示error，返回-9表示Radio ID非法*/
													/*返回-10表示Group ID非法，返回-11表示partial failure*/
													/*返回-12表示group id does not exist，返回-13表示input value should be 1 to 884736*/
{ 
	if(NULL == connection)
			return 0;

	if((NULL == WlanID)||(NULL == VALUE))
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned char wlan_id = 0;
	unsigned int value = 0;  
	int retu = 0;

	wlan_id = atoi(WlanID);
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		return -1;
	}

	ret = parse_int_ID((char *)VALUE,&value);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
		return -2;
	} 
	if((value > 884736)||(value < 1))
	{
		return -13;
	}	
	
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in radio_bss_traffic_limit_average_value_cmd_group is %d\n",id);
			return -9;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in radio_bss_traffic_limit_average_value_cmd_group is %d\n",id);
			return -10;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								unsigned int ,
								int *,
								unsigned int *
							);
	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"radio_bss_taffic_limit_average_value_cmd_wlan_ID_traffic_limit_station_average_value");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 wlan_id,
								 value,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret==WLAN_ID_NOT_EXIST)
			retu = -3;
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -4;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -5;
		else if(ret==RADIO_NO_BINDING_WLAN)
			retu = -6;
		else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
			retu = -6;
		else if(ret == WID_DBUS_SUCCESS)
			retu = 1;
		else if(ret == IF_POLICY_CONFLICT)
			retu = -7;
		else
			retu = -8;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -11;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -12;
	}
	return retu; 
}
#endif

int radio_bss_traffic_limit_average_value_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *WlanID,char *VALUE)
																									 /*返回0表示失败，返回1表示成功*/
																									 /*返回-1表示wlan id should be 1 to WLAN_NUM-1*/
																									 /*返回-2表示input parameter argv[1] error*/
																									 /*返回-3表示wlan isn't existed，返回-4表示wtp isn't existed*/
																									 /*返回-5表示radio isn't existed，返回-6表示radio doesn't bind wlan argv[0]*/
																									 /*返回-7表示station traffic limit value is more than bss traffic limit value*/
																									 /*返回-8表示error，返回-9表示Radio ID非法*/
																									 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
																									 /*返回-13表示input value should be 1 to 884736*/
{
	if(NULL == connection)
		return 0;
	
	if((NULL == WlanID)||(NULL == VALUE))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = radio_bss_traffic_limit_average_value_cmd_group(parameter,connection,0,RID,WlanID,VALUE,&RadioList_Head);
	if(retu == -11)
	{
		Free_radio_bss_traffic_limit_average_value_cmd_group(RadioList_Head);
	}
	return retu;
#else
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int ret;
	unsigned int RadioID;
	unsigned char wlan_id = 0;
	unsigned int value = 0;   
	int retu;
	
	//RadioID = (int)RID;
	wlan_id = atoi(WlanID);
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		return -1;
	}

	ret = parse_int_ID((char *)VALUE,&value);	
	if (ret != WID_DBUS_SUCCESS)
	{	
		return -2;
	} 	
	if((value > 884736)||(value < 1))
	{
		return -13;
	}	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	RadioID = RID;
	if(RadioID > G_RADIO_NUM || RadioID == 0){
		syslog(LOG_DEBUG,"radio id in radio_bss_traffic_limit_average_value_cmd is %d\n",RadioID);
		return -9;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_TRAFFIC_LIMIT_AVERAGE_VALUE);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_TRAFFIC_LIMIT_AVERAGE_VALUE);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							DBUS_TYPE_UINT32,&RadioID,
							DBUS_TYPE_BYTE,&wlan_id,
							DBUS_TYPE_UINT32,&value,
							DBUS_TYPE_INVALID);

	
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	
	if(ret==WLAN_ID_NOT_EXIST)
		retu=-3;
	else if(ret == WTP_ID_NOT_EXIST)
		retu=-4;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu=-5;
	else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
		retu=-6;
	else if(ret == WID_DBUS_SUCCESS)
		retu=1;
	else if(ret == IF_POLICY_CONFLICT)
		retu=-7;
	else
		retu=-8;

	dbus_message_unref(reply);

	return retu; 
#endif	
}

int radio_bss_traffic_limit_sta_value_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *WlanID,char *MAC,char *VALUE)
																										  /*返回0表示失败，返回1表示成功*/
																										  /*返回-1表示wlan id should be 1 to WLAN_NUM-1*/
																										  /*返回-2表示input parameter argv[2] error*/
																										  /*返回-3表示wlan doesn't work*/
																										  /*返回-4表示can't find sta under wlan WlanID*/
																										  /*返回-5表示station traffic limit value is more than bss traffic limit value*/
																										  /*返回-6表示error，返回-7表示Radio ID非法*/
																										  /*返回-8表示input value should be 1 to 884736*/
{
	if(NULL == connection)
		return 0;

	if((NULL == WlanID)||(NULL == MAC)||(NULL == VALUE))
		return 0;
	
	unsigned int	value = 0;
	unsigned int	mac[MAC_LEN]={0};
	unsigned char	mac1[MAC_LEN]={0};
	unsigned int	ret=0;
	unsigned int 	RadioID = 0;
	unsigned char 	wlan_id = 0;
	unsigned char	type = 1;
	int retu;
	
	wlan_id = atoi(WlanID);
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		return -1;
	}

	memset(mac,0,MAC_LEN);
	sscanf(MAC,"%X:%X:%X:%X:%X:%X",&mac[0],&mac[1],&mac[2],&mac[3],&mac[4],&mac[5]);
	mac1[0] = (unsigned char)mac[0];
	mac1[1] = (unsigned char)mac[1];	
	mac1[2] = (unsigned char)mac[2];	
	mac1[3] = (unsigned char)mac[3];	
	mac1[4] = (unsigned char)mac[4];	
	mac1[5] = (unsigned char)mac[5];

	ret = parse_int_ID((char *)VALUE,&value);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
		return -2;
	} 
	if((value > 884736)||(value < 1))
	{
		return -8;
	}	
	
		
	RadioID = RID;
	if(RadioID > G_RADIO_NUM || RadioID == 0){
		syslog(LOG_DEBUG,"radio id in radio_bss_traffic_limit_sta_value_cmd is %d\n",RadioID);
		return -7;
    }

	void (*dcli_init_func)(
					DBusConnection *,
					int , 
					unsigned char *, 
					unsigned char , 
					unsigned int , 
					unsigned char , 
					unsigned int , 
					int ,
					unsigned int *
				);

	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"asd_set_sta_info");
		if(NULL != dcli_init_func)
		{
			(*dcli_init_func)
				  (
					 connection,
					 parameter.instance_id,
					 mac1,
					 wlan_id,
					 RadioID,
					 type,
					 value,
					 parameter.local_id,
					 &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == 0)
	{
		void (*dcli_init_func)(
					DBusConnection *,
					int , 
					unsigned char *, 
					unsigned char , 
					unsigned int , 
					unsigned char , 
					unsigned int , 
					int , 
					unsigned int *
				);

		if(NULL != ccgi_dl_handle)
		{
			dcli_init_func = dlsym(ccgi_dl_handle,"wid_set_sta_info");
			if(NULL != dcli_init_func)
			{
				(*dcli_init_func)
					  (
						 connection,
						 parameter.instance_id,
						 mac1,
						 wlan_id,
						 RadioID,
						 type,
						 value,
						 parameter.local_id,
						 &ret
					  );
			}
			else
			{
				return 0;
			}
		}
		else
		{
			return 0;
		}

		if(ret == 0)
		{
			void (*dcli_init_func)(
						DBusConnection *,
						int , 
						unsigned char *, 
						unsigned char , 
						unsigned int ,
						unsigned char , 
						unsigned int , 
						int ,
						unsigned int *
					);

			if(NULL != ccgi_dl_handle)
			{
				dcli_init_func = dlsym(ccgi_dl_handle,"set_sta_static_info");
				if(NULL != dcli_init_func)
				{
					(*dcli_init_func)
						  (
							 connection,
							 parameter.instance_id,
							 mac1,
							 wlan_id,
							 RadioID,
							 type,
							 value,
							 parameter.local_id,
							 &ret
						  );
				}
				else
				{
					return 0;
				}
			}
			else
			{
				return 0;
			}

			if(ret == 0)
				retu = 1;
			else if (ret == ASD_DBUS_ERROR)
				retu = 0;
			else
				retu = -6;
		}
		else if (ret == ASD_DBUS_ERROR)
			retu = 0;
		else
			retu = -6;
	}
	else if(ret==ASD_WLAN_NOT_EXIST)
		retu = -3;
	else if(ret == ASD_STA_NOT_EXIST)
		retu = -4;
	else if(ret == ASD_DBUS_ERROR)
		retu = -5;
	else
		retu = -6;

	return retu; 
}

#if _GROUP_POLICY
void Free_radio_bss_traffic_limit_cancel_sta_value_cmd_group(struct RadioList *RadioList_Head)
{
	if(RadioList_Head != NULL)
	{
		free(RadioList_Head);
		RadioList_Head = NULL;
	}
}

/*返回-11时，调用Free_radio_bss_traffic_limit_cancel_sta_value_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int radio_bss_traffic_limit_cancel_sta_value_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *WlanID,char *MAC,struct RadioList **RadioList_Head)
																/*返回0表示失败，返回1表示成功*/
																/*返回-1表示wlan id should be 1 to WLAN_NUM-1*/
																/*返回-2表示wlan doesn't work*/
																/*返回-3表示can't find sta under wlan WlanID*/
																/*返回-4表示wlan isn't existed，返回-5表示wtp isn't existed*/
																/*返回-6表示radio isn't existed*/
																/*返回-7表示radio doesn't bind wlan argv[0]，返回-8表示error*/
																/*返回-9表示Radio ID非法，返回-10表示Group ID非法*/
																/*返回-11表示partial failure，返回-12表示group id does not exist*/
{
	if(NULL == connection)
		return 0;

	if((NULL == WlanID)||(NULL == MAC))
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int ret_asd = 0;
	int ret_wid = 0;
	int count = 0;
	int failnum = 0;
	unsigned int id = 0;
	unsigned int type = 0;
  	unsigned char wlan_id = 0;
	unsigned char mac1[MAC_LEN];
	unsigned int mac[MAC_LEN];
	int retu = 0;

	wlan_id = atoi(WlanID);
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		return -1;
	}

	memset(mac,0,MAC_LEN);
	sscanf(MAC,"%X:%X:%X:%X:%X:%X",&mac[0],&mac[1],&mac[2],&mac[3],&mac[4],&mac[5]);
	mac1[0] = (unsigned char)mac[0];
	mac1[1] = (unsigned char)mac[1];	
	mac1[2] = (unsigned char)mac[2];	
	mac1[3] = (unsigned char)mac[3];	
	mac1[4] = (unsigned char)mac[4];	
	mac1[5] = (unsigned char)mac[5];

	
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in radio_bss_traffic_limit_cancel_sta_value_cmd_group is %d\n",id);
			return -9;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in radio_bss_traffic_limit_cancel_sta_value_cmd_group is %d\n",id);
			return -10;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								unsigned char *, 
								int *,
								unsigned int *,
								unsigned int *,
								unsigned int *,
								int *
							);
	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"radio_bss_taffic_limit_cancel_sta_value_cmd_wlan_configure");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,id,
								 wlan_id,
								 mac1,
								 &count,
								 &ret,
								 &ret_asd,
								 &ret_wid,
								 &failnum
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == WID_DBUS_SUCCESS)
		{
			if(ret_asd == ASD_WLAN_NOT_EXIST)
				retu = -2;
			else if(ret_asd == ASD_STA_NOT_EXIST)
				retu = -3;
			else if(ret_asd != ASD_DBUS_SUCCESS)
				retu = -8;
			if(ret_asd == ASD_DBUS_SUCCESS)
			{
				if(ret_wid == WID_DBUS_SUCCESS)
					retu = 1;
				else if(ret_wid == WTP_ID_NOT_EXIST)
					retu = -5;
				else if(ret_wid == RADIO_ID_NOT_EXIST)
					retu = -6;
				else if(ret_wid==RADIO_NO_BINDING_WLAN)
					retu = -7;
				else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
					retu = -7;
				else if(ret_wid==WLAN_ID_NOT_EXIST)
					retu = -4;
				else
					retu = -8;
			}
		}
		else
			retu = -6;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((failnum != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -11;
				/*vty_out(vty,"radio ");					
				for(i=0; i<failnum; i++)
				{
					vty_out(vty,"%d ",RadioList_Head[i].RadioId);	
					vty_out(vty,"%d ",RadioList_Head[i].FailReason);		
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -12;
	}	
	return retu; 
}
#endif

int radio_bss_traffic_limit_cancel_sta_value_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *WlanID,char *MAC)
																									  /*返回0表示失败，返回1表示成功*/
																									  /*返回-1表示wlan id should be 1 to WLAN_NUM-1*/
																									  /*返回-2表示wlan doesn't work*/
																									  /*返回-3表示can't find sta under wlan WlanID*/
																									  /*返回-4表示wlan isn't existed，返回-5表示wtp isn't existed*/
																									  /*返回-6表示radio isn't existed*/
																									  /*返回-7表示radio doesn't bind wlan argv[0]，返回-8表示error*/
																									  /*返回-9表示Radio ID非法*/
																									  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
		return 0;
	
	if((NULL == WlanID)||(NULL == MAC))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = radio_bss_traffic_limit_cancel_sta_value_cmd_group(parameter,connection,0,RID,WlanID,MAC,&RadioList_Head);
	if(retu == -11)
	{
		Free_radio_bss_traffic_limit_cancel_sta_value_cmd_group(RadioList_Head);
	}
	return retu;
#else
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int ret;
	unsigned int RadioID;
	unsigned char wlan_id = 0;
	unsigned char cancel_flag = 0;
	unsigned char mac1[MAC_LEN];
	unsigned int mac[MAC_LEN];
	int retu;
	
	//RadioID = (int)RID;
	wlan_id = atoi(WlanID);
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		return -1;
	}

	memset(mac,0,MAC_LEN);
	sscanf(MAC,"%X:%X:%X:%X:%X:%X",&mac[0],&mac[1],&mac[2],&mac[3],&mac[4],&mac[5]);
	mac1[0] = (unsigned char)mac[0];
	mac1[1] = (unsigned char)mac[1];	
	mac1[2] = (unsigned char)mac[2];	
	mac1[3] = (unsigned char)mac[3];	
	mac1[4] = (unsigned char)mac[4];	
	mac1[5] = (unsigned char)mac[5];

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	RadioID = RID;
	if(RadioID > G_RADIO_NUM || RadioID == 0){
		syslog(LOG_DEBUG,"radio id in radio_bss_traffic_limit_cancel_sta_value_cmd is %d\n",RadioID);
		return -9;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,ASD_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,ASD_DBUS_STA_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,ASD_DBUS_STA_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,ASD_DBUS_STA_METHOD_STA_TRAFFIC_LIMIT_CANCEL);
	
	/*query = dbus_message_new_method_call(ASD_DBUS_BUSNAME,ASD_DBUS_STA_OBJPATH,\
						ASD_DBUS_STA_INTERFACE,ASD_DBUS_STA_METHOD_STA_TRAFFIC_LIMIT_CANCEL);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							DBUS_TYPE_UINT32,&RadioID,
							DBUS_TYPE_BYTE,&wlan_id,
							DBUS_TYPE_BYTE,&mac1[0],
							DBUS_TYPE_BYTE,&mac1[1],
							DBUS_TYPE_BYTE,&mac1[2],
							DBUS_TYPE_BYTE,&mac1[3],
							DBUS_TYPE_BYTE,&mac1[4],
							DBUS_TYPE_BYTE,&mac1[5],
							DBUS_TYPE_INVALID);

	
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&cancel_flag);
	
	if(ret==ASD_WLAN_NOT_EXIST)
		retu=-2;
	else if(ret == ASD_STA_NOT_EXIST)
		retu=-3;
	else if(ret != ASD_DBUS_SUCCESS)
		retu=-8;

	dbus_message_unref(reply);


	if(ret == ASD_DBUS_SUCCESS)
	{		
	/*	int index;
		char BUSNAME[PATH_LEN];
		char OBJPATH[PATH_LEN];
		char INTERFACE[PATH_LEN];
		if(vty->node == RADIO_NODE){
			index = 0;			
			RadioID = (int)vty->index;
		}else if(vty->node == HANSI_RADIO_NODE){
			index = vty->index; 		
			RadioID = (int)vty->index_sub;
		}*/
		memset(BUSNAME,0,PATH_LEN);
		memset(OBJPATH,0,PATH_LEN);
		memset(INTERFACE,0,PATH_LEN);

		ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
		ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
		ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
		query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_TRAFFIC_LIMIT_CANCEL_STA_VALUE);

		/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_TRAFFIC_LIMIT_CANCEL_STA_VALUE);*/
		dbus_error_init(&err);

		dbus_message_append_args(query,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&wlan_id,
								DBUS_TYPE_BYTE,&cancel_flag,
								DBUS_TYPE_BYTE,&mac1[0],
								DBUS_TYPE_BYTE,&mac1[1],
								DBUS_TYPE_BYTE,&mac1[2],
								DBUS_TYPE_BYTE,&mac1[3],
								DBUS_TYPE_BYTE,&mac1[4],
								DBUS_TYPE_BYTE,&mac1[5],
								DBUS_TYPE_INVALID);

		
		reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
		
		dbus_message_unref(query);
		
		if (NULL == reply) {
			if (dbus_error_is_set(&err)) {
				dbus_error_free(&err);
			}
			return SNMPD_CONNECTION_ERROR;
		}
		dbus_message_iter_init(reply,&iter);
		dbus_message_iter_get_basic(&iter,&ret);

		if(ret==WLAN_ID_NOT_EXIST)
			retu=-4;
		else if(ret == WTP_ID_NOT_EXIST)
			retu=-5;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu=-6;
		else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
			retu=-7;
		else if(ret == WID_DBUS_SUCCESS)
			retu=1;
		else
			retu=-8;

		dbus_message_unref(reply);
	}

	return retu; 
#endif	
}

#if _GROUP_POLICY
void Free_radio_apply_wlan_clean_vlan_cmd_func_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-12时，调用Free_radio_apply_wlan_clean_vlan_cmd_func_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int radio_apply_wlan_clean_vlan_cmd_func_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *WlanID,struct RadioList **RadioList_Head)
									  /*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
									  /*返回-2表示wlan id should be 1 to WLAN_NUM-1，返回-3表示wtp id does not exist*/
									  /*返回-4表示radio id does not exist，返回-5表示binding wlan does not exist*/
									  /*返回-6表示radio is not binding this wlan，返回-7表示bss is enable, you should disable it first*/
									  /*返回-8表示error，返回-9表示Radio ID非法*/
									  /*返回-10表示illegal input:Input exceeds the maximum value of the parameter type*/
									  /*返回-11表示Group ID非法，返回-12表示partial failure*/
									  /*返回-13表示group id does not exist*/
{
	if(NULL == connection)
		return 0;

	if(NULL == WlanID)
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned char wlan_id = 0;
	int retu = 0;

	ret = parse_char_ID((char*)WlanID, &wlan_id);
	if(ret != WID_DBUS_SUCCESS){
        if(ret == WID_ILLEGAL_INPUT){
			retu = -10;
        }
		else{
			retu = -1;
		}
		return retu;
	}	
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		return -2;
	}
	

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in radio_apply_wlan_clean_vlan_cmd_func_group is %d\n",id);
			return -9;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in radio_apply_wlan_clean_vlan_cmd_func_group is %d\n",id);
			return -11;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								int *,
								unsigned int *
							);
	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"radio_apply_wlan_clean_vlan_cmd_radio_apply_wlan_ID");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 wlan_id,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -3;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -4;
		else if(ret == WLAN_ID_NOT_EXIST)
			retu = -5;
		else if(ret == WTP_WLAN_BINDING_NOT_MATCH)
			retu = -6;
		else if(ret == BSS_BE_ENABLE)
			retu = -7;
		else
			retu = -8;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -12;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -13;
	}	
	return retu;
}
#endif

int radio_apply_wlan_clean_vlan_cmd_func(dbus_parameter parameter, DBusConnection *connection,int Rid,char *WlanID)
																					  /*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
																					  /*返回-2表示wlan id should be 1 to WLAN_NUM-1，返回-3表示wtp id does not exist*/
																					  /*返回-4表示radio id does not exist，返回-5表示binding wlan does not exist*/
																					  /*返回-6表示radio is not binding this wlan，返回-7表示bss is enable, you should disable it first*/
																					  /*返回-8表示error，返回-9表示Radio ID非法*/
																					  /*返回-10表示illegal input:Input exceeds the maximum value of the parameter type*/
																					  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
		return 0;
	
	if(NULL == WlanID)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = radio_apply_wlan_clean_vlan_cmd_func_group(parameter,connection,0,Rid,WlanID,&RadioList_Head);
	if(retu == -12)
	{
		Free_radio_apply_wlan_clean_vlan_cmd_func_group(RadioList_Head);
	}
	return retu;
#else
	int ret,retu;
	unsigned int radio_id;
	unsigned char wlan_id;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	//radio_id = Rid;	
	
	ret = parse_char_ID((char*)WlanID, &wlan_id);
	if(ret != WID_DBUS_SUCCESS){
        if(ret == WID_ILLEGAL_INPUT){
			retu = -10;
        }
		else{
			retu = -1;
		}
		return retu;
	}	
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		return -2;
	}
	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radio_id = Rid;	
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in radio_apply_wlan_clean_vlan_cmd_func is %d\n",radio_id);
		return -9;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_RADIO_APPLY_WLANID_CLEAN_VLANID);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_RADIO_APPLY_WLANID_CLEAN_VLANID);*/

	dbus_error_init(&err);

	dbus_message_append_args(query,					
						DBUS_TYPE_UINT32,&radio_id,
						DBUS_TYPE_BYTE,&wlan_id,	
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	dbus_message_unref(query);
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu=1;
	else if(ret == WTP_ID_NOT_EXIST)
		retu=-3;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu=-4;
	else if(ret == WLAN_ID_NOT_EXIST)
		retu=-5;
	else if(ret == WTP_WLAN_BINDING_NOT_MATCH)
		retu=-6;
	else if(ret == BSS_BE_ENABLE)
		retu=-7;
	else
		retu=-8;

	dbus_message_unref(reply);

	return retu;	
#endif
}

#if _GROUP_POLICY
void Free_radio_bss_traffic_limit_send_value_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-10时，调用Free_radio_bss_traffic_limit_send_value_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int radio_bss_traffic_limit_send_value_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *WlanID,char *VALUE,struct RadioList **RadioList_Head)
															/*返回0表示失败，返回1表示成功*/
															/*返回-1表示wlan id should be 1 to WLAN_NUM-1*/
															/*返回-2表示input parameter argv[1] error*/
															/*返回-3表示wtp isn't existed，返回-4表示radio isn't existed*/
															/*返回-5表示radio doesn't bind wlan argv[0]*/
															/*返回-6表示wlan isn't existed，返回-7表示error*/
															/*返回-8表示Radio ID非法，返回-9表示Group ID非法*/
															/*返回-10表示partial failure，返回-11表示group id does not exist*/
															/*返回-12表示input value should be 1 to 884736*/
{ 	
	if(NULL == connection)
		return 0;

	if((NULL == WlanID)||(NULL == VALUE))
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned char wlan_id = 0;
	unsigned int value = 0;  
	int retu = 0;

	wlan_id = atoi(WlanID);
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		return -1;
	}

	ret = parse_int_ID((char *)VALUE,&value);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
		return -2;
	} 	
	if((value > 884736)||(value < 1))
	{
		return -12;
	}	

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in radio_bss_traffic_limit_send_value_cmd_group is %d\n",id);
			return -8;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in radio_bss_traffic_limit_send_value_cmd_group is %d\n",id);
			return -9;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								unsigned int ,
								int *,
								unsigned int *
							);
	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"radio_bss_taffic_limit_send_value_cmd_wlan_ID_traffic_limit_send_value");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 wlan_id,
								 value,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == WID_DBUS_SUCCESS)		
			retu = 1;
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -3;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -4;
		else if(ret==RADIO_NO_BINDING_WLAN)
			retu = -5;
		else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
			retu = -5;
		else if(ret==WLAN_ID_NOT_EXIST)
			retu = -6;
		else
			retu = -7;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -10;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -11;
	}	
	return retu; 
}
#endif

int radio_bss_traffic_limit_send_value_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *WlanID,char *VALUE)
																								  /*返回0表示失败，返回1表示成功*/
																								  /*返回-1表示wlan id should be 1 to WLAN_NUM-1*/
																								  /*返回-2表示input parameter argv[1] error*/
																								  /*返回-3表示wtp isn't existed，返回-4表示radio isn't existed*/
																								  /*返回-5表示radio doesn't bind wlan argv[0]*/
																								  /*返回-6表示wlan isn't existed，返回-7表示error*/
																								  /*返回-8表示Radio ID非法*/
																								  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
																								  /*返回-12表示input value should be 1 to 884736*/
{
	if(NULL == connection)
		return 0;
	
	if((NULL == WlanID)||(NULL == VALUE))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = radio_bss_traffic_limit_send_value_cmd_group(parameter,connection,0,RID,WlanID,VALUE,&RadioList_Head);
	if(retu == -10)
	{
		Free_radio_bss_traffic_limit_send_value_cmd_group(RadioList_Head);
	}
	return retu;
#else
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int ret;
	unsigned int RadioID;
	unsigned char wlan_id = 0;
	unsigned int value = 0;   
	int retu;
	
	//RadioID = RID;
	wlan_id = atoi(WlanID);
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		return -1;
	}

	ret = parse_int_ID((char *)VALUE,&value);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
		return -2;
	}	
	if((value > 884736)||(value < 1))
	{
		return -12;
	}	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	RadioID = RID;
	if(RadioID > G_RADIO_NUM || RadioID == 0){
		syslog(LOG_DEBUG,"radio id in radio_bss_traffic_limit_send_value_cmd is %d\n",RadioID);
		return -8;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_TRAFFIC_LIMIT_SEND_VALUE);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_TRAFFIC_LIMIT_SEND_VALUE);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							DBUS_TYPE_UINT32,&RadioID,
							DBUS_TYPE_BYTE,&wlan_id,
							DBUS_TYPE_UINT32,&value,
							DBUS_TYPE_INVALID);

	
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	
	if(ret == WID_DBUS_SUCCESS)	
		retu=1;
	else if(ret == WTP_ID_NOT_EXIST)
		retu=-3;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu=-4;
	else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
		retu=-5;
	else if(ret==WLAN_ID_NOT_EXIST)
		retu=-6;
	else
		retu=-7;

	dbus_message_unref(reply);

	return retu; 
#endif	
}

#if _GROUP_POLICY
void Free_radio_bss_traffic_limit_average_send_value_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-11时，调用Free_radio_bss_traffic_limit_average_send_value_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int radio_bss_traffic_limit_average_send_value_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *WlanID,char *VALUE,struct RadioList **RadioList_Head)
													/*返回0表示失败，返回1表示成功*/
												    /*返回-1表示wlan id should be 1 to WLAN_NUM-1*/
												    /*返回-2表示input parameter argv[1] error*/
												    /*返回-3表示station traffic limit value is more than bss traffic limit value*/
												    /*返回-4表示wtp isn't existed，返回-5表示radio isn't existed*/
												    /*返回-6表示radio doesn't bind wlan argv[0]*/
												    /*返回-7表示wlan isn't existed，返回-8表示error*/
													/*返回-9表示Radio ID非法，返回-10表示Group ID非法*/
													/*返回-11表示partial failure，返回-12表示group id does not exist*/
													/*返回-13表示input value should be 1 to 884736*/
{ 
	if(NULL == connection)
		return 0;

	if((NULL == WlanID)||(NULL == VALUE))
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned char wlan_id = 0;
	unsigned int value = 0;  
	int retu = 0;
	
	wlan_id = atoi(WlanID);
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		return -1;
	}

	ret = parse_int_ID((char *)VALUE,&value);	
	if (ret != WID_DBUS_SUCCESS)
	{	
		return -2;
	} 
	if((value > 884736)||(value < 1))
	{
		return -13;
	}	
	
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in radio_bss_traffic_limit_average_send_value_cmd_group is %d\n",id);
			return -9;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in radio_bss_traffic_limit_average_send_value_cmd_group is %d\n",id);
			return -10;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								unsigned int ,
								int *,
								unsigned int *
							);
	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"radio_bss_taffic_limit_average_send_value_cmd_wlan_configure");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 wlan_id,
								 value,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == IF_POLICY_CONFLICT)
			retu = -3;
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -4;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -5;
		else if(ret==RADIO_NO_BINDING_WLAN)
			retu = -6;
		else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
			retu = -6;
		else if(ret == WID_DBUS_SUCCESS)
			retu = 1;
		else if(ret==WLAN_ID_NOT_EXIST)
			retu = -7;
		else
			retu = -8;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -11;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -12;
	}	
	return retu; 
}
#endif

int radio_bss_traffic_limit_average_send_value_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *WlanID,char *VALUE)
																											/*返回0表示失败，返回1表示成功*/
																										    /*返回-1表示wlan id should be 1 to WLAN_NUM-1*/
																										    /*返回-2表示input parameter argv[1] error*/
																										    /*返回-3表示station traffic limit value is more than bss traffic limit value*/
																										    /*返回-4表示wtp isn't existed，返回-5表示radio isn't existed*/
																										    /*返回-6表示radio doesn't bind wlan argv[0]*/
																										    /*返回-7表示wlan isn't existed，返回-8表示error*/
																											/*返回-9表示Radio ID非法*/
																											/*返回SNMPD_CONNECTION_ERROR表示connection error*/
																											/*返回-13表示input value should be 1 to 884736*/
{
	if(NULL == connection)
		return 0;
	
	if((NULL == WlanID)||(NULL == VALUE))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = radio_bss_traffic_limit_average_send_value_cmd_group(parameter,connection,0,RID,WlanID,VALUE,&RadioList_Head);
	if(retu == -11)
	{
		Free_radio_bss_traffic_limit_average_send_value_cmd_group(RadioList_Head);
	}
	return retu;
#else
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int ret;
	unsigned int RadioID;
	unsigned char wlan_id = 0;
	unsigned int value = 0;   
	int retu;
	
	//RadioID = RID;
	wlan_id = atoi(WlanID);
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		return -1;
	}

	ret = parse_int_ID((char *)VALUE,&value);	
	if (ret != WID_DBUS_SUCCESS)
	{	
		return -2;
	} 	
	if((value > 884736)||(value < 1))
	{
		return -13;
	}	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	RadioID = RID;
	if(RadioID > G_RADIO_NUM || RadioID == 0){
		syslog(LOG_DEBUG,"radio id in radio_bss_traffic_limit_average_send_value_cmd is %d\n",RadioID);
		return -9;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_TRAFFIC_LIMIT_AVERAGE_SEND_VALUE);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_TRAFFIC_LIMIT_AVERAGE_SEND_VALUE);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							DBUS_TYPE_UINT32,&RadioID,
							DBUS_TYPE_BYTE,&wlan_id,
							DBUS_TYPE_UINT32,&value,
							DBUS_TYPE_INVALID);

	
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	
	if(ret == IF_POLICY_CONFLICT)
		retu=-3;
	else if(ret == WTP_ID_NOT_EXIST)
		retu=-4;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu=-5;
	else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
		retu=-6;
	else if(ret == WID_DBUS_SUCCESS)
		retu=1;
	else if(ret==WLAN_ID_NOT_EXIST)
		retu=-7;
	else
		retu=-8;

	dbus_message_unref(reply);

	return retu; 
#endif	
}

#if _GROUP_POLICY
void Free_radio_bss_traffic_limit_sta_send_value_cmd_group(struct RadioList *RadioList_Head)
{
	if(RadioList_Head != NULL)
	{
		free(RadioList_Head);
		RadioList_Head =NULL;
	}
}

/*返回-9时，调用Free_radio_bss_traffic_limit_sta_send_value_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int radio_bss_traffic_limit_sta_send_value_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *WlanID,char *MAC,char *VALUE,struct RadioList **RadioList_Head)
																	/*返回0表示失败，返回1表示成功*/
																    /*返回-1表示wlan id should be 1 to WLAN_NUM-1*/
																    /*返回-2表示input parameter argv[2] error*/
																    /*返回-3表示wlan doesn't work*/
																    /*返回-4表示can't find sta under wlan WlanID*/
																    /*返回-5表示station traffic limit value is more than bss traffic limit value*/
															        /*返回-6表示error，返回-7表示Radio ID非法*/
																	/*返回-8表示Group ID非法，返回-9表示partial failure*/
																	/*返回-10表示group id does not exist*/
																	/*返回-11表示input value should be 1 to 884736*/
{	
	if(NULL == connection)
		return 0;

	if((NULL == WlanID)||(NULL == MAC)||(NULL == VALUE))
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int ret1 = 0;
	int ret2 = 0;
	int ret3 = 0;
	int count = 0;
	int failnum = 0;
	unsigned int id = 0;
	unsigned int TYPE = 0;
	unsigned char wlan_id = 0;
	unsigned char	type = 2;
	unsigned int	value = 0;
	unsigned int	mac[MAC_LEN]={0};
	unsigned char	mac1[MAC_LEN]={0};
	int retu = 0;
	
	wlan_id = atoi(WlanID);
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		return -1;
	}

	memset(mac,0,MAC_LEN);
	sscanf(MAC,"%X:%X:%X:%X:%X:%X",&mac[0],&mac[1],&mac[2],&mac[3],&mac[4],&mac[5]);
	mac1[0] = (unsigned char)mac[0];
	mac1[1] = (unsigned char)mac[1];	
	mac1[2] = (unsigned char)mac[2];	
	mac1[3] = (unsigned char)mac[3];	
	mac1[4] = (unsigned char)mac[4];	
	mac1[5] = (unsigned char)mac[5];

	ret = parse_int_ID((char *)VALUE,&value);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
		return -2;
	}	
	if((value > 884736)||(value < 1))
	{
		return -11;
	}	

	id = group_id;
	TYPE = group_type;
	if(TYPE == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in radio_bss_traffic_limit_sta_send_value_cmd_group is %d\n",id);
			return -7;
		}
	}
	else if(TYPE == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in radio_bss_traffic_limit_sta_send_value_cmd_group is %d\n",id);
			return -8;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char [],
								unsigned char ,
								unsigned char ,
								unsigned int ,
								int *,
								unsigned int *,
								unsigned int *,
								unsigned int *,
								unsigned int *,
								int *
							);
	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"radio_bss_taffic_limit_sta_send_value_cmd_wlan_traffic_limit_station_send_value");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 TYPE,
								 id,
								 mac1,
								 wlan_id,
								 type,
								 value,
								 &count,
								 &ret,
								 &ret1,
								 &ret2,
								 &ret3,
								 &failnum
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(TYPE==0)
	{
		if(ret == 0)
		{	
			if(ret2 == 0)
			{
				if(ret3 == 0)
					retu = 1;
				else if (ret3 == ASD_DBUS_ERROR)
					retu = 0;
				else
					retu = -6;
			}
			else if (ret2 == ASD_DBUS_ERROR)
				retu = 0;
			else
				retu = -6;
		}
		else if(ret==ASD_WLAN_NOT_EXIST)
			retu = -3;
		else if(ret == ASD_STA_NOT_EXIST)
			retu = -4;
		else if(ret == ASD_DBUS_ERROR)
			retu = -5;
		else
			retu = -6;
	}
	else if(TYPE==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(TYPE == 1)&&(*RadioList_Head!=NULL)&&(failnum != 0))
			{
				retu = -9;
				/*vty_out(vty,"radio ");					
				for(i=0; i<failnum; i++)
				{

					vty_out(vty,"%d ",RadioList_Head[i].RadioId);
					//vty_out(vty,"%d",RadioList_Head[i].FailReason);
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -10;
	}	
	return retu; 
}
#endif

int radio_bss_traffic_limit_sta_send_value_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *WlanID,char *MAC,char *VALUE)
																												/*返回0表示失败，返回1表示成功*/
																											    /*返回-1表示wlan id should be 1 to WLAN_NUM-1*/
																											    /*返回-2表示input parameter argv[2] error*/
																											    /*返回-3表示wlan doesn't work*/
																											    /*返回-4表示can't find sta under wlan WlanID*/
																											    /*返回-5表示station traffic limit value is more than bss traffic limit value*/
																										        /*返回-6表示error，返回-7表示Radio ID非法*/
																												/*返回-11表示input value should be 1 to 884736*/
{
	if(NULL == connection)
		return 0;
	
	if((NULL == WlanID)||(NULL == MAC)||(NULL == VALUE))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = radio_bss_traffic_limit_sta_send_value_cmd_group(parameter,connection,0,RID,WlanID,MAC,VALUE,&RadioList_Head);
	if(retu == -9)
	{
		Free_radio_bss_traffic_limit_sta_send_value_cmd_group(RadioList_Head);
	}
	return retu;
#else
	unsigned int	value = 0;
	unsigned int	mac[MAC_LEN]={0};
	unsigned char	mac1[MAC_LEN]={0};
	unsigned int	ret=0;
	unsigned int 	RadioID = 0;
	unsigned char 	wlan_id = 0;
	unsigned char	type = 2;
	int retu;
	
	wlan_id = atoi(WlanID);
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		return -1;
	}

	memset(mac,0,MAC_LEN);
	sscanf(MAC,"%X:%X:%X:%X:%X:%X",&mac[0],&mac[1],&mac[2],&mac[3],&mac[4],&mac[5]);
	mac1[0] = (unsigned char)mac[0];
	mac1[1] = (unsigned char)mac[1];	
	mac1[2] = (unsigned char)mac[2];	
	mac1[3] = (unsigned char)mac[3];	
	mac1[4] = (unsigned char)mac[4];	
	mac1[5] = (unsigned char)mac[5];

	ret = parse_int_ID((char *)VALUE,&value);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
		return -2;
	} 
	if((value > 884736)||(value < 1))
	{
		return -11;
	}	
			
	RadioID = RID;
	if(RadioID > G_RADIO_NUM || RadioID == 0){
		syslog(LOG_DEBUG,"radio id in radio_bss_traffic_limit_sta_send_value_cmd is %d\n",RadioID);
		return -7;
    }

	void (*dcli_init_func)(
					DBusConnection *,
					int , 
					unsigned char *, 
					unsigned char , 
					unsigned int , 
					unsigned char , 
					unsigned int , 
					int ,
					unsigned int *
				);

	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"asd_set_sta_info");
		if(NULL != dcli_init_func)
		{
			(*dcli_init_func)
				  (
					 connection,
					 parameter.instance_id,
					 mac1,
					 wlan_id,
					 RadioID,
					 type,
					 value,
					 parameter.local_id,
					 &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}


	if(ret == 0)
	{
		void (*dcli_init_func)(
						DBusConnection *,
						int , 
						unsigned char *, 
						unsigned char , 
						unsigned int , 
						unsigned char , 
						unsigned int , 
						int ,
						unsigned int *
					);

		if(NULL != ccgi_dl_handle)
		{
			dcli_init_func = dlsym(ccgi_dl_handle,"wid_set_sta_info");
			if(NULL != dcli_init_func)
			{
				(*dcli_init_func)
					  (
						 connection,
						 parameter.instance_id,
						 mac1,
						 wlan_id,
						 RadioID,
						 type,
						 value,
						 parameter.local_id,
						 &ret
					  );
			}
			else
			{
				return 0;
			}
		}
		else
		{
			return 0;
		}

		if(ret == 0)
		{
			void (*dcli_init_func)(
							DBusConnection *,
							int , 
							unsigned char *, 
							unsigned char ,
							unsigned int , 
							unsigned char , 
							unsigned int , 
							int ,
							unsigned int *
						);

			if(NULL != ccgi_dl_handle)
			{
				dcli_init_func = dlsym(ccgi_dl_handle,"set_sta_static_info");
				if(NULL != dcli_init_func)
				{
					(*dcli_init_func)
						  (
							 connection,
							 parameter.instance_id,
							 mac1,
							 wlan_id,
							 RadioID,
							 type,
							 value,
							 parameter.local_id,
							 &ret
						  );
				}
				else
				{
					return 0;
				}
			}
			else
			{
				return 0;
			}

			if(ret == 0)
				retu = 1;
			else if (ret == ASD_DBUS_ERROR)
				retu = 0;
			else
				retu = -6;
		}
		else if (ret == ASD_DBUS_ERROR)
			retu = 0;
		else
			retu = -6;
	}
	else if(ret==ASD_WLAN_NOT_EXIST)
		retu = -3;
	else if(ret == ASD_STA_NOT_EXIST)
		retu = -4;
	else if(ret == ASD_DBUS_ERROR)
		retu = -5;
	else
		retu = -6;

	return retu; 
#endif	
}

#if _GROUP_POLICY
void Free_radio_bss_traffic_limit_cancel_sta_send_value_cmd_group(struct RadioList *RadioList_Head)
{
	if(RadioList_Head != NULL)
	{
		free(RadioList_Head);
		RadioList_Head =NULL;
	}
}

/*返回-11时，调用Free_radio_bss_traffic_limit_cancel_sta_send_value_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int radio_bss_traffic_limit_cancel_sta_send_value_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *WlanID,char *MAC,struct RadioList **RadioList_Head)
																	 /*返回0表示失败，返回1表示成功*/
																     /*返回-1表示wlan id should be 1 to WLAN_NUM-1*/
																     /*返回-2表示wlan doesn't work*/
																     /*返回-3表示can't find sta under wlan WlanID*/
																     /*返回-4表示wtp isn't existed，返回-5表示radio isn't existed*/
																     /*返回-6表示radio doesn't bind wlan argv[0]*/
																     /*返回-7表示wlan isn't existed，返回-8表示error*/
																	 /*返回-9表示Radio ID非法，返回-10表示Group ID非法*/
																	 /*返回-11表示partial failure，返回-12表示group id does not exist*/
{
	if(NULL == connection)
		return 0;

	if((NULL == WlanID)||(NULL == MAC))
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int ret_asd = 0;
	int ret_wid = 0;
	int count = 0;
	int failnum = 0;
	unsigned int id = 0;
	unsigned int type = 0;
  	unsigned char wlan_id = 0;
	unsigned char cancel_flag = 0;
	unsigned char mac1[MAC_LEN];
	unsigned int mac[MAC_LEN];
	int retu = 0;

	wlan_id = atoi(WlanID);
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		return -1;
	}

	memset(mac,0,MAC_LEN);
	sscanf(MAC,"%X:%X:%X:%X:%X:%X",&mac[0],&mac[1],&mac[2],&mac[3],&mac[4],&mac[5]);
	mac1[0] = (unsigned char)mac[0];
	mac1[1] = (unsigned char)mac[1];	
	mac1[2] = (unsigned char)mac[2];	
	mac1[3] = (unsigned char)mac[3];	
	mac1[4] = (unsigned char)mac[4];	
	mac1[5] = (unsigned char)mac[5];

	
	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in radio_bss_traffic_limit_cancel_sta_send_value_cmd_group is %d\n",id);
			return -9;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in radio_bss_traffic_limit_cancel_sta_send_value_cmd_group is %d\n",id);
			return -10;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								unsigned char *, 
								int *,
								unsigned int *,
								unsigned int *,
								unsigned int *,
								int *
							);
	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"radio_bss_taffic_limit_cancel_sta_send_value_cmd_wlan_configure");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 wlan_id,
								 mac1,
								 &count,
								 &ret,
								 &ret_asd,
								 &ret_wid,
								 &failnum
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}	

	if(type==0)
	{
		if(ret == WID_DBUS_SUCCESS)
		{
			if(ret_asd == ASD_WLAN_NOT_EXIST)
				retu = -2;
			else if(ret_asd == ASD_STA_NOT_EXIST)
				retu = -3;
			else if(ret_asd != ASD_DBUS_SUCCESS)
				retu = -8;
			if(ret_asd == ASD_DBUS_SUCCESS)
			{
				if(ret_wid == WID_DBUS_SUCCESS)
					retu = 1;
				else if(ret_wid == WTP_ID_NOT_EXIST)
					retu = -4;
				else if(ret_wid == RADIO_ID_NOT_EXIST)
					retu = -5;
				else if(ret_wid==RADIO_NO_BINDING_WLAN)
					retu = -6;
				else if(ret_wid==WLAN_ID_NOT_EXIST)
					retu = -7;
				else
					retu = -8;
			}
		}
		else
			retu = -5;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((failnum != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -11;
				/*vty_out(vty,"radio ");					
				for(i=0; i<failnum; i++)
				{
					vty_out(vty,"%d ",RadioList_Head[i].RadioId);	
					vty_out(vty,"%d ",RadioList_Head[i].FailReason);		
				}
				vty_out(vty," failed.\n");*/
				//dcli_free_RadioList(RadioList_Head);
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -12;
	}	
	return retu; 
}
#endif

int radio_bss_traffic_limit_cancel_sta_send_value_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *WlanID,char *MAC)
																											 /*返回0表示失败，返回1表示成功*/
																										     /*返回-1表示wlan id should be 1 to WLAN_NUM-1*/
																										     /*返回-2表示wlan doesn't work*/
																										     /*返回-3表示can't find sta under wlan WlanID*/
																										     /*返回-4表示wtp isn't existed，返回-5表示radio isn't existed*/
																										     /*返回-6表示radio doesn't bind wlan argv[0]*/
																										     /*返回-7表示wlan isn't existed，返回-8表示error*/
																											 /*返回-9表示Radio ID非法*/
																											 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
		return 0;
	
	if((NULL == WlanID)||(NULL == MAC))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = radio_bss_traffic_limit_cancel_sta_send_value_cmd_group(parameter,connection,0,RID,WlanID,MAC,&RadioList_Head);
	if(retu == -11)
	{
		Free_radio_bss_traffic_limit_cancel_sta_send_value_cmd_group(RadioList_Head);
	}
	return retu;
#else
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int ret;
	unsigned int RadioID;
	unsigned char wlan_id = 0;
	unsigned char cancel_flag = 0;
	unsigned char mac1[MAC_LEN];
	unsigned int mac[MAC_LEN];
	int retu=0;
	
	//RadioID = RID;
	wlan_id = atoi(WlanID);
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		return -1;
	}

	memset(mac,0,MAC_LEN);
	sscanf(MAC,"%X:%X:%X:%X:%X:%X",&mac[0],&mac[1],&mac[2],&mac[3],&mac[4],&mac[5]);
	mac1[0] = (unsigned char)mac[0];
	mac1[1] = (unsigned char)mac[1];	
	mac1[2] = (unsigned char)mac[2];	
	mac1[3] = (unsigned char)mac[3];	
	mac1[4] = (unsigned char)mac[4];	
	mac1[5] = (unsigned char)mac[5];

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	RadioID = RID;
	if(RadioID > G_RADIO_NUM || RadioID == 0){
		syslog(LOG_DEBUG,"radio id in radio_bss_traffic_limit_cancel_sta_send_value_cmd is %d\n",RadioID);
		return -9;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,ASD_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,ASD_DBUS_STA_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,ASD_DBUS_STA_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,ASD_DBUS_STA_METHOD_STA_SEND_TRAFFIC_LIMIT_CANCEL);
	
	/*query = dbus_message_new_method_call(ASD_DBUS_BUSNAME,ASD_DBUS_STA_OBJPATH,\
						ASD_DBUS_STA_INTERFACE,ASD_DBUS_STA_METHOD_STA_SEND_TRAFFIC_LIMIT_CANCEL);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							DBUS_TYPE_UINT32,&RadioID,
							DBUS_TYPE_BYTE,&wlan_id,
							DBUS_TYPE_BYTE,&mac1[0],
							DBUS_TYPE_BYTE,&mac1[1],
							DBUS_TYPE_BYTE,&mac1[2],
							DBUS_TYPE_BYTE,&mac1[3],
							DBUS_TYPE_BYTE,&mac1[4],
							DBUS_TYPE_BYTE,&mac1[5],
							DBUS_TYPE_INVALID);

	
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&cancel_flag);
	
	if(ret==ASD_WLAN_NOT_EXIST)
		retu=-2;
	else if(ret == ASD_STA_NOT_EXIST)
		retu=-3;
	else if(ret != ASD_DBUS_SUCCESS)
		retu=-8;

	dbus_message_unref(reply);


	if(ret == ASD_DBUS_SUCCESS)
	{	
	/*	int index;
		char BUSNAME[PATH_LEN];
		char OBJPATH[PATH_LEN];
		char INTERFACE[PATH_LEN];
		if(vty->node == RADIO_NODE){
			index = 0;			
			RadioID = (int)vty->index;
		}else if(vty->node == HANSI_RADIO_NODE){
			index = vty->index; 		
			RadioID = (int)vty->index_sub;
		}*/
		memset(BUSNAME,0,PATH_LEN);
		memset(OBJPATH,0,PATH_LEN);
		memset(INTERFACE,0,PATH_LEN);

		ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
		ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
		ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
		query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_TRAFFIC_LIMIT_CANCEL_STA_SEND_VALUE);

		/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_TRAFFIC_LIMIT_CANCEL_STA_SEND_VALUE);*/
		dbus_error_init(&err);

		dbus_message_append_args(query,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&wlan_id,
								DBUS_TYPE_BYTE,&cancel_flag,
								DBUS_TYPE_BYTE,&mac1[0],
								DBUS_TYPE_BYTE,&mac1[1],
								DBUS_TYPE_BYTE,&mac1[2],
								DBUS_TYPE_BYTE,&mac1[3],
								DBUS_TYPE_BYTE,&mac1[4],
								DBUS_TYPE_BYTE,&mac1[5],
								DBUS_TYPE_INVALID);

		
		reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
		
		dbus_message_unref(query);
		
		if (NULL == reply) {
			if (dbus_error_is_set(&err)) {
				dbus_error_free(&err);
			}
			return SNMPD_CONNECTION_ERROR;
		}
		dbus_message_iter_init(reply,&iter);
		dbus_message_iter_get_basic(&iter,&ret);

		if(ret == WID_DBUS_SUCCESS)
			retu=1;
		else if(ret == WTP_ID_NOT_EXIST)
			retu=-4;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu=-5;
		else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
			retu=-6;
		else if(ret==WLAN_ID_NOT_EXIST)
			retu=-7;
		else
			retu=-8;

		dbus_message_unref(reply);
	}

	return retu; 
#endif	
}

void Free_set_sta_mac_vlanid_cmd(struct dcli_sta_info *sta)
{
	void (*dcli_init_free_func)(struct dcli_sta_info *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_sta");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(sta);
		}
	}
}


/*未使用*/
/*当flag为1时，调用Free_set_sta_mac_vlanid_cmd()释放空间*/
int set_sta_mac_vlanid_cmd(dbus_parameter parameter, DBusConnection *connection,unsigned int *flag,char *sta_mac,char *vlanID)
																							  /*返回0表示失败，返回1表示，返回 -1表示vlan id should be 0 to 4095*/
																						      /*返回-2表示input parameter argv[2] error，返回-3表示set info error*/
																							  /*返回-4表示wid set error，返回-5表示can't find sta*/
																							  /*返回-6表示check sta set invalid value，返回-7表示check sta error*/
{	
	if(NULL == connection)
		return 0;

	if((NULL == sta_mac)||(NULL == vlanID))
		return 0;

	struct dcli_sta_info *sta = NULL;
	unsigned int	value = 0;
	unsigned int	mac[MAC_LEN]={0};
	unsigned char	mac1[MAC_LEN]={0};
	unsigned char	type = 0;
	unsigned int	ret=0;
	int retu;

	*flag = 0;
	
	sscanf(sta_mac,"%X:%X:%X:%X:%X:%X",&mac[0],&mac[1],&mac[2],&mac[3],&mac[4],&mac[5]);
	mac1[0] = (unsigned char)mac[0];
	mac1[1] = (unsigned char)mac[1];	
	mac1[2] = (unsigned char)mac[2];	
	mac1[3] = (unsigned char)mac[3];	
	mac1[4] = (unsigned char)mac[4];	
	mac1[5] = (unsigned char)mac[5];		
	
	int(*parse2_int_ID_func)(char* ,unsigned int* );
	if(NULL != ccgi_dl_handle)
	{
		parse2_int_ID_func = dlsym(ccgi_dl_handle,"parse2_int_ID");
		if(NULL != parse2_int_ID_func)
		{
			ret  = (*parse2_int_ID_func)((char*)vlanID, &value);
			if(value > 4095 || value < 0){
				return -1;
			}
			if (ret != ASD_DBUS_SUCCESS) {	
				return -2;
			} 	
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	struct dcli_sta_info*(*dcli_init_func)(
											DBusConnection *,
											int , 
											unsigned char *, 
											unsigned char , 
											unsigned int , 
											int,
											unsigned int *
										  );


	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"check_sta_by_mac");
		if(NULL != dcli_init_func)
		{
			sta =(*dcli_init_func)
				  (
					 connection,
					 parameter.instance_id,
					 mac1,
					 type,
					 value,
					 parameter.local_id,
					 &ret
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if((ret == 0) && (sta != NULL))
	{
		void(*dcli_init_func)(
								DBusConnection *,
								int , 
								unsigned char *, 
								unsigned char , 
								unsigned int , 
								unsigned char , 
								unsigned int , 
								int ,
								unsigned int *
							);

		if(NULL != ccgi_dl_handle)
		{
			dcli_init_func = dlsym(ccgi_dl_handle,"wid_set_sta_info");
			if(NULL != dcli_init_func)
			{
				(*dcli_init_func)
					  (
						 connection,
						 parameter.instance_id,
						 mac1,
						 sta->wlan_id,
						 sta->radio_g_id,
						 type,
						 value,
						 parameter.local_id,
						 &ret
					  );
			}
			else
			{
				return 0;
			}
		}
		else
		{
			return 0;
		}
		
		if(ret == 0)
		{
			void(*dcli_init_func)(
									DBusConnection *,
									int , 
									unsigned char *, 
									unsigned char , 
									unsigned int , 
									unsigned char , 
									unsigned int , 
									int ,
									unsigned int *
								);

			if(NULL != ccgi_dl_handle)
			{
				dcli_init_func = dlsym(ccgi_dl_handle,"set_sta_static_info");
				if(NULL != dcli_init_func)
				{
					(*dcli_init_func)
						  (
							 connection,
							 parameter.instance_id,
							 mac1,
							 sta->wlan_id,
							 sta->radio_g_id,
							 type,
							 value,
							 parameter.local_id,
							 &ret
						  );
				}
				else
				{
					return 0;
				}
			}
			else
			{
				return 0;
			}
			if(ret == 0)
			{
				retu = 1;
			}
			else if (ret == ASD_DBUS_ERROR)
				retu = 0;
			else
				retu = -3;
		}
		else
			retu = -4;
		*flag = 1;
	}
	else if (ret == ASD_STA_NOT_EXIST)
		retu = -5;
	else if (ret == ASD_DBUS_SET_ERROR)
		retu = -6;
	else if (ret == ASD_DBUS_ERROR)
		retu = 0;
	else
		retu = -7;

	return retu;
}	

#if _GROUP_POLICY
void Free_set_sta_dhcp_before_authorized_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-12时，调用Free_set_sta_dhcp_before_authorized_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*state为"enable"或"disable"*/
int set_sta_dhcp_before_authorized_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *wlan_id,char *state,struct RadioList **RadioList_Head)
									 /*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
									 /*返回-2表示wlan id should be 1 to WLAN_NUM-1，返回-3表示input patameter only with 'enable' or 'disable'*/
									 /*返回-4表示wlan not exist，返回-5表示wtp not binding wlan argv[0]*/
									 /*返回-6表示wtp id does not run，返回-7表示binding wlan error，返回-8表示error，返回-9表示Radio ID非法*/
									 /*返回-10表示illegal input:Input exceeds the maximum value of the parameter type*/
									 /*返回-11表示Group ID非法，返回-12表示partial failure，返回-13表示group id does not exist*/
{
	if(NULL == connection)
		return 0;

	if((NULL == wlan_id)||(NULL == state))
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int policy = 0;
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned char wlanid = 0;
	int retu = 0;

	ret = parse_char_ID((char*)wlan_id, &wlanid);
	if(ret != WID_DBUS_SUCCESS){
        if(ret == WID_ILLEGAL_INPUT){
			retu = -10;
        }
		else{
			retu = -1;
		}
		return retu;
	}	
	if(wlanid >= WLAN_NUM || wlanid == 0){
		return -2;
	}
	if (!strcmp(state,"enable"))
	{
		policy = 1; 
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0; 
	}
	else
	{
		return -3;
	}
	

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_sta_dhcp_before_authorized_cmd_group is %d\n",id);
			return -9;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_sta_dhcp_before_authorized_cmd_group is %d\n",id);
			return -11;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								int ,
								int *,
								unsigned int *
							);
	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_sta_dhcp_before_authorized_cmd_wlan_ID_sta_dhcp");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 wlanid,
								 policy,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}	

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if (ret == WLAN_ID_NOT_EXIST)
			retu = -4;
		else if (ret == WTP_IS_NOT_BINDING_WLAN_ID)
			retu = -5;
		else if (ret == WTP_NOT_IN_RUN_STATE)
			retu = -6;
		else if (ret == WTP_OVER_MAX_BSS_NUM)
			retu = -7;
		else
			retu = -8;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -12;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
					{
						if(Radio_Show_Node == NULL)
							Radio_Show_Node = RadioList_Head->RadioList_list;
						else 
							Radio_Show_Node = Radio_Show_Node->next;
						if(Radio_Show_Node == NULL)
							break;
						vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
					}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -13;
	}			
	return retu; 		
}
#endif

/*未使用*/
/*state为"enable"或"disable"*/
int set_sta_dhcp_before_authorized_cmd(dbus_parameter parameter, DBusConnection *connection,int Rid,char *wlan_id,char *state)
																								 /*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
																								 /*返回-2表示wlan id should be 1 to WLAN_NUM-1，返回-3表示input patameter only with 'enable' or 'disable'*/
																								 /*返回-4表示wlan not exist，返回-5表示wtp not binding wlan argv[0]*/
																								 /*返回-6表示wtp id does not run，返回-7表示binding wlan error，返回-8表示error，返回-9表示Radio ID非法*/
																								 /*返回-10表示illegal input:Input exceeds the maximum value of the parameter type*/
																								 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
		return 0;
	
	if((NULL == wlan_id)||(NULL == state))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_sta_dhcp_before_authorized_cmd_group(parameter,connection,0,Rid,wlan_id,state,&RadioList_Head);
	if(retu == -12)
	{
		Free_set_sta_dhcp_before_authorized_cmd_group(RadioList_Head);
	}
	return retu;
#else	
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;
	unsigned int radioID = 0;
	unsigned char wlanid = 0;
	int ret = WID_DBUS_SUCCESS;
	//radioID = (unsigned int)vty->index;
	int policy = 0;
	int retu;
	ret = parse_char_ID((char*)wlan_id, &wlanid);
	if(ret != WID_DBUS_SUCCESS){
		if(ret == WID_ILLEGAL_INPUT){
			retu = -10;
		}
		else{
			retu = -1;
		}
		return retu;
	}	
	if(wlanid >= WLAN_NUM || wlanid == 0){
		return -2;
	}
	if (!strcmp(state,"enable"))
	{
		policy = 1; 
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0; 
	}
	else
	{
		return -3;
	}	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radioID = Rid;
	if(radioID > G_RADIO_NUM || radioID == 0){
		syslog(LOG_DEBUG,"radio id in set_sta_dhcp_before_authorized_cmd is %d\n",radioID);
		return -9;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_SET_STA_DHCP_BEFORE_AUTHERIZED);
	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_SET_STA_DHCP_BEFORE_AUTHERIZED);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radioID,
							 DBUS_TYPE_BYTE,&wlanid,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		retu = 1;
	}
	else if (ret == WLAN_ID_NOT_EXIST)
	{
		retu = -4;
	}
	else if (ret == WTP_IS_NOT_BINDING_WLAN_ID)
	{
		retu = -5;
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
	{
		retu = -6;
	}
	else if (ret == WTP_OVER_MAX_BSS_NUM)
	{
		retu = -7;
	}
	else
	{
		retu = -8;
	}
		
	dbus_message_unref(reply);	
	return retu; 		
#endif	
}


#if _GROUP_POLICY
void Free_set_sta_ip_mac_binding_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-11时，调用Free_set_sta_ip_mac_binding_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*state为"enable"或"disable"*/
int set_sta_ip_mac_binding_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *wlan_id,char *state,struct RadioList **RadioList_Head)
								/*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
								/*返回-2表示wlan id should be 1 to WLAN_NUM-1，返回-3表示input patameter only with 'enable' or 'disable'*/
								/*返回-4表示wlan not exist，返回-5表示wtp not binding wlan argv[0]*/
								/*返回-6表示binding wlan error，返回-7表示error，返回-8表示Radio ID非法*/
								/*返回-9表示illegal input:Input exceeds the maximum value of the parameter type*/
								/*返回-10表示Group ID非法，返回-11表示partial failure，返回-12表示group id does not exist*/
{
	if(NULL == connection)
		return 0;

	if((NULL == wlan_id)||(NULL == state))
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int policy = 0;
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned char wlanid = 0;
	int retu = 0;

	ret = parse_char_ID((char*)wlan_id, &wlanid);
	if(ret != WID_DBUS_SUCCESS){
        if(ret == WID_ILLEGAL_INPUT){
			retu = -9;
        }
		else{
			retu = -1;
		}
		return retu;
	}	
	if(wlanid >= WLAN_NUM || wlanid == 0){
		return -2;
	}
	if (!strcmp(state,"enable"))
	{
		policy = 1; 
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0; 
	}
	else
	{
		return -3;
	}

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_sta_ip_mac_binding_cmd_group is %d\n",id);
			return -8;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_sta_ip_mac_binding_cmd_group is %d\n",id);
			return -10;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								int ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_sta_ip_mac_binding_cmd_wlan_ID_sta_ip_mac_binding");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 wlanid,
								 policy,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if (ret == WLAN_ID_NOT_EXIST)
			retu = -4;
		else if (ret == WTP_IS_NOT_BINDING_WLAN_ID)
			retu = -5;
		else if (ret == WTP_OVER_MAX_BSS_NUM)
			retu = -6;
		else
			retu = -7;
	}

	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -11;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -12;
	}	
	return retu; 		
}
#endif

/*未使用*/
/*state为"enable"或"disable"*/
int set_sta_ip_mac_binding_cmd(dbus_parameter parameter, DBusConnection *connection,int Rid,char *wlan_id,char *state)
																						/*返回0表示失败，返回1表示成功，返回-1表示unknown id format*/
																						/*返回-2表示wlan id should be 1 to WLAN_NUM-1，返回-3表示input patameter only with 'enable' or 'disable'*/
																						/*返回-4表示wlan not exist，返回-5表示wtp not binding wlan argv[0]*/
																						/*返回-6表示binding wlan error，返回-7表示error，返回-8表示Radio ID非法*/
																						/*返回-9表示illegal input:Input exceeds the maximum value of the parameter type*/
																						/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
		return 0;
	
	if((NULL == wlan_id)||(NULL == state))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_sta_ip_mac_binding_cmd_group(parameter,connection,0,Rid,wlan_id,state,&RadioList_Head);
	if(retu == -11)
	{
		Free_set_sta_ip_mac_binding_cmd_group(RadioList_Head);
	}
	return retu;
#else		
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;
	unsigned int radioID = 0;
	unsigned char wlanid = 0;
	int ret = WID_DBUS_SUCCESS;
	//radioID = (unsigned int)vty->index;
	int policy = 0;
	int retu;
	ret = parse_char_ID((char*)wlan_id, &wlanid);
	if(ret != WID_DBUS_SUCCESS){
		if(ret == WID_ILLEGAL_INPUT){
			retu = -9;
		}
		else{
			retu = -1;
		}
		return retu;
	}	
	if(wlanid >= WLAN_NUM || wlanid == 0){
		return -2;
	}
	if (!strcmp(state,"enable"))
	{
		policy = 1; 
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0; 
	}
	else
	{
		return -3;
	}
	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
		
	radioID = Rid;
	if(radioID > G_RADIO_NUM || radioID == 0){
		syslog(LOG_DEBUG,"radio id in set_sta_ip_mac_binding_cmd is %d\n",radioID);
		return -8;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_SET_STA_IP_MAC_BINDING);
	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_SET_STA_IP_MAC_BINDING);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radioID,
							 DBUS_TYPE_BYTE,&wlanid,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		if (dbus_error_is_set(&err))
		{
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		retu = 1;
	}
	else if (ret == WLAN_ID_NOT_EXIST)
	{
		retu = -4;
	}
	else if (ret == WTP_IS_NOT_BINDING_WLAN_ID)
	{
		retu = -5;
	}
	else if (ret == WTP_OVER_MAX_BSS_NUM)
	{
		retu = -6;
	}
	else
	{
		retu = -7;
	}
		
	dbus_message_unref(reply);

	
	return retu; 		
#endif	
}

#if _GROUP_POLICY
void Free_set_radio_guard_interval_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-8时，调用Free_set_radio_guard_interval_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*interval为"800"或"400"*/
int set_radio_guard_interval_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *Interval,struct RadioList **RadioList_Head)
										 /*返回0表示失败，返回1表示成功，返回-1表示input parameter error*/
										 /*返回-2表示radio id does not exist，返回-3表示radio is disable, please enable it first*/
										 /*返回-4表示radio is not binging wlan，返回-5表示error，返回-6表示Radio ID非法*/
										 /*返回-7表示Group ID非法，返回-8表示partial failure，返回-9表示group id does not exist*/
{
	if(NULL == connection)
		return 0;

	if(NULL == Interval)
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned int interval = 0;
	unsigned short guard_interval = 0;
	int retu = 0;

    /*rtsthre= atoi(argv[0]);*/
	ret = parse_int_ID((char *)Interval,&interval);
	if(interval == 800){
		guard_interval = 0;

	}else if(interval == 400){
		guard_interval = 1;
	}
	//guard_interval =(unsigned short)interval;
	if (ret != WID_DBUS_SUCCESS)
	{	
		return -1;
	}

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_radio_guard_interval_cmd_group is %d\n",id);
			return -6;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_radio_guard_interval_cmd_group is %d\n",id);
			return -7;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned short ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_guard_interval_cmd_11n_guard_interval");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 guard_interval,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -2;
		else if(ret == RADIO_IS_DISABLE)
			retu = -3;
		else if(ret == WTP_IS_NOT_BINDING_WLAN_ID)
			retu = -4;
		else
			retu = -5;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -8;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -9;
	}	
	return retu;
}
#endif

/*interval为"800"或"400"*/
int set_radio_guard_interval_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *Interval)
																			 /*返回0表示失败，返回1表示成功，返回-1表示input parameter error*/
																			 /*返回-2表示radio id does not exist，返回-3表示radio is disable, please enable it first*/
																			 /*返回-4表示radio is not binging wlan，返回-5表示error，返回-6表示Radio ID非法*/
																			 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
		return 0;
	
	if(NULL == Interval)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_radio_guard_interval_cmd_group(parameter,connection,0,RID,Interval,&RadioList_Head);
	if(retu == -8)
	{
		Free_set_radio_guard_interval_cmd_group(RadioList_Head);
	}
	return retu;
#else	
	unsigned int radio_id; 
	unsigned int interval ;
	unsigned short guard_interval;
	int ret;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;	
	int retu;
	
    /*rtsthre= atoi(argv[0]);*/
	ret = parse_int_ID((char *)Interval,&interval);
	if(interval == 800){
		guard_interval = 0;

	}else if(interval == 400){
		guard_interval = 1;
	}
	//guard_interval =(unsigned short)interval;
	
	if (ret != WID_DBUS_SUCCESS)
	{	
		return -1;
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
		
	radio_id = RID;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in set_radio_guard_interval_cmd is %d\n",radio_id);
		return -6;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_GUARD_INTERVAL);

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_GUARD_INTERVAL);*/
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radio_id,
							 DBUS_TYPE_UINT16,&guard_interval,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu = 1;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu = -2;
	else if(ret == RADIO_IS_DISABLE)
		retu = -3;		
	else if(ret == WTP_IS_NOT_BINDING_WLAN_ID)
		retu = -4;
	else
		retu = -5;

	dbus_message_unref(reply);
	return retu;
#endif
}

#if _GROUP_POLICY
void Free_set_radio_mcs_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-9时，调用Free_set_radio_mcs_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*mcs_value是一个以","分隔的数字集合*/
int set_radio_mcs_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *mcs_value,struct RadioList **RadioList_Head)
											   /*返回0表示失败，返回1表示成功，返回-1表示parse mcs list failed*/
											   /*返回-2表示radio id does not exist，返回-3表示radio is disable, please enable it first*/
											   /*返回-4表示error，返回-5表示Radio ID非法，返回-6表示Group ID非法*/
											   /*返回-7表示partial failure，返回-8表示group id does not exist*/
											   /*返回-9表示mcs cross the border, if your stream is one,mcs should be 0~7,if your stream is two,mcs should be 8~15,and if your stream is three,mcs should be 16~23*/
{
	if(NULL == connection)
		return 0;

	if(NULL == mcs_value)
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	//unsigned short mcs = 0;
	update_mcs_list *mcslist = NULL;  
	int retu = 0;

	struct tag_mcsid *tmp = NULL;
	mcslist = (struct tag_mcsid_list*)malloc(sizeof(struct tag_mcsid_list));
	mcslist->mcsidlist = NULL ; 	
	mcslist->count = 0;


	ret = parse_mcs_list((char*)mcs_value,&mcslist);
	if(ret != 0){
	    //cli_syslog_info("parse mcs list failed\n");
	    return -1;
	}

	/*ret = parse_short_ID((char *)mcs_value,&mcs);
	
	if (ret != WID_DBUS_SUCCESS)
	{	
       if(ret == WID_ILLEGAL_INPUT){
	   		retu = -7;
       }
	   else{
	   		retu = -1;
	   }		
		return retu;
	}

	if((mcs<0)||(mcs>31))
	{
		return -6;
	}*/

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_radio_mcs_cmd_group is %d\n",id);
			return -5;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_radio_mcs_cmd_group is %d\n",id);
			return -6;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								update_mcs_list *,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_mcs_cmd_11n_mcs");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 mcslist,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}	

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -2;
		else if(ret == RADIO_IS_DISABLE)
			retu = -3;		
		else if(ret == MCS_CROSS_THE_BORDER)
			retu = -9;	
		else
			retu = -4;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -7;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -8;
	}	
	return retu;
}
#endif

/*mcs_value是一个以","分隔的数字集合*/
int set_radio_mcs_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *mcs_value)
																   /*返回0表示失败，返回1表示成功，返回-1表示input mcs should be 0-31,format should be 1-31 or 1,2,31*/
																   /*返回-2表示radio id does not exist，返回-3表示radio is disable, please enable it first*/
																   /*返回-4表示error，返回-5表示Radio ID非法*/
																   /*返回-9表示mcs cross the border, if your stream is one,mcs should be 0~7,if your stream is two,mcs should be 8~15,and if your stream is three,mcs should be 16~23*/
																   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
		return 0;
	
	if(NULL == mcs_value)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_radio_mcs_cmd_group(parameter,connection,0,RID,mcs_value,&RadioList_Head);
	if(retu == -9)
	{
		Free_set_radio_mcs_cmd_group(RadioList_Head);
	}
	return retu;
#else	
	update_mcs_list *mcslist = NULL;  
	int i =0;
	unsigned int radio_id = 0; 
	unsigned short mcs;
	int ret = 0;
	DBusMessage *query = NULL, *reply = NULL;	
	DBusMessageIter	 iter;
	DBusError err;	
	int retu = 0;
	
	struct tag_mcsid *tmp = NULL;
	mcslist = (struct tag_mcsid_list*)malloc(sizeof(struct tag_mcsid_list));
	mcslist->mcsidlist = NULL ; 	
	mcslist->count = 0;


	ret = parse_mcs_list((char*)mcs_value,&mcslist);

	if(ret != 0){
	    //cli_syslog_info("parse mcs list failed\n");
	    free_mcs_list(mcslist);
	    return -1;
	}	

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
		
	radio_id = RID;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in set_radio_mcs_cmd is %d\n",radio_id);
		return -5;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_MCS);
		

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_RADIO_OBJPATH,\
						WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_MCS);*/
	
	dbus_error_init(&err);

	/*dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radio_id,
							 DBUS_TYPE_UINT16,&mcs,
							 DBUS_TYPE_INVALID);*/
	
	dbus_message_iter_init_append (query, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&radio_id);										 
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32,&(mcslist->count));	
										
	tmp = mcslist->mcsidlist;

	for(i = 0; ((i < mcslist->count) && (tmp)); i++){
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &(tmp->mcsid));
		tmp = tmp->next;
	}											 

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		free_mcs_list(mcslist);
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		retu = 1;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu = -2;
	else if(ret == RADIO_IS_DISABLE)
		retu = -3;		
	else if(ret == MCS_CROSS_THE_BORDER)
		retu = -9;
	else
		retu = -4;

	dbus_message_unref(reply);
	free_mcs_list(mcslist);
	return retu;
#endif
}

#if _GROUP_POLICY
void Free_set_radio_cmmode_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-10时，调用Free_set_radio_cmmode_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*cwmode_value为"ht20"或"ht20/40"或"ht40"*/
int set_radio_cmmode_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *cwmode_value,struct RadioList **RadioList_Head)
											   /*返回0表示失败，返回1表示成功，返回-1表示input parameter error*/
											   /*返回-2表示radio id does not exist，返回-3表示radio is disable, please enable it first*/
											   /*返回-4表示radio is not binging wlan，返回-5表示error，返回-6表示Radio ID非法*/
											   /*返回-7表示radio mode is not 11N ,don't support this command，返回-8表示Group ID非法*/
											   /*返回-9表示channel offset should be set none，返回-10表示partial failure，返回-11表示group id does not exist*/
											   /*返回-12表示the current radio channel is larger than the max channel,you are not allowed to set channel offset up*/
{
	if(NULL == connection)
		return 0;

	if(NULL == cwmode_value)
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned short cwmode = 0;
	unsigned int max_channel = 0;
	unsigned int min_channel = 0;
	unsigned char current_channel = 0;	
	int retu = 0;

	if(!strcmp(cwmode_value,"ht20")){
		cwmode = 0;
	}
	else if(!strcmp(cwmode_value,"ht20/40")){
		cwmode = 1;
	}
	else if(!strcmp(cwmode_value,"ht40")){
		cwmode = 2;
	}
	else{
		return -1;
	}	

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_radio_cmmode_cmd_group is %d\n",id);
			return -6;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_radio_cmmode_cmd_group is %d\n",id);
			return -8;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned short ,
								int *,
								unsigned int *,
								unsigned int *,
								unsigned int *,
								unsigned char *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_cmmode_cmd_11n_cwmode");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 cwmode,
								 &count,
								 &ret,
								 &max_channel,
								 &min_channel,
								 &current_channel								 
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}	
		
	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -2;
		else if(ret == RADIO_IS_DISABLE)
			retu = -3;
		else if(ret == WTP_IS_NOT_BINDING_WLAN_ID)
			retu = -4;
		else if(ret == RADIO_CHANNEL_OFFSET_NEED_BE_RESET)
			retu = -9;
		else if(ret == CHANNEL_CROSS_THE_BORDER)
			retu = -12;
		else
			retu = -5;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -10;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -11;
	}
	return retu;
}
#endif

/*cwmode_value为"ht20"或"ht20/40"或"ht40"*/
int set_radio_cmmode_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *cwmode_value)
																		   /*返回0表示失败，返回1表示成功，返回-1表示input parameter error*/
																		   /*返回-2表示radio id does not exist，返回-3表示radio is disable, please enable it first*/
																		   /*返回-4表示radio is not binging wlan，返回-5表示error，返回-6表示Radio ID非法*/
																		   /*返回-7表示radio mode is not 11N ,don't support this command*/
																		   /*返回-12表示the current radio channel is larger than the max channel,you are not allowed to set channel offset up!Please turn down channel*/
																		   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
		return 0;
	
	if(NULL == cwmode_value)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_radio_cmmode_cmd_group(parameter,connection,0,RID,cwmode_value,&RadioList_Head);
	if(retu == -10)
	{
		Free_set_radio_cmmode_cmd_group(RadioList_Head);
	}
	return retu;
#else
	unsigned int radio_id; 
	unsigned short cwmode;
	int ret = 0;	
	unsigned int max_channel = 0;
	unsigned int min_channel = 0;
	unsigned char current_channel = 0;	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;	
	int retu;
	
    /*rtsthre= atoi(argv[0]);*/
	//ret = parse_int_ID((char *)argv[0],&mode);	
	if(!strcmp(cwmode_value,"ht20")){
		cwmode = 0;
	}
	else if(!strcmp(cwmode_value,"ht20/40")){
		cwmode = 1;
	}
	else if(!strcmp(cwmode_value,"ht40")){
		cwmode = 2;
	}
	else{}
	
	
	//cwmode = (unsigned short)mode;
	
	if (ret != WID_DBUS_SUCCESS)
	{	
		return -1;
	}


	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
		
	radio_id = RID;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in set_radio_cmmode_cmd is %d\n",radio_id);
		return -6;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_CMMODE);
			
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&radio_id,
							 DBUS_TYPE_UINT16,&cwmode,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	
	if(ret == CHANNEL_CROSS_THE_BORDER){
	 dbus_message_iter_next(&iter); 
	 dbus_message_iter_get_basic(&iter,&max_channel);
	 dbus_message_iter_next(&iter); 	
	 dbus_message_iter_get_basic(&iter,&min_channel);
	 dbus_message_iter_next(&iter); 	
	 dbus_message_iter_get_basic(&iter,&current_channel);		 
	 }

	if(ret == 0)
		retu = 1;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu = -2;
	else if(ret == RADIO_IS_DISABLE)
		retu = -3;		
	else if(ret == WTP_IS_NOT_BINDING_WLAN_ID)
		retu = -4;		
	else if(ret == RADIO_MODE_IS_11N)
		retu = -7;	
	else if(ret == CHANNEL_CROSS_THE_BORDER)
		retu = -12;	
	else
		retu = -5;

	dbus_message_unref(reply);
	return retu;
#endif
}

#if _GROUP_POLICY
void Free_set_radio_inter_vap_forwarding_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-9时，调用Free_set_radio_inter_vap_forwarding_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*state为"enable"或"disable"*/
int set_radio_inter_vap_forwarding_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *state,struct RadioList **RadioList_Head)
															  /*返回0表示失败，返回1表示成功*/
															  /*返回-1表示input patameter only with 'enable' or 'disable'*/
															  /*返回-2表示wtp isn't existed，返回-3表示radio isn't existed*/
															  /*返回-4表示radio doesn't bind wlan*/
															  /*返回-5表示radio not support this command，返回-6表示error*/
															  /*返回-7表示Radio ID非法，返回-8表示Group ID非法*/
															  /*返回-9表示partial failure，返回-10表示group id does not exist*/
															  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{ 
	if(NULL == connection)
		return 0;

	if(NULL == state)
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned char policy =0;   
	int retu = 0;
		
	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -1;
	}
	

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_radio_inter_vap_forwarding_cmd_group is %d\n",id);
			return -7;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_radio_inter_vap_forwarding_cmd_group is %d\n",id);
			return -8;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_inter_vap_forwarding_cmd_set_inter_VAP_forwarding");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 policy,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == -1)
			retu = SNMPD_CONNECTION_ERROR;
		else if(ret == WTP_ID_NOT_EXIST)
			retu = -2;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -3;
		else if(ret==RADIO_NO_BINDING_WLAN)
			retu = -4;
		else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
			retu = -4;
		else if(ret == WID_DBUS_SUCCESS)
			retu = 1;
		else if(ret == RADIO_NOT_SUPPORT_COMMAND)
			retu = -5;
		else
			retu = -6;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -9;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -10;
	}
	return retu; 
}
#endif

/*未使用*/
/*state为"enable"或"disable"*/
int set_radio_inter_vap_forwarding_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *state)
																				  /*返回0表示失败，返回1表示成功*/
																				  /*返回-1表示input patameter only with 'enable' or 'disable'*/
																				  /*返回-2表示wtp isn't existed，返回-3表示radio isn't existed*/
																				  /*返回-4表示radio doesn't bind wlan*/
																				  /*返回-5表示radio not support this command，返回-6表示error*/
																				  /*返回-7表示Radio ID非法*/
																				  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
		return 0;
	
	if(NULL == state)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_radio_inter_vap_forwarding_cmd_group(parameter,connection,0,RID,state,&RadioList_Head);
	if(retu == -9)
	{
		Free_set_radio_inter_vap_forwarding_cmd_group(RadioList_Head);
	}
	return retu;
#else
	unsigned int ret = 0;
	unsigned int RadioID;
	unsigned char policy =0;   
	int retu;
		
	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -1;
	}
	
		
	RadioID = RID;
	if(RadioID > G_RADIO_NUM || RadioID == 0){
		syslog(LOG_DEBUG,"radio id in set_radio_inter_vap_forwarding_cmd is %d\n",RadioID);
		return -7;
    }

	int(*dcli_init_func)(
							int ,
							int ,
							int ,
							unsigned char ,
							DBusConnection *
						);

	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"radio_set_radio_inter_vap_type");
		if(NULL != dcli_init_func)
		{
			ret =(*dcli_init_func)
				  (
					 parameter.local_id,
					 parameter.instance_id,
					 RadioID,
					 policy,
					 connection
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
		
	if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else if(ret == WTP_ID_NOT_EXIST)
		retu = -2;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu = -3;
	else if(ret==RADIO_NO_BINDING_WLAN)
		retu = -4;
	else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
		retu = -4;
	else if(ret == WID_DBUS_SUCCESS)
		retu = 1;
	else if(ret == RADIO_NOT_SUPPORT_COMMAND)
		retu = -5;
	else
		retu = -6;

	return retu; 
#endif	
}

#if _GROUP_POLICY
void Free_set_radio_keep_alive_period_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-8时，调用Free_set_radio_keep_alive_period_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*value的范围是1-3600*/
int set_radio_keep_alive_period_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *value,struct RadioList **RadioList_Head)
																	/*返回0表示失败，返回1表示成功*/
																	/*返回-1表示input parameter should be 1-3600*/
																	/*返回-2表示wtp isn't existed*/
																	/*返回-3表示radio isn't existed*/
																	/*返回-4表示radio doesn't bind wlan*/
																	/*返回-5表示error，返回-6表示Radio ID非法*/
																	/*返回-7表示Group ID非法，返回-8表示partial failure*/
																	/*返回-9表示group id does not exist*/
																	/*返回-10表示this radio not supports those commands*/
{  
	if(NULL == connection)
		return 0;

	if(NULL == value)
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned int period =0; 
	int retu = 0;

	period = (unsigned int)atoi(value);
		
	if ((period < 1)||(period > 3600)) 
	{
		return -1;
	}

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_radio_keep_alive_period_cmd_group is %d\n",id);
			return -6;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_radio_keep_alive_period_cmd_group is %d\n",id);
			return -7;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned int ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_keep_alive_period_cmd_set_radio_keep_alive_period");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 period,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == WTP_ID_NOT_EXIST)
			retu = -2;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -3;
		else if(ret==RADIO_NO_BINDING_WLAN)
			retu = -4;
		else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
			retu = -4;
		else if(ret == WID_DBUS_SUCCESS)
			retu = 1;
		else if (ret == RADIO_NOT_SUPPORT_COMMAND)
			retu = -10;
		else
			retu = -5;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -8;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -9;
	}		
	return retu; 
}
#endif

/*未使用*/
/*value的范围是1-3600*/
int set_radio_keep_alive_period_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *value)
																			  /*返回0表示失败，返回1表示成功*/
																			  /*返回-1表示input parameter should be 1-3600*/
																			  /*返回-2表示wtp isn't existed*/
																			  /*返回-3表示radio isn't existed*/
																			  /*返回-4表示radio doesn't bind wlan*/
																			  /*返回-5表示error，返回-6表示Radio ID非法*/
																			  /*返回-10表示this radio not supports those commands*/
																			  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
		return 0;
	
	if(NULL == value)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_radio_keep_alive_period_cmd_group(parameter,connection,0,RID,value,&RadioList_Head);
	if(retu == -8)
	{
		Free_set_radio_keep_alive_period_cmd_group(RadioList_Head);
	}
	return retu;
#else
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int ret;
	unsigned int RadioID;
	unsigned int period =0;   
	int retu;

	period = (unsigned int)atoi(value);
		
	if ((period < 1)||(period > 3600)) 
	{
		return -1;
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
		
	RadioID = RID;
	if(RadioID > G_RADIO_NUM || RadioID == 0){
		syslog(LOG_DEBUG,"radio id in set_radio_keep_alive_period_cmd is %d\n",RadioID);
		return -6;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_KEEP_ALIVE_PERIOD);


	dbus_error_init(&err);

	dbus_message_append_args(query,
							DBUS_TYPE_UINT32,&RadioID,
							DBUS_TYPE_UINT32,&period,
							DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
		
	if(ret == WTP_ID_NOT_EXIST)
		retu = -2;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu = -3;
	else if(ret==RADIO_NO_BINDING_WLAN)
		retu = -4;
	else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
		retu = -4;
	else if(ret == WID_DBUS_SUCCESS)
		retu = 1;
	else if (ret == RADIO_NOT_SUPPORT_COMMAND)
		retu = -10;
	else
		retu = -5;

	dbus_message_unref(reply);

	return retu; 
#endif	
}

#if _GROUP_POLICY
void Free_set_radio_keep_alive_idle_time_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-8时，调用Free_set_radio_keep_alive_idle_time_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*value的范围是1-3600*/
int set_radio_keep_alive_idle_time_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *value,struct RadioList **RadioList_Head) 
														/*返回0表示失败，返回1表示成功*/
														/*返回-1表示input parameter should be 1-3600*/
														/*返回-2表示wtp isn't existed*/
														/*返回-3表示radio isn't existed*/
														/*返回-4表示radio doesn't bind wlan*/
														/*返回-5表示error，返回-6表示Radio ID非法*/
														/*返回-7表示Group ID非法*/
														/*返回-8表示partial failure，返回-9表示group id does not exist*/
														/*返回-10表示this radio not supports those commands*/
{  
	if(NULL == connection)
		return 0;

	if(NULL == value)
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned int period =0; 
	int retu = 0;
		
	period = (unsigned int)atoi(value);
		
	if ((period < 1)||(period > 3600)) 
	{
		return -1;
	}

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_radio_keep_alive_idle_time_cmd_group is %d\n",id);
			return -6;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_radio_keep_alive_idle_time_cmd_group is %d\n",id);
			return -7;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned int ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_keep_alive_idle_time_cmd_set_radio_keep_alive_idle_time");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 period,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == WTP_ID_NOT_EXIST)
			retu = -2;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -3;
		else if(ret==RADIO_NO_BINDING_WLAN)
			retu = -4;
		else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
			retu = -4;
		else if(ret == WID_DBUS_SUCCESS)
			retu = 1;
		else if (ret == RADIO_NOT_SUPPORT_COMMAND)
			retu = -10;
		else
			retu = -5;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -8;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -9;
	}	
	return retu; 
}
#endif

/*未使用*/
/*value的范围是1-3600*/
int set_radio_keep_alive_idle_time_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *value) 
																				  /*返回0表示失败，返回1表示成功*/
																				  /*返回-1表示input parameter should be 1-3600*/
																				  /*返回-2表示wtp isn't existed*/
																				  /*返回-3表示radio isn't existed*/
																				  /*返回-4表示radio doesn't bind wlan*/
																				  /*返回-5表示error，返回-6表示Radio ID非法*/
																				  /*返回-10表示this radio not supports those commands*/
																				  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
		return 0;
	
	if(NULL == value)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_radio_keep_alive_idle_time_cmd_group(parameter,connection,0,RID,value,&RadioList_Head);
	if(retu == -8)
	{
		Free_set_radio_keep_alive_idle_time_cmd_group(RadioList_Head);
	}
	return retu;
#else
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int ret;
	unsigned int RadioID;
	unsigned int period =0;   
	int retu;

	period = (unsigned int)atoi(value);
		
	if ((period < 1)||(period > 3600)) 
	{
		return -1;
	}

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
		
	RadioID = RID;
	if(RadioID > G_RADIO_NUM || RadioID == 0){
		syslog(LOG_DEBUG,"radio id in set_radio_keep_alive_idle_time_cmd is %d\n",RadioID);
		return -6;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_KEEP_ALIVE_IDLE_TIME);


	dbus_error_init(&err);

	dbus_message_append_args(query,
							DBUS_TYPE_UINT32,&RadioID,
							DBUS_TYPE_UINT32,&period,
							DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
		
	if(ret == WTP_ID_NOT_EXIST)
		retu = -2;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu = -3;
	else if(ret==RADIO_NO_BINDING_WLAN)
		retu = -4;
	else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
		retu = -4;
	else if(ret == WID_DBUS_SUCCESS)
		retu = 1;
	else if (ret == RADIO_NOT_SUPPORT_COMMAND)
		retu = -10;
	else
		retu = -5;

	dbus_message_unref(reply);

	return retu; 
#endif	
}

#if _GROUP_POLICY
void Free_set_radio_congestion_avoidance_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-8时，调用Free_set_radio_congestion_avoidance_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*state的范围是(disable|tail-drop|red|fwred|)*/
int set_radio_congestion_avoidance_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *state,struct RadioList **RadioList_Head)
																	/*返回0表示失败，返回1表示成功*/
																	/*返回-1表示unknow command*/
																	/*返回-2表示wtp isn't existed*/
																	/*返回-3表示radio isn't existed*/
																	/*返回-4表示radio doesn't bind wlan*/
																	/*返回-5表示error，返回-6表示Radio ID非法*/
																	/*返回-7表示Group ID非法	，返回-8表示partial failure*/
																	/*返回-9表示group id does not exist*/
																	/*返回-10表示this radio not supports those commands*/
{
	if(NULL == connection)
		return 0;

	if(NULL == state)
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned int congestion_av_state = 0; 
	int retu = 0;
	
	if (!strcmp(state,"disable"))
	{
		congestion_av_state = 0; 
	}
	else if (!strcmp(state,"tail-drop"))
	{
		congestion_av_state = 1; 
	}
	else if (!strcmp(state,"red"))
	{
		congestion_av_state = 2; 
	}
	else if (!strcmp(state,"fwred"))
	{
		congestion_av_state = 3; 
	}
	else{
		return -1;
	}


	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_radio_congestion_avoidance_cmd_group is %d\n",id);
			return -6;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_radio_congestion_avoidance_cmd_group is %d\n",id);
			return -7;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned int ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_congestion_avoidance_cmd_set_radio_congestion_avoidance");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 congestion_av_state,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}	

	if(type==0)
	{
		if(ret == WTP_ID_NOT_EXIST)
			retu = -2;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -3;
		else if(ret==RADIO_NO_BINDING_WLAN)
			retu = -4;
		else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
			retu = -4;
		else if(ret == WID_DBUS_SUCCESS)
			retu = 1;
		else if (ret == RADIO_NOT_SUPPORT_COMMAND)
			retu = -10;
		else
			retu = -5;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -8;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -9;
	}
	return retu; 
}
#endif

/*未使用*/
/*state的范围是(disable|tail-drop|red|fwred|)*/
int set_radio_congestion_avoidance_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *state)
																				   /*返回0表示失败，返回1表示成功*/
																				   /*返回-1表示unknow command*/
																				   /*返回-2表示wtp isn't existed*/
																				   /*返回-3表示radio isn't existed*/
																				   /*返回-4表示radio doesn't bind wlan*/
																				   /*返回-5表示error，返回-6表示Radio ID非法*/
																				   /*返回-10表示this radio not supports those commands*/
																				   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
		return 0;
	
	if(NULL == state)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_radio_congestion_avoidance_cmd_group(parameter,connection,0,RID,state,&RadioList_Head);
	if(retu == -8)
	{
		Free_set_radio_congestion_avoidance_cmd_group(RadioList_Head);
	}
	return retu;
#else
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int ret;
	unsigned int RadioID;
	unsigned int congestion_av_state;
	int retu;

	if (!strcmp(state,"disable"))
	{
		congestion_av_state = 0; 
	}
	else if (!strcmp(state,"tail-drop"))
	{
		congestion_av_state = 1; 
	}
	else if (!strcmp(state,"red"))
	{
		congestion_av_state = 2; 
	}
	else if (!strcmp(state,"fwred"))
	{
		congestion_av_state = 3; 
	}
	else
	{
		return -1;
	}


	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
			
	RadioID = RID;
	if(RadioID > G_RADIO_NUM || RadioID == 0){
		syslog(LOG_DEBUG,"radio id in set_radio_congestion_avoidance_cmd is %d\n",RadioID);
		return -6;
    }
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id,WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_SET_CONGESTION_AVOID_STATE);


	dbus_error_init(&err);

	dbus_message_append_args(query,
							DBUS_TYPE_UINT32,&RadioID,
							DBUS_TYPE_UINT32,&congestion_av_state,
							DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return SNMPD_CONNECTION_ERROR;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
		
	if(ret == WTP_ID_NOT_EXIST)
		retu = -2;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu = -3;
	else if(ret==RADIO_NO_BINDING_WLAN)
		retu = -4;
	else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
		retu = -4;
	else if(ret == WID_DBUS_SUCCESS)
		retu = 1;
	else if (ret == RADIO_NOT_SUPPORT_COMMAND)
		retu = -10;
	else
		retu = -5;

	dbus_message_unref(reply);

	return retu; 
#endif	
}

/*未使用*/
/*state为"enable"或"disable"*/
int set_wtp_list_sta_static_arp_enable_cmd(dbus_parameter parameter, DBusConnection *connection,char *wlan_id,char *wtp_list,char *state,char *if_name)
																									/*返回0表示失败，返回1表示成功*/
																								    /*返回-1表示unknown id format*/
																								    /*返回-2表示wlan id should be 1 to WLAN_NUM-1*/
																								    /*返回-3表示set wtp list error,like 1,8,9-20,33*/
																								    /*返回-4表示input patameter only with 'enable' or 'disable'*/
																								    /*返回-5表示interface no exist，返回-6表示error*/
																									/*返回-7表示illegal input:Input exceeds the maximum value of the parameter type*/
																									/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
	if(NULL == connection)
		return 0;
	
	if((NULL == wlan_id)||(NULL == wtp_list)||(NULL == state)||(NULL == if_name))
		return 0;
	
	int ret;
	update_wtp_list *wtplist;
    int policy = 0;
	unsigned char wlanid;
	char *ifname;
	int retu;
	
	ret = parse_char_ID((char*)wlan_id, &wlanid);
	if(ret != WID_DBUS_SUCCESS){
		if(ret == WID_ILLEGAL_INPUT){
			retu = -7;
		}
		else{
			retu = -1;
		}
		return retu;
	}	
	if(wlanid >= WLAN_NUM || wlanid == 0){
		return -2;
	}

	wtplist = (struct tag_wtpid_list*)malloc(sizeof(struct tag_wtpid_list));
	if(NULL == wtplist)
		return 0;
	wtplist->wtpidlist = NULL ; 	
	wtplist->count = 0;
	
	if (!strcmp(wtp_list,"all"))
	{
		;	
	}else{
		ret = parse_wtpid_list((char*)wtp_list,&wtplist);
		if(ret != 0)
		{
			destroy_input_wtp_list(wtplist);
			return -3;
		}
		else
		{
			delsame(wtplist);		
		}
	}

	
	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		destroy_input_wtp_list(wtplist);
		return -4;
	}
	ifname = malloc(strlen(if_name)+1);
	if(ifname)
	{
		memset(ifname, 0, strlen(if_name)+1);
		memcpy(ifname, if_name, strlen(if_name));
	}

	int(*dcli_init_func)(
							int ,
							int ,
							int ,
							unsigned char ,
							struct tag_wtpid_list * ,
							char *,
							DBusConnection *
						);

	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wlan_wtp_list_sta_static_arp");
		if(NULL != dcli_init_func)
		{
			ret =(*dcli_init_func)
				  (
					 parameter.local_id,
					 parameter.instance_id,
					 policy,
					 wlanid,
					 wtplist,
					 ifname,
					 connection
				  );
		}
		else
		{
			FREE_OBJECT(ifname);
			return 0;
		}
	}
	else
	{
		FREE_OBJECT(ifname);
		return 0;
	}

	destroy_input_wtp_list(wtplist);
	FREE_OBJECT(ifname);

	if(ret == 0)
		retu = 1;
	else if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;	
	else if(ret == APPLY_IF_FAIL)
		retu = -5;
	else
		retu = -6;
	
	return retu; 
}

#if _GROUP_POLICY
void Free_set_wtp_sta_static_arp_enable_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-8时，调用Free_set_wtp_sta_static_arp_enable_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*state为"enable"或"disable"*/
int set_wtp_sta_static_arp_enable_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *wlan_id,char *state,char *if_name,struct RadioList **RadioList_Head)
															/*返回0表示失败，返回1表示成功*/
														    /*返回-1表示unknown id format*/
														    /*返回-2表示wlan id should be 1 to WLAN_NUM-1*/
														    /*返回-3表示input patameter only with 'enable' or 'disable'*/
														    /*返回-4表示error，返回-5表示Radio ID非法*/
															/*返回-6表示illegal input:Input exceeds the maximum value of the parameter type*/
															/*返回-7表示Group ID非法，返回-8表示partial failure*/
															/*返回-9表示group id does not exist*/
{	
	if(NULL == connection)
		return 0;

	if((NULL == wlan_id)||(NULL == state)||(NULL == if_name))
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	unsigned char wlanid;
	char *ifname;
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned int policy = 0;
	int retu = 0;
		
	ret = parse_char_ID((char*)wlan_id, &wlanid);
	if(ret != WID_DBUS_SUCCESS){
        if(ret == WID_ILLEGAL_INPUT){
			retu = -6;
        }
		else{
			retu = -1;
		}
		return retu;
	}	
	if(wlanid >= WLAN_NUM || wlanid == 0){
		return -2;
	}
	
	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -3;
	}
	ifname = malloc(strlen(if_name)+1);
	if(ifname)
	{
		memset(ifname, 0, strlen(if_name)+1);
		memcpy(ifname, if_name, strlen(if_name));
	}

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_wtp_sta_static_arp_enable_cmd_group is %d\n",id);
			FREE_OBJECT(ifname);
			return -5;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_wtp_sta_static_arp_enable_cmd_group is %d\n",id);
			FREE_OBJECT(ifname);
			return -7;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								char *, 
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_wtp_sta_static_arp_enable_cmd_set_wlan_sta_static_arp");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 policy,
								 wlanid,
								 ifname,
								 &count,
								 &ret
							  );
		}
		else
		{
			FREE_OBJECT(ifname);
			return 0;
		}
	}
	else
	{
		FREE_OBJECT(ifname);
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else
			retu = -4;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -8;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -9;
	}	

	FREE_OBJECT(ifname);
	return retu;
}
#endif

/*未使用*/
/*state为"enable"或"disable"*/
int set_wtp_sta_static_arp_enable_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *wlan_id,char *state,char *if_name)
																										 	/*返回0表示失败，返回1表示成功*/
																										    /*返回-1表示unknown id format*/
																										    /*返回-2表示wlan id should be 1 to WLAN_NUM-1*/
																										    /*返回-3表示input patameter only with 'enable' or 'disable'*/
																											/*返回-4表示interface no exist*/
																										    /*返回-5表示error，返回-6表示Radio ID非法*/
																											/*返回-7表示illegal input:Input exceeds the maximum value of the parameter type*/
																											/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{	
	if(NULL == connection)
		return 0;
	
	if((NULL == wlan_id)||(NULL == state)||(NULL == if_name))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_wtp_sta_static_arp_enable_cmd_group(parameter,connection,0,RID,wlan_id,state,if_name,&RadioList_Head);
	if(retu == -8)
	{
		Free_set_wtp_sta_static_arp_enable_cmd_group(RadioList_Head);
	}
	return retu;
#else
	int ret;
	unsigned int radioid = 0;
    int policy = 0;
	unsigned char wlanid;
	char *ifname;
	int retu;
	
	ret = parse_char_ID((char*)wlan_id, &wlanid);
	if(ret != WID_DBUS_SUCCESS){
		if(ret == WID_ILLEGAL_INPUT){
			retu = -7;
		}
		else{
			retu = -1;
		}
		return retu;
	}	
	if(wlanid >= WLAN_NUM || wlanid == 0){
		return -2;
	}
	
	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -3;
	}
	ifname = malloc(strlen(if_name)+1);
	if(ifname)
	{
		memset(ifname, 0, strlen(if_name)+1);
		memcpy(ifname, if_name, strlen(if_name));
	}

		
	radioid = RID;
	if(radioid > G_RADIO_NUM || radioid == 0){
		syslog(LOG_DEBUG,"radio id in set_wtp_sta_static_arp_enable_cmd is %d\n",radioid);
		if(ifname){
			free(ifname);
			ifname = NULL;
		}
		return -6;
    }

	int(*dcli_init_func)(
							int ,
							int ,
							int ,
							unsigned char ,
							unsigned int ,
							char * , 
							DBusConnection *
						);

	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_wlan_wtp_sta_static_arp");
		if(NULL != dcli_init_func)
		{
			ret =(*dcli_init_func)
				  (
					 parameter.local_id,
					 parameter.instance_id,
					 policy,
					 wlanid,
					 radioid,
					 ifname,
					 connection
				  );
			
			if(ifname){
				free(ifname);
				ifname = NULL;
			}
		}
		else
		{
			if(ifname){
				free(ifname);
				ifname = NULL;
			}
			return 0;
		}
	}
	else
	{
		if(ifname){
			free(ifname);
			ifname = NULL;
		}
		return 0;
	}
	
	if(ret == 0)
		retu = 1;
	else if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else if(ret == APPLY_IF_FAIL)
		retu = -4;
	else
		retu = -5;
	
	return retu; 
#endif	
}

#if _GROUP_POLICY
void Free_set_radio_11n_ampdu_able_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-12时，调用Free_set_radio_11n_ampdu_able_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*Type为"ampdu"或"amsdu"*/
/*state为"enable"或"disable"*/
int set_radio_11n_ampdu_able_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *Type,char *state,struct RadioList **RadioList_Head) 
																	/*返回0表示失败，返回1表示成功*/
																	/*返回-1表示input patameter only with 'enable' or 'disable'*/
																	/*返回-2表示radio id does not exist*/
																	/*返回-3表示radio is not binding wlan, please bind it first*/
																	/*返回-4表示radio is disable, please enable it first*/
																	/*返回-5表示radio mode is not 11n,don't support this op*/
																	/*返回-6表示error，返回-7表示Radio ID非法*/
																	/*返回-8表示input patameter only with 'ampdu' or 'amsdu'*/
																	/*返回-9表示amsdu switch is enable, please disable it first*/
																	/*返回-10表示ampdu switch is enable, please disable it first*/
																	/*返回-11表示Group ID非法，返回-12表示partial failure*/
																	/*返回-13表示group id does not exist*/
{
	if(NULL == connection)
		return 0;

	if((NULL == Type)||(NULL == state))
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int TYPE = 0;
	unsigned char type = 0;
	unsigned char policy = 0;
	int retu = 0;
		
    if (!strcmp(Type,"ampdu"))
	{
		type = 1;	
	}
	else if (!strcmp(Type,"amsdu"))
	{
		type = 2;	
	}
	else
	{
		return -8;
	}

	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -1;
	}

	id = group_id;
	TYPE = group_type;
	if(TYPE == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_radio_11n_ampdu_able_cmd_group is %d\n",id);
			return -7;
		}
	}
	else if(TYPE == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_radio_11n_ampdu_able_cmd_group is %d\n",id);
			return -11;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								unsigned char ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_11n_ampdu_able_cmd_11n");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 TYPE,
								 id,
								 policy,
								 type,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(TYPE==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -2;
		else if(ret == RADIO_NO_BINDING_WLAN)
			retu = -3;
		else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
			retu = -3;
		else if(ret == RADIO_IS_DISABLE)
			retu = -4;
		else if(ret == RADIO_MODE_IS_11N)
			retu = -5;
		else if(ret == RADIO_11N_AMSDU_MUTEX)
			retu = -9;
		else if(ret == RADIO_11N_AMPDU_MUTEX)
			retu = -10;
		else
			retu = -6;
	}
	else if(TYPE==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(TYPE == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -12;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -13;
	}
	return retu;
}
#endif

/*Type为"ampdu"或"amsdu"*/
/*state为"enable"或"disable"*/
int set_radio_11n_ampdu_able_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *Type,char *state) 
																						 /*返回0表示失败，返回1表示成功*/
																					     /*返回-1表示input patameter only with 'enable' or 'disable'*/
																					     /*返回-2表示radio id does not exist*/
																					     /*返回-3表示radio is not binding wlan, please bind it first*/
																					     /*返回-4表示radio is disable, please enable it first*/
																						 /*返回-5表示radio mode is not 11n,don't support this op*/
																						 /*返回-6表示error，返回-7表示Radio ID非法*/
																						 /*返回-8表示input patameter only with 'ampdu' or 'amsdu'*/
																						 /*返回-9表示amsdu switch is enable, please disable it first*/
																						 /*返回-10表示ampdu switch is enable, please disable it first*/
																						 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
		return 0;
	
	if((NULL == Type)||(NULL == state))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_radio_11n_ampdu_able_cmd_group(parameter,connection,0,RID,Type,state,&RadioList_Head);
	if(retu == -12)
	{
		Free_set_radio_11n_ampdu_able_cmd_group(RadioList_Head);
	}
	return retu;
#else
	unsigned int radio_id; 
	int ret;
	unsigned char policy = 0;
	unsigned char type = 0;
	int retu = 0;

    if (!strcmp(Type,"ampdu"))
	{
		type = 1;	
	}
	else if (!strcmp(Type,"amsdu"))
	{
		type = 2;	
	}
	else
	{
		return -8;
	}

	if (!strcmp(state,"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0;	
	}
	else
	{
		return -1;
	}

			
	radio_id = RID;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in set_radio_11n_ampdu_able_cmd is %d\n",radio_id);
		return -7;
    }
	
	int(*dcli_init_func)(
							int ,
							int ,
							unsigned char ,
							unsigned int ,
							unsigned char ,
							DBusConnection *
						);

	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_radio_11n_set_ampdu_able");
		if(NULL != dcli_init_func)
		{
			ret =(*dcli_init_func)
				  (
					 parameter.local_id,
					 parameter.instance_id,
					 policy,
					 radio_id,
					 type,
					 connection
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(ret == 0)
		retu = 1;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu = -2;
	else if(ret == RADIO_NO_BINDING_WLAN)
		retu = -3;
	else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
		retu = -3;
	else if(ret == RADIO_IS_DISABLE)
		retu = -4;
	else if(ret == RADIO_MODE_IS_11N)
		retu = -5;
    else if(ret == RADIO_11N_AMSDU_MUTEX)
		retu = -9;
    else if(ret == RADIO_11N_AMPDU_MUTEX)
		retu = -10;
    else if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else
		retu = -6;

	return retu;
#endif	
}

#if _GROUP_POLICY
void Free_set_radio_11n_ampdu_limit_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-12时，调用Free_set_radio_11n_ampdu_limit_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*Type为"ampdu"或"amsdu"*/
/*value的范围是ampdu:1024-65535 amsdu:2290-4096*/
int set_radio_11n_ampdu_limit_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *Type,char *value,struct RadioList **RadioList_Head)
																/*返回0表示失败，返回1表示成功*/
																/*返回-1表示input patameter error*/
																/*返回-2表示input patameter error,ampdu limit should be 1024-65535*/
																/*返回-3表示radio id does not exist*/
																/*返回-4表示radio is not binding wlan, please bind it first*/
																/*返回-5表示radio is disable, please enable it first*/
																/*返回-6表示radio mode is not 11n,don't support this op*/
																/*返回-7表示error，返回-8表示Radio ID非法*/
																/*返回-9表示input patameter only with 'ampdu' or 'amsdu'*/
																/*返回-10表示input patameter error,amsdu limit should be 2290-4096*/
																/*返回-11表示Group ID非法，返回-12表示partial failure*/
																/*返回-13表示group id does not exist*/
{	
	if(NULL == connection)
		return 0;

	if((NULL == Type)||(NULL == value))
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int TYPE = 0;
	unsigned char type = 0;
	unsigned int limit = 0;
	int retu = 0;

    if (!strcmp(Type,"ampdu"))
	{
		type = 1;	
	}
	else if (!strcmp(Type,"amsdu"))
	{
		type = 2;	
	}
	else
	{
		return -9;
	}
	
	ret = parse_int_ID((char *)value,&limit);
	if(ret != 0){
		return -1;
	}
	else if(ret == 0)
	{
    	if((type == 1)&&((limit<1024)||(limit>65535)))
    	{
    		return -2;
    	}
    	else if((type == 2)&&((limit<2290)||(limit>4096)))
    	{
    		return -10;
    	}
	}

	id = group_id;
	TYPE = group_type;
	if(TYPE == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_radio_11n_ampdu_limit_cmd_group is %d\n",id);
			return -8;
		}
	}
	else if(TYPE == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_radio_11n_ampdu_limit_cmd_group is %d\n",id);
			return -11;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_11n_ampdu_limit_cmd_11n");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 TYPE,
								 id,
								 limit,
								 type,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}	

	if(TYPE==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -3;
		else if(ret == RADIO_NO_BINDING_WLAN)
			retu = -4;
		else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
			retu = -4;
		else if(ret == RADIO_IS_DISABLE)
			retu = -5;
		else if(ret == RADIO_MODE_IS_11N)
			retu = -6;
		else
			retu = -7;
	}
	else if(TYPE==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(TYPE == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -12;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -13;
	}
	return retu;
}
#endif

/*Type为"ampdu"或"amsdu"*/
/*value的范围是ampdu:1024-65535 amsdu:2290-4096*/
int set_radio_11n_ampdu_limit_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *Type,char *value)
																						 /*返回0表示失败，返回1表示成功*/
																					     /*返回-1表示input patameter error*/
																					     /*返回-2表示input patameter error,ampdu limit should be 1024-65535*/
																					     /*返回-3表示radio id does not exist*/
																					     /*返回-4表示radio is not binding wlan, please bind it first*/
																						 /*返回-5表示radio is disable, please enable it first*/
																						 /*返回-6表示radio mode is not 11n,don't support this op*/
																						 /*返回-7表示error，返回-8表示Radio ID非法*/
																						 /*返回-9表示input patameter only with 'ampdu' or 'amsdu'*/
																						 /*返回-10表示input patameter error,amsdu limit should be 2290-4096*/
																						 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
		return 0;
	
	if((NULL == Type)||(NULL == value))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_radio_11n_ampdu_limit_cmd_group(parameter,connection,0,RID,Type,value,&RadioList_Head);
	if(retu == -12)
	{
		Free_set_radio_11n_ampdu_limit_cmd_group(RadioList_Head);
	}
	return retu;
#else
	unsigned int radio_id; 
	unsigned int limit;
	int ret;
	unsigned char type = 0;
	int retu = 0;

    if (!strcmp(Type,"ampdu"))
	{
		type = 1;	
	}
	else if (!strcmp(Type,"amsdu"))
	{
		type = 2;	
	}
	else
	{
		return -9;
	}
	
	ret = parse_int_ID((char *)value,&limit);
	if(ret != 0){
		return -1;
	}	
	else if(ret == 0)
	{
    	if((type == 1)&&((limit<1024)||(limit>65535)))
    	{
    		return -2;
    	}
    	else if((type == 2)&&((limit<2290)||(limit>4096)))
    	{
    		return -10;
    	}
	}
	
		
	radio_id = RID;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in set_radio_11n_ampdu_limit_cmd is %d\n",radio_id);
		return -8;
    }
	
	int(*dcli_init_func)(
							int ,
							int ,
							unsigned int ,
							unsigned int ,
							unsigned char ,
							DBusConnection *
						);

	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_radio_11n_set_ampdu_limit");
		if(NULL != dcli_init_func)
		{
			ret =(*dcli_init_func)
				  (
					 parameter.local_id,
					 parameter.instance_id,
					 radio_id,
					 limit,
					 type,
					 connection
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(ret == 0)
		retu = 1;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu = -3;
	else if(ret == RADIO_NO_BINDING_WLAN)
		retu = -4;
	else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
		retu = -4;
	else if(ret == RADIO_IS_DISABLE)
		retu = -5;
	else if(ret == RADIO_MODE_IS_11N)
		retu = -6;
	else if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else
		retu = -7;

	return retu;
#endif
}

#if _GROUP_POLICY
void Free_set_radio_11n_ampdu_subframe_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-11时，调用Free_set_radio_11n_ampdu_subframe_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*Type为"ampdu"或"amsdu"*/
/*value的范围是2-64*/
int set_radio_11n_ampdu_subframe_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *Type,char *value,struct RadioList **RadioList_Head)
															/*返回0表示失败，返回1表示成功*/
															/*返回-1表示input patameter only with 'ampdu' or 'amsdu'*/
															/*返回-2表示input patameter error*/
															/*返回-3表示input patameter error,limit should be 2-64*/
															/*返回-4表示Radio ID非法，返回-5表示radio id does not exist*/
															/*返回-6表示radio is not binding wlan, please bind it first*/
															/*返回-7表示radio is disable, please enable it first*/
															/*返回-8表示radio mode is not 11n,don't support this op，返回-9表示error*/
															/*返回-10表示Group ID非法，返回-11表示partial failure*/
															/*返回-12表示group id does not exist*/
{
	if(NULL == connection)
		return 0;

	if((NULL == Type)||(NULL == value))
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int TYPE = 0;
	unsigned int limit = 0;
	unsigned char type = 0;
	int retu = 0;
		
    if (!strcmp(Type,"ampdu"))
	{
		type = 1;	
	}
	else if (!strcmp(Type,"amsdu"))
	{
		type = 2;	
	}
	else
	{
		return -1;
	}
	
	ret = parse_int_ID((char *)value,&limit);
	if(ret != 0){
		return -2;
	}
	else if((ret == 0)&&((limit<2)||(limit>64))){
		return -3;
	}

	id = group_id;
	TYPE = group_type;
	if(TYPE == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_radio_11n_ampdu_subframe_cmd_group is %d\n",id);
			return -9;
		}
	}
	else if(TYPE == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_radio_11n_ampdu_subframe_cmd_group is %d\n",id);
			return -10;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								unsigned char ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_11n_ampdu_subframe_cmd_11n");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 TYPE,
								 id,
								 limit,
								 type,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(TYPE==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -5;
		else if(ret == RADIO_NO_BINDING_WLAN)
			retu = -6;
		else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
			retu = -6;
		else if(ret == RADIO_IS_DISABLE)
			retu = -7;
		else if(ret == RADIO_MODE_IS_11N)
			retu = -8;
		else
			retu = -9;
	}
	else if(TYPE==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(TYPE == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -11;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -12;
	}
	return retu;
}
#endif

/*Type为"ampdu"或"amsdu"*/
/*value的范围是2-64*/
int set_radio_11n_ampdu_subframe_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *Type,char *value)
																							 /*返回0表示失败，返回1表示成功*/
																						     /*返回-1表示input patameter only with 'ampdu' or 'amsdu'*/
																						     /*返回-2表示input patameter error*/
																						     /*返回-3表示input patameter error,limit should be 2-64*/
																						     /*返回-4表示Radio ID非法，返回-5表示radio id does not exist*/
																							 /*返回-6表示radio is not binding wlan, please bind it first*/
																							 /*返回-7表示radio is disable, please enable it first*/
																							 /*返回-8表示radio mode is not 11n,don't support this op，返回-9表示error*/
																							 /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
		return 0;
	
	if((NULL == Type)||(NULL == value))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_radio_11n_ampdu_subframe_cmd_group(parameter,connection,0,RID,Type,value,&RadioList_Head);
	if(retu == -11)
	{
		Free_set_radio_11n_ampdu_subframe_cmd_group(RadioList_Head);
	}
	return retu;
#else
	unsigned int radio_id; 
	unsigned int limit;
	int ret;
	unsigned char type = 0;
	int retu = 0;

    if (!strcmp(Type,"ampdu"))
	{
		type = 1;	
	}
	else if (!strcmp(Type,"amsdu"))
	{
		type = 2;	
	}
	else
	{
		return -1;
	}
	
	ret = parse_int_ID((char *)value,&limit);
	if(ret != 0){
		return -2;
	}
	else if((ret == 0)&&((limit<2)||(limit>64))){
		return -3;
	}

		
	radio_id = RID;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in set_radio_11n_ampdu_subframe_cmd is %d\n",radio_id);
		return -4;
    }
	
	int(*dcli_init_func)(
							int ,
							int ,
							unsigned int ,
							unsigned char ,
							unsigned char , 
							DBusConnection *
						);

	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_radio_11n_set_ampdu_subframe");
		if(NULL != dcli_init_func)
		{
			ret =(*dcli_init_func)
				  (
					 parameter.local_id,
					 parameter.instance_id,
					 radio_id,
					 limit,
					 type,
					 connection
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(ret == 0)
		retu = 1;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu = -5;
	else if(ret == RADIO_NO_BINDING_WLAN)
		retu = -6;
	else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
		retu = -6;
	else if(ret == RADIO_IS_DISABLE)
		retu = -7;
	else if(ret == RADIO_MODE_IS_11N)
		retu = -8;
	else if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else
		retu = -9;

	return retu;
#endif
}

#if _GROUP_POLICY
void Free_set_radio_11n_puren_mixed_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-11时，调用Free_set_radio_11n_puren_mixed_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*workmode为"puren"或"mixed"*/
int set_radio_11n_puren_mixed_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *wlan_id,char *workmode,struct RadioList **RadioList_Head)
															/*返回0表示失败，返回1表示成功*/
															/*返回-1表示input patameter error*/
															/*返回-2表示input patameter only with 'puren' or 'mixed'*/
															/*返回-3表示radio id does not exist*/
															/*返回-4表示radio is not binding wlan, please bind it first*/
															/*返回-5表示radio is disable, please enable it first*/
															/*返回-6表示radio mode is not 11n,don't support this op*/
															/*返回-7表示error，返回-8表示Radio ID非法*/
															/*返回-9表示illegal input:Input exceeds the maximum value of the parameter type*/
															/*返回-10表示Group ID非法，返回-11表示partial failure*/
															/*返回-12表示group id does not exist*/
{
	if(NULL == connection)
		return 0;

	if((NULL == wlan_id)||(NULL == workmode))
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned char policy = 0;
	unsigned char WLANID = 0;
	int retu = 0;
		
	ret = parse_char_ID((char *)wlan_id,&WLANID);
	if((ret != 0)||(WLANID<=0)){
		if(ret == WID_ILLEGAL_INPUT){
			retu = -9;
        }
		else{
			retu = -1;
		}
		return retu;
	}else{}
	
	if (!strcmp(workmode,"puren"))
	{
		policy = 1;	
	}
	else if (!strcmp(workmode,"mixed"))
	{
		policy = 0;	
	}
	else
	{
		return -2;
	}

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_radio_11n_puren_mixed_cmd_group is %d\n",id);
			return -8;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_radio_11n_puren_mixed_cmd_group is %d\n",id);
			return -10;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								unsigned char ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_11n_puren_mixed_cmd_wlan_VALUE_workmode");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 policy,
								 WLANID,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}	

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -3;
		else if(ret == RADIO_NO_BINDING_WLAN)
			retu = -4;
		else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
			retu = -4;
		else if(ret == RADIO_IS_DISABLE)
			retu = -5;
		else if(ret == RADIO_MODE_IS_11N)
			retu = -6;
		else
			retu = -7;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -11;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -12;
	}
	return retu;
}
#endif

/*workmode为"puren"或"mixed"*/
int set_radio_11n_puren_mixed_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *wlan_id,char *workmode)
																							   /*返回0表示失败，返回1表示成功*/
																						       /*返回-1表示input patameter error*/
																						       /*返回-2表示input patameter only with 'puren' or 'mixed'*/
																						       /*返回-3表示radio id does not exist*/
																						       /*返回-4表示radio is not binding wlan, please bind it first*/
																							   /*返回-5表示radio is disable, please enable it first*/
																							   /*返回-6表示radio mode is not 11n,don't support this op*/
																							   /*返回-7表示error，返回-8表示Radio ID非法*/
																							   /*返回-9表示illegal input:Input exceeds the maximum value of the parameter type*/
																							   /*返回-10表示now radio mode is an or gn, belong to puren,you can set it to mixed*/
																							   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
		return 0;
	
	if((NULL == wlan_id)||(NULL == workmode))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_radio_11n_puren_mixed_cmd_group(parameter,connection,0,RID,wlan_id,workmode,&RadioList_Head);
	if(retu == -11)
	{
		Free_set_radio_11n_puren_mixed_cmd_group(RadioList_Head);
	}
	return retu;
#else
	unsigned int radio_id; 
	int ret;
	unsigned char policy = 0;
	unsigned char WLANID;
	int retu;
	
	ret = parse_char_ID((char *)wlan_id,&WLANID);
	if((ret != 0)||(WLANID<=0)){
		if(ret == WID_ILLEGAL_INPUT){
				retu = -9;
            }
			else{
				retu = -1;
			}
		return retu;
	}else{}
	
	if (!strcmp(workmode,"puren"))
	{
		policy = 1;	
	}
	else if (!strcmp(workmode,"mixed"))
	{
		policy = 0;	
	}
	else
	{
		return -2;
	}

		
	radio_id = RID;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in set_radio_11n_puren_mixed_cmd is %d\n",radio_id);
		return -8;
    }
	
	int(*dcli_init_func)(
							int ,
							int ,
							unsigned char ,
							unsigned char ,
							unsigned int ,
							DBusConnection *
						);

	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_radio_11n_set_mixed_puren_switch");
		if(NULL != dcli_init_func)
		{
			ret =(*dcli_init_func)
				  (
					 parameter.local_id,
					 parameter.instance_id,
					 policy,
					 WLANID,
					 radio_id,
					 connection
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == 0)
		retu = 1;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu = -3;
	else if(ret == RADIO_NO_BINDING_WLAN)
		retu = -4;
	else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
		retu = -4;
	else if(ret == RADIO_IS_DISABLE)
		retu = -5;
	else if(ret == RADIO_MODE_IS_11N)
		retu = -6;
	else if(ret == WID_DBUS_ERROR)
		retu = -10;
	else if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else
		retu = -7;

	return retu;
#endif	
}

#if 0
/*未使用*/
/*state为"enable"或"disable"*/
int set_tx_chainmask_cmd(int instance_id,int RID,char *list,char *state)/*返回0表示失败，返回1表示成功*/
																			  /*返回-1表示input patameter only with 'enable' or 'disable'*/
																			  /*返回-2表示input parameter only should be 0,1,2, one or more of them,such as 1,2 or 0,2*/
																			  /*返回-3表示radio id does not exist，返回-4表示radio not support this command*/
																			  /*返回-5表示error，返回-6表示Radio ID非法*/
{
	if((NULL == list)||(NULL == state))
		return 0;
	
	unsigned int radio_id; 
	unsigned int wlanid = 0; 
	int policy = 0;
	int ret = 0;
	unsigned char hex_id = 0;
	int retu;
	
	ret = parse_radio_tx_chainmask_list((char*)list,&hex_id);

	if (!strcmp(state,"enable"))
	{
		policy = 1; 
	}
	else if (!strcmp(state,"disable"))
	{
		policy = 0; 
	}
	else
	{
		return -1;
	}
	
	if (ret != WID_DBUS_SUCCESS)
	{	
		return -2;
	}
	
	int index;
	/*if(vty->node == RADIO_NODE){
		index = 0;			
		radio_id = (int)vty->index;
	}else if(vty->node == HANSI_RADIO_NODE){
		index = vty->index; 		
		radio_id = (int)vty->index_sub;
	}*/
	index = instance_id;			
	radio_id = RID;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in set_tx_chainmask_cmd is %d\n",radio_id);
		return -6;
    }
	
	int(*dcli_init_func)(
							int ,
							int ,
							int ,
							unsigned char ,
							unsigned int ,
							char* ,
							char* ,
							DBusConnection *
						);

	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"radio_set_method_functiontwo");
		if(NULL != dcli_init_func)
		{
			ret =(*dcli_init_func)
				  (
					index,
					radio_id,
					wlanid,
					hex_id,
					policy,
					NULL,
					WID_DBUS_RADIO_TX_CHAINMASK_SET_CMD,
					ccgi_dbus_connection
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
	
	if(ret == -1)
		retu = 0;
	else if(ret == 0)
		retu = 1;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu = -3;
	else if(ret == RADIO_NOT_SUPPORT_COMMAND)
		retu = -4;
	else
		retu = -5;

	return retu;
}
#endif

#if _GROUP_POLICY
void Free_set_radio_11n_channel_offset_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-12时，调用Free_set_radio_11n_channel_offset_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*state为"up"或"down"*/
int set_radio_11n_channel_offset_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *state,struct RadioList **RadioList_Head)
				/*返回0表示失败，返回1表示成功，返回-1表示input patameter only with 'enable' or 'down'*/
				/*返回-2表示radio id does not exist，返回-3表示radio is not binding wlan, please bind it first*/			
				/*返回-4表示radio is disable, please enable it first，返回-5表示radio mode is not 11n,don't support this op*/
				/*返回-6表示error，返回-7表示Radio ID非法，返回-8表示radio channel bandwidth is not 40,don't support this op*/
			    /*返回-9表示the current radio channel is larger than the max channel,you are not allowed to set channel offset up*/
				/*返回-10表示the current radio channel is less than the min channel ,you are not allowed to set channel offset down*/
				/*返回-11表示Group ID非法，返回-12表示partial failure，返回-13表示group id does not exist*/
				/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
		return 0;

	if(NULL == state)
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned char policy = 0;
	unsigned int type = 0;
	int retu = 0;
		
	if (!strcmp(state,"up"))
	{
		policy = 1; 
	}
	/*else if (!strcmp(state,"none"))
	{
		policy = 0; 
	}*/
	else if (!strcmp(state,"down"))
	{
		policy = -1; 
	}
	else
	{
		return -1;
	}


	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_radio_11n_channel_offset_cmd_group is %d\n",id);
			return -7;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_radio_11n_channel_offset_cmd_group is %d\n",id);
			return -11;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								int *,
								unsigned int *
							);

	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_11n_channel_offset_cmd_channel_offset");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 policy,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == 0)
			retu = 1;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -2;
		else if(ret == RADIO_NO_BINDING_WLAN)
			retu = -3;
		else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
			retu = -3;
		else if(ret == RADIO_IS_DISABLE)
			retu = -4;
		else if(ret == RADIO_MODE_IS_11N)
			retu = -5;
		else if(ret == RADIO_HT_IS_NOT_40)
			retu = -8;
		else if(ret == -1)
			retu = SNMPD_CONNECTION_ERROR;
		else
			retu = -6;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -12;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if(ret == -1)
			retu = SNMPD_CONNECTION_ERROR;
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -13;
	}
	return retu;
}
#endif

/*state为"up"或"down"*/
int set_radio_11n_channel_offset_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *state)
																				/*返回0表示失败，返回1表示成功，返回-1表示input patameter only with 'enable' or 'down'*/
																				/*返回-2表示radio id does not exist，返回-3表示radio is not binding wlan, please bind it first*/			
																				/*返回-4表示radio is disable, please enable it first，返回-5表示radio mode is not 11n,don't support this op*/
																				/*返回-6表示error，返回-7表示Radio ID非法，返回-8表示radio channel bandwidth is not 40,don't support this op*/
																			    /*返回-9表示the current radio channel is larger than the max channel,you are not allowed to set channel offset up!Please turn down channel*/
																				/*返回-10表示the current radio channel is less than the min channel ,you are not allowed to set channel offset down!Please turn up channel*/
																				/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
		return 0;
	
	if(NULL == state)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_radio_11n_channel_offset_cmd_group(parameter,connection,0,RID,state,&RadioList_Head);
	if(retu == -12)
	{
		Free_set_radio_11n_channel_offset_cmd_group(RadioList_Head);
	}
	return retu;
#else
	unsigned int radio_id = 0; 
	char policy = 0;
	int ret = 0;
	unsigned int max_channel = 0;
	unsigned int min_channel = 0;
	unsigned char current_channel = 0;
	int retu;
	
	if (!strcmp(state,"up"))
	{
		policy = 1; 
	}
	else if (!strcmp(state,"down"))
	{
		policy = -1; 
	}
	else
	{
		return -1;
	}

	
	radio_id = RID;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in set_radio_11n_channel_offset_cmd is %d\n",radio_id);
		return -7;
    }
	
	int(*dcli_init_func)(
							int ,
							int ,
							unsigned int ,
							char ,
							int *,
							unsigned int *,
							unsigned int *,
							unsigned char *,
							DBusConnection *
						);

	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"dcli_radio_11n_channel_offset");
		if(NULL != dcli_init_func)
		{
			(*dcli_init_func)
				  (
					 parameter.local_id,
					 parameter.instance_id,
					 radio_id,
					 policy,
					 &ret,
					 &max_channel,
					 &min_channel,
					 &current_channel,
					 connection
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == 0)
		retu = 1;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu = -2;
	else if(ret == RADIO_NO_BINDING_WLAN)
		retu = -3;
	else if(ret==WTP_IS_NOT_BINDING_WLAN_ID)
		retu = -3;
	else if(ret == RADIO_IS_DISABLE)
		retu = -4;
	else if(ret == RADIO_MODE_IS_11N)
		retu = -5;	
	else if(ret == RADIO_HT_IS_NOT_40)
		retu = -8;	
	else if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;	
	else if(ret == CHANNEL_CWMODE_HT40)
	{
		if(1 == policy)
		{
			retu = -9;
		}
		else if(-1 == policy)
		{
			retu = -10;
		}
	}
	else
		retu = -6;

	return retu;
#endif
}

#if _GROUP_POLICY
void Free_set_tx_chainmask_v2_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-11时，调用Free_set_tx_chainmask_v2_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
/*Type为"tx_chainmask"或"rx_chainmask"*/
/*value为"1.0.0","0.1.0","1.1.0","0.0.1","1.0.1","0.1.1"或"1.1.1"*/
int set_tx_chainmask_v2_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *Type,char *value,struct RadioList **RadioList_Head)
		/*返回0表示失败，返回1表示成功，返回-1表示input patameter only with '0.0.1','0.1.0','0.1.1','1.0.0','1.0.1','1.1.0' or '1.1.1'*/
		/*返回-2表示radio id does not exist，返回-3表示radio not support this command*/			
		/*返回-4表示radio mode is not 11N ,don't support this command，返回-5表示error，返回-6表示Radio ID非法*/
		/*返回-7表示input patameter only with 'tx_chainmask' or 'rx_chainmask'*/
		/*返回-8表示radio chainmask number is 1, don't support this value*/
		/*返回-9表示radio chainmask number is 2, don't support this value*/
		/*返回-10表示Group ID非法，返回-11表示partial failure，返回-12表示group id does not exist*/
		/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
		return 0;

	if((NULL == Type)||(NULL == value))
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int TYPE = 0;
	unsigned char policy = 0;
	unsigned char type = 0;
	int retu = 0;

    /* check para 1 */
    if (!strcmp(Type,"tx_chainmask"))
	{
		type = 1; 
	}
	else if (!strcmp(Type,"rx_chainmask"))
	{
		type = 2; 
	}
	else
	{
		return -7;
	}

    /* check para 2 */
	if (!strcmp(value,"0.0.1"))
	{
		policy = 1; 
	}
	else if (!strcmp(value,"0.1.0"))
	{
		policy = 2; 
	}
	else if (!strcmp(value,"0.1.1"))
	{
		policy = 3; 
	}
	else if (!strcmp(value,"1.0.0"))
	{
		policy = 4; 
	}
	else if (!strcmp(value,"1.0.1"))
	{
		policy = 5; 
	}
	else if (!strcmp(value,"1.1.0"))
	{
		policy = 6; 
	}
	else if (!strcmp(value,"1.1.1"))
	{
		policy = 7; 
	}
	else
	{
		return -1;
	}


	id = group_id;
	TYPE = group_type;
	if(TYPE == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_tx_chainmask_v2_cmd_group is %d\n",id);
			return -6;
		}
	}
	else if(TYPE == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_tx_chainmask_v2_cmd_group is %d\n",id);
			return -10;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned char ,
								unsigned char ,
								int *,
								int *
							);
	
	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_tx_chainmask_v2_cmd_tx_chainmask_rx_chainmask");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 TYPE,
								 id,
								 policy,
								 type,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}	

	if(TYPE==0)
	{
		if(ret == -1)
			retu = SNMPD_CONNECTION_ERROR;
		else if(ret == 0)
			retu = 1;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -2;
		else if(ret == RADIO_NOT_SUPPORT_COMMAND)
			retu = -3;
		else if(ret == RADIO_MODE_IS_11N)
			retu = -4;
		else if(ret == RADIO_CHAINMASK_NUM_1)
			retu = -8;
		else if(ret == RADIO_CHAINMASK_NUM_2)
			retu = -9;
		else
			retu = -5;
	}
	else if(TYPE==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(TYPE == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -11;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -12;
		else if (ret == -1)
			retu = SNMPD_CONNECTION_ERROR;
	}
//	dbus_message_unref(reply);
	return retu;
}
#endif

/*Type为"tx_chainmask"或"rx_chainmask"*/
/*value为"1.0.0","0.1.0","1.1.0","0.0.1","1.0.1","0.1.1"或"1.1.1"*/
int set_tx_chainmask_v2_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *Type,char *value)
																				  /*返回0表示失败，返回1表示成功，返回-1表示input patameter only with '0.0.1','0.1.0','0.1.1','1.0.0','1.0.1','1.1.0' or '1.1.1'*/
																				  /*返回-2表示radio id does not exist，返回-3表示radio not support this command*/			
																				  /*返回-4表示radio mode is not 11N ,don't support this command，返回-5表示error，返回-6表示Radio ID非法*/
																				  /*返回-7表示input patameter only with 'tx_chainmask' or 'rx_chainmask'*/
																				  /*返回-8表示radio chainmask number is 1, don't support this value*/
																				  /*返回-9表示radio chainmask number is 2, don't support this value*/
																				  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
		return 0;
	
	if((NULL == Type)||(NULL == value))
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_tx_chainmask_v2_cmd_group(parameter,connection,0,RID,Type,value,&RadioList_Head);
	if(retu == -11)
	{
		Free_set_tx_chainmask_v2_cmd_group(RadioList_Head);
	}
	return retu;
#else
	unsigned int radio_id; 
	unsigned char policy = 0;
	unsigned char type = 0;	
	int ret = 0;
	int retu = 0;	

    /* check para 1 */
    if (!strcmp(Type,"tx_chainmask"))
	{
		type = 1; 
	}
	else if (!strcmp(Type,"rx_chainmask"))
	{
		type = 2; 
	}
	else
	{
		return -7;
	}

    /* check para 2 */	
	if (!strcmp(value,"0.0.1"))
	{
		policy = 1; 
	}
	else if (!strcmp(value,"0.1.0"))
	{
		policy = 2; 
	}
	else if (!strcmp(value,"0.1.1"))
	{
		policy = 3; 
	}
	else if (!strcmp(value,"1.0.0"))
	{
		policy = 4; 
	}
	else if (!strcmp(value,"1.0.1"))
	{
		policy = 5; 
	}
	else if (!strcmp(value,"1.1.0"))
	{
		policy = 6; 
	}
	else if (!strcmp(value,"1.1.1"))
	{
		policy = 7; 
	}	
	else
	{
		return -1;
	}
	
		
	radio_id = RID;
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio id in set_tx_chainmask_v2_cmd is %d\n",radio_id);
		return -6;
    }
	
	int(*dcli_init_func)(
							int ,
							int ,
							unsigned int ,
							unsigned char ,
							unsigned char ,
							DBusConnection *
						);

	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"radio_set_method_chainmask");
		if(NULL != dcli_init_func)
		{
			ret =(*dcli_init_func)
				  (
					 parameter.local_id,
					 parameter.instance_id,
					 radio_id,
					 policy,
					 type,
					 connection
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}
		
	if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else if(ret == 0)
		retu = 1;
	else if(ret == RADIO_ID_NOT_EXIST)
		retu = -2;
	else if(ret == RADIO_NOT_SUPPORT_COMMAND)
		retu = -3;
	else if(ret == RADIO_MODE_IS_11N)
		retu = -4;	
	else if(ret == RADIO_CHAINMASK_NUM_1)
		retu = -8;
	else if(ret == RADIO_CHAINMASK_NUM_2)
		retu = -9;
	else
		retu = -5;
	
//	dbus_message_unref(reply);
	return retu;
#endif
}

#if _GROUP_POLICY
void Free_set_radio_txpowerstep_cmd_group(struct RadioList *RadioList_Head)
{
	void (*dcli_init_free_func)(struct RadioList *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_RadioList");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(RadioList_Head);
		}
	}
}

/*返回-7时，调用Free_set_radio_txpowerstep_cmd_group()释放空间*/
/*group_type为1，表示组配置*/
/*group_type为0，表示单独配置*/
int set_radio_txpowerstep_cmd_group(dbus_parameter parameter, DBusConnection *connection,int group_type,int group_id,char *txp_step,struct RadioList **RadioList_Head)
										/*返回0表示失败，返回1表示成功*/
										/*返回-1表示Input exceeds the maximum value of the parameter type*/
										/*返回-2表示unknown id format，返回-3表示RADIO ID非法*/			
										/*返回-4表示radio id does not exist，返回-5表示this radio is not binding wlan,binding wlan first*/
										/*返回-6表示Group ID非法，返回-7表示partial failure，返回-8表示group id does not exist*/
										/*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
		return 0;

	if(NULL == txp_step)
	{
		*RadioList_Head = NULL;
		return 0;
	}
	
	int ret = 0;
	int count = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned short txpowerstep = 0;
	int retu = 0;

	ret = parse_short_ID((char *)txp_step,&txpowerstep);
	if(ret != WID_DBUS_SUCCESS){
	    if(ret == WID_ILLEGAL_INPUT){
			retu = -1;
	    }
		else{
			retu = -2;
		}
		return retu;
	}	

	id = group_id;
	type = group_type;
	if(type == 0)
	{
		if(id > G_RADIO_NUM || id == 0){
			syslog(LOG_DEBUG,"radio id in set_radio_txpowerstep_cmd_group is %d\n",id);
			return -3;
		}
	}
	else if(type == 1)
	{
		if(id >= WTP_GROUP_NUM || id == 0){
			syslog(LOG_DEBUG,"group id in set_radio_txpowerstep_cmd_group is %d\n",id);
			return -6;
		}
	}

	void *(*dcli_init_func)(
								int ,
								int ,
								DBusConnection *,
								unsigned int ,
								unsigned int ,
								unsigned short ,
								int *,
								unsigned int *
							);
	
	*RadioList_Head = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_txpowerstep_cmd_txpowerstep");
		if(NULL != dcli_init_func)
		{
			*RadioList_Head =(*dcli_init_func)
							  (
								 parameter.local_id,
								 parameter.instance_id,
								 connection,
								 type,
								 id,
								 txpowerstep,
								 &count,
								 &ret
							  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(type==0)
	{
		if(ret == -1)
			retu = SNMPD_CONNECTION_ERROR;
		else if(ret == 0)
			retu = 1;
		else if(ret == RADIO_ID_NOT_EXIST)
			retu = -4;
		else if(ret == RADIO_NO_BINDING_WLAN)
			retu = -5;
	}
	else if(type==1)
	{
		if(ret == 0)
		{
			retu = 1;
			if((count != 0)&&(type == 1)&&(*RadioList_Head!=NULL))
			{
				retu = -7;
				/*vty_out(vty,"radio ");					
				for(i=0; i<count; i++)
				{
					if(Radio_Show_Node == NULL)
						Radio_Show_Node = RadioList_Head->RadioList_list;
					else 
						Radio_Show_Node = Radio_Show_Node->next;
					if(Radio_Show_Node == NULL)
						break;
					vty_out(vty,"%d ",Radio_Show_Node->RadioId);					
				}
				vty_out(vty," failed.\n");*/
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
			retu = -8;
	}
	return retu;
}
#endif

int set_radio_txpowerstep_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *txp_step)
																		   /*返回0表示失败，返回1表示成功*/
																		   /*返回-1表示Input exceeds the maximum value of the parameter type*/
																	       /*返回-2表示unknown id format，返回-3表示RADIO ID非法*/			
																	       /*返回-4表示radio id does not exist，返回-5表示this radio is not binding wlan,binding wlan first*/
																		   /*返回-9表示txpowerstep should > 0*/
																		   /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
		return 0;
	
	if(NULL == txp_step)
		return 0;
	
#if _GROUP_POLICY
	int retu = 0;
	struct RadioList *RadioList_Head = NULL;

	retu = set_radio_txpowerstep_cmd_group(parameter,connection,0,RID,txp_step,&RadioList_Head);
	if(retu == -7)
	{
		Free_set_radio_txpowerstep_cmd_group(RadioList_Head);
	}
	return retu;
#else
	unsigned int radio_id; 
	unsigned short txpowerstep;
	int ret = 0;

	int retu = 0;
	ret = parse_short_ID((char *)txp_step,&txpowerstep);
	if(txpowerstep == 0)
	{
		return -9;
	}
	if(ret != WID_DBUS_SUCCESS){
	    if(ret == WID_ILLEGAL_INPUT){
			retu = -1;
	    }
		else{
			retu = -2;
		}
		return retu;
	}	
		
	radio_id = RID;	
	if(radio_id > G_RADIO_NUM || radio_id == 0){
		syslog(LOG_DEBUG,"radio global id in set_radio_txpowerstep_cmd is %d\n",radio_id);
		return -3;
	}

	int(*dcli_init_func)(
							int ,
							int ,
							unsigned int ,
							unsigned short ,
							DBusConnection *
						);

	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"radio_set_txpower_step");
		if(NULL != dcli_init_func)
		{
			ret =(*dcli_init_func)
				  (
					 parameter.local_id,
					 parameter.instance_id,
					 radio_id,
					 txpowerstep,
					 connection
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1) 
	{
		retu = SNMPD_CONNECTION_ERROR;
	}
	else if(ret == 0)
	{
		retu = 1;
	}
	else if(ret == RADIO_ID_NOT_EXIST)
	{
		retu = -4;
	}
	else if(ret == RADIO_NO_BINDING_WLAN)
	{
		retu = -5;
	}

	return retu;
#endif	
}


void Free_show_all_wlan_ssid_stats_information_of_all_radio_cmd(struct SSIDStatsInfo *WtpHead)
{
	void (*dcli_init_free_func)(struct SSIDStatsInfo *);
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_free_func = dlsym(ccgi_dl_handle,"dcli_free_ssid_stats_Info");
		if(NULL != dcli_init_free_func)
		{
			dcli_init_free_func(WtpHead);
		}
	}
}

/*只要调用，就通过Free_show_all_wlan_ssid_stats_information_of_all_radio_cmd()释放空间*/
int show_all_wlan_ssid_stats_information_of_all_radio_cmd(dbus_parameter parameter, DBusConnection *connection,struct SSIDStatsInfo **WtpHead)
																								  /*返回0表示失败，返回1表示成功*/
																								  /*返回-1表示There is no WTP now*/
																								  /*返回-2表示error*/
																								  /*返回SNMPD_CONNECTION_ERROR表示connection error*/
{
	if(NULL == connection)
		return 0;

	int ret=0;
	unsigned int num = 0;
	int retu = 0;
	
	void*(*dcli_init_func)(
						int ,
						int ,
						DBusConnection *, 
						unsigned int *, 
						unsigned int *
						);

	*WtpHead = NULL;
	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"show_wtp_wlan_SSIDStatsInfo_of_all_wtp");
		if(NULL != dcli_init_func)
		{
			*WtpHead = (*dcli_init_func)
				(
					parameter.instance_id,
					parameter.local_id,
					connection, 
					&num, 
					&ret
				);
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if((*WtpHead!=NULL)&&(ret == 0))
		retu = 1;
	else if (ret == WID_DBUS_ERROR)
		retu = 0;
	else if(ret == WTP_ID_NOT_EXIST)
		retu = -1;
	else if(ret == -1)
		retu = SNMPD_CONNECTION_ERROR;
	else
		retu = -2;

	return retu;
}

/*Rssi的范围是0-95*/
int set_radio_wlan_limit_rssi_access_sta_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *wlan_id,char *Rssi)
																			/*返回0表示失败，返回1表示成功*/
																			/*返回-1表示unknown id format*/
																			/*返回-2表示wlan id should be 1 to WLAN_NUM-1*/
																			/*返回-3表示RSSI should be 0 to 95*/
																			/*返回-4表示RADIO ID非法*/			
																			/*返回-5表示radio id does not exist*/
																			/*返回-6表示wtp id does not exist*/
																			/*返回-7表示wlan id does not exist*/
																			/*返回-8表示bss id does not exist*/
																			/*返回-9表示wlan is not bind by this radio*/
{
	if(NULL == connection)
		return 0;
	
	if((NULL == wlan_id)||(NULL == Rssi))
		return 0;
	
	unsigned int radioid = 0;
	unsigned char wlanid = 0;
	unsigned char rssi =0;
	int ret = 0;
	int retu = 0;

	if((NULL == wlan_id)||(NULL == Rssi))
		return 0;
	
	ret = parse_char_ID((char *)wlan_id,&wlanid);
	if(ret != WID_DBUS_SUCCESS){
		return -1;
	}
	if(wlanid >= WLAN_NUM ||wlanid == 0){
		return -2;
	}

	ret = parse_char_ID((char *)Rssi,&rssi);
	if(ret != WID_DBUS_SUCCESS){
		return -1;
	}	
	if(rssi > 95 ||rssi < 0){
		return -3;
	}	

	radioid = RID;	
	if(radioid > G_RADIO_NUM || radioid == 0){
		syslog(LOG_DEBUG,"radio global id in set_radio_wlan_limit_rssi_access_sta_cmd is %d\n",radioid);
		return -4;
	}
	
	int(*dcli_init_func)(
							int ,
							int ,
							unsigned int ,
							unsigned char ,
							unsigned char ,
							DBusConnection *
						);

	if(NULL != ccgi_dl_handle)
	{
		dcli_init_func = dlsym(ccgi_dl_handle,"set_radio_wlan_limit_rssi_access_sta_set");
		if(NULL != dcli_init_func)
		{
			ret =(*dcli_init_func)
				  (
				  	 parameter.local_id,
					 parameter.instance_id,
					 radioid,
					 wlanid,
					 rssi,
					 connection
				  );
		}
		else
		{
			return 0;
		}
	}
	else
	{
		return 0;
	}

	if(ret == -1) 
		retu = 0;
	else if(ret == 0)
		retu = 1;
	else if(ret == WLAN_BE_DISABLE)
	{
		retu = 1;
		//vty_out(vty,"set radio wlan %d access sta limit rssi %d.\n",wlanid,rssi);
	  	//vty_out(vty,"Warning:now wlan is disable ,ap could not success\n");
	}
	else if(ret == RADIO_ID_NOT_EXIST)
		retu = -5;
	else if(ret == WTP_ID_NOT_EXIST)
		retu = -6;
	else if(ret ==WLAN_ID_NOT_EXIST)
		retu = -7;
	else if(ret == BSS_NOT_EXIST)
		retu = -8;
	else if(ret == Wlan_IF_NOT_BE_BINDED)
		retu = -9;

	return retu;    	
}

/*Switch的取值是"enable"或"disable"*/
int set_bss_multi_user_optimize_cmd(dbus_parameter parameter, DBusConnection *connection,int RID,char *wlanID,char *Switch)
																					/*返回0表示失败，返回1表示成功*/
																					/*返回-1表示input parameter error*/
																					/*返回-2表示wlanid should be 1 to WLAN_NUM-1*/
																					/*返回-3表示RADIO ID非法，返回-4表示bss not exist*/			
																					/*返回-5表示operation fail，返回-6表示wlan is not binded radio*/
																					/*返回-7表示error*/
{
	int ret = 0 ; 
	DBusMessage *query,*reply;
	DBusError err;
	DBusMessageIter iter;
	unsigned int radioid = 0 ; 
	unsigned char type = 0 ; 
	unsigned int wlan_id = 0; 
	unsigned char wlanid = 0 ;
	int retu = 0;

	if((NULL == connection)||(NULL == wlanID)||(NULL == Switch))
		return 0;
	
	ret = parse_int_ID((char *)wlanID,&wlan_id);    
	if(ret != WID_DBUS_SUCCESS)
	{
		return -1;
	}
	wlanid = (char)wlan_id;
	if((wlanid < 1 )||(wlanid > WLAN_NUM-1))
	{
		return -2;
	}
	if(!strcmp(Switch,"enable"))
	{
		type = 1; 
	}
	else if(!strcmp(Switch,"disable"))
	{
		type = 0 ; 
	}
	dbus_error_init(&err);
	
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	radioid = RID;	
	if(radioid > G_RADIO_NUM || radioid == 0){
		syslog(LOG_DEBUG,"radio global id in set_bss_multi_user_optimize_cmd is %d\n",radioid);
		return -3;
	}
	
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id, WID_DBUS_BUSNAME,BUSNAME);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id, WID_DBUS_RADIO_OBJPATH,OBJPATH);
	ccgi_ReInitDbusPath_v2(parameter.local_id, parameter.instance_id, WID_DBUS_RADIO_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_RADIO_METHOD_MOLTI_USER_OPTIMIZE_SWITH);
	dbus_message_append_args(query,
					DBUS_TYPE_BYTE,&wlanid,
					DBUS_TYPE_UINT32,&radioid,
					DBUS_TYPE_BYTE,&type,
					DBUS_TYPE_INVALID);
	reply = dbus_connection_send_with_reply_and_block (connection,query,-1, &err);
		
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return 0;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(WID_DBUS_SUCCESS == ret )
		retu = 1;
	else if(ret==WLAN_ID_NOT_EXIST) 	
		retu = -4;
	else if(ret==WID_DBUS_ERROR)
		retu = -5;
	else if(ret == Wlan_IF_NOT_BE_BINDED)
		retu = -6;
	else
		retu = -7;

	dbus_message_unref(reply);
	return retu;
}

#ifdef __cplusplus
}
#endif
   
   
   
