/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "dot11WtpVersionFileGroupUpdate.h"

#include "autelanWtpGroup.h"

#include "ws_dbus_def.h"
#include "ws_dbus_list_interface.h"

#include "wcpss/asd/asd.h"
#include "wcpss/wid/WID.h"
#include "dbus/wcpss/dcli_wid_wtp.h"
#include "dbus/wcpss/dcli_wid_wlan.h"


#define WTPGROUPUPDATEID   "2.15.6.1"
#define WTPVERSIONFILENAME  "2.15.6.2"

struct wtpGroupID_s { 
    unsigned long wtpid_start;
    unsigned long wtpid_end;

    struct wtpGroupID_s *next;
};

struct wtpGroupUpdate_s {
    struct wtpGroupID_s *wtpGroupID;
    char wtpVersionFileName[256];
};

static struct wtpGroupUpdate_s wtpGroupUpdateInfo = { 0 };
static char wtpGroupUpdateID[256] = { 0 };

static void
free_wtpGroupID_list(struct wtpGroupID_s **wtpGroupID) {
    if(NULL == wtpGroupID) {
        return ; 
    }

    while(*wtpGroupID) {
        struct wtpGroupID_s *temp_node = (*wtpGroupID)->next;
        free(*wtpGroupID);
        *wtpGroupID = temp_node;
    }

    return ;
}



static int
wtp_groupUpdateID_parse(char *group_id, struct wtpGroupID_s **wtpGroupID) {

    if(NULL == group_id || NULL == wtpGroupID) {
        return -1;
    }
    *wtpGroupID = NULL;
    
    char *temp_group_id = group_id;
    char *temp_string = NULL;    

    char temp[256] = { 0 } ;

    do {
        memset(temp, 0, sizeof(temp));

        temp_string = strchr(temp_group_id, ',');
        if(NULL == temp_string) {
            strncpy(temp, temp_group_id, MIN(sizeof(temp) - 1, strlen(temp_group_id)));
        }
        else if (1 == strlen(temp_string)) {
            snmp_log(LOG_DEBUG, "wtp_groupUpdateID_parse: the ',' can`t at the last string\n");
            return -1;
        }
        else {
            strncpy(temp, temp_group_id, MIN(sizeof(temp) - 1, temp_string - temp_group_id));
        }
        temp_group_id = temp_string + 1;

        
        struct wtpGroupID_s *temp_node = (struct wtpGroupID_s *)malloc(sizeof(struct wtpGroupID_s));
        if(NULL == temp_node) {
            snmp_log(LOG_DEBUG, "wtp_groupUpdateID_parse: malloc temp_node failed\n");            
            free_wtpGroupID_list(wtpGroupID);            
            return -1;
        }
        memset(temp_node, 0, sizeof(struct wtpGroupID_s));
        snmp_log(LOG_DEBUG, "wtp_groupUpdateID_parse: temp = %s\n", temp);
        if(strchr(temp, '-')) {
 
            if(2 != sscanf(temp, "%lu-%lu", &temp_node->wtpid_start, &temp_node->wtpid_end)) {                
                snmp_log(LOG_DEBUG, "wtp_groupUpdateID_parse: sscanf temp (%s) '%lu-%lu' fail\n", temp);            
                free(temp_node);                
                free_wtpGroupID_list(wtpGroupID);
                return -1;
            }
            
        } else {
            temp_node->wtpid_start = atoi(temp);  
            temp_node->wtpid_end = temp_node->wtpid_start;
        }

        if(0 == temp_node->wtpid_start || 0 == temp_node->wtpid_end || temp_node->wtpid_start > temp_node->wtpid_end 
            || (temp_node->wtpid_end % WIRELESS_MAX_NUM) > WTP_NUM || (temp_node->wtpid_start / WIRELESS_MAX_NUM) != (temp_node->wtpid_end / WIRELESS_MAX_NUM) 
            || (temp_node->wtpid_end - temp_node->wtpid_start) > WTP_NUM) {            
            snmp_log(LOG_DEBUG, "wtp_groupUpdateID_parse: the wtpid_start %d or wtpid_end %d is error\n", temp_node->wtpid_start, temp_node->wtpid_end);            
            free(temp_node);                
            free_wtpGroupID_list(wtpGroupID);
            return -1;
        }
        
        temp_node->next = *wtpGroupID;
        *wtpGroupID = temp_node;
    }while(temp_string);
    
    return 0;
}

/** Initializes the dot11WtpVersionFileGroupUpdate module */
void
init_dot11WtpVersionFileGroupUpdate(void)
{
    static oid wtpGroupUpdateID_oid[128] = { 0 };
    static oid wtpVersionFileName_oid[128] = { 0 };

  DEBUGMSGTL(("dot11WtpVersionFileGroupUpdate", "Initializing\n"));

    memset(&wtpGroupUpdateInfo, 0, sizeof(wtpGroupUpdateInfo));
    
	size_t public_oid_len   = 0;    
	
	mad_dev_oid(wtpGroupUpdateID_oid, WTPGROUPUPDATEID, &public_oid_len, enterprise_pvivate_oid);
	mad_dev_oid(wtpVersionFileName_oid, WTPVERSIONFILENAME, &public_oid_len, enterprise_pvivate_oid);
	
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("wtpGroupUpdateid", handle_wtpGroupUpdateID,
                               wtpGroupUpdateID_oid, public_oid_len,
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("wtpVersionFileName", handle_wtpVersionFileName,
                               wtpVersionFileName_oid, public_oid_len,
                               HANDLER_CAN_RWRITE
        ));
}

int
handle_wtpGroupUpdateID(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    snmp_log(LOG_DEBUG, "enter handle_wtpGroupUpdateID\n");
    
    switch(reqinfo->mode) {

        case MODE_GET:
            {     
                #if 0
                char wtpGroupUpdateID[128] = { 0 };
                
                if(0 == wtpGroupUpdateInfo.wtpid_start || 0 == wtpGroupUpdateInfo.wtpid_end || wtpGroupUpdateInfo.wtpid_start > wtpGroupUpdateInfo.wtpid_end 
                    || (wtpGroupUpdateInfo.wtpid_end % WIRELESS_MAX_NUM) > WTP_NUM || (wtpGroupUpdateInfo.wtpid_end - wtpGroupUpdateInfo.wtpid_start) > WTP_NUM) {
                    snmp_log(LOG_DEBUG, "handle_wtpGroupUpdateID: the wtpid_start(%d) and wtpid_end(%d) is error!\n", 
                                        wtpGroupUpdateInfo.wtpid_start, wtpGroupUpdateInfo.wtpid_end);
                }
                else {
                    snprintf(wtpGroupUpdateID, sizeof(wtpGroupUpdateID) - 1, "%lu-%lu", 
                                wtpGroupUpdateInfo.wtpid_start, wtpGroupUpdateInfo.wtpid_end);
                }
                #endif       
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                         (u_char *)wtpGroupUpdateID,
                                         strlen(wtpGroupUpdateID));
            }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            #if 0
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            #endif
            break;

        case MODE_SET_RESERVE2:
            #if 0
            /* XXX malloc "undo" storage buffer */
            if (/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            #endif
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            {            
                if(0 == requests->requestvb->val_len) {
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                    break;
                }                
                
                struct wtpGroupID_s *temp_list = NULL;
                if(wtp_groupUpdateID_parse(requests->requestvb->val.string, &temp_list)) {
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                    break;
                }
                
                free_wtpGroupID_list(&wtpGroupUpdateInfo.wtpGroupID);
                wtpGroupUpdateInfo.wtpGroupID = temp_list;
                
                snmp_log(LOG_DEBUG, "list group update id\n");
                struct wtpGroupID_s *temp_node = NULL;
                for(temp_node = wtpGroupUpdateInfo.wtpGroupID; temp_node; temp_node = temp_node->next) {
                    snmp_log(LOG_DEBUG, "wtp start id %d, wtp end id %d\n", temp_node->wtpid_start, temp_node->wtpid_end);
                }
                
                strncpy(wtpGroupUpdateID, requests->requestvb->val.string, sizeof(wtpGroupUpdateID) - 1);
                
            }
            break;

        case MODE_SET_COMMIT:
            #if 0
            /* XXX: delete temporary storage */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            #endif
            break;

        case MODE_SET_UNDO:
            #if 0
            /* XXX: UNDO and return to previous value for the object */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            #endif
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_wtpGroupUpdateID\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }
    
    snmp_log(LOG_DEBUG, "exit handle_wtpGroupUpdateID\n");

    return SNMP_ERR_NOERROR;
}
int
handle_wtpVersionFileName(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    snmp_log(LOG_DEBUG, "enter handle_wtpVersionFileName\n");
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     (u_char *)wtpGroupUpdateInfo.wtpVersionFileName,
                                     strlen(wtpGroupUpdateInfo.wtpVersionFileName));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            #if 0
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            #endif
            break;

        case MODE_SET_RESERVE2:
            #if 0
            /* XXX malloc "undo" storage buffer */
            if (/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            #endif
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            {
                char temp_version_file[256] = { 0 };
                char version[256] = {0};
                
                if(requests->requestvb->val_len) {
                    strncpy(temp_version_file, requests->requestvb->val.string, sizeof(temp_version_file) - 1);

                    unsigned int string_len = strlen(temp_version_file);
                    unsigned int start = 0, end = 0;
                    unsigned int k = 0, m = 0;
                    
                    for(start = 0; start < (string_len - 1); start++) {
                        if(temp_version_file[start] == '.') 
                            break;
                    }
                    
                    for(end = string_len - 1; end; end--) {
                        if(temp_version_file[end] == '.') 
                            break;
                    }
                    
                    for(k = start - 1; k < end; k++){  
                       version[m] = temp_version_file[k];
                       m++;
                    }
                }

                snmp_log(LOG_DEBUG, "temp_version_file = %s, version = %s\n", temp_version_file, version);
                
                struct wtpGroupID_s *temp_node = NULL;
                for(temp_node = wtpGroupUpdateInfo.wtpGroupID; NULL != temp_node; temp_node = temp_node->next) {

                    dbus_parameter parameter;
                    unsigned long local_wtpid_start = global_to_local_ID(&parameter, temp_node->wtpid_start, WIRELESS_MAX_NUM);
                    unsigned long local_wtpid_end = temp_node->wtpid_end % WIRELESS_MAX_NUM;

                    void *connection = NULL;
                    if(SNMPD_DBUS_SUCCESS != get_instance_dbus_connection(parameter, &connection, SNMPD_INSTANCE_MASTER_V3)) {
                        netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                        break;
                    }


                    int i = 0;
                    if(temp_version_file[0]) {
                        for(i = local_wtpid_start; i <= local_wtpid_end; i++) {
                            update_wtp_img_cmd_func(parameter, connection, i, temp_version_file, version, "now");
                        }
                        
                    }
                    else {                        
                        for(i = local_wtpid_start; i <= local_wtpid_end; i++) {
                            clear_wtp_img_cmd_func(parameter, connection, i);
                        }
                    }
                    
                }

                memset(wtpGroupUpdateInfo.wtpVersionFileName, 0, sizeof(wtpGroupUpdateInfo.wtpVersionFileName));
                strncpy(wtpGroupUpdateInfo.wtpVersionFileName, temp_version_file, sizeof(wtpGroupUpdateInfo.wtpVersionFileName) - 1);
            }
            break;

        case MODE_SET_COMMIT:
            #if 0
            /* XXX: delete temporary storage */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            #endif
            break;

        case MODE_SET_UNDO:
            #if 0
            /* XXX: UNDO and return to previous value for the object */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            #endif
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_wtpVersionFileName\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    snmp_log(LOG_DEBUG, "exit handle_wtpVersionFileName\n");

    return SNMP_ERR_NOERROR;
}
