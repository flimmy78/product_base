/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.8 2004/10/14 12:57:34 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "dot11ConfigSysLogServerGroup.h"
#include "ws_sysinfo.h"
#include "ws_init_dbus.h"
#include "mibs_public.h"
#include "ws_log_conf.h"
#include "ws_stp.h"
#include "wcpss/asd/asd.h"
#include "wcpss/wid/WID.h"
#include "dbus/wcpss/dcli_wid_wtp.h"
#include "dbus/wcpss/dcli_wid_wlan.h"
#include "ws_dcli_wlans.h"
#include "ws_dcli_ac.h"
#include "ws_log_conf.h"
#include "ws_dhcp_conf.h"

#include "autelanWtpGroup.h"

#define LOGSERVERADDR       "2.26.1"
#define LOGSERVERPORT    "2.26.2"
/** Initializes the dot11ConfigSysLogServerGroup module */
void
init_dot11ConfigSysLogServerGroup(void)
{
    static oid SyslogServerIPAddr_oid[128] = {0};
    static oid SyslogServerPort_oid[128] = {0};

  size_t public_oid_len   = 0;

  mad_dev_oid(SyslogServerIPAddr_oid,LOGSERVERADDR,&public_oid_len,enterprise_pvivate_oid);
  mad_dev_oid(SyslogServerPort_oid,LOGSERVERPORT,&public_oid_len,enterprise_pvivate_oid);
  DEBUGMSGTL(("dot11ConfigSysLogServerGroup", "Initializing\n"));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SyslogServerIPAddr", handle_SyslogServerIPAddr,
                               SyslogServerIPAddr_oid, public_oid_len,
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SyslogServerPort", handle_SyslogServerPort,
                               SyslogServerPort_oid, public_oid_len,
                               HANDLER_CAN_RWRITE
        ));
}

int
handle_SyslogServerIPAddr(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
		{
			//int acNTPConfig = 0;
			int ret = 0;
			ST_LOG_KEY logkey;

			memset(&logkey,0,sizeof(logkey));
			if(access(XML_FPATH,0)==0)
			{
				ret = find_log_node(XML_FPATH,NODE_DES,NODE_ATT,"sysip",NODE_CONTENT,&logkey);
				if(ret==0)
				{
					//INET_ATON(acNTPConfig, sname)
					//找到第一个ip地址。
					//char cmd_all[256];
					char get_ip[32];
					int ip_addr;


					//sprintf( cmd_all, LOG_CMD_FORMAT, logkey.key, "\\2","","" );
					//GET_CMD_STDOUT( get_ip, sizeof(get_ip), cmd_all );
					if(strcmp(logkey.key,"")!=0)
					{
						cut_up_ip( logkey.key,get_ip);
						INET_ATON(ip_addr,get_ip);

					}
					else
					{
						ip_addr=0;
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
												(u_char *)&ip_addr,
												sizeof(ip_addr));
				}	
				else
				{
					snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
												(u_char *)"UNKNOWN",
												strlen("UNKNOWN"));
				}
			}
			else
			{
				snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
											(u_char *)"UNKNOWN",
											strlen("UNKNOWN"));
			}
		 }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
          
            break;

        case MODE_SET_RESERVE2:         
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
		   {
				int ret = 0;
				ST_LOG_KEY logkey;

				memset(&logkey,0,sizeof(logkey));
				//ret=find_ntp_node(fpath,NTP_SERV,NODE_ATT,"1",NODE_VALUE,&sname);

				ret = find_log_node(XML_FPATH,NODE_DES,NODE_ATT,"sysip",NODE_CONTENT,&logkey);
				if(ret==0)
				{
					//找到第一个ip地址。
					//char cmd_all[256];
					char set_ip[32];
					int ip_addr;
					char cur_ip[32];
					char *temp;
					ST_SYS_ALL sysall;

					ip_addr = *requests->requestvb->val.integer;
					INET_NTOA( ip_addr, set_ip );
					//sprintf( cmd_all, LOG_CMD_FORMAT, logkey.key, "\\1",set_ip,"\\3" );
					//GET_CMD_STDOUT( logkey.key, sizeof(logkey.key), cmd_all );
					cut_up_ip( logkey.key,cur_ip);
					temp = replace_ip( logkey.key, cur_ip, set_ip);
					mod_log_node( XML_FPATH,NODE_DES,NODE_ATT,"sysip",NODE_CONTENT,temp);

					read_filter( XML_FPATH, NULL, &sysall);
					write_config( &sysall, CONF_FPATH);
					free(temp);
				}			
			}
            break;

        case MODE_SET_COMMIT:
          
            break;

        case MODE_SET_UNDO:
         
            break;

        default:
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_SyslogServerPort(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
        {
			ST_LOG_KEY * logkey;
			logkey = (ST_LOG_KEY *)malloc(sizeof(ST_LOG_KEY));
			memset(logkey,0,sizeof(ST_LOG_KEY));
			char *temp = (char *)malloc(10);
			memset(temp,0,10);
			int ret = 0;
			int port = 0;
			char *endptr = NULL;  
			
			if(access(XML_FPATH,0)==0)
			{
				ret = find_log_node(XML_FPATH,NODE_DES,NODE_ATT,"sysip",NODE_CONTENT,logkey);
				if(ret==0)
				{
					if(strcmp(logkey->key,"")!=0)
					{
						cut_up_port(logkey->key,temp);
					}
				}
			}
			port= strtoul(temp,&endptr,10);	 /*char转成int，10代表十进制*/
			
			snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
										(u_char *)&port,
										sizeof(port));
			
			free(temp);
			free(logkey);
		}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:          
            break;

        case MODE_SET_RESERVE2:          
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
          {	
			ST_LOG_KEY * logkey = NULL;
			if(NULL == logkey)
				break;
			
			logkey = (ST_LOG_KEY *)malloc(sizeof(ST_LOG_KEY));
			memset(logkey,0,sizeof(ST_LOG_KEY));
			char *port = (char *)malloc(10);
			memset(port,0,10);
			int ret = 0;
			char * temp = (char *)malloc(50);
			memset(temp,0,50);
			char *port_value = (char *)malloc(10);
			memset(port_value,0,10);
			if(access(XML_FPATH,0)!=0)
			{
				restart_syslog();
			}
			ret = find_log_node(XML_FPATH,NODE_DES,NODE_ATT,"sysip",NODE_CONTENT,logkey);
			if(ret==0)
			{
				if(strcmp(logkey->key,"")!=0)
				{
					cut_up_port(logkey->key,port); 
					sprintf(port_value,"%d",*requests->requestvb->val.integer);
					char *t = replace_ip(logkey->key,port,port_value);
					if(t)
					{
						memcpy(temp,t,strlen(t));
						free(t);
					}
					mod_log_node( XML_FPATH,NODE_DES,NODE_ATT,"sysip",NODE_CONTENT,temp);
				}
			}
			free(port);
			free(temp);
			free(logkey);
			free(port_value);
		  }
            break;

        case MODE_SET_COMMIT:         
            break;

        case MODE_SET_UNDO:          
            break;

        default:          
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
