/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.18.2.1 $ of : mfd-data-get.m2c,v $ 
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "dot11WtpWiredIfStatsTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement dot11WtpWiredIfStatsTable get routines.
 * TODO:240:M: Implement dot11WtpWiredIfStatsTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table dot11WtpWiredIfStatsTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * dot11WtpWiredIfStatsTable is subid 2 of wtpInterface.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.2, length: 12
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement dot11WtpWiredIfStatsTable data context functions.
 */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpInfoEntry.wtpMacAddr
 * wtpMacAddr is subid 1 of dot11WtpInfoEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.1.1.1.1
 * Description:
AP mac.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is Dot11BaseWtpIdTC (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max )
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpMacAddr.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpMacAddr_dot11WtpWiredIfStatsTable_map(char **mib_wtpMacAddr_val_ptr_ptr, size_t *mib_wtpMacAddr_val_ptr_len_ptr, char *raw_wtpMacAddr_val_ptr, size_t raw_wtpMacAddr_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpMacAddr_val_ptr);
    netsnmp_assert((NULL != mib_wtpMacAddr_val_ptr_ptr) && (NULL != mib_wtpMacAddr_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpMacAddr_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpMacAddr non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpMacAddr_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpMacAddr_val_ptr_ptr) || (*mib_wtpMacAddr_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpMacAddr_val_ptr_ptr = realloc( *mib_wtpMacAddr_val_ptr_ptr, converted_len * sizeof(**mib_wtpMacAddr_val_ptr_ptr));
        if(NULL == *mib_wtpMacAddr_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpMacAddr_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpMacAddr_val_ptr_ptr, raw_wtpMacAddr_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpMacAddr_map */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpIfEntry.wtpIfIndex
 * wtpIfIndex is subid 1 of dot11WtpIfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.1.1.1
 * Description:
The interface number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpIfIndex.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpIfIndex_wiredifstats_map(long *mib_wtpIfIndex_val_ptr, long raw_wtpIfIndex_val)
{
    netsnmp_assert(NULL != mib_wtpIfIndex_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpIfIndex_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpIfIndex mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpIfIndex_val_ptr) = raw_wtpIfIndex_val;

    return MFD_SUCCESS;
} /* wtpIfIndex_map */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
dot11WtpWiredIfStatsTable_indexes_set_tbl_idx(dot11WtpWiredIfStatsTable_mib_index *tbl_idx, char *wtpMacAddr_val_ptr,  size_t wtpMacAddr_val_ptr_len, long wtpIfIndex_val)
{
    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:dot11WtpWiredIfStatsTable_indexes_set_tbl_idx","called\n"));

    /* wtpMacAddr(1)/Dot11BaseWtpIdTC/ASN_OCTET_STR/char(char)//L/A/w/e/r/d/h */
     tbl_idx->wtpMacAddr_len = sizeof(tbl_idx->wtpMacAddr);
    /*
     * make sure there is enough space for wtpMacAddr data
     */
    if ((NULL == tbl_idx->wtpMacAddr) ||
        (tbl_idx->wtpMacAddr_len < (wtpMacAddr_val_ptr_len * sizeof(tbl_idx->wtpMacAddr[0])))) {
        snmp_log(LOG_ERR,"not enough space for value\n");
        return MFD_ERROR;
    }
    tbl_idx->wtpMacAddr_len = wtpMacAddr_val_ptr_len * sizeof(tbl_idx->wtpMacAddr[0]);
    memcpy( tbl_idx->wtpMacAddr, wtpMacAddr_val_ptr, tbl_idx->wtpMacAddr_len );
    
    /* wtpIfIndex(1)/INTEGER/ASN_INTEGER/long(long)//l/A/w/e/r/d/h */
    tbl_idx->wtpIfIndex = wtpIfIndex_val;
    

    return MFD_SUCCESS;
} /* dot11WtpWiredIfStatsTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
dot11WtpWiredIfStatsTable_indexes_set(dot11WtpWiredIfStatsTable_rowreq_ctx *rowreq_ctx, char *wtpMacAddr_val_ptr,  size_t wtpMacAddr_val_ptr_len, long wtpIfIndex_val)
{
    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:dot11WtpWiredIfStatsTable_indexes_set","called\n"));

    if(MFD_SUCCESS != dot11WtpWiredIfStatsTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
                                   , wtpMacAddr_val_ptr, wtpMacAddr_val_ptr_len
                                   , wtpIfIndex_val
           ))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if(0 != dot11WtpWiredIfStatsTable_index_to_oid(&rowreq_ctx->oid_idx,
                                    &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* dot11WtpWiredIfStatsTable_indexes_set */


/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWiredIfStatsEntry.wtpWiredifInUcastPkts
 * wtpWiredifInUcastPkts is subid 1 of dot11WtpWiredIfStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.2.1.1
 * Description:
Received the numbers of unicast packets.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWiredifInUcastPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWiredifInUcastPkts_map(u_long *mib_wtpWiredifInUcastPkts_val_ptr, u_long raw_wtpWiredifInUcastPkts_val)
{
    netsnmp_assert(NULL != mib_wtpWiredifInUcastPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifInUcastPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWiredifInUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWiredifInUcastPkts_val_ptr) = raw_wtpWiredifInUcastPkts_val;

    return MFD_SUCCESS;
} /* wtpWiredifInUcastPkts_map */

/**
 * Extract the current value of the wtpWiredifInUcastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWiredifInUcastPkts_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWiredifInUcastPkts_get( dot11WtpWiredIfStatsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWiredifInUcastPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWiredifInUcastPkts_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifInUcastPkts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWiredifInUcastPkts data.
 * set (* wtpWiredifInUcastPkts_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWiredifInUcastPkts_val_ptr ) = rowreq_ctx->data.wtpWiredifInUcastPkts;

    return MFD_SUCCESS;
} /* wtpWiredifInUcastPkts_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWiredIfStatsEntry.wtpWiredifInNUcastPkts
 * wtpWiredifInNUcastPkts is subid 2 of dot11WtpWiredIfStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.2.1.2
 * Description:
Received the numbers of non-unicast packets.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWiredifInNUcastPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWiredifInNUcastPkts_map(u_long *mib_wtpWiredifInNUcastPkts_val_ptr, u_long raw_wtpWiredifInNUcastPkts_val)
{
    netsnmp_assert(NULL != mib_wtpWiredifInNUcastPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifInNUcastPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWiredifInNUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWiredifInNUcastPkts_val_ptr) = raw_wtpWiredifInNUcastPkts_val;

    return MFD_SUCCESS;
} /* wtpWiredifInNUcastPkts_map */

/**
 * Extract the current value of the wtpWiredifInNUcastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWiredifInNUcastPkts_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWiredifInNUcastPkts_get( dot11WtpWiredIfStatsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWiredifInNUcastPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWiredifInNUcastPkts_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifInNUcastPkts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWiredifInNUcastPkts data.
 * set (* wtpWiredifInNUcastPkts_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWiredifInNUcastPkts_val_ptr ) = rowreq_ctx->data.wtpWiredifInNUcastPkts;

    return MFD_SUCCESS;
} /* wtpWiredifInNUcastPkts_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWiredIfStatsEntry.wtpWiredifInPkts
 * wtpWiredifInPkts is subid 3 of dot11WtpWiredIfStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.2.1.3
 * Description:
The total number of received packets.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWiredifInPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWiredifInPkts_map(u_long *mib_wtpWiredifInPkts_val_ptr, u_long raw_wtpWiredifInPkts_val)
{
    netsnmp_assert(NULL != mib_wtpWiredifInPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifInPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWiredifInPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWiredifInPkts_val_ptr) = raw_wtpWiredifInPkts_val;

    return MFD_SUCCESS;
} /* wtpWiredifInPkts_map */

/**
 * Extract the current value of the wtpWiredifInPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWiredifInPkts_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWiredifInPkts_get( dot11WtpWiredIfStatsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWiredifInPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWiredifInPkts_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifInPkts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWiredifInPkts data.
 * set (* wtpWiredifInPkts_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWiredifInPkts_val_ptr ) = rowreq_ctx->data.wtpWiredifInPkts;

    return MFD_SUCCESS;
} /* wtpWiredifInPkts_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWiredIfStatsEntry.wtpWiredifInDiscardPkts
 * wtpWiredifInDiscardPkts is subid 4 of dot11WtpWiredIfStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.2.1.4
 * Description:
Discarded packets received .
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWiredifInDiscardPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWiredifInDiscardPkts_map(u_long *mib_wtpWiredifInDiscardPkts_val_ptr, u_long raw_wtpWiredifInDiscardPkts_val)
{
    netsnmp_assert(NULL != mib_wtpWiredifInDiscardPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifInDiscardPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWiredifInDiscardPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWiredifInDiscardPkts_val_ptr) = raw_wtpWiredifInDiscardPkts_val;

    return MFD_SUCCESS;
} /* wtpWiredifInDiscardPkts_map */

/**
 * Extract the current value of the wtpWiredifInDiscardPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWiredifInDiscardPkts_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWiredifInDiscardPkts_get( dot11WtpWiredIfStatsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWiredifInDiscardPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWiredifInDiscardPkts_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifInDiscardPkts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWiredifInDiscardPkts data.
 * set (* wtpWiredifInDiscardPkts_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWiredifInDiscardPkts_val_ptr ) = rowreq_ctx->data.wtpWiredifInDiscardPkts;

    return MFD_SUCCESS;
} /* wtpWiredifInDiscardPkts_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWiredIfStatsEntry.wtpWiredifInErrors
 * wtpWiredifInErrors is subid 5 of dot11WtpWiredIfStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.2.1.5
 * Description:
Error packets received.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWiredifInErrors.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWiredifInErrors_map(u_long *mib_wtpWiredifInErrors_val_ptr, u_long raw_wtpWiredifInErrors_val)
{
    netsnmp_assert(NULL != mib_wtpWiredifInErrors_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifInErrors_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWiredifInErrors mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWiredifInErrors_val_ptr) = raw_wtpWiredifInErrors_val;

    return MFD_SUCCESS;
} /* wtpWiredifInErrors_map */

/**
 * Extract the current value of the wtpWiredifInErrors data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWiredifInErrors_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWiredifInErrors_get( dot11WtpWiredIfStatsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWiredifInErrors_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWiredifInErrors_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifInErrors_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWiredifInErrors data.
 * set (* wtpWiredifInErrors_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWiredifInErrors_val_ptr ) = rowreq_ctx->data.wtpWiredifInErrors;

    return MFD_SUCCESS;
} /* wtpWiredifInErrors_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWiredIfStatsEntry.wtpWiredifOutUcastPkts
 * wtpWiredifOutUcastPkts is subid 6 of dot11WtpWiredIfStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.2.1.6
 * Description:
The number of unicast packets sended.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWiredifOutUcastPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWiredifOutUcastPkts_map(u_long *mib_wtpWiredifOutUcastPkts_val_ptr, u_long raw_wtpWiredifOutUcastPkts_val)
{
    netsnmp_assert(NULL != mib_wtpWiredifOutUcastPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifOutUcastPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWiredifOutUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWiredifOutUcastPkts_val_ptr) = raw_wtpWiredifOutUcastPkts_val;

    return MFD_SUCCESS;
} /* wtpWiredifOutUcastPkts_map */

/**
 * Extract the current value of the wtpWiredifOutUcastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWiredifOutUcastPkts_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWiredifOutUcastPkts_get( dot11WtpWiredIfStatsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWiredifOutUcastPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWiredifOutUcastPkts_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifOutUcastPkts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWiredifOutUcastPkts data.
 * set (* wtpWiredifOutUcastPkts_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWiredifOutUcastPkts_val_ptr ) = rowreq_ctx->data.wtpWiredifOutUcastPkts;

    return MFD_SUCCESS;
} /* wtpWiredifOutUcastPkts_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWiredIfStatsEntry.wtpWiredifOutNUcastPkts
 * wtpWiredifOutNUcastPkts is subid 7 of dot11WtpWiredIfStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.2.1.7
 * Description:
The number of sent non-unicast packets.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWiredifOutNUcastPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWiredifOutNUcastPkts_map(u_long *mib_wtpWiredifOutNUcastPkts_val_ptr, u_long raw_wtpWiredifOutNUcastPkts_val)
{
    netsnmp_assert(NULL != mib_wtpWiredifOutNUcastPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifOutNUcastPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWiredifOutNUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWiredifOutNUcastPkts_val_ptr) = raw_wtpWiredifOutNUcastPkts_val;

    return MFD_SUCCESS;
} /* wtpWiredifOutNUcastPkts_map */

/**
 * Extract the current value of the wtpWiredifOutNUcastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWiredifOutNUcastPkts_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWiredifOutNUcastPkts_get( dot11WtpWiredIfStatsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWiredifOutNUcastPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWiredifOutNUcastPkts_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifOutNUcastPkts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWiredifOutNUcastPkts data.
 * set (* wtpWiredifOutNUcastPkts_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWiredifOutNUcastPkts_val_ptr ) = rowreq_ctx->data.wtpWiredifOutNUcastPkts;

    return MFD_SUCCESS;
} /* wtpWiredifOutNUcastPkts_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWiredIfStatsEntry.wtpWiredifOutPkts
 * wtpWiredifOutPkts is subid 8 of dot11WtpWiredIfStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.2.1.8
 * Description:
The total number of packets sent.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWiredifOutPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWiredifOutPkts_map(u_long *mib_wtpWiredifOutPkts_val_ptr, u_long raw_wtpWiredifOutPkts_val)
{
    netsnmp_assert(NULL != mib_wtpWiredifOutPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifOutPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWiredifOutPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWiredifOutPkts_val_ptr) = raw_wtpWiredifOutPkts_val;

    return MFD_SUCCESS;
} /* wtpWiredifOutPkts_map */

/**
 * Extract the current value of the wtpWiredifOutPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWiredifOutPkts_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWiredifOutPkts_get( dot11WtpWiredIfStatsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWiredifOutPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWiredifOutPkts_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifOutPkts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWiredifOutPkts data.
 * set (* wtpWiredifOutPkts_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWiredifOutPkts_val_ptr ) = rowreq_ctx->data.wtpWiredifOutPkts;

    return MFD_SUCCESS;
} /* wtpWiredifOutPkts_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWiredIfStatsEntry.wtpWiredifOutDiscardPkts
 * wtpWiredifOutDiscardPkts is subid 9 of dot11WtpWiredIfStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.2.1.9
 * Description:
The number to send the packet which discarded.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWiredifOutDiscardPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWiredifOutDiscardPkts_map(u_long *mib_wtpWiredifOutDiscardPkts_val_ptr, u_long raw_wtpWiredifOutDiscardPkts_val)
{
    netsnmp_assert(NULL != mib_wtpWiredifOutDiscardPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifOutDiscardPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWiredifOutDiscardPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWiredifOutDiscardPkts_val_ptr) = raw_wtpWiredifOutDiscardPkts_val;

    return MFD_SUCCESS;
} /* wtpWiredifOutDiscardPkts_map */

/**
 * Extract the current value of the wtpWiredifOutDiscardPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWiredifOutDiscardPkts_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWiredifOutDiscardPkts_get( dot11WtpWiredIfStatsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWiredifOutDiscardPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWiredifOutDiscardPkts_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifOutDiscardPkts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWiredifOutDiscardPkts data.
 * set (* wtpWiredifOutDiscardPkts_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWiredifOutDiscardPkts_val_ptr ) = rowreq_ctx->data.wtpWiredifOutDiscardPkts;

    return MFD_SUCCESS;
} /* wtpWiredifOutDiscardPkts_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWiredIfStatsEntry.wtpWiredifOutErrors
 * wtpWiredifOutErrors is subid 10 of dot11WtpWiredIfStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.2.1.10
 * Description:
The wrong number of packages which sent.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWiredifOutErrors.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWiredifOutErrors_map(u_long *mib_wtpWiredifOutErrors_val_ptr, u_long raw_wtpWiredifOutErrors_val)
{
    netsnmp_assert(NULL != mib_wtpWiredifOutErrors_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifOutErrors_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWiredifOutErrors mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWiredifOutErrors_val_ptr) = raw_wtpWiredifOutErrors_val;

    return MFD_SUCCESS;
} /* wtpWiredifOutErrors_map */

/**
 * Extract the current value of the wtpWiredifOutErrors data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWiredifOutErrors_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWiredifOutErrors_get( dot11WtpWiredIfStatsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWiredifOutErrors_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWiredifOutErrors_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifOutErrors_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWiredifOutErrors data.
 * set (* wtpWiredifOutErrors_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWiredifOutErrors_val_ptr ) = rowreq_ctx->data.wtpWiredifOutErrors;

    return MFD_SUCCESS;
} /* wtpWiredifOutErrors_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWiredIfStatsEntry.wtpWiredifUpDwnTimes
 * wtpWiredifUpDwnTimes is subid 11 of dot11WtpWiredIfStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.2.1.11
 * Description:
Wired interface updown times.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWiredifUpDwnTimes.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWiredifUpDwnTimes_map(u_long *mib_wtpWiredifUpDwnTimes_val_ptr, u_long raw_wtpWiredifUpDwnTimes_val)
{
    netsnmp_assert(NULL != mib_wtpWiredifUpDwnTimes_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifUpDwnTimes_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWiredifUpDwnTimes mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWiredifUpDwnTimes_val_ptr) = raw_wtpWiredifUpDwnTimes_val;

    return MFD_SUCCESS;
} /* wtpWiredifUpDwnTimes_map */

/**
 * Extract the current value of the wtpWiredifUpDwnTimes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWiredifUpDwnTimes_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWiredifUpDwnTimes_get( dot11WtpWiredIfStatsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWiredifUpDwnTimes_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWiredifUpDwnTimes_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifUpDwnTimes_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWiredifUpDwnTimes data.
 * set (* wtpWiredifUpDwnTimes_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWiredifUpDwnTimes_val_ptr ) = rowreq_ctx->data.wtpWiredifUpDwnTimes;

    return MFD_SUCCESS;
} /* wtpWiredifUpDwnTimes_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWiredIfStatsEntry.wtpWiredifInOctets
 * wtpWiredifInOctets is subid 12 of dot11WtpWiredIfStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.2.1.12
 * Description:
The total number of received bytes.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWiredifInOctets.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWiredifInOctets_map(u_long *mib_wtpWiredifInOctets_val_ptr, unsigned long long raw_wtpWiredifInOctets_val)
{
    netsnmp_assert(NULL != mib_wtpWiredifInOctets_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifInOctets_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWiredifInOctets mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWiredifInOctets_val_ptr) = raw_wtpWiredifInOctets_val;

    return MFD_SUCCESS;
} /* wtpWiredifInOctets_map */

/**
 * Extract the current value of the wtpWiredifInOctets data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWiredifInOctets_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWiredifInOctets_get( dot11WtpWiredIfStatsTable_rowreq_ctx *rowreq_ctx, unsigned long long * wtpWiredifInOctets_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWiredifInOctets_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifInOctets_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWiredifInOctets data.
 * set (* wtpWiredifInOctets_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWiredifInOctets_val_ptr ) = rowreq_ctx->data.wtpWiredifInOctets;

    return MFD_SUCCESS;
} /* wtpWiredifInOctets_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWiredIfStatsEntry.wtpWiredifOutOctets
 * wtpWiredifOutOctets is subid 13 of dot11WtpWiredIfStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.2.1.13
 * Description:
The total number of bytes sent.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWiredifOutOctets.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWiredifOutOctets_map(u_long *mib_wtpWiredifOutOctets_val_ptr, unsigned long long raw_wtpWiredifOutOctets_val)
{
    netsnmp_assert(NULL != mib_wtpWiredifOutOctets_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifOutOctets_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWiredifOutOctets mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWiredifOutOctets_val_ptr) = raw_wtpWiredifOutOctets_val;

    return MFD_SUCCESS;
} /* wtpWiredifOutOctets_map */

/**
 * Extract the current value of the wtpWiredifOutOctets data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWiredifOutOctets_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWiredifOutOctets_get( dot11WtpWiredIfStatsTable_rowreq_ctx *rowreq_ctx, unsigned long long * wtpWiredifOutOctets_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWiredifOutOctets_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifOutOctets_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWiredifOutOctets data.
 * set (* wtpWiredifOutOctets_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWiredifOutOctets_val_ptr ) = rowreq_ctx->data.wtpWiredifOutOctets;

    return MFD_SUCCESS;
} /* wtpWiredifOutOctets_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWiredIfStatsEntry.wtpWiredifInDataOctets
 * wtpWiredifInDataOctets is subid 14 of dot11WtpWiredIfStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.2.1.14
 * Description:
The number of received data bytes.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWiredifInDataOctets.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWiredifInDataOctets_map(u_long *mib_wtpWiredifInDataOctets_val_ptr, unsigned long long raw_wtpWiredifInDataOctets_val)
{
    netsnmp_assert(NULL != mib_wtpWiredifInDataOctets_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifInDataOctets_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWiredifInDataOctets mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWiredifInDataOctets_val_ptr) = raw_wtpWiredifInDataOctets_val;

    return MFD_SUCCESS;
} /* wtpWiredifInDataOctets_map */

/**
 * Extract the current value of the wtpWiredifInDataOctets data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWiredifInDataOctets_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWiredifInDataOctets_get( dot11WtpWiredIfStatsTable_rowreq_ctx *rowreq_ctx, unsigned long long * wtpWiredifInDataOctets_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWiredifInDataOctets_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifOutOctets_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWiredifOutOctets data.
 * set (* wtpWiredifOutOctets_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWiredifInDataOctets_val_ptr ) = rowreq_ctx->data.wtpWiredifInDataOctets;

    return MFD_SUCCESS;
} /* wtpWiredifOutOctets_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWiredIfStatsEntry.wtpWiredifOutDataOctets
 * wtpWiredifOutDataOctets is subid 15 of dot11WtpWiredIfStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.2.1.15
 * Description:
The  number of send data bytes.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWiredifOutDataOctets.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWiredifOutDataOctets_map(u_long *mib_wtpWiredifOutDataOctets_val_ptr, unsigned long long raw_wtpWiredifOutDataOctets_val)
{
    netsnmp_assert(NULL != mib_wtpWiredifOutDataOctets_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifOutDataOctets_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWiredifOutDataOctets mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWiredifOutDataOctets_val_ptr) = raw_wtpWiredifOutDataOctets_val;

    return MFD_SUCCESS;
} /* wtpWiredifOutDataOctets_map */

/**
 * Extract the current value of the wtpWiredifOutDataOctets data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWiredifOutDataOctets_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWiredifOutDataOctets_get( dot11WtpWiredIfStatsTable_rowreq_ctx *rowreq_ctx, unsigned long long * wtpWiredifOutDataOctets_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWiredifOutDataOctets_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWiredIfStatsTable:wtpWiredifOutOctets_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWiredifOutOctets data.
 * set (* wtpWiredifOutOctets_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWiredifOutDataOctets_val_ptr ) = rowreq_ctx->data.wtpWiredifOutDataOctets;

    return MFD_SUCCESS;
} /* wtpWiredifOutOctets_get */


/** @} */
