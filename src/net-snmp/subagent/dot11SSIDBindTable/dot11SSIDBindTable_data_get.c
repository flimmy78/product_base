/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.18.2.1 $ of : mfd-data-get.m2c,v $ 
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "dot11SSIDBindTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement dot11SSIDBindTable get routines.
 * TODO:240:M: Implement dot11SSIDBindTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table dot11SSIDBindTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * dot11SSIDBindTable is subid 4 of dot11wtpConfig.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.31656.6.1.2.12.4, length: 12
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement dot11SSIDBindTable data context functions.
 */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11SSIDBindEntry.NewWtpMac
 * NewWtpMac is subid 1 of dot11SSIDBindEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.12.4.1.1
 * Description:
 wtpMac.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewWtpMac.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewWtpMac_map(char **mib_NewWtpMac_val_ptr_ptr, size_t *mib_NewWtpMac_val_ptr_len_ptr, char *raw_NewWtpMac_val_ptr, size_t raw_NewWtpMac_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_NewWtpMac_val_ptr);
    netsnmp_assert((NULL != mib_NewWtpMac_val_ptr_ptr) && (NULL != mib_NewWtpMac_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11SSIDBindTable:NewWtpMac_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement NewWtpMac non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_NewWtpMac_val_ptr_len; /* assume equal */
    if((NULL == *mib_NewWtpMac_val_ptr_ptr) || (*mib_NewWtpMac_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_NewWtpMac_val_ptr_ptr = realloc( *mib_NewWtpMac_val_ptr_ptr, converted_len * sizeof(**mib_NewWtpMac_val_ptr_ptr));
        if(NULL == *mib_NewWtpMac_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_NewWtpMac_val_ptr_len_ptr = converted_len;
    memcpy( *mib_NewWtpMac_val_ptr_ptr, raw_NewWtpMac_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* NewWtpMac_map */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11SSIDBindEntry.NewInterface
 * NewInterface is subid 2 of dot11SSIDBindEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.12.4.1.2
 * Description:
Interface.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewInterface.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewInterface_map(long *mib_NewInterface_val_ptr, long raw_NewInterface_val)
{
    netsnmp_assert(NULL != mib_NewInterface_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11SSIDBindTable:NewInterface_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewInterface mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewInterface_val_ptr) = raw_NewInterface_val;

    return MFD_SUCCESS;
} /* NewInterface_map */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11SSIDBindEntry.NewWlanId
 * NewWlanId is subid 3 of dot11SSIDBindEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.12.4.1.3
 * Description:
Wlan Id.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewWlanId.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewWlanId_map(long *mib_NewWlanId_val_ptr, long raw_NewWlanId_val)
{
    netsnmp_assert(NULL != mib_NewWlanId_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11SSIDBindTable:NewWlanId_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewWlanId mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewWlanId_val_ptr) = raw_NewWlanId_val;

    return MFD_SUCCESS;
} /* NewWlanId_map */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
dot11SSIDBindTable_indexes_set_tbl_idx(dot11SSIDBindTable_mib_index *tbl_idx, char *NewWtpMac_val_ptr,  size_t NewWtpMac_val_ptr_len, long NewInterface_val, long NewWlanId_val)
{
    DEBUGMSGTL(("verbose:dot11SSIDBindTable:dot11SSIDBindTable_indexes_set_tbl_idx","called\n"));

    /* NewWtpMac(1)/DisplayString/ASN_OCTET_STR/char(char)//L/A/w/e/R/d/H */
     tbl_idx->NewWtpMac_len = sizeof(tbl_idx->NewWtpMac);
    /*
     * make sure there is enough space for NewWtpMac data
     */
    if ((NULL == tbl_idx->NewWtpMac) ||
        (tbl_idx->NewWtpMac_len < (NewWtpMac_val_ptr_len * sizeof(tbl_idx->NewWtpMac[0])))) {
        snmp_log(LOG_ERR,"not enough space for value\n");
        return MFD_ERROR;
    }
    tbl_idx->NewWtpMac_len = NewWtpMac_val_ptr_len * sizeof(tbl_idx->NewWtpMac[0]);
    memcpy( tbl_idx->NewWtpMac, NewWtpMac_val_ptr, tbl_idx->NewWtpMac_len );
    
    /* NewInterface(2)/INTEGER/ASN_INTEGER/long(long)//l/A/w/e/r/d/h */
    tbl_idx->NewInterface = NewInterface_val;
    
    /* NewWlanId(3)/INTEGER/ASN_INTEGER/long(long)//l/A/w/e/r/d/h */
    tbl_idx->NewWlanId = NewWlanId_val;
    

    return MFD_SUCCESS;
} /* dot11SSIDBindTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
dot11SSIDBindTable_indexes_set(dot11SSIDBindTable_rowreq_ctx *rowreq_ctx, char *NewWtpMac_val_ptr,  size_t NewWtpMac_val_ptr_len, long NewInterface_val, long NewWlanId_val)
{
    DEBUGMSGTL(("verbose:dot11SSIDBindTable:dot11SSIDBindTable_indexes_set","called\n"));

    if(MFD_SUCCESS != dot11SSIDBindTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
                                   , NewWtpMac_val_ptr, NewWtpMac_val_ptr_len
                                   , NewInterface_val
                                   , NewWlanId_val
           ))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if(0 != dot11SSIDBindTable_index_to_oid(&rowreq_ctx->oid_idx,
                                    &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* dot11SSIDBindTable_indexes_set */


/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11SSIDBindEntry.BssIDMac
 * BssIDMac is subid 4 of dot11SSIDBindEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.12.4.1.4
 * Description:
BssIDMac.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: 1x:
 *
 *
 * Its syntax is PhysAddress (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-BssIDMac.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
BssIDMac_map(char **mib_BssIDMac_val_ptr_ptr, size_t *mib_BssIDMac_val_ptr_len_ptr, char *raw_BssIDMac_val_ptr, size_t raw_BssIDMac_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_BssIDMac_val_ptr);
    netsnmp_assert((NULL != mib_BssIDMac_val_ptr_ptr) && (NULL != mib_BssIDMac_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11SSIDBindTable:BssIDMac_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement BssIDMac non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_BssIDMac_val_ptr_len; /* assume equal */
    if((NULL == *mib_BssIDMac_val_ptr_ptr) || (*mib_BssIDMac_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_BssIDMac_val_ptr_ptr = realloc( *mib_BssIDMac_val_ptr_ptr, converted_len * sizeof(**mib_BssIDMac_val_ptr_ptr));
        if(NULL == *mib_BssIDMac_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_BssIDMac_val_ptr_len_ptr = converted_len;
    memcpy( *mib_BssIDMac_val_ptr_ptr, raw_BssIDMac_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* BssIDMac_map */

/**
 * Extract the current value of the BssIDMac data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param BssIDMac_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param BssIDMac_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by BssIDMac.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*BssIDMac_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update BssIDMac_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
BssIDMac_get( dot11SSIDBindTable_rowreq_ctx *rowreq_ctx, char **BssIDMac_val_ptr_ptr, size_t *BssIDMac_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != BssIDMac_val_ptr_ptr) && (NULL != *BssIDMac_val_ptr_ptr));
   netsnmp_assert( NULL != BssIDMac_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11SSIDBindTable:BssIDMac_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the BssIDMac data.
 * set (* BssIDMac_val_ptr_ptr ) and (* BssIDMac_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for BssIDMac data
     */
    if ((NULL == (* BssIDMac_val_ptr_ptr )) ||
        ((* BssIDMac_val_ptr_len_ptr ) < (rowreq_ctx->data.BssIDMac_len * sizeof((* BssIDMac_val_ptr_ptr )[0])))) {
        /*
         * allocate space for BssIDMac data
         */
        (* BssIDMac_val_ptr_ptr ) = malloc(rowreq_ctx->data.BssIDMac_len * sizeof((* BssIDMac_val_ptr_ptr )[0]));
        if(NULL == (* BssIDMac_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* BssIDMac_val_ptr_len_ptr ) = rowreq_ctx->data.BssIDMac_len * sizeof((* BssIDMac_val_ptr_ptr )[0]);
    memcpy( (* BssIDMac_val_ptr_ptr ), rowreq_ctx->data.BssIDMac, (* BssIDMac_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* BssIDMac_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11SSIDBindEntry.BssIDBindRowStatus
 * BssIDBindRowStatus is subid 5 of dot11SSIDBindEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.4.1.31656.6.1.2.12.4.1.5
 * Description:
BssIDMac.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * Its syntax is RowStatus (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-BssIDBindRowStatus.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
BssIDBindRowStatus_map(u_long *mib_BssIDBindRowStatus_val_ptr, u_long raw_BssIDBindRowStatus_val)
{
    netsnmp_assert(NULL != mib_BssIDBindRowStatus_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11SSIDBindTable:BssIDBindRowStatus_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement BssIDBindRowStatus enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_BssIDBindRowStatus_val) {
        case INTERNAL_BSSIDBINDROWSTATUS_ACTIVE:
             *mib_BssIDBindRowStatus_val_ptr = ROWSTATUS_ACTIVE;
             break;

        case INTERNAL_BSSIDBINDROWSTATUS_NOTINSERVICE:
             *mib_BssIDBindRowStatus_val_ptr = ROWSTATUS_NOTINSERVICE;
             break;

        case INTERNAL_BSSIDBINDROWSTATUS_NOTREADY:
             *mib_BssIDBindRowStatus_val_ptr = ROWSTATUS_NOTREADY;
             break;

        case INTERNAL_BSSIDBINDROWSTATUS_CREATEANDGO:
             *mib_BssIDBindRowStatus_val_ptr = ROWSTATUS_CREATEANDGO;
             break;

        case INTERNAL_BSSIDBINDROWSTATUS_CREATEANDWAIT:
             *mib_BssIDBindRowStatus_val_ptr = ROWSTATUS_CREATEANDWAIT;
             break;

        case INTERNAL_BSSIDBINDROWSTATUS_DESTROY:
             *mib_BssIDBindRowStatus_val_ptr = ROWSTATUS_DESTROY;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for BssIDBindRowStatus\n", raw_BssIDBindRowStatus_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* BssIDBindRowStatus_map */

/**
 * Extract the current value of the BssIDBindRowStatus data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param BssIDBindRowStatus_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
BssIDBindRowStatus_get( dot11SSIDBindTable_rowreq_ctx *rowreq_ctx, u_long * BssIDBindRowStatus_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != BssIDBindRowStatus_val_ptr );

    (* BssIDBindRowStatus_val_ptr ) = rowreq_ctx->data.BssIDBindRowStatus;
    /*
     * TODO:245:o: |-> Implement dot11SSIDBindTable RowStatus mapping
     */
    /*
     * update INTERNAL_* macros defined in the header, if neccessary
     */
    switch ((* BssIDBindRowStatus_val_ptr )) {

        /* `active', which indicates that the conceptual row is
              available for use by the managed device */
    case INTERNAL_BSSIDBINDROWSTATUS_ACTIVE:
        (* BssIDBindRowStatus_val_ptr ) = ROWSTATUS_ACTIVE;
        break;

        /* `notInService', which indicates that the conceptual
                 row exists in the agent, but is unavailable for use by
                 the managed device (see NOTE below); 'notInService' has
                 no implication regarding the internal consistency of
                 the row, availability of resources, or consistency with
                 the current state of the managed device */
    case INTERNAL_BSSIDBINDROWSTATUS_NOTINSERVICE:
        (* BssIDBindRowStatus_val_ptr ) = ROWSTATUS_NOTINSERVICE;
        break;

        /* `notReady', which indicates that the conceptual row
                 exists in the agent, but is missing information
                 necessary in order to be available for use by the
                 managed device (i.e., one or more required columns in
                 the conceptual row have not been instanciated) */
    case INTERNAL_BSSIDBINDROWSTATUS_NOTREADY:
        (* BssIDBindRowStatus_val_ptr ) = ROWSTATUS_NOTREADY;
        break;

    default:
        snmp_log(LOG_ERR,
                 "couldn't map value %d for dAssignmentsRowStatus\n",
                 (* BssIDBindRowStatus_val_ptr ));
        return SNMP_ERR_GENERR;
    }


    return MFD_SUCCESS;
} /* BssIDBindRowStatus_get */



/** @} */
