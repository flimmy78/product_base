/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.18.2.1 $ of : mfd-data-get.m2c,v $ 
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "dot11WtpWirelessIfTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement dot11WtpWirelessIfTable get routines.
 * TODO:240:M: Implement dot11WtpWirelessIfTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table dot11WtpWirelessIfTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * dot11WtpWirelessIfTable is subid 3 of wtpInterface.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.3, length: 12
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement dot11WtpWirelessIfTable data context functions.
 */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpInfoEntry.wtpMacAddr
 * wtpMacAddr is subid 1 of dot11WtpInfoEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.1.1.1.1
 * Description:
AP mac.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is Dot11BaseWtpIdTC (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max )
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpMacAddr.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpMacAddr_dot11WtpWirelessIfTable_map(char **mib_wtpMacAddr_val_ptr_ptr, size_t *mib_wtpMacAddr_val_ptr_len_ptr, char *raw_wtpMacAddr_val_ptr, size_t raw_wtpMacAddr_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpMacAddr_val_ptr);
    netsnmp_assert((NULL != mib_wtpMacAddr_val_ptr_ptr) && (NULL != mib_wtpMacAddr_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpMacAddr_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpMacAddr non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpMacAddr_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpMacAddr_val_ptr_ptr) || (*mib_wtpMacAddr_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpMacAddr_val_ptr_ptr = realloc( *mib_wtpMacAddr_val_ptr_ptr, converted_len * sizeof(**mib_wtpMacAddr_val_ptr_ptr));
        if(NULL == *mib_wtpMacAddr_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpMacAddr_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpMacAddr_val_ptr_ptr, raw_wtpMacAddr_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpMacAddr_map */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWirelessIfEntry.wtpWirelessIfIndex
 * wtpWirelessIfIndex is subid 1 of dot11WtpWirelessIfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.3.1.1
 * Description:
Wireless interface index.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessIfIndex.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessIfIndex_dot11WtpWirelessIfTable_map(long *mib_wtpWirelessIfIndex_val_ptr, long raw_wtpWirelessIfIndex_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessIfIndex_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfIndex_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessIfIndex mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWirelessIfIndex_val_ptr) = raw_wtpWirelessIfIndex_val;

    return MFD_SUCCESS;
} /* wtpWirelessIfIndex_map */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
dot11WtpWirelessIfTable_indexes_set_tbl_idx(dot11WtpWirelessIfTable_mib_index *tbl_idx, char *wtpMacAddr_val_ptr,  size_t wtpMacAddr_val_ptr_len, long wtpWirelessIfIndex_val)
{
    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:dot11WtpWirelessIfTable_indexes_set_tbl_idx","called\n"));

    /* wtpMacAddr(1)/Dot11BaseWtpIdTC/ASN_OCTET_STR/char(char)//L/A/w/e/r/d/h */
     tbl_idx->wtpMacAddr_len = sizeof(tbl_idx->wtpMacAddr);
    /*
     * make sure there is enough space for wtpMacAddr data
     */
    if ((NULL == tbl_idx->wtpMacAddr) ||
        (tbl_idx->wtpMacAddr_len < (wtpMacAddr_val_ptr_len * sizeof(tbl_idx->wtpMacAddr[0])))) {
        snmp_log(LOG_ERR,"not enough space for value\n");
        return MFD_ERROR;
    }
    tbl_idx->wtpMacAddr_len = wtpMacAddr_val_ptr_len * sizeof(tbl_idx->wtpMacAddr[0]);
    memcpy( tbl_idx->wtpMacAddr, wtpMacAddr_val_ptr, tbl_idx->wtpMacAddr_len );
    
    /* wtpWirelessIfIndex(1)/INTEGER/ASN_INTEGER/long(long)//l/A/w/e/r/d/h */
    tbl_idx->wtpWirelessIfIndex = wtpWirelessIfIndex_val;
    

    return MFD_SUCCESS;
} /* dot11WtpWirelessIfTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
dot11WtpWirelessIfTable_indexes_set(dot11WtpWirelessIfTable_rowreq_ctx *rowreq_ctx, char *wtpMacAddr_val_ptr,  size_t wtpMacAddr_val_ptr_len, long wtpWirelessIfIndex_val)
{
    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:dot11WtpWirelessIfTable_indexes_set","called\n"));

    if(MFD_SUCCESS != dot11WtpWirelessIfTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
                                   , wtpMacAddr_val_ptr, wtpMacAddr_val_ptr_len
                                   , wtpWirelessIfIndex_val
           ))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if(0 != dot11WtpWirelessIfTable_index_to_oid(&rowreq_ctx->oid_idx,
                                    &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* dot11WtpWirelessIfTable_indexes_set */


/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWirelessIfEntry.wtpWirelessIfDescr
 * wtpWirelessIfDescr is subid 2 of dot11WtpWirelessIfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.3.1.2
 * Description:
The information that describe wireless interface(microFX/wireless side SSID).
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessIfDescr.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessIfDescr_map(char **mib_wtpWirelessIfDescr_val_ptr_ptr, size_t *mib_wtpWirelessIfDescr_val_ptr_len_ptr, char *raw_wtpWirelessIfDescr_val_ptr, size_t raw_wtpWirelessIfDescr_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpWirelessIfDescr_val_ptr);
    netsnmp_assert((NULL != mib_wtpWirelessIfDescr_val_ptr_ptr) && (NULL != mib_wtpWirelessIfDescr_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfDescr_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpWirelessIfDescr non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpWirelessIfDescr_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpWirelessIfDescr_val_ptr_ptr) || (*mib_wtpWirelessIfDescr_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpWirelessIfDescr_val_ptr_ptr = realloc( *mib_wtpWirelessIfDescr_val_ptr_ptr, converted_len * sizeof(**mib_wtpWirelessIfDescr_val_ptr_ptr));
        if(NULL == *mib_wtpWirelessIfDescr_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpWirelessIfDescr_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpWirelessIfDescr_val_ptr_ptr, raw_wtpWirelessIfDescr_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpWirelessIfDescr_map */

/**
 * Extract the current value of the wtpWirelessIfDescr data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessIfDescr_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wtpWirelessIfDescr_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wtpWirelessIfDescr.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wtpWirelessIfDescr_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wtpWirelessIfDescr_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wtpWirelessIfDescr_get( dot11WtpWirelessIfTable_rowreq_ctx *rowreq_ctx, char **wtpWirelessIfDescr_val_ptr_ptr, size_t *wtpWirelessIfDescr_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != wtpWirelessIfDescr_val_ptr_ptr) && (NULL != *wtpWirelessIfDescr_val_ptr_ptr));
   netsnmp_assert( NULL != wtpWirelessIfDescr_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfDescr_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessIfDescr data.
 * set (* wtpWirelessIfDescr_val_ptr_ptr ) and (* wtpWirelessIfDescr_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for wtpWirelessIfDescr data
     */
    if ((NULL == (* wtpWirelessIfDescr_val_ptr_ptr )) ||
        ((* wtpWirelessIfDescr_val_ptr_len_ptr ) < (rowreq_ctx->data.wtpWirelessIfDescr_len * sizeof((* wtpWirelessIfDescr_val_ptr_ptr )[0])))) {
        /*
         * allocate space for wtpWirelessIfDescr data
         */
        (* wtpWirelessIfDescr_val_ptr_ptr ) = malloc(rowreq_ctx->data.wtpWirelessIfDescr_len * sizeof((* wtpWirelessIfDescr_val_ptr_ptr )[0]));
        if(NULL == (* wtpWirelessIfDescr_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* wtpWirelessIfDescr_val_ptr_len_ptr ) = rowreq_ctx->data.wtpWirelessIfDescr_len * sizeof((* wtpWirelessIfDescr_val_ptr_ptr )[0]);
    memcpy( (* wtpWirelessIfDescr_val_ptr_ptr ), rowreq_ctx->data.wtpWirelessIfDescr, (* wtpWirelessIfDescr_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* wtpWirelessIfDescr_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWirelessIfEntry.wtpWirelessIfType
 * wtpWirelessIfType is subid 3 of dot11WtpWirelessIfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.3.1.3
 * Description:
Wireless interface type.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 1/8. Values:  Wifi(41)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessIfType.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessIfType_map(u_long *mib_wtpWirelessIfType_val_ptr, u_long raw_wtpWirelessIfType_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessIfType_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfType_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessIfType enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wtpWirelessIfType_val) {
        case INTERNAL_WTPWIRELESSIFTYPE_WIFI:
             *mib_wtpWirelessIfType_val_ptr = WTPWIRELESSIFTYPE_WIFI;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wtpWirelessIfType\n", raw_wtpWirelessIfType_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wtpWirelessIfType_map */

/**
 * Extract the current value of the wtpWirelessIfType data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessIfType_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelessIfType_get( dot11WtpWirelessIfTable_rowreq_ctx *rowreq_ctx, u_long * wtpWirelessIfType_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelessIfType_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfType_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessIfType data.
 * set (* wtpWirelessIfType_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWirelessIfType_val_ptr ) = rowreq_ctx->data.wtpWirelessIfType;

    return MFD_SUCCESS;
} /* wtpWirelessIfType_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWirelessIfEntry.wtpWirelessIfMTU
 * wtpWirelessIfMTU is subid 4 of dot11WtpWirelessIfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.3.1.4
 * Description:
Wireless interface MTU.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessIfMTU.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessIfMTU_map(long *mib_wtpWirelessIfMTU_val_ptr, long raw_wtpWirelessIfMTU_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessIfMTU_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfMTU_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessIfMTU mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWirelessIfMTU_val_ptr) = raw_wtpWirelessIfMTU_val;

    return MFD_SUCCESS;
} /* wtpWirelessIfMTU_map */

/**
 * Extract the current value of the wtpWirelessIfMTU data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessIfMTU_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelessIfMTU_get( dot11WtpWirelessIfTable_rowreq_ctx *rowreq_ctx, long * wtpWirelessIfMTU_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelessIfMTU_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfMTU_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessIfMTU data.
 * set (* wtpWirelessIfMTU_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWirelessIfMTU_val_ptr ) = rowreq_ctx->data.wtpWirelessIfMTU;

    return MFD_SUCCESS;
} /* wtpWirelessIfMTU_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWirelessIfEntry.wtpWirelessIfSpeed
 * wtpWirelessIfSpeed is subid 5 of dot11WtpWirelessIfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.3.1.5
 * Description:
Wireless interface speed(UNIT kbps).
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is GAUGE (based on perltype GAUGE)
 * The net-snmp type is ASN_GAUGE. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessIfSpeed.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessIfSpeed_map(u_long *mib_wtpWirelessIfSpeed_val_ptr, u_long raw_wtpWirelessIfSpeed_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessIfSpeed_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfSpeed_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessIfSpeed mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWirelessIfSpeed_val_ptr) = raw_wtpWirelessIfSpeed_val;

    return MFD_SUCCESS;
} /* wtpWirelessIfSpeed_map */

/**
 * Extract the current value of the wtpWirelessIfSpeed data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessIfSpeed_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelessIfSpeed_get( dot11WtpWirelessIfTable_rowreq_ctx *rowreq_ctx, u_long * wtpWirelessIfSpeed_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelessIfSpeed_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfSpeed_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessIfSpeed data.
 * set (* wtpWirelessIfSpeed_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWirelessIfSpeed_val_ptr ) = rowreq_ctx->data.wtpWirelessIfSpeed;

    return MFD_SUCCESS;
} /* wtpWirelessIfSpeed_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWirelessIfEntry.wtpWirelessIfPhysAddress
 * wtpWirelessIfPhysAddress is subid 6 of dot11WtpWirelessIfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.3.1.6
 * Description:
Wireless interface MAC address.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessIfPhysAddress.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessIfPhysAddress_map(char **mib_wtpWirelessIfPhysAddress_val_ptr_ptr, size_t *mib_wtpWirelessIfPhysAddress_val_ptr_len_ptr, char *raw_wtpWirelessIfPhysAddress_val_ptr, size_t raw_wtpWirelessIfPhysAddress_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpWirelessIfPhysAddress_val_ptr);
    netsnmp_assert((NULL != mib_wtpWirelessIfPhysAddress_val_ptr_ptr) && (NULL != mib_wtpWirelessIfPhysAddress_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfPhysAddress_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpWirelessIfPhysAddress non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpWirelessIfPhysAddress_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpWirelessIfPhysAddress_val_ptr_ptr) || (*mib_wtpWirelessIfPhysAddress_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpWirelessIfPhysAddress_val_ptr_ptr = realloc( *mib_wtpWirelessIfPhysAddress_val_ptr_ptr, converted_len * sizeof(**mib_wtpWirelessIfPhysAddress_val_ptr_ptr));
        if(NULL == *mib_wtpWirelessIfPhysAddress_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpWirelessIfPhysAddress_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpWirelessIfPhysAddress_val_ptr_ptr, raw_wtpWirelessIfPhysAddress_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpWirelessIfPhysAddress_map */

/**
 * Extract the current value of the wtpWirelessIfPhysAddress data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessIfPhysAddress_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wtpWirelessIfPhysAddress_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wtpWirelessIfPhysAddress.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wtpWirelessIfPhysAddress_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wtpWirelessIfPhysAddress_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wtpWirelessIfPhysAddress_get( dot11WtpWirelessIfTable_rowreq_ctx *rowreq_ctx, char **wtpWirelessIfPhysAddress_val_ptr_ptr, size_t *wtpWirelessIfPhysAddress_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != wtpWirelessIfPhysAddress_val_ptr_ptr) && (NULL != *wtpWirelessIfPhysAddress_val_ptr_ptr));
   netsnmp_assert( NULL != wtpWirelessIfPhysAddress_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfPhysAddress_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessIfPhysAddress data.
 * set (* wtpWirelessIfPhysAddress_val_ptr_ptr ) and (* wtpWirelessIfPhysAddress_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for wtpWirelessIfPhysAddress data
     */
    if ((NULL == (* wtpWirelessIfPhysAddress_val_ptr_ptr )) ||
        ((* wtpWirelessIfPhysAddress_val_ptr_len_ptr ) < (rowreq_ctx->data.wtpWirelessIfPhysAddress_len * sizeof((* wtpWirelessIfPhysAddress_val_ptr_ptr )[0])))) {
        /*
         * allocate space for wtpWirelessIfPhysAddress data
         */
        (* wtpWirelessIfPhysAddress_val_ptr_ptr ) = malloc(rowreq_ctx->data.wtpWirelessIfPhysAddress_len * sizeof((* wtpWirelessIfPhysAddress_val_ptr_ptr )[0]));
        if(NULL == (* wtpWirelessIfPhysAddress_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* wtpWirelessIfPhysAddress_val_ptr_len_ptr ) = rowreq_ctx->data.wtpWirelessIfPhysAddress_len * sizeof((* wtpWirelessIfPhysAddress_val_ptr_ptr )[0]);
    memcpy( (* wtpWirelessIfPhysAddress_val_ptr_ptr ), rowreq_ctx->data.wtpWirelessIfPhysAddress, (* wtpWirelessIfPhysAddress_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* wtpWirelessIfPhysAddress_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWirelessIfEntry.wtpWirelessIfAdminStatus
 * wtpWirelessIfAdminStatus is subid 7 of dot11WtpWirelessIfEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.3.1.7
 * Description:
Wireless interface admin status.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 1/8. Values:  up(1), down(2)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessIfAdminStatus.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessIfAdminStatus_map(u_long *mib_wtpWirelessIfAdminStatus_val_ptr, u_long raw_wtpWirelessIfAdminStatus_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessIfAdminStatus_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfAdminStatus_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessIfAdminStatus enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wtpWirelessIfAdminStatus_val) {
        case INTERNAL_WTPWIRELESSIFADMINSTATUS_UP:
             *mib_wtpWirelessIfAdminStatus_val_ptr = WTPWIRELESSIFADMINSTATUS_UP;
             break;

        case INTERNAL_WTPWIRELESSIFADMINSTATUS_DOWN:
             *mib_wtpWirelessIfAdminStatus_val_ptr = WTPWIRELESSIFADMINSTATUS_DOWN;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wtpWirelessIfAdminStatus\n", raw_wtpWirelessIfAdminStatus_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wtpWirelessIfAdminStatus_map */

/**
 * Extract the current value of the wtpWirelessIfAdminStatus data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessIfAdminStatus_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelessIfAdminStatus_get( dot11WtpWirelessIfTable_rowreq_ctx *rowreq_ctx, u_long * wtpWirelessIfAdminStatus_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelessIfAdminStatus_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfAdminStatus_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessIfAdminStatus data.
 * set (* wtpWirelessIfAdminStatus_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWirelessIfAdminStatus_val_ptr ) = rowreq_ctx->data.wtpWirelessIfAdminStatus;

    return MFD_SUCCESS;
} /* wtpWirelessIfAdminStatus_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWirelessIfEntry.wtpWirelessIfOperStatus
 * wtpWirelessIfOperStatus is subid 8 of dot11WtpWirelessIfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.3.1.8
 * Description:
Wireless interface current status.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 5/8. Values:  up(1), down(2), testing(3), unknown(4), dormant(5), notPresent(6), lowerLayerDown(7)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessIfOperStatus.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessIfOperStatus_map(u_long *mib_wtpWirelessIfOperStatus_val_ptr, u_long raw_wtpWirelessIfOperStatus_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessIfOperStatus_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfOperStatus_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessIfOperStatus enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wtpWirelessIfOperStatus_val) {
        case INTERNAL_WTPWIRELESSIFOPERSTATUS_UP:
             *mib_wtpWirelessIfOperStatus_val_ptr = WTPWIRELESSIFOPERSTATUS_UP;
             break;

        case INTERNAL_WTPWIRELESSIFOPERSTATUS_DOWN:
             *mib_wtpWirelessIfOperStatus_val_ptr = WTPWIRELESSIFOPERSTATUS_DOWN;
             break;

        case INTERNAL_WTPWIRELESSIFOPERSTATUS_TESTING:
             *mib_wtpWirelessIfOperStatus_val_ptr = WTPWIRELESSIFOPERSTATUS_TESTING;
             break;

        case INTERNAL_WTPWIRELESSIFOPERSTATUS_UNKNOWN:
             *mib_wtpWirelessIfOperStatus_val_ptr = WTPWIRELESSIFOPERSTATUS_UNKNOWN;
             break;

        case INTERNAL_WTPWIRELESSIFOPERSTATUS_DORMANT:
             *mib_wtpWirelessIfOperStatus_val_ptr = WTPWIRELESSIFOPERSTATUS_DORMANT;
             break;

        case INTERNAL_WTPWIRELESSIFOPERSTATUS_NOTPRESENT:
             *mib_wtpWirelessIfOperStatus_val_ptr = WTPWIRELESSIFOPERSTATUS_NOTPRESENT;
             break;

        case INTERNAL_WTPWIRELESSIFOPERSTATUS_LOWERLAYERDOWN:
             *mib_wtpWirelessIfOperStatus_val_ptr = WTPWIRELESSIFOPERSTATUS_LOWERLAYERDOWN;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wtpWirelessIfOperStatus\n", raw_wtpWirelessIfOperStatus_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wtpWirelessIfOperStatus_map */

/**
 * Extract the current value of the wtpWirelessIfOperStatus data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessIfOperStatus_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelessIfOperStatus_get( dot11WtpWirelessIfTable_rowreq_ctx *rowreq_ctx, u_long * wtpWirelessIfOperStatus_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelessIfOperStatus_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfOperStatus_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessIfOperStatus data.
 * set (* wtpWirelessIfOperStatus_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWirelessIfOperStatus_val_ptr ) = rowreq_ctx->data.wtpWirelessIfOperStatus;

    return MFD_SUCCESS;
} /* wtpWirelessIfOperStatus_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWirelessIfEntry.wtpWirelessIfLastChange
 * wtpWirelessIfLastChange is subid 9 of dot11WtpWirelessIfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.3.1.9
 * Description:
The last time the wireless interface into current work mode.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is TICKS (based on perltype TICKS)
 * The net-snmp type is ASN_TIMETICKS. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessIfLastChange.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessIfLastChange_map(u_long *mib_wtpWirelessIfLastChange_val_ptr, u_long raw_wtpWirelessIfLastChange_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessIfLastChange_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfLastChange_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessIfLastChange mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWirelessIfLastChange_val_ptr) = raw_wtpWirelessIfLastChange_val;

    return MFD_SUCCESS;
} /* wtpWirelessIfLastChange_map */

/**
 * Extract the current value of the wtpWirelessIfLastChange data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessIfLastChange_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelessIfLastChange_get( dot11WtpWirelessIfTable_rowreq_ctx *rowreq_ctx, u_long * wtpWirelessIfLastChange_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelessIfLastChange_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfLastChange_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessIfLastChange data.
 * set (* wtpWirelessIfLastChange_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWirelessIfLastChange_val_ptr ) = rowreq_ctx->data.wtpWirelessIfLastChange;

    return MFD_SUCCESS;
} /* wtpWirelessIfLastChange_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWirelessIfEntry.wtpWirelessIfRadioChannelAutoSelectEnable
 * wtpWirelessIfRadioChannelAutoSelectEnable is subid 10 of dot11WtpWirelessIfEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.3.1.10
 * Description:
Whether select and config wireless channel .
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 1/8. Values:  auto(1), manual(2)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessIfRadioChannelAutoSelectEnable.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessIfRadioChannelAutoSelectEnable_map(u_long *mib_wtpWirelessIfRadioChannelAutoSelectEnable_val_ptr, u_long raw_wtpWirelessIfRadioChannelAutoSelectEnable_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessIfRadioChannelAutoSelectEnable_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfRadioChannelAutoSelectEnable_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessIfRadioChannelAutoSelectEnable enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wtpWirelessIfRadioChannelAutoSelectEnable_val) {
        case INTERNAL_WTPWIRELESSIFRADIOCHANNELAUTOSELECTENABLE_AUTO:
             *mib_wtpWirelessIfRadioChannelAutoSelectEnable_val_ptr = WTPWIRELESSIFRADIOCHANNELAUTOSELECTENABLE_AUTO;
             break;

        case INTERNAL_WTPWIRELESSIFRADIOCHANNELAUTOSELECTENABLE_MANUAL:
             *mib_wtpWirelessIfRadioChannelAutoSelectEnable_val_ptr = WTPWIRELESSIFRADIOCHANNELAUTOSELECTENABLE_MANUAL;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wtpWirelessIfRadioChannelAutoSelectEnable\n", raw_wtpWirelessIfRadioChannelAutoSelectEnable_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wtpWirelessIfRadioChannelAutoSelectEnable_map */

/**
 * Extract the current value of the wtpWirelessIfRadioChannelAutoSelectEnable data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessIfRadioChannelAutoSelectEnable_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelessIfRadioChannelAutoSelectEnable_get( dot11WtpWirelessIfTable_rowreq_ctx *rowreq_ctx, u_long * wtpWirelessIfRadioChannelAutoSelectEnable_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelessIfRadioChannelAutoSelectEnable_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfRadioChannelAutoSelectEnable_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessIfRadioChannelAutoSelectEnable data.
 * set (* wtpWirelessIfRadioChannelAutoSelectEnable_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWirelessIfRadioChannelAutoSelectEnable_val_ptr ) = rowreq_ctx->data.wtpWirelessIfRadioChannelAutoSelectEnable;

    return MFD_SUCCESS;
} /* wtpWirelessIfRadioChannelAutoSelectEnable_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWirelessIfEntry.wtpWirelessIfRadioChannelConfig
 * wtpWirelessIfRadioChannelConfig is subid 11 of dot11WtpWirelessIfEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.3.1.11
 * Description:
If wireless channel select switch is closed,it needs to config wireless channel manually.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 11;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessIfRadioChannelConfig.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessIfRadioChannelConfig_map(long *mib_wtpWirelessIfRadioChannelConfig_val_ptr, long raw_wtpWirelessIfRadioChannelConfig_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessIfRadioChannelConfig_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfRadioChannelConfig_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessIfRadioChannelConfig mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWirelessIfRadioChannelConfig_val_ptr) = raw_wtpWirelessIfRadioChannelConfig_val;

    return MFD_SUCCESS;
} /* wtpWirelessIfRadioChannelConfig_map */

/**
 * Extract the current value of the wtpWirelessIfRadioChannelConfig data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessIfRadioChannelConfig_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelessIfRadioChannelConfig_get( dot11WtpWirelessIfTable_rowreq_ctx *rowreq_ctx, long * wtpWirelessIfRadioChannelConfig_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelessIfRadioChannelConfig_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfRadioChannelConfig_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessIfRadioChannelConfig data.
 * set (* wtpWirelessIfRadioChannelConfig_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWirelessIfRadioChannelConfig_val_ptr ) = rowreq_ctx->data.wtpWirelessIfRadioChannelConfig;

    return MFD_SUCCESS;
} /* wtpWirelessIfRadioChannelConfig_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWirelessIfEntry.wtpWirelessIfDiversitySelectionRx
 * wtpWirelessIfDiversitySelectionRx is subid 12 of dot11WtpWirelessIfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.3.1.12
 * Description:
If it is true,it means device supports receive diversit selection
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 2/8. Values:  false(0), true(1)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessIfDiversitySelectionRx.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessIfDiversitySelectionRx_map(u_long *mib_wtpWirelessIfDiversitySelectionRx_val_ptr, u_long raw_wtpWirelessIfDiversitySelectionRx_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessIfDiversitySelectionRx_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfDiversitySelectionRx_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessIfDiversitySelectionRx enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wtpWirelessIfDiversitySelectionRx_val) {
        case INTERNAL_WTPWIRELESSIFDIVERSITYSELECTIONRX_FALSE:
             *mib_wtpWirelessIfDiversitySelectionRx_val_ptr = WTPWIRELESSIFDIVERSITYSELECTIONRX_FALSE;
             break;

        case INTERNAL_WTPWIRELESSIFDIVERSITYSELECTIONRX_TRUE:
             *mib_wtpWirelessIfDiversitySelectionRx_val_ptr = WTPWIRELESSIFDIVERSITYSELECTIONRX_TRUE;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wtpWirelessIfDiversitySelectionRx\n", raw_wtpWirelessIfDiversitySelectionRx_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wtpWirelessIfDiversitySelectionRx_map */

/**
 * Extract the current value of the wtpWirelessIfDiversitySelectionRx data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessIfDiversitySelectionRx_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelessIfDiversitySelectionRx_get( dot11WtpWirelessIfTable_rowreq_ctx *rowreq_ctx, u_long * wtpWirelessIfDiversitySelectionRx_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelessIfDiversitySelectionRx_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfDiversitySelectionRx_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessIfDiversitySelectionRx data.
 * set (* wtpWirelessIfDiversitySelectionRx_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWirelessIfDiversitySelectionRx_val_ptr ) = rowreq_ctx->data.wtpWirelessIfDiversitySelectionRx;

    return MFD_SUCCESS;
} /* wtpWirelessIfDiversitySelectionRx_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWirelessIfEntry.wtpWirelessIfCurrRadioModeSupport
 * wtpWirelessIfCurrRadioModeSupport is subid 13 of dot11WtpWirelessIfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.3.1.13
 * Description:
Supported wireless mode(All the above base on the 802.11 standard).
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 6/16. Values:  a(1), b(2), ab(3), g(4), ag(5), bg(6), abg(7), an(8), gn(16), bgn(18)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessIfCurrRadioModeSupport.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessIfCurrRadioModeSupport_map(u_long *mib_wtpWirelessIfCurrRadioModeSupport_val_ptr, u_long raw_wtpWirelessIfCurrRadioModeSupport_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessIfCurrRadioModeSupport_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfCurrRadioModeSupport_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessIfCurrRadioModeSupport enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wtpWirelessIfCurrRadioModeSupport_val) {
        case INTERNAL_WTPWIRELESSIFCURRRADIOMODESUPPORT_A:
             *mib_wtpWirelessIfCurrRadioModeSupport_val_ptr = WTPWIRELESSIFCURRRADIOMODESUPPORT_A;
             break;

        case INTERNAL_WTPWIRELESSIFCURRRADIOMODESUPPORT_B:
             *mib_wtpWirelessIfCurrRadioModeSupport_val_ptr = WTPWIRELESSIFCURRRADIOMODESUPPORT_B;
             break;

        case INTERNAL_WTPWIRELESSIFCURRRADIOMODESUPPORT_G:
             *mib_wtpWirelessIfCurrRadioModeSupport_val_ptr = WTPWIRELESSIFCURRRADIOMODESUPPORT_G;
             break;

        case INTERNAL_WTPWIRELESSIFCURRRADIOMODESUPPORT_BG:
             *mib_wtpWirelessIfCurrRadioModeSupport_val_ptr = WTPWIRELESSIFCURRRADIOMODESUPPORT_BG;
             break;

        case INTERNAL_WTPWIRELESSIFCURRRADIOMODESUPPORT_AN:
             *mib_wtpWirelessIfCurrRadioModeSupport_val_ptr = WTPWIRELESSIFCURRRADIOMODESUPPORT_AN;
             break;

        case INTERNAL_WTPWIRELESSIFCURRRADIOMODESUPPORT_AAN:
             *mib_wtpWirelessIfCurrRadioModeSupport_val_ptr = WTPWIRELESSIFCURRRADIOMODESUPPORT_AAN;
             break;

        case INTERNAL_WTPWIRELESSIFCURRRADIOMODESUPPORT_GN:
             *mib_wtpWirelessIfCurrRadioModeSupport_val_ptr = WTPWIRELESSIFCURRRADIOMODESUPPORT_GN;
             break;

        case INTERNAL_WTPWIRELESSIFCURRRADIOMODESUPPORT_GGN:
             *mib_wtpWirelessIfCurrRadioModeSupport_val_ptr = WTPWIRELESSIFCURRRADIOMODESUPPORT_GGN;
             break;

        case INTERNAL_WTPWIRELESSIFCURRRADIOMODESUPPORT_BGGN:
             *mib_wtpWirelessIfCurrRadioModeSupport_val_ptr = WTPWIRELESSIFCURRRADIOMODESUPPORT_BGGN;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wtpWirelessIfCurrRadioModeSupport\n", raw_wtpWirelessIfCurrRadioModeSupport_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wtpWirelessIfCurrRadioModeSupport_map */

/**
 * Extract the current value of the wtpWirelessIfCurrRadioModeSupport data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessIfCurrRadioModeSupport_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelessIfCurrRadioModeSupport_get( dot11WtpWirelessIfTable_rowreq_ctx *rowreq_ctx, u_long * wtpWirelessIfCurrRadioModeSupport_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelessIfCurrRadioModeSupport_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfCurrRadioModeSupport_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessIfCurrRadioModeSupport data.
 * set (* wtpWirelessIfCurrRadioModeSupport_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWirelessIfCurrRadioModeSupport_val_ptr ) = rowreq_ctx->data.wtpWirelessIfCurrRadioModeSupport;

    return MFD_SUCCESS;
} /* wtpWirelessIfCurrRadioModeSupport_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWirelessIfEntry.wtpWirelessIfTransmitSpeedConfig
 * wtpWirelessIfTransmitSpeedConfig is subid 14 of dot11WtpWirelessIfEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.3.1.14
 * Description:
Wireless interface transport speed.(The value you input must be 10,20,55,60,90,110,120,180,240,360,480,540,otherwise you will not set the value)
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessIfTransmitSpeedConfig.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessIfTransmitSpeedConfig_map(char **mib_wtpWirelessIfTransmitSpeedConfig_val_ptr_ptr, size_t *mib_wtpWirelessIfTransmitSpeedConfig_val_ptr_len_ptr, char *raw_wtpWirelessIfTransmitSpeedConfig_val_ptr, size_t raw_wtpWirelessIfTransmitSpeedConfig_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpWirelessIfTransmitSpeedConfig_val_ptr);
    netsnmp_assert((NULL != mib_wtpWirelessIfTransmitSpeedConfig_val_ptr_ptr) && (NULL != mib_wtpWirelessIfTransmitSpeedConfig_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfTransmitSpeedConfig_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpWirelessIfTransmitSpeedConfig non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpWirelessIfTransmitSpeedConfig_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpWirelessIfTransmitSpeedConfig_val_ptr_ptr) || (*mib_wtpWirelessIfTransmitSpeedConfig_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpWirelessIfTransmitSpeedConfig_val_ptr_ptr = realloc( *mib_wtpWirelessIfTransmitSpeedConfig_val_ptr_ptr, converted_len * sizeof(**mib_wtpWirelessIfTransmitSpeedConfig_val_ptr_ptr));
        if(NULL == *mib_wtpWirelessIfTransmitSpeedConfig_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpWirelessIfTransmitSpeedConfig_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpWirelessIfTransmitSpeedConfig_val_ptr_ptr, raw_wtpWirelessIfTransmitSpeedConfig_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpWirelessIfTransmitSpeedConfig_map */

/**
 * Extract the current value of the wtpWirelessIfTransmitSpeedConfig data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessIfTransmitSpeedConfig_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wtpWirelessIfTransmitSpeedConfig_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wtpWirelessIfTransmitSpeedConfig.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wtpWirelessIfTransmitSpeedConfig_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wtpWirelessIfTransmitSpeedConfig_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wtpWirelessIfTransmitSpeedConfig_get( dot11WtpWirelessIfTable_rowreq_ctx *rowreq_ctx, char **wtpWirelessIfTransmitSpeedConfig_val_ptr_ptr, size_t *wtpWirelessIfTransmitSpeedConfig_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != wtpWirelessIfTransmitSpeedConfig_val_ptr_ptr) && (NULL != *wtpWirelessIfTransmitSpeedConfig_val_ptr_ptr));
   netsnmp_assert( NULL != wtpWirelessIfTransmitSpeedConfig_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfTransmitSpeedConfig_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessIfTransmitSpeedConfig data.
 * set (* wtpWirelessIfTransmitSpeedConfig_val_ptr_ptr ) and (* wtpWirelessIfTransmitSpeedConfig_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for wtpWirelessIfTransmitSpeedConfig data
     */
    if ((NULL == (* wtpWirelessIfTransmitSpeedConfig_val_ptr_ptr )) ||
        ((* wtpWirelessIfTransmitSpeedConfig_val_ptr_len_ptr ) < (rowreq_ctx->data.wtpWirelessIfTransmitSpeedConfig_len * sizeof((* wtpWirelessIfTransmitSpeedConfig_val_ptr_ptr )[0])))) {
        /*
         * allocate space for wtpWirelessIfTransmitSpeedConfig data
         */
        (* wtpWirelessIfTransmitSpeedConfig_val_ptr_ptr ) = malloc(rowreq_ctx->data.wtpWirelessIfTransmitSpeedConfig_len * sizeof((* wtpWirelessIfTransmitSpeedConfig_val_ptr_ptr )[0]));
        if(NULL == (* wtpWirelessIfTransmitSpeedConfig_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* wtpWirelessIfTransmitSpeedConfig_val_ptr_len_ptr ) = rowreq_ctx->data.wtpWirelessIfTransmitSpeedConfig_len * sizeof((* wtpWirelessIfTransmitSpeedConfig_val_ptr_ptr )[0]);
    memcpy( (* wtpWirelessIfTransmitSpeedConfig_val_ptr_ptr ), rowreq_ctx->data.wtpWirelessIfTransmitSpeedConfig, (* wtpWirelessIfTransmitSpeedConfig_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* wtpWirelessIfTransmitSpeedConfig_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWirelessIfEntry.wtpWirelessIfPwrAttRange
 * wtpWirelessIfPwrAttRange is subid 15 of dot11WtpWirelessIfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.3.1.15
 * Description:
Power attenuation range(units dB,not less than 20dB).
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessIfPwrAttRange.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessIfPwrAttRange_map(long *mib_wtpWirelessIfPwrAttRange_val_ptr, long raw_wtpWirelessIfPwrAttRange_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessIfPwrAttRange_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfPwrAttRange_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessIfPwrAttRange mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWirelessIfPwrAttRange_val_ptr) = raw_wtpWirelessIfPwrAttRange_val;

    return MFD_SUCCESS;
} /* wtpWirelessIfPwrAttRange_map */

/**
 * Extract the current value of the wtpWirelessIfPwrAttRange data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessIfPwrAttRange_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelessIfPwrAttRange_get( dot11WtpWirelessIfTable_rowreq_ctx *rowreq_ctx, long * wtpWirelessIfPwrAttRange_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelessIfPwrAttRange_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfPwrAttRange_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessIfPwrAttRange data.
 * set (* wtpWirelessIfPwrAttRange_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWirelessIfPwrAttRange_val_ptr ) = rowreq_ctx->data.wtpWirelessIfPwrAttRange;

    return MFD_SUCCESS;
} /* wtpWirelessIfPwrAttRange_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWirelessIfEntry.wtpWirelessIfPwrAttValue
 * wtpWirelessIfPwrAttValue is subid 16 of dot11WtpWirelessIfEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.3.1.16
 * Description:
Accuracy 0.5dB,step length 1dB.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessIfPwrAttValue.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessIfPwrAttValue_map(long *mib_wtpWirelessIfPwrAttValue_val_ptr, long raw_wtpWirelessIfPwrAttValue_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessIfPwrAttValue_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfPwrAttValue_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessIfPwrAttValue mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWirelessIfPwrAttValue_val_ptr) = raw_wtpWirelessIfPwrAttValue_val;

    return MFD_SUCCESS;
} /* wtpWirelessIfPwrAttValue_map */

/**
 * Extract the current value of the wtpWirelessIfPwrAttValue data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessIfPwrAttValue_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelessIfPwrAttValue_get( dot11WtpWirelessIfTable_rowreq_ctx *rowreq_ctx, long * wtpWirelessIfPwrAttValue_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelessIfPwrAttValue_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfPwrAttValue_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessIfPwrAttValue data.
 * set (* wtpWirelessIfPwrAttValue_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWirelessIfPwrAttValue_val_ptr ) = rowreq_ctx->data.wtpWirelessIfPwrAttValue;

    return MFD_SUCCESS;
} /* wtpWirelessIfPwrAttValue_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWirelessIfEntry.wtpWirelessIfAntennaGain
 * wtpWirelessIfAntennaGain is subid 17 of dot11WtpWirelessIfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.3.1.17
 * Description:
Antenna gain(units dBi).
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessIfAntennaGain.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessIfAntennaGain_map(long *mib_wtpWirelessIfAntennaGain_val_ptr, long raw_wtpWirelessIfAntennaGain_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessIfAntennaGain_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfAntennaGain_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessIfAntennaGain mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWirelessIfAntennaGain_val_ptr) = raw_wtpWirelessIfAntennaGain_val;

    return MFD_SUCCESS;
} /* wtpWirelessIfAntennaGain_map */

/**
 * Extract the current value of the wtpWirelessIfAntennaGain data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessIfAntennaGain_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelessIfAntennaGain_get( dot11WtpWirelessIfTable_rowreq_ctx *rowreq_ctx, long * wtpWirelessIfAntennaGain_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelessIfAntennaGain_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfAntennaGain_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessIfAntennaGain data.
 * set (* wtpWirelessIfAntennaGain_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWirelessIfAntennaGain_val_ptr ) = rowreq_ctx->data.wtpWirelessIfAntennaGain;

    return MFD_SUCCESS;
} /* wtpWirelessIfAntennaGain_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWirelessIfEntry.wtpWirelessIfPowerMgmtEnable
 * wtpWirelessIfPowerMgmtEnable is subid 18 of dot11WtpWirelessIfEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.3.1.18
 * Description:
ON:AP configs transmission power automatically,power attenuation configuration invalid;OFF:manual adjustment,power attenuation configuration valid.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  OFF(0), ON(1)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessIfPowerMgmtEnable.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessIfPowerMgmtEnable_map(u_long *mib_wtpWirelessIfPowerMgmtEnable_val_ptr, u_long raw_wtpWirelessIfPowerMgmtEnable_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessIfPowerMgmtEnable_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfPowerMgmtEnable_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessIfPowerMgmtEnable enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wtpWirelessIfPowerMgmtEnable_val) {
        case INTERNAL_WTPWIRELESSIFPOWERMGMTENABLE_OFF:
             *mib_wtpWirelessIfPowerMgmtEnable_val_ptr = WTPWIRELESSIFPOWERMGMTENABLE_OFF;
             break;

        case INTERNAL_WTPWIRELESSIFPOWERMGMTENABLE_ON:
             *mib_wtpWirelessIfPowerMgmtEnable_val_ptr = WTPWIRELESSIFPOWERMGMTENABLE_ON;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wtpWirelessIfPowerMgmtEnable\n", raw_wtpWirelessIfPowerMgmtEnable_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wtpWirelessIfPowerMgmtEnable_map */

/**
 * Extract the current value of the wtpWirelessIfPowerMgmtEnable data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessIfPowerMgmtEnable_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelessIfPowerMgmtEnable_get( dot11WtpWirelessIfTable_rowreq_ctx *rowreq_ctx, u_long * wtpWirelessIfPowerMgmtEnable_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelessIfPowerMgmtEnable_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfPowerMgmtEnable_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessIfPowerMgmtEnable data.
 * set (* wtpWirelessIfPowerMgmtEnable_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWirelessIfPowerMgmtEnable_val_ptr ) = rowreq_ctx->data.wtpWirelessIfPowerMgmtEnable;

    return MFD_SUCCESS;
} /* wtpWirelessIfPowerMgmtEnable_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWirelessIfEntry.wtpWirelessIfMaxStationNumPermitted
 * wtpWirelessIfMaxStationNumPermitted is subid 19 of dot11WtpWirelessIfEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.3.1.19
 * Description:
support max station number
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 64;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessIfMaxStationNumPermitted.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessIfMaxStationNumPermitted_map(long *mib_wtpWirelessIfMaxStationNumPermitted_val_ptr, long raw_wtpWirelessIfMaxStationNumPermitted_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessIfMaxStationNumPermitted_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfMaxStationNumPermitted_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessIfMaxStationNumPermitted mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWirelessIfMaxStationNumPermitted_val_ptr) = raw_wtpWirelessIfMaxStationNumPermitted_val;

    return MFD_SUCCESS;
} /* wtpWirelessIfMaxStationNumPermitted_map */

/**
 * Extract the current value of the wtpWirelessIfMaxStationNumPermitted data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessIfMaxStationNumPermitted_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelessIfMaxStationNumPermitted_get( dot11WtpWirelessIfTable_rowreq_ctx *rowreq_ctx, long * wtpWirelessIfMaxStationNumPermitted_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelessIfMaxStationNumPermitted_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfMaxStationNumPermitted_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessIfMaxStationNumPermitted data.
 * set (* wtpWirelessIfMaxStationNumPermitted_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWirelessIfMaxStationNumPermitted_val_ptr ) = rowreq_ctx->data.wtpWirelessIfMaxStationNumPermitted;

    return MFD_SUCCESS;
} /* wtpWirelessIfMaxStationNumPermitted_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWirelessIfEntry.wtpWirelessIfMaxTxPwrLvl
 * wtpWirelessIfMaxTxPwrLvl is subid 20 of dot11WtpWirelessIfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.3.1.20
 * Description:
support max tx power
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessIfMaxTxPwrLvl.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessIfMaxTxPwrLvl_map(char **mib_wtpWirelessIfMaxTxPwrLvl_val_ptr_ptr, size_t *mib_wtpWirelessIfMaxTxPwrLvl_val_ptr_len_ptr, char *raw_wtpWirelessIfMaxTxPwrLvl_val_ptr, size_t raw_wtpWirelessIfMaxTxPwrLvl_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpWirelessIfMaxTxPwrLvl_val_ptr);
    netsnmp_assert((NULL != mib_wtpWirelessIfMaxTxPwrLvl_val_ptr_ptr) && (NULL != mib_wtpWirelessIfMaxTxPwrLvl_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfMaxTxPwrLvl_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpWirelessIfMaxTxPwrLvl non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpWirelessIfMaxTxPwrLvl_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpWirelessIfMaxTxPwrLvl_val_ptr_ptr) || (*mib_wtpWirelessIfMaxTxPwrLvl_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpWirelessIfMaxTxPwrLvl_val_ptr_ptr = realloc( *mib_wtpWirelessIfMaxTxPwrLvl_val_ptr_ptr, converted_len * sizeof(**mib_wtpWirelessIfMaxTxPwrLvl_val_ptr_ptr));
        if(NULL == *mib_wtpWirelessIfMaxTxPwrLvl_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpWirelessIfMaxTxPwrLvl_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpWirelessIfMaxTxPwrLvl_val_ptr_ptr, raw_wtpWirelessIfMaxTxPwrLvl_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpWirelessIfMaxTxPwrLvl_map */

/**
 * Extract the current value of the wtpWirelessIfMaxTxPwrLvl data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessIfMaxTxPwrLvl_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wtpWirelessIfMaxTxPwrLvl_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wtpWirelessIfMaxTxPwrLvl.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wtpWirelessIfMaxTxPwrLvl_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wtpWirelessIfMaxTxPwrLvl_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wtpWirelessIfMaxTxPwrLvl_get( dot11WtpWirelessIfTable_rowreq_ctx *rowreq_ctx, char **wtpWirelessIfMaxTxPwrLvl_val_ptr_ptr, size_t *wtpWirelessIfMaxTxPwrLvl_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != wtpWirelessIfMaxTxPwrLvl_val_ptr_ptr) && (NULL != *wtpWirelessIfMaxTxPwrLvl_val_ptr_ptr));
   netsnmp_assert( NULL != wtpWirelessIfMaxTxPwrLvl_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfMaxTxPwrLvl_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessIfMaxTxPwrLvl data.
 * set (* wtpWirelessIfMaxTxPwrLvl_val_ptr_ptr ) and (* wtpWirelessIfMaxTxPwrLvl_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for wtpWirelessIfMaxTxPwrLvl data
     */
    if ((NULL == (* wtpWirelessIfMaxTxPwrLvl_val_ptr_ptr )) ||
        ((* wtpWirelessIfMaxTxPwrLvl_val_ptr_len_ptr ) < (rowreq_ctx->data.wtpWirelessIfMaxTxPwrLvl_len * sizeof((* wtpWirelessIfMaxTxPwrLvl_val_ptr_ptr )[0])))) {
        /*
         * allocate space for wtpWirelessIfMaxTxPwrLvl data
         */
        (* wtpWirelessIfMaxTxPwrLvl_val_ptr_ptr ) = malloc(rowreq_ctx->data.wtpWirelessIfMaxTxPwrLvl_len * sizeof((* wtpWirelessIfMaxTxPwrLvl_val_ptr_ptr )[0]));
        if(NULL == (* wtpWirelessIfMaxTxPwrLvl_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* wtpWirelessIfMaxTxPwrLvl_val_ptr_len_ptr ) = rowreq_ctx->data.wtpWirelessIfMaxTxPwrLvl_len * sizeof((* wtpWirelessIfMaxTxPwrLvl_val_ptr_ptr )[0]);
    memcpy( (* wtpWirelessIfMaxTxPwrLvl_val_ptr_ptr ), rowreq_ctx->data.wtpWirelessIfMaxTxPwrLvl, (* wtpWirelessIfMaxTxPwrLvl_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* wtpWirelessIfMaxTxPwrLvl_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWirelessIfEntry.wtpWirelessIfTxPwrStep
 * wtpWirelessIfTxPwrStep is subid 21 of dot11WtpWirelessIfEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.3.1.21
 * Description:
txpower adjustment step
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessIfTxPwrStep.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessIfTxPwrStep_map(long *mib_wtpWirelessIfTxPwrStep_val_ptr, long raw_wtpWirelessIfTxPwrStep_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessIfTxPwrStep_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfTxPwrStep_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessIfTxPwrStep mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWirelessIfTxPwrStep_val_ptr) = raw_wtpWirelessIfTxPwrStep_val;

    return MFD_SUCCESS;
} /* wtpWirelessIfTxPwrStep_map */

/**
 * Extract the current value of the wtpWirelessIfTxPwrStep data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessIfTxPwrStep_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelessIfTxPwrStep_get( dot11WtpWirelessIfTable_rowreq_ctx *rowreq_ctx, long * wtpWirelessIfTxPwrStep_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelessIfTxPwrStep_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWirelessIfTable:wtpWirelessIfTxPwrStep_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessIfTxPwrStep data.
 * set (* wtpWirelessIfTxPwrStep_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWirelessIfTxPwrStep_val_ptr ) = rowreq_ctx->data.wtpWirelessIfTxPwrStep;

    return MFD_SUCCESS;
} /* wtpWirelessIfTxPwrStep_get */



/** @} */
