/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 12077 $ of $
 *
 * $Id:$
 *
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "dot11PortalWhiteListTable.h"
#include "nm/app/eag/eag_errcode.h"
#include "nm/app/eag/eag_conf.h"
#include "nm/app/eag/eag_interface.h"
#include "nm/app/drp/drp_def.h"
#include "nm/app/drp/drp_interface.h"
#include "ws_dbus_list_interface.h"
#include "dot11PortalWhiteListTable.h"
#include "autelanWtpGroup.h"
#include <netinet/in.h>
#include "mibs_public.h"


#define IP_ADDR_LEN					24
#define IPRANGE_LEN					40
#define PORTSET_LEN					40

/*if eag is running, return 1*/
/*static int 
eag_ins_running_state(DBusConnection *connection, int hansitype, int insid)
{
	int ret = 0;
	struct eag_base_conf baseconf;		
	memset( &baseconf, 0, sizeof(baseconf));

	ret = eag_get_base_conf( connection, hansitype, insid, &baseconf );

	if( (EAG_RETURN_OK == ret) && (1 == baseconf.status) )
		ret = 1;
	else
		ret = 0;
	return ret;
}*/

static int 
captive_check_portset_format(const char *str)
{
	const char *p = NULL;
	char *tmp = NULL, *token = NULL;
	
	if (NULL == str || '\0' == str[0] || ',' == str[0]) 
		return 1;

	if (strlen(str) > PORTSET_LEN -1)
		return 1;
	
	if (strcmp(str, "all") == 0)
		return 0;
	
	for (p = str; *p; p++){
		if ((*p < '0' || *p > '9') && *p != ',')
			return 1;
		if (',' == *p && ',' == *(p+1))
			return 1;
	}
	if (',' ==  *(p-1))
		return 1;

	tmp = strdup(str);
	for (token = strtok(tmp, ","); token; token = strtok(NULL, ",")){
		int port = atoi(token);
		if (port <= 0 || port > 65535 || '0' == token[0]){
			free(tmp);
			return 1;
		}
	}

	free(tmp);
	return 0;
	
}

typedef struct {
	char iprange[IPRANGE_LEN];
	char portset[PORTSET_LEN];
} iprange_portset_t;

/** @defgroup data_set data_set: Routines to set data
 *
 * These routines are used to set the value for individual objects. The
 * row context is passed, along with the new value.
 * 
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table dot11PortalWhiteListTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * DOT11-AC-MIB::dot11PortalWhiteListTable is subid 2 of dot11ConfigPortalServerGroup.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.2, length: 12
*/
    /*
     * NOTE: if you update this chart, please update the versions in
     *       local/mib2c-conf.d/parent-set.m2i
     *       agent/mibgroup/helpers/baby_steps.c
     * while you're at it.
     */
    /*
     ***********************************************************************
     * Baby Steps Flow Chart (2004.06.05)                                  *
     *                                                                     *
     * +--------------+    +================+    U = unconditional path    *
     * |optional state|    ||required state||    S = path for success      *
     * +--------------+    +================+    E = path for error        *
     ***********************************************************************
     *
     *                        +--------------+
     *                        |     pre      |
     *                        |   request    |
     *                        +--------------+
     *                               | U
     * +-------------+        +==============+
     * |    row    |f|<-------||  object    ||
     * |  create   |1|      E ||  lookup    ||
     * +-------------+        +==============+
     *     E |   | S                 | S
     *       |   +------------------>|
     *       |                +==============+
     *       |              E ||   check    ||
     *       |<---------------||   values   ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |       +<-------||   undo     ||
     *       |       |      E ||   setup    ||
     *       |       |        +==============+
     *       |       |               | S
     *       |       |        +==============+
     *       |       |        ||    set     ||-------------------------->+
     *       |       |        ||   value    || E                         |
     *       |       |        +==============+                           |
     *       |       |               | S                                 |
     *       |       |        +--------------+                           |
     *       |       |        |    check     |-------------------------->|
     *       |       |        |  consistency | E                         |
     *       |       |        +--------------+                           |
     *       |       |               | S                                 |
     *       |       |        +==============+         +==============+  |
     *       |       |        ||   commit   ||-------->||     undo   ||  |
     *       |       |        ||            || E       ||    commit  ||  |
     *       |       |        +==============+         +==============+  |
     *       |       |               | S                     U |<--------+
     *       |       |        +--------------+         +==============+
     *       |       |        | irreversible |         ||    undo    ||
     *       |       |        |    commit    |         ||     set    ||
     *       |       |        +--------------+         +==============+
     *       |       |               | U                     U |
     *       |       +-------------->|<------------------------+
     *       |                +==============+
     *       |                ||   undo     ||
     *       |                ||  cleanup   ||
     *       |                +==============+
     *       +---------------------->| U
     *                               |
     *                          (err && f1)------------------->+
     *                               |                         |
     *                        +--------------+         +--------------+
     *                        |    post      |<--------|      row     |
     *                        |   request    |       U |    release   |
     *                        +--------------+         +--------------+
     *
     */

/**
 * Setup up context with information needed to undo a set request.
 *
 * This function will be called before the individual node undo setup
 * functions are called. If you need to do any undo setup that is not
 * related to a specific column, you can do it here.
 *
 * Note that the undo context has been allocated with
 * dot11PortalWhiteListTable_allocate_data(), but may need extra
 * initialization similar to what you may have done in
 * dot11PortalWhiteListTable_rowreq_ctx_init().
 * Note that an individual node's undo_setup function will only be called
 * if that node is being set to a new value.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in the node's undo_setup
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11PortalWhiteListTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
dot11PortalWhiteListTable_undo_setup( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:dot11PortalWhiteListTable_undo_setup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> Setup dot11PortalWhiteListTable undo.
     * set up dot11PortalWhiteListTable undo information, in preparation for a set.
     * Undo storage is in (* WLRowStatus_val_ptr )*
     */

    return rc;
} /* dot11PortalWhiteListTable_undo_setup */

/**
 * Undo a set request.
 *
 * This function will be called before the individual node undo
 * functions are called. If you need to do any undo that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo function will only be called
 * if that node is being set to a new value.
 *
 * If there is anything  specific to a particular column (e.g. releasing
 * memory for a string), you should do that setup in the node's undo
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11PortalWhiteListTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
dot11PortalWhiteListTable_undo( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:dot11PortalWhiteListTable_undo","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> dot11PortalWhiteListTable undo.
     * dot11PortalWhiteListTable undo information, in response to a failed set.
     * Undo storage is in (* WLRowStatus_val_ptr )*
     */

    return rc;
} /* dot11PortalWhiteListTable_undo_setup */

/**
 * Cleanup up context undo information.
 *
 * This function will be called after set/commit processing. If you
 * allocated any resources in undo_setup, this is the place to release
 * those resources.
 *
 * This function is called regardless of the success or failure of the set
 * request. If you need to perform different steps for cleanup depending
 * on success or failure, you can add a flag to the rowreq_ctx.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11PortalWhiteListTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
dot11PortalWhiteListTable_undo_cleanup( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:dot11PortalWhiteListTable_undo_cleanup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:452:M: |-> Cleanup dot11PortalWhiteListTable undo.
     * Undo storage is in (* WLRowStatus_val_ptr )*
     */

    return rc;
} /* dot11PortalWhiteListTable_undo_cleanup */

/**
 * commit new values.
 *
 * At this point, you should have done everything you can to ensure that
 * this commit will not fail.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * dot11PortalWhiteListTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param dot11PortalWhiteListTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
dot11PortalWhiteListTable_commit( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;
    int             save_flags;

    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:dot11PortalWhiteListTable_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * save flags, then clear until we actually do something
     */
    save_flags = rowreq_ctx->column_set_flags;
    rowreq_ctx->column_set_flags = 0;
	
    if(RS_NOTREADY == rowreq_ctx->data.WLRowStatus) {
        rowreq_ctx->data.WLRowStatus = RS_NOTINSERVICE;
    }

    /*
     * commit dot11PortalWhiteListTable data
     * 1) check the column's flag in save_flags to see if it was set.
     * 2) clear the flag when you handle that column
     * 3) set the column's flag in column_set_flags if it needs undo
     *    processing in case of a failure.
     */
    if (save_flags & COLUMN_WLTYPE_FLAG) {
       save_flags &= ~COLUMN_WLTYPE_FLAG; /* clear WLtype */
       /*
        * TODO:482:o: |-> commit column WLtype.
        */
       rc = MFD_SUCCESS;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11PortalWhiteListTable column WLtype commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo WLtype
             */
            rowreq_ctx->column_set_flags |= COLUMN_WLTYPE_FLAG;
       }
    }

    if (save_flags & COLUMN_WLSTARTIP_FLAG) {
       save_flags &= ~COLUMN_WLSTARTIP_FLAG; /* clear WLstartip */
       /*
        * TODO:482:o: |-> commit column WLstartip.
        */
       rc = MFD_SUCCESS;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11PortalWhiteListTable column WLstartip commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo WLstartip
             */
            rowreq_ctx->column_set_flags |= COLUMN_WLSTARTIP_FLAG;
       }
    }

    if (save_flags & COLUMN_WLENDIP_FLAG) {
       save_flags &= ~COLUMN_WLENDIP_FLAG; /* clear WLendip */
       /*
        * TODO:482:o: |-> commit column WLendip.
        */
       rc = MFD_SUCCESS;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11PortalWhiteListTable column WLendip commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo WLendip
             */
            rowreq_ctx->column_set_flags |= COLUMN_WLENDIP_FLAG;
       }
    }

    if (save_flags & COLUMN_WLPORT_FLAG) {
       save_flags &= ~COLUMN_WLPORT_FLAG; /* clear WLport */
       /*
        * TODO:482:o: |-> commit column WLport.
        */
       rc = MFD_SUCCESS;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11PortalWhiteListTable column WLport commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo WLport
             */
            rowreq_ctx->column_set_flags |= COLUMN_WLPORT_FLAG;
       }
    }

    if (save_flags & COLUMN_WLURL_FLAG) {
       save_flags &= ~COLUMN_WLURL_FLAG; /* clear WLURL */
       /*
        * TODO:482:o: |-> commit column WLURL.
        */
       rc = MFD_SUCCESS;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11PortalWhiteListTable column WLURL commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo WLURL
             */
            rowreq_ctx->column_set_flags |= COLUMN_WLURL_FLAG;
       }
    }

    if (save_flags & COLUMN_WLROWSTATUS_FLAG) {
        save_flags &= ~COLUMN_WLROWSTATUS_FLAG; /* clear WLRowStatus */
        switch(rowreq_ctx->data.WLRowStatus) {
            case RS_ACTIVE:
                {
					rc = -1;
					switch(rowreq_ctx->data.WLtype)
					{
						case 0:		/*ip*/
							{
								if(0 != rowreq_ctx->data.WLstartip)
							    {
								    void *connection = NULL;
								    if(SNMPD_DBUS_SUCCESS == get_instance_dbus_connection(rowreq_ctx->data.parameter, &connection, SNMPD_INSTANCE_MASTER_V3)) 
									{
										int ret = -1;
										RULE_TYPE type = RULE_IPADDR;
										iprange_portset_t item;
										char ipaddr_begin[IP_ADDR_LEN] = { 0 };
										char ipaddr_end[IP_ADDR_LEN] = { 0 };
										
//										if(eag_ins_running_state(connection, rowreq_ctx->data.parameter.local_id, rowreq_ctx->data.parameter.instance_id) == 1)
//										{
											memset(&item, 0, sizeof(item));
										
											INET_NTOA(rowreq_ctx->data.WLstartip, ipaddr_begin);
											INET_NTOA(rowreq_ctx->data.WLendip, ipaddr_end);
											if(rowreq_ctx->data.WLendip == 0)
											{
												strncpy(item.iprange, ipaddr_begin, IPRANGE_LEN-1);
											}
											else
											{
												snprintf(item.iprange, IPRANGE_LEN-1, "%s-%s", ipaddr_begin, ipaddr_end);
											}

											if(strcmp(rowreq_ctx->data.WLport,""))
											{
												if (captive_check_portset_format(rowreq_ctx->data.WLport) != 0)
												{
													break;
												}
												strncpy(item.portset, rowreq_ctx->data.WLport, PORTSET_LEN-1);
											}
											else
											{
												strncpy(item.portset, "all", PORTSET_LEN-1);
											}
						
											ret = eag_conf_captive_list( connection, rowreq_ctx->data.parameter.local_id,
																			rowreq_ctx->data.parameter.instance_id, 
																			type, item.iprange, item.portset, "", "", 
																			CP_ADD_LIST, CP_WHITE_LIST);
						
											snmp_log(LOG_DEBUG, "dot11PortalWhiteListTable_commit: eag_conf_captive_list: ret = %d\n", ret);
											if(ret == EAG_RETURN_OK)
											{
												 if(rowreq_ctx->data.WLendip == 0)
												 {
												 	rowreq_ctx->data.WLendip = rowreq_ctx->data.WLstartip;
												 }
												 if(0 == strcmp(rowreq_ctx->data.WLport,""))
												 {
													 rowreq_ctx->data.WLport_len = MIN(sizeof(rowreq_ctx->data.WLport) - 1, strlen("all"));
													 memcpy( rowreq_ctx->data.WLport, "all", rowreq_ctx->data.WLport_len );
												 }
					
												 rc = MFD_SUCCESS;
					                             break;
											}
											else if(EAG_ERR_DBUS_FAILED == ret) 
											{
												close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
											}
//										}
								    }    					    
							   	}
							}
							break;	
						case 1:		/*domain*/
							{
								if(strcmp(rowreq_ctx->data.WLURL,""))
							    {
								    void *connection = NULL;
								    if(SNMPD_DBUS_SUCCESS == get_instance_dbus_connection(rowreq_ctx->data.parameter, &connection, SNMPD_INSTANCE_MASTER_V3)) 
									{
										int ret = -1;
										RULE_TYPE type = RULE_DOMAIN;
										char domain[256] = { 0 };
										domain_pt domain_conf;
										domain_ct domain_ctr;
										int i = 0;
										
//										if(eag_ins_running_state(connection, rowreq_ctx->data.parameter.local_id, rowreq_ctx->data.parameter.instance_id) == 1)
//										{
											memset(&domain, 0, sizeof(domain));
											strncpy(domain, rowreq_ctx->data.WLURL, sizeof(domain)-1);										
										
											memset (&domain_conf,0,sizeof(domain_conf));
											strncpy((domain_conf.domain_name),domain,sizeof(domain_conf.domain_name)-1);
											memset (&domain_ctr,0,sizeof(domain_ctr));
											ret = conf_drp_get_domain_ip(connection, &domain_conf, &domain_ctr);
											if (0 == ret)
											{
												int nbyte = 0;
												for (i = 0; i < domain_ctr.num ; i++)
												{
													nbyte = snprintf (domain,sizeof (domain),"%s",rowreq_ctx->data.WLURL);
													for (i = 0; i<domain_ctr.num; i++)
													{
														nbyte += snprintf(domain+nbyte,sizeof(domain)-nbyte,";%lu",domain_ctr.domain_ip[i].ipaddr);
													}
												}
											}
											else
											{
												break;
											}
							
											ret = eag_conf_captive_list( connection, rowreq_ctx->data.parameter.local_id,
																			rowreq_ctx->data.parameter.instance_id,
																			type, "", "", domain, "",
																			CP_ADD_LIST, CP_WHITE_LIST);
								
											snmp_log(LOG_DEBUG, "dot11PortalWhiteListTable_commit: eag_conf_captive_list: ret = %d\n", ret);
											if(ret == EAG_RETURN_OK)
											{
												 rc = MFD_SUCCESS;
					                             break;
											}
											else if(EAG_ERR_DBUS_FAILED == ret) 
											{
												close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
											}
//										}
								    }    					    
							   	}
							}
							break;
					}
                }
                break;

            case RS_CREATEANDWAIT:
                rowreq_ctx->data.WLRowStatus = RS_NOTREADY;
                rc = MFD_SUCCESS;
                break;
                
            case RS_DESTROY:  
                {
					rc = -1;
					void *connection = NULL;
					if(SNMPD_DBUS_SUCCESS == get_instance_dbus_connection(rowreq_ctx->data.parameter, &connection, SNMPD_INSTANCE_MASTER_V3))
					{
						int ret = -1;
						switch(rowreq_ctx->data.WLtype)
						{
							case 0: 	/*ip*/
								{
									RULE_TYPE type = RULE_IPADDR;
									iprange_portset_t item;
									char ipaddr_begin[IP_ADDR_LEN] = { 0 };
									char ipaddr_end[IP_ADDR_LEN] = { 0 };
									char intf[255];
						
//									if(eag_ins_running_state(connection, rowreq_ctx->data.parameter.local_id, rowreq_ctx->data.parameter.instance_id) == 1)
//									{
										memset(&item, 0, sizeof(item));
						
										INET_NTOA(rowreq_ctx->data.WLstartip, ipaddr_begin);
										INET_NTOA(rowreq_ctx->data.WLendip, ipaddr_end);
										if(rowreq_ctx->data.WLendip == 0)
										{
											strncpy(item.iprange, ipaddr_begin, IPRANGE_LEN-1);
										}
										else
										{
											snprintf(item.iprange, IPRANGE_LEN-1, "%s-%s", ipaddr_begin, ipaddr_end);
										}										

										if(strcmp(rowreq_ctx->data.WLport,""))
										{
											if (captive_check_portset_format(rowreq_ctx->data.WLport) != 0)
											{
												break;
											}
											strncpy(item.portset, rowreq_ctx->data.WLport, PORTSET_LEN-1);
										}
										else
										{
											strncpy(item.portset, "all", PORTSET_LEN-1);
										}
					
										ret = eag_conf_captive_list( connection, rowreq_ctx->data.parameter.local_id,
																		rowreq_ctx->data.parameter.instance_id, 
																		type, item.iprange, item.portset, "", rowreq_ctx->data.WLintf,
																		CP_DEL_LIST, CP_WHITE_LIST);
						
										snmp_log(LOG_DEBUG, "dot11PortalWhiteListTable_commit: eag_conf_captive_list: ret = %d\n", ret);
										if(ret == EAG_RETURN_OK)
										{
											rc = MFD_SUCCESS;
				                            break;
										}
										else if(EAG_ERR_DBUS_FAILED == ret) 
										{
				                            close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
				                        }
//									}	
								}
								break;
							case 1: 	/*domain*/
								{
									RULE_TYPE type = RULE_DOMAIN;
									char domain[256] = { 0 };
						
//									if(eag_ins_running_state(connection, rowreq_ctx->data.parameter.local_id, rowreq_ctx->data.parameter.instance_id) == 1)
//									{
										memset(&domain, 0, sizeof(domain));
										strncpy(domain, rowreq_ctx->data.WLURL, sizeof(domain)-1);
							
										ret = eag_conf_captive_list( connection, rowreq_ctx->data.parameter.local_id,
																		rowreq_ctx->data.parameter.instance_id, 
																		type, "", "", domain, rowreq_ctx->data.WLintf, 
																		CP_DEL_LIST, CP_WHITE_LIST);
						
										snmp_log(LOG_DEBUG, "dot11PortalWhiteListTable_commit: eag_conf_captive_list: ret = %d\n", ret);
										if(ret == EAG_RETURN_OK)
										{
											rc = MFD_SUCCESS;
				                            break;
										}
										else if(EAG_ERR_DBUS_FAILED == ret) 
										{
				                            close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
				                        }
//									}	
								}
								break;
						}			
					}
                }
				if(MFD_SUCCESS != rc)
				{
                	rowreq_ctx->rowreq_flags &= ~MFD_ROW_DELETED;
				}
                break;
                
            default:
                break;
        }
       /*
        * TODO:482:o: |-> commit column WLRowStatus.
        */
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11PortalWhiteListTable column WLRowStatus commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo WLRowStatus
             */
            rowreq_ctx->column_set_flags |= COLUMN_WLROWSTATUS_FLAG;
       }
    }

    /*
     * if we successfully commited this row, set the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags |= MFD_ROW_DIRTY;
    }

    if (save_flags) {
       snmp_log(LOG_ERR, "unhandled columns (0x%x) in commit\n", save_flags);
       return MFD_ERROR;
    }

    return rc;
} /* dot11PortalWhiteListTable_commit */

/**
 * undo commit new values.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * dot11PortalWhiteListTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param dot11PortalWhiteListTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
dot11PortalWhiteListTable_undo_commit( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:dot11PortalWhiteListTable_undo_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:485:M: |-> Undo dot11PortalWhiteListTable commit.
     * check the column's flag in rowreq_ctx->column_set_flags to see
     * if it was set during commit, then undo it.
     *
     * eg: if (rowreq_ctx->column_set_flags & COLUMN__FLAG) {}
     */

    
    /*
     * if we successfully un-commited this row, clear the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags &= ~MFD_ROW_DIRTY;
    }

    return rc;
} /* dot11PortalWhiteListTable_undo_commit */

/*
 * TODO:440:M: Implement dot11PortalWhiteListTable node value checks.
 * TODO:450:M: Implement dot11PortalWhiteListTable undo functions.
 * TODO:460:M: Implement dot11PortalWhiteListTable set functions.
 * TODO:480:M: Implement dot11PortalWhiteListTable commit functions.
 */
/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11PortalWhiteListEntry.WLtype
 * WLtype is subid 2 of dot11PortalWhiteListEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.2.1.2
 * Description:
white list type.
					if the white list type is ip,ip range and port must set to be applied to the white list.
					if the white list type is domain,domain url must set to be applied to the white list
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  ip(0), domain(1)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param WLtype_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11PortalWhiteListTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  ip(0), domain(1)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
WLtype_check_value( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx, u_long WLtype_val)
{
    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:WLtype_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid WLtype value.
     */

    if(RS_NOTINSERVICE == rowreq_ctx->data.WLRowStatus || RS_NOTREADY == rowreq_ctx->data.WLRowStatus)
	    return MFD_SUCCESS;
	else     
        return MFD_ERROR; /* WLtype value not illegal */
} /* WLtype_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11PortalWhiteListTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11PortalWhiteListTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
WLtype_undo_setup( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:WLtype_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup WLtype undo.
     */
    /*
     * copy WLtype data
     * set rowreq_ctx->undo->WLtype from rowreq_ctx->data.WLtype
     */
    rowreq_ctx->undo->WLtype = rowreq_ctx->data.WLtype;


    return MFD_SUCCESS;
} /* WLtype_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param WLtype_val
 *        A long containing the new value.
 */
int
WLtype_set( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx, u_long WLtype_val )
{

    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:WLtype_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set WLtype value.
     * set WLtype value in rowreq_ctx->data
     */
    rowreq_ctx->data.WLtype = WLtype_val;

    return MFD_SUCCESS;
} /* WLtype_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
WLtype_undo( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:WLtype_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up WLtype undo.
     */
    /*
     * copy WLtype data
     * set rowreq_ctx->data.WLtype from rowreq_ctx->undo->WLtype
     */
    rowreq_ctx->data.WLtype = rowreq_ctx->undo->WLtype;

    
    return MFD_SUCCESS;
} /* WLtype_undo */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11PortalWhiteListEntry.WLstartip
 * WLstartip is subid 3 of dot11PortalWhiteListEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.2.1.3
 * Description:
white list start ip.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is IPADDR (based on perltype IPADDR)
 * The net-snmp type is ASN_IPADDRESS. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param WLstartip_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11PortalWhiteListTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_IPADDRESS
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
WLstartip_check_value( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx, u_long WLstartip_val)
{
    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:WLstartip_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid WLstartip value.
     */

    if(RS_NOTINSERVICE == rowreq_ctx->data.WLRowStatus || RS_NOTREADY == rowreq_ctx->data.WLRowStatus)
	    return MFD_SUCCESS;
	else     
        return MFD_ERROR; /* WLstartip value not illegal */
} /* WLstartip_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11PortalWhiteListTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11PortalWhiteListTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
WLstartip_undo_setup( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:WLstartip_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup WLstartip undo.
     */
    /*
     * copy WLstartip data
     * set rowreq_ctx->undo->WLstartip from rowreq_ctx->data.WLstartip
     */
    rowreq_ctx->undo->WLstartip = rowreq_ctx->data.WLstartip;


    return MFD_SUCCESS;
} /* WLstartip_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param WLstartip_val
 *        A u_long containing the new value.
 */
int
WLstartip_set( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx, u_long WLstartip_val )
{

    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:WLstartip_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set WLstartip value.
     * set WLstartip value in rowreq_ctx->data
     */
    rowreq_ctx->data.WLstartip = WLstartip_val;

    return MFD_SUCCESS;
} /* WLstartip_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
WLstartip_undo( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:WLstartip_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up WLstartip undo.
     */
    /*
     * copy WLstartip data
     * set rowreq_ctx->data.WLstartip from rowreq_ctx->undo->WLstartip
     */
    rowreq_ctx->data.WLstartip = rowreq_ctx->undo->WLstartip;

    
    return MFD_SUCCESS;
} /* WLstartip_undo */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11PortalWhiteListEntry.WLendip
 * WLendip is subid 4 of dot11PortalWhiteListEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.2.1.4
 * Description:
white list end ip.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is IPADDR (based on perltype IPADDR)
 * The net-snmp type is ASN_IPADDRESS. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param WLendip_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11PortalWhiteListTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_IPADDRESS
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
WLendip_check_value( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx, u_long WLendip_val)
{
    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:WLendip_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid WLendip value.
     */

    if(RS_NOTINSERVICE == rowreq_ctx->data.WLRowStatus || RS_NOTREADY == rowreq_ctx->data.WLRowStatus)
	    return MFD_SUCCESS;
	else     
        return MFD_ERROR; /* WLendip value not illegal */
} /* WLendip_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11PortalWhiteListTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11PortalWhiteListTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
WLendip_undo_setup( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:WLendip_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup WLendip undo.
     */
    /*
     * copy WLendip data
     * set rowreq_ctx->undo->WLendip from rowreq_ctx->data.WLendip
     */
    rowreq_ctx->undo->WLendip = rowreq_ctx->data.WLendip;


    return MFD_SUCCESS;
} /* WLendip_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param WLendip_val
 *        A u_long containing the new value.
 */
int
WLendip_set( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx, u_long WLendip_val )
{

    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:WLendip_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set WLendip value.
     * set WLendip value in rowreq_ctx->data
     */
    rowreq_ctx->data.WLendip = WLendip_val;

    return MFD_SUCCESS;
} /* WLendip_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
WLendip_undo( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:WLendip_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up WLendip undo.
     */
    /*
     * copy WLendip data
     * set rowreq_ctx->data.WLendip from rowreq_ctx->undo->WLendip
     */
    rowreq_ctx->data.WLendip = rowreq_ctx->undo->WLendip;

    
    return MFD_SUCCESS;
} /* WLendip_undo */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11PortalWhiteListEntry.WLport
 * WLport is subid 5 of dot11PortalWhiteListEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.2.1.5
 * Description:
white list port list,the format is (all|PORT[,PORT]...)
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param WLport_val_ptr
 *        A char containing the new value.
 * @param WLport_val_ptr_len
 *        The size (in bytes) of the data pointed to by WLport_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11PortalWhiteListTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is < sizeof(rowreq_ctx->data.WLport).
 *    The length is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
WLport_check_value( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx, char *WLport_val_ptr,  size_t WLport_val_ptr_len)
{
    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:WLport_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != WLport_val_ptr);

    /*
     * TODO:441:o: |-> Check for valid WLport value.
     */

    if(RS_NOTINSERVICE == rowreq_ctx->data.WLRowStatus || RS_NOTREADY == rowreq_ctx->data.WLRowStatus)
	    return MFD_SUCCESS;
	else     
        return MFD_ERROR; /* WLport value not illegal */
} /* WLport_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11PortalWhiteListTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11PortalWhiteListTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
WLport_undo_setup( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:WLport_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup WLport undo.
     */
    /*
     * copy WLport and WLport_len data
     * set rowreq_ctx->undo->WLport from rowreq_ctx->data.WLport
     */
    memcpy( rowreq_ctx->undo->WLport, rowreq_ctx->data.WLport,
            (rowreq_ctx->data.WLport_len * sizeof(rowreq_ctx->undo->WLport[0])));
    rowreq_ctx->undo->WLport_len = rowreq_ctx->data.WLport_len;


    return MFD_SUCCESS;
} /* WLport_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param WLport_val_ptr
 *        A char containing the new value.
 * @param WLport_val_ptr_len
 *        The size (in bytes) of the data pointed to by WLport_val_ptr
 */
int
WLport_set( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx, char *WLport_val_ptr,  size_t WLport_val_ptr_len )
{

    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:WLport_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != WLport_val_ptr);

    /*
     * TODO:461:M: |-> Set WLport value.
     * set WLport value in rowreq_ctx->data
     */
    memcpy( rowreq_ctx->data.WLport, WLport_val_ptr, WLport_val_ptr_len );
    /** convert bytes to number of char */
    rowreq_ctx->data.WLport_len = WLport_val_ptr_len / sizeof(WLport_val_ptr[0]);

    return MFD_SUCCESS;
} /* WLport_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
WLport_undo( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:WLport_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up WLport undo.
     */
    /*
     * copy WLport and WLport_len data
     * set rowreq_ctx->data.WLport from rowreq_ctx->undo->WLport
     */
    memcpy( rowreq_ctx->data.WLport, rowreq_ctx->undo->WLport,
            (rowreq_ctx->undo->WLport_len * sizeof(rowreq_ctx->data.WLport[0])));
    rowreq_ctx->data.WLport_len = rowreq_ctx->undo->WLport_len;

    
    return MFD_SUCCESS;
} /* WLport_undo */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11PortalWhiteListEntry.WLURL
 * WLURL is subid 6 of dot11PortalWhiteListEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.2.1.6
 * Description:
white list URL.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param WLURL_val_ptr
 *        A char containing the new value.
 * @param WLURL_val_ptr_len
 *        The size (in bytes) of the data pointed to by WLURL_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11PortalWhiteListTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is < sizeof(rowreq_ctx->data.WLURL).
 *    The length is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
WLURL_check_value( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx, char *WLURL_val_ptr,  size_t WLURL_val_ptr_len)
{
    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:WLURL_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != WLURL_val_ptr);

    /*
     * TODO:441:o: |-> Check for valid WLURL value.
     */

    if(RS_NOTINSERVICE == rowreq_ctx->data.WLRowStatus || RS_NOTREADY == rowreq_ctx->data.WLRowStatus)
	    return MFD_SUCCESS;
	else     
        return MFD_ERROR; /* WLURL value not illegal */
} /* WLURL_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11PortalWhiteListTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11PortalWhiteListTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
WLURL_undo_setup( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:WLURL_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup WLURL undo.
     */
    /*
     * copy WLURL and WLURL_len data
     * set rowreq_ctx->undo->WLURL from rowreq_ctx->data.WLURL
     */
    memcpy( rowreq_ctx->undo->WLURL, rowreq_ctx->data.WLURL,
            (rowreq_ctx->data.WLURL_len * sizeof(rowreq_ctx->undo->WLURL[0])));
    rowreq_ctx->undo->WLURL_len = rowreq_ctx->data.WLURL_len;


    return MFD_SUCCESS;
} /* WLURL_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param WLURL_val_ptr
 *        A char containing the new value.
 * @param WLURL_val_ptr_len
 *        The size (in bytes) of the data pointed to by WLURL_val_ptr
 */
int
WLURL_set( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx, char *WLURL_val_ptr,  size_t WLURL_val_ptr_len )
{

    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:WLURL_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != WLURL_val_ptr);

    /*
     * TODO:461:M: |-> Set WLURL value.
     * set WLURL value in rowreq_ctx->data
     */
    memcpy( rowreq_ctx->data.WLURL, WLURL_val_ptr, WLURL_val_ptr_len );
    /** convert bytes to number of char */
    rowreq_ctx->data.WLURL_len = WLURL_val_ptr_len / sizeof(WLURL_val_ptr[0]);

    return MFD_SUCCESS;
} /* WLURL_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
WLURL_undo( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:WLURL_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up WLURL undo.
     */
    /*
     * copy WLURL and WLURL_len data
     * set rowreq_ctx->data.WLURL from rowreq_ctx->undo->WLURL
     */
    memcpy( rowreq_ctx->data.WLURL, rowreq_ctx->undo->WLURL,
            (rowreq_ctx->undo->WLURL_len * sizeof(rowreq_ctx->data.WLURL[0])));
    rowreq_ctx->data.WLURL_len = rowreq_ctx->undo->WLURL_len;

    
    return MFD_SUCCESS;
} /* WLURL_undo */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11PortalWhiteListEntry.WLRowStatus
 * WLRowStatus is subid 7 of dot11PortalWhiteListEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.2.1.7
 * Description:
This variable is used to create, modify, and/or delete a row
			        	 in this table.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * Its syntax is RowStatus (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param WLRowStatus_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11PortalWhiteListTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
WLRowStatus_check_value( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx, u_long WLRowStatus_val)
{
    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:WLRowStatus_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid WLRowStatus value.
     */

    return MFD_SUCCESS; /* WLRowStatus value not illegal */
} /* WLRowStatus_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11PortalWhiteListTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11PortalWhiteListTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
WLRowStatus_undo_setup( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:WLRowStatus_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup WLRowStatus undo.
     */
    /*
     * copy WLRowStatus data
     * set rowreq_ctx->undo->WLRowStatus from rowreq_ctx->data.WLRowStatus
     */
    rowreq_ctx->undo->WLRowStatus = rowreq_ctx->data.WLRowStatus;


    return MFD_SUCCESS;
} /* WLRowStatus_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param WLRowStatus_val
 *        A long containing the new value.
 */
int
WLRowStatus_set( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx, u_long WLRowStatus_val )
{

    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:WLRowStatus_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set WLRowStatus value.
     * set WLRowStatus value in rowreq_ctx->data
     */
    int ret = MFD_SUCCESS;
    
    switch(WLRowStatus_val) {
    
        case RS_ACTIVE:         
        case RS_DESTROY:
            rowreq_ctx->data.WLRowStatus = WLRowStatus_val;
            ret = MFD_SUCCESS;
            break;
    
        case RS_NOTINSERVICE:
        case RS_NOTREADY:
        case RS_CREATEANDGO:
            ret = MFD_ERROR;
            break;
    
        case RS_CREATEANDWAIT:
            if(RS_NONEXISTENT == rowreq_ctx->data.WLRowStatus) {
                global_to_local_ID(&(rowreq_ctx->data.parameter), 
                                    rowreq_ctx->tbl_idx.WLid, 
                                    WIRELESS_MAX_NUM);
                rowreq_ctx->data.WLRowStatus = WLRowStatus_val;
                ret = MFD_SUCCESS;
            }
            else {
                ret = MFD_ERROR;
            }
            break;
    
        default:
            snmp_log(LOG_WARNING, "unknow %s in WLRowStatus_set", WLRowStatus_val);
            ret = MFD_ERROR;
            break;
    }

    return ret;
    
} /* WLRowStatus_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
WLRowStatus_undo( dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11PortalWhiteListTable:WLRowStatus_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up WLRowStatus undo.
     */
    /*
     * copy WLRowStatus data
     * set rowreq_ctx->data.WLRowStatus from rowreq_ctx->undo->WLRowStatus
     */
    rowreq_ctx->data.WLRowStatus = rowreq_ctx->undo->WLRowStatus;

    
    return MFD_SUCCESS;
} /* WLRowStatus_undo */

/**
 * check dependencies
 *
 * This is useful for for tables which have dependencies between columns
 * (or rows, or tables). For example, two columns allocating a percentage
 * of something add up 100%.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * dot11PortalWhiteListTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @retval MFD_SUCCESS all the changes to the row are legal
 * @retval MFD_ERROR   one or more changes are not legal
 *
 * (see README-table-dot11PortalWhiteListTable if you don't have dependencies)
 */
int
dot11PortalWhiteListTable_check_dependencies(dot11PortalWhiteListTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;
    
    DEBUGMSGTL(("internal:dot11PortalWhiteListTable:dot11PortalWhiteListTable_check_dependencies","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:470:o: Check dot11PortalWhiteListTable row dependencies.
     * check that all new value are legal and consistent with each other
     */
    /*
     * check RowStatus dependencies
     */
    if (rowreq_ctx->column_set_flags & COLUMN_WLROWSTATUS_FLAG) {
        /*
         * check for valid RowStatus transition (old, new)
         * (Note: move transition check to 
         *  to catch errors earlier)
         */
        rc = check_rowstatus_transition( rowreq_ctx->undo->WLRowStatus,
                                         rowreq_ctx->data.WLRowStatus );
        if (MFD_SUCCESS != rc)
            return rc;
        
        /*
         * row creation requirements
         */
        if (rowreq_ctx->rowreq_flags & MFD_ROW_CREATED) {
            if (ROWSTATUS_DESTROY ==  rowreq_ctx->data.WLRowStatus) {
                rowreq_ctx->rowreq_flags |= MFD_ROW_DELETED;
            }
            else if (ROWSTATUS_CREATEANDGO ==  rowreq_ctx->data.WLRowStatus) {
                if ((rowreq_ctx->column_set_flags & DOT11PORTALWHITELISTTABLE_REQUIRED_COLS)
                    != DOT11PORTALWHITELISTTABLE_REQUIRED_COLS) {
                    DEBUGMSGTL(("dot11PortalWhiteListTable",
                                "required columns missing (0x%0x != 0x%0x)\n",
                                rowreq_ctx->column_set_flags, DOT11PORTALWHITELISTTABLE_REQUIRED_COLS));
                    return MFD_CANNOT_CREATE_NOW;
                }
                rowreq_ctx->data.WLRowStatus = ROWSTATUS_ACTIVE;
            }
        } /* row creation */
        else {
            /*
             * row change requirements
             */
            /*
             * don't allow a destroy if any other value was changed, since
             * that might call data access routines with bad info.
             *
             * you may or may not require the row be notInService before it
             * can be destroyed.
             */
            if (ROWSTATUS_DESTROY == rowreq_ctx->data.WLRowStatus) {
                if (rowreq_ctx->column_set_flags & ~COLUMN_WLROWSTATUS_FLAG) {
                    DEBUGMSGTL(("dot11PortalWhiteListTable",
                                "destroy must be only varbind for row\n"));
                    return MFD_NOT_VALID_NOW;
                }
                rowreq_ctx->rowreq_flags |= MFD_ROW_DELETED;

            } /* row destroy */
        } /* row change */
    }
    else {
        /*
         * must have row status to create a row
         */
        if (rowreq_ctx->rowreq_flags & MFD_ROW_CREATED) {
            DEBUGMSGTL(("dot11PortalWhiteListTable",
                        "must use RowStatus to create rows\n"));
            return MFD_CANNOT_CREATE_NOW;
        }
    } /* row status not set */

    if ( MFD_SUCCESS != rc )
        return rc;

    return rc;
} /* dot11PortalWhiteListTable_check_dependencies */

/** @} */
