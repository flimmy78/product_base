/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.18.2.1 $ of : mfd-data-get.m2c,v $ 
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "dot11WtpParaTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement dot11WtpParaTable get routines.
 * TODO:240:M: Implement dot11WtpParaTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table dot11WtpParaTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * dot11WtpParaTable is subid 5 of wtpStats.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.5, length: 12
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement dot11WtpParaTable data context functions.
 */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpInfoEntry.wtpMacAddr
 * wtpMacAddr is subid 1 of dot11WtpInfoEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.1.1.1.1
 * Description:
AP mac.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is Dot11BaseWtpIdTC (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max )
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpMacAddr.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpMacAddr_dot11WtpParaTable_map(char **mib_wtpMacAddr_val_ptr_ptr, size_t *mib_wtpMacAddr_val_ptr_len_ptr, char *raw_wtpMacAddr_val_ptr, size_t raw_wtpMacAddr_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpMacAddr_val_ptr);
    netsnmp_assert((NULL != mib_wtpMacAddr_val_ptr_ptr) && (NULL != mib_wtpMacAddr_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpMacAddr_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpMacAddr non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpMacAddr_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpMacAddr_val_ptr_ptr) || (*mib_wtpMacAddr_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpMacAddr_val_ptr_ptr = realloc( *mib_wtpMacAddr_val_ptr_ptr, converted_len * sizeof(**mib_wtpMacAddr_val_ptr_ptr));
        if(NULL == *mib_wtpMacAddr_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpMacAddr_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpMacAddr_val_ptr_ptr, raw_wtpMacAddr_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpMacAddr_map */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
dot11WtpParaTable_indexes_set_tbl_idx(dot11WtpParaTable_mib_index *tbl_idx, char *wtpMacAddr_val_ptr,  size_t wtpMacAddr_val_ptr_len)
{
    DEBUGMSGTL(("verbose:dot11WtpParaTable:dot11WtpParaTable_indexes_set_tbl_idx","called\n"));

    /* wtpMacAddr(1)/Dot11BaseWtpIdTC/ASN_OCTET_STR/char(char)//L/A/w/e/r/d/h */
     tbl_idx->wtpMacAddr_len = sizeof(tbl_idx->wtpMacAddr);
    /*
     * make sure there is enough space for wtpMacAddr data
     */
    if ((NULL == tbl_idx->wtpMacAddr) ||
        (tbl_idx->wtpMacAddr_len < (wtpMacAddr_val_ptr_len * sizeof(tbl_idx->wtpMacAddr[0])))) {
        snmp_log(LOG_ERR,"not enough space for value\n");
        return MFD_ERROR;
    }
    tbl_idx->wtpMacAddr_len = wtpMacAddr_val_ptr_len * sizeof(tbl_idx->wtpMacAddr[0]);
    memcpy( tbl_idx->wtpMacAddr, wtpMacAddr_val_ptr, tbl_idx->wtpMacAddr_len );
    

    return MFD_SUCCESS;
} /* dot11WtpParaTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
dot11WtpParaTable_indexes_set(dot11WtpParaTable_rowreq_ctx *rowreq_ctx, char *wtpMacAddr_val_ptr,  size_t wtpMacAddr_val_ptr_len)
{
    DEBUGMSGTL(("verbose:dot11WtpParaTable:dot11WtpParaTable_indexes_set","called\n"));

    if(MFD_SUCCESS != dot11WtpParaTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
                                   , wtpMacAddr_val_ptr, wtpMacAddr_val_ptr_len
           ))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if(0 != dot11WtpParaTable_index_to_oid(&rowreq_ctx->oid_idx,
                                    &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* dot11WtpParaTable_indexes_set */


/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpParaEntry.wtpCurBssid
 * wtpCurBssid is subid 1 of dot11WtpParaEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.5.1.1
 * Description:
The current BSSID of AP.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpCurBssid.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpCurBssid_map(char **mib_wtpCurBssid_val_ptr_ptr, size_t *mib_wtpCurBssid_val_ptr_len_ptr, char *raw_wtpCurBssid_val_ptr, size_t raw_wtpCurBssid_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpCurBssid_val_ptr);
    netsnmp_assert((NULL != mib_wtpCurBssid_val_ptr_ptr) && (NULL != mib_wtpCurBssid_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpCurBssid_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpCurBssid non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpCurBssid_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpCurBssid_val_ptr_ptr) || (*mib_wtpCurBssid_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpCurBssid_val_ptr_ptr = realloc( *mib_wtpCurBssid_val_ptr_ptr, converted_len * sizeof(**mib_wtpCurBssid_val_ptr_ptr));
        if(NULL == *mib_wtpCurBssid_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpCurBssid_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpCurBssid_val_ptr_ptr, raw_wtpCurBssid_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpCurBssid_map */

/**
 * Extract the current value of the wtpCurBssid data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpCurBssid_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wtpCurBssid_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wtpCurBssid.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wtpCurBssid_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wtpCurBssid_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wtpCurBssid_get( dot11WtpParaTable_rowreq_ctx *rowreq_ctx, char **wtpCurBssid_val_ptr_ptr, size_t *wtpCurBssid_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != wtpCurBssid_val_ptr_ptr) && (NULL != *wtpCurBssid_val_ptr_ptr));
   netsnmp_assert( NULL != wtpCurBssid_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpCurBssid_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpCurBssid data.
 * set (* wtpCurBssid_val_ptr_ptr ) and (* wtpCurBssid_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for wtpCurBssid data
     */
    if ((NULL == (* wtpCurBssid_val_ptr_ptr )) ||
        ((* wtpCurBssid_val_ptr_len_ptr ) < (rowreq_ctx->data.wtpCurBssid_len * sizeof((* wtpCurBssid_val_ptr_ptr )[0])))) {
        /*
         * allocate space for wtpCurBssid data
         */
        (* wtpCurBssid_val_ptr_ptr ) = malloc(rowreq_ctx->data.wtpCurBssid_len * sizeof((* wtpCurBssid_val_ptr_ptr )[0]));
        if(NULL == (* wtpCurBssid_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* wtpCurBssid_val_ptr_len_ptr ) = rowreq_ctx->data.wtpCurBssid_len * sizeof((* wtpCurBssid_val_ptr_ptr )[0]);
    memcpy( (* wtpCurBssid_val_ptr_ptr ), rowreq_ctx->data.wtpCurBssid, (* wtpCurBssid_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* wtpCurBssid_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpParaEntry.wtpGateAddr
 * wtpGateAddr is subid 2 of dot11WtpParaEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.5.1.2
 * Description:
The AP gateway address.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is IPADDR (based on perltype IPADDR)
 * The net-snmp type is ASN_IPADDRESS. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpGateAddr.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpGateAddr_map(u_long *mib_wtpGateAddr_val_ptr, u_long raw_wtpGateAddr_val)
{
    netsnmp_assert(NULL != mib_wtpGateAddr_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpGateAddr_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpGateAddr mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpGateAddr_val_ptr) = raw_wtpGateAddr_val;

    return MFD_SUCCESS;
} /* wtpGateAddr_map */

/**
 * Extract the current value of the wtpGateAddr data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpGateAddr_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpGateAddr_get( dot11WtpParaTable_rowreq_ctx *rowreq_ctx, u_long * wtpGateAddr_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpGateAddr_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpGateAddr_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpGateAddr data.
 * set (* wtpGateAddr_val_ptr ) from rowreq_ctx->data
 */
    (* wtpGateAddr_val_ptr ) = rowreq_ctx->data.wtpGateAddr;

    return MFD_SUCCESS;
} /* wtpGateAddr_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpParaEntry.wtpNetElementCode
 * wtpNetElementCode is subid 3 of dot11WtpParaEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.5.1.3
 * Description:
The net element of AP coding.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  1 - 32;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 32)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpNetElementCode.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpNetElementCode_map(char **mib_wtpNetElementCode_val_ptr_ptr, size_t *mib_wtpNetElementCode_val_ptr_len_ptr, char *raw_wtpNetElementCode_val_ptr, size_t raw_wtpNetElementCode_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpNetElementCode_val_ptr);
    netsnmp_assert((NULL != mib_wtpNetElementCode_val_ptr_ptr) && (NULL != mib_wtpNetElementCode_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpNetElementCode_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpNetElementCode non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpNetElementCode_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpNetElementCode_val_ptr_ptr) || (*mib_wtpNetElementCode_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpNetElementCode_val_ptr_ptr = realloc( *mib_wtpNetElementCode_val_ptr_ptr, converted_len * sizeof(**mib_wtpNetElementCode_val_ptr_ptr));
        if(NULL == *mib_wtpNetElementCode_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpNetElementCode_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpNetElementCode_val_ptr_ptr, raw_wtpNetElementCode_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpNetElementCode_map */

/**
 * Extract the current value of the wtpNetElementCode data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpNetElementCode_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wtpNetElementCode_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wtpNetElementCode.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wtpNetElementCode_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wtpNetElementCode_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wtpNetElementCode_get( dot11WtpParaTable_rowreq_ctx *rowreq_ctx, char **wtpNetElementCode_val_ptr_ptr, size_t *wtpNetElementCode_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != wtpNetElementCode_val_ptr_ptr) && (NULL != *wtpNetElementCode_val_ptr_ptr));
   netsnmp_assert( NULL != wtpNetElementCode_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpNetElementCode_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpNetElementCode data.
 * set (* wtpNetElementCode_val_ptr_ptr ) and (* wtpNetElementCode_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for wtpNetElementCode data
     */
    if ((NULL == (* wtpNetElementCode_val_ptr_ptr )) ||
        ((* wtpNetElementCode_val_ptr_len_ptr ) < (rowreq_ctx->data.wtpNetElementCode_len * sizeof((* wtpNetElementCode_val_ptr_ptr )[0])))) {
        /*
         * allocate space for wtpNetElementCode data
         */
        (* wtpNetElementCode_val_ptr_ptr ) = malloc(rowreq_ctx->data.wtpNetElementCode_len * sizeof((* wtpNetElementCode_val_ptr_ptr )[0]));
        if(NULL == (* wtpNetElementCode_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* wtpNetElementCode_val_ptr_len_ptr ) = rowreq_ctx->data.wtpNetElementCode_len * sizeof((* wtpNetElementCode_val_ptr_ptr )[0]);
    memcpy( (* wtpNetElementCode_val_ptr_ptr ), rowreq_ctx->data.wtpNetElementCode, (* wtpNetElementCode_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* wtpNetElementCode_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpParaEntry.wtpAddrMask
 * wtpAddrMask is subid 4 of dot11WtpParaEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.5.1.4
 * Description:
AP address mask .
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is IPADDR (based on perltype IPADDR)
 * The net-snmp type is ASN_IPADDRESS. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpAddrMask.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpAddrMask_map(u_long *mib_wtpAddrMask_val_ptr, u_long raw_wtpAddrMask_val)
{
    netsnmp_assert(NULL != mib_wtpAddrMask_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpAddrMask_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpAddrMask mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpAddrMask_val_ptr) = raw_wtpAddrMask_val;

    return MFD_SUCCESS;
} /* wtpAddrMask_map */

/**
 * Extract the current value of the wtpAddrMask data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpAddrMask_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpAddrMask_get( dot11WtpParaTable_rowreq_ctx *rowreq_ctx, u_long * wtpAddrMask_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpAddrMask_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpAddrMask_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpAddrMask data.
 * set (* wtpAddrMask_val_ptr ) from rowreq_ctx->data
 */
    (* wtpAddrMask_val_ptr ) = rowreq_ctx->data.wtpAddrMask;

    return MFD_SUCCESS;
} /* wtpAddrMask_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpParaEntry.wtpsupportIfType
 * wtpsupportIfType is subid 5 of dot11WtpParaEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.5.1.5
 * Description:
AP interface type.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpsupportIfType.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpsupportIfType_map(char **mib_wtpsupportIfType_val_ptr_ptr, size_t *mib_wtpsupportIfType_val_ptr_len_ptr, char *raw_wtpsupportIfType_val_ptr, size_t raw_wtpsupportIfType_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpsupportIfType_val_ptr);
    netsnmp_assert((NULL != mib_wtpsupportIfType_val_ptr_ptr) && (NULL != mib_wtpsupportIfType_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpsupportIfType_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpsupportIfType non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpsupportIfType_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpsupportIfType_val_ptr_ptr) || (*mib_wtpsupportIfType_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpsupportIfType_val_ptr_ptr = realloc( *mib_wtpsupportIfType_val_ptr_ptr, converted_len * sizeof(**mib_wtpsupportIfType_val_ptr_ptr));
        if(NULL == *mib_wtpsupportIfType_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpsupportIfType_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpsupportIfType_val_ptr_ptr, raw_wtpsupportIfType_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpsupportIfType_map */

/**
 * Extract the current value of the wtpsupportIfType data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpsupportIfType_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wtpsupportIfType_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wtpsupportIfType.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wtpsupportIfType_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wtpsupportIfType_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wtpsupportIfType_get( dot11WtpParaTable_rowreq_ctx *rowreq_ctx, char **wtpsupportIfType_val_ptr_ptr, size_t *wtpsupportIfType_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != wtpsupportIfType_val_ptr_ptr) && (NULL != *wtpsupportIfType_val_ptr_ptr));
   netsnmp_assert( NULL != wtpsupportIfType_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpsupportIfType_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpsupportIfType data.
 * set (* wtpsupportIfType_val_ptr_ptr ) and (* wtpsupportIfType_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for wtpsupportIfType data
     */
    if ((NULL == (* wtpsupportIfType_val_ptr_ptr )) ||
        ((* wtpsupportIfType_val_ptr_len_ptr ) < (rowreq_ctx->data.wtpsupportIfType_len * sizeof((* wtpsupportIfType_val_ptr_ptr )[0])))) {
        /*
         * allocate space for wtpsupportIfType data
         */
        (* wtpsupportIfType_val_ptr_ptr ) = malloc(rowreq_ctx->data.wtpsupportIfType_len * sizeof((* wtpsupportIfType_val_ptr_ptr )[0]));
        if(NULL == (* wtpsupportIfType_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* wtpsupportIfType_val_ptr_len_ptr ) = rowreq_ctx->data.wtpsupportIfType_len * sizeof((* wtpsupportIfType_val_ptr_ptr )[0]);
    memcpy( (* wtpsupportIfType_val_ptr_ptr ), rowreq_ctx->data.wtpsupportIfType, (* wtpsupportIfType_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* wtpsupportIfType_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpParaEntry.wtpRemoteRestartFun
 * wtpRemoteRestartFun is subid 6 of dot11WtpParaEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.5.1.6
 * Description:
AP remote reset function.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  unused(0), used(1)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpRemoteRestartFun.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpRemoteRestartFun_map(u_long *mib_wtpRemoteRestartFun_val_ptr, u_long raw_wtpRemoteRestartFun_val)
{
    netsnmp_assert(NULL != mib_wtpRemoteRestartFun_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpRemoteRestartFun_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpRemoteRestartFun enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wtpRemoteRestartFun_val) {
        case INTERNAL_WTPREMOTERESTARTFUN_UNUSED:
             *mib_wtpRemoteRestartFun_val_ptr = WTPREMOTERESTARTFUN_UNUSED;
             break;

        case INTERNAL_WTPREMOTERESTARTFUN_USED:
             *mib_wtpRemoteRestartFun_val_ptr = WTPREMOTERESTARTFUN_USED;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wtpRemoteRestartFun\n", raw_wtpRemoteRestartFun_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wtpRemoteRestartFun_map */

/**
 * Extract the current value of the wtpRemoteRestartFun data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpRemoteRestartFun_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpRemoteRestartFun_get( dot11WtpParaTable_rowreq_ctx *rowreq_ctx, u_long * wtpRemoteRestartFun_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpRemoteRestartFun_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpRemoteRestartFun_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpRemoteRestartFun data.
 * set (* wtpRemoteRestartFun_val_ptr ) from rowreq_ctx->data
 */
    (* wtpRemoteRestartFun_val_ptr ) = rowreq_ctx->data.wtpRemoteRestartFun;

    return MFD_SUCCESS;
} /* wtpRemoteRestartFun_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpParaEntry.wtpWorkMode
 * wtpWorkMode is subid 7 of dot11WtpParaEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.5.1.7
 * Description:
AP work mode.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 3/8. Values:  fat_ap(1), bridge_mode(2), ap_and_brige(3)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWorkMode.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWorkMode_map(u_long *mib_wtpWorkMode_val_ptr, u_long raw_wtpWorkMode_val)
{
    netsnmp_assert(NULL != mib_wtpWorkMode_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpWorkMode_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWorkMode enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wtpWorkMode_val) {
        case INTERNAL_WTPWORKMODE_FAT_AP:
             *mib_wtpWorkMode_val_ptr = WTPWORKMODE_FAT_AP;
             break;

        case INTERNAL_WTPWORKMODE_BRIDGE_MODE:
             *mib_wtpWorkMode_val_ptr = WTPWORKMODE_BRIDGE_MODE;
             break;

        case INTERNAL_WTPWORKMODE_AP_AND_BRIGE:
             *mib_wtpWorkMode_val_ptr = WTPWORKMODE_AP_AND_BRIGE;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wtpWorkMode\n", raw_wtpWorkMode_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wtpWorkMode_map */

/**
 * Extract the current value of the wtpWorkMode data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWorkMode_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWorkMode_get( dot11WtpParaTable_rowreq_ctx *rowreq_ctx, u_long * wtpWorkMode_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWorkMode_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpWorkMode_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWorkMode data.
 * set (* wtpWorkMode_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWorkMode_val_ptr ) = rowreq_ctx->data.wtpWorkMode;

    return MFD_SUCCESS;
} /* wtpWorkMode_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpParaEntry.wtpReceiverSignalPWL
 * wtpReceiverSignalPWL is subid 8 of dot11WtpParaEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.5.1.8
 * Description:
Receiver signal PWL.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpReceiverSignalPWL.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpReceiverSignalPWL_map(char **mib_wtpReceiverSignalPWL_val_ptr_ptr, size_t *mib_wtpReceiverSignalPWL_val_ptr_len_ptr, char *raw_wtpReceiverSignalPWL_val_ptr, size_t raw_wtpReceiverSignalPWL_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpReceiverSignalPWL_val_ptr);
    netsnmp_assert((NULL != mib_wtpReceiverSignalPWL_val_ptr_ptr) && (NULL != mib_wtpReceiverSignalPWL_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpReceiverSignalPWL_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpReceiverSignalPWL non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpReceiverSignalPWL_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpReceiverSignalPWL_val_ptr_ptr) || (*mib_wtpReceiverSignalPWL_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpReceiverSignalPWL_val_ptr_ptr = realloc( *mib_wtpReceiverSignalPWL_val_ptr_ptr, converted_len * sizeof(**mib_wtpReceiverSignalPWL_val_ptr_ptr));
        if(NULL == *mib_wtpReceiverSignalPWL_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpReceiverSignalPWL_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpReceiverSignalPWL_val_ptr_ptr, raw_wtpReceiverSignalPWL_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpReceiverSignalPWL_map */

/**
 * Extract the current value of the wtpReceiverSignalPWL data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpReceiverSignalPWL_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wtpReceiverSignalPWL_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wtpReceiverSignalPWL.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wtpReceiverSignalPWL_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wtpReceiverSignalPWL_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wtpReceiverSignalPWL_get( dot11WtpParaTable_rowreq_ctx *rowreq_ctx, char **wtpReceiverSignalPWL_val_ptr_ptr, size_t *wtpReceiverSignalPWL_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != wtpReceiverSignalPWL_val_ptr_ptr) && (NULL != *wtpReceiverSignalPWL_val_ptr_ptr));
   netsnmp_assert( NULL != wtpReceiverSignalPWL_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpReceiverSignalPWL_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpReceiverSignalPWL data.
 * set (* wtpReceiverSignalPWL_val_ptr_ptr ) and (* wtpReceiverSignalPWL_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for wtpReceiverSignalPWL data
     */
    if ((NULL == (* wtpReceiverSignalPWL_val_ptr_ptr )) ||
        ((* wtpReceiverSignalPWL_val_ptr_len_ptr ) < (rowreq_ctx->data.wtpReceiverSignalPWL_len * sizeof((* wtpReceiverSignalPWL_val_ptr_ptr )[0])))) {
        /*
         * allocate space for wtpReceiverSignalPWL data
         */
        (* wtpReceiverSignalPWL_val_ptr_ptr ) = malloc(rowreq_ctx->data.wtpReceiverSignalPWL_len * sizeof((* wtpReceiverSignalPWL_val_ptr_ptr )[0]));
        if(NULL == (* wtpReceiverSignalPWL_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* wtpReceiverSignalPWL_val_ptr_len_ptr ) = rowreq_ctx->data.wtpReceiverSignalPWL_len * sizeof((* wtpReceiverSignalPWL_val_ptr_ptr )[0]);
    memcpy( (* wtpReceiverSignalPWL_val_ptr_ptr ), rowreq_ctx->data.wtpReceiverSignalPWL, (* wtpReceiverSignalPWL_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* wtpReceiverSignalPWL_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpParaEntry.wtpMacConApAc
 * wtpMacConApAc is subid 9 of dot11WtpParaEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.5.1.9
 * Description:
The MAC address which the connection between AP and AC.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is PhysAddress (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpMacConApAc.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpMacConApAc_map(char **mib_wtpMacConApAc_val_ptr_ptr, size_t *mib_wtpMacConApAc_val_ptr_len_ptr, char *raw_wtpMacConApAc_val_ptr, size_t raw_wtpMacConApAc_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpMacConApAc_val_ptr);
    netsnmp_assert((NULL != mib_wtpMacConApAc_val_ptr_ptr) && (NULL != mib_wtpMacConApAc_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpMacConApAc_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpMacConApAc non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpMacConApAc_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpMacConApAc_val_ptr_ptr) || (*mib_wtpMacConApAc_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpMacConApAc_val_ptr_ptr = realloc( *mib_wtpMacConApAc_val_ptr_ptr, converted_len * sizeof(**mib_wtpMacConApAc_val_ptr_ptr));
        if(NULL == *mib_wtpMacConApAc_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpMacConApAc_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpMacConApAc_val_ptr_ptr, raw_wtpMacConApAc_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpMacConApAc_map */

/**
 * Extract the current value of the wtpMacConApAc data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpMacConApAc_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wtpMacConApAc_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wtpMacConApAc.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wtpMacConApAc_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wtpMacConApAc_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wtpMacConApAc_get( dot11WtpParaTable_rowreq_ctx *rowreq_ctx, char **wtpMacConApAc_val_ptr_ptr, size_t *wtpMacConApAc_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != wtpMacConApAc_val_ptr_ptr) && (NULL != *wtpMacConApAc_val_ptr_ptr));
   netsnmp_assert( NULL != wtpMacConApAc_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpMacConApAc_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpMacConApAc data.
 * set (* wtpMacConApAc_val_ptr_ptr ) and (* wtpMacConApAc_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for wtpMacConApAc data
     */
    if ((NULL == (* wtpMacConApAc_val_ptr_ptr )) ||
        ((* wtpMacConApAc_val_ptr_len_ptr ) < (rowreq_ctx->data.wtpMacConApAc_len * sizeof((* wtpMacConApAc_val_ptr_ptr )[0])))) {
        /*
         * allocate space for wtpMacConApAc data
         */
        (* wtpMacConApAc_val_ptr_ptr ) = malloc(rowreq_ctx->data.wtpMacConApAc_len * sizeof((* wtpMacConApAc_val_ptr_ptr )[0]));
        if(NULL == (* wtpMacConApAc_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* wtpMacConApAc_val_ptr_len_ptr ) = rowreq_ctx->data.wtpMacConApAc_len * sizeof((* wtpMacConApAc_val_ptr_ptr )[0]);
    memcpy( (* wtpMacConApAc_val_ptr_ptr ), rowreq_ctx->data.wtpMacConApAc, (* wtpMacConApAc_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* wtpMacConApAc_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpParaEntry.wtpState
 * wtpState is subid 10 of dot11WtpParaEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.5.1.10
 * Description:
Show the AP state.It has such state:join,configure,datacheck,run,quit,imagedata.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 4/8. Values:  join(2), configure(3), datacheck(4), run(5), quit(7), imagedata(8)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpState.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpState_map(u_long *mib_wtpState_val_ptr, u_long raw_wtpState_val)
{
    netsnmp_assert(NULL != mib_wtpState_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpState_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpState enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wtpState_val) {
        case INTERNAL_WTPSTATE_JOIN:
             *mib_wtpState_val_ptr = WTPSTATE_JOIN;
             break;

        case INTERNAL_WTPSTATE_CONFIGURE:
             *mib_wtpState_val_ptr = WTPSTATE_CONFIGURE;
             break;

        case INTERNAL_WTPSTATE_DATACHECK:
             *mib_wtpState_val_ptr = WTPSTATE_DATACHECK;
             break;

        case INTERNAL_WTPSTATE_RUN:
             *mib_wtpState_val_ptr = WTPSTATE_RUN;
             break;

        case INTERNAL_WTPSTATE_QUIT:
             *mib_wtpState_val_ptr = WTPSTATE_QUIT;
             break;

        case INTERNAL_WTPSTATE_IMAGEDATA:
             *mib_wtpState_val_ptr = WTPSTATE_IMAGEDATA;
             break;

		case INTERNAL_WTPSTATE_BAK_RUN:
             *mib_wtpState_val_ptr = WTPSTATE_BAK_RUN;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wtpState\n", raw_wtpState_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wtpState_map */

/**
 * Extract the current value of the wtpState data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpState_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpState_get( dot11WtpParaTable_rowreq_ctx *rowreq_ctx, u_long * wtpState_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpState_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpState_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpState data.
 * set (* wtpState_val_ptr ) from rowreq_ctx->data
 */
    (* wtpState_val_ptr ) = rowreq_ctx->data.wtpState;

    return MFD_SUCCESS;
} /* wtpState_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpParaEntry.wtpDefenceDOSAttack
 * wtpDefenceDOSAttack is subid 11 of dot11WtpParaEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.5.1.11
 * Description:
Defence DOS attack.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  disable(0), enable(1)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpDefenceDOSAttack.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpDefenceDOSAttack_map(u_long *mib_wtpDefenceDOSAttack_val_ptr, u_long raw_wtpDefenceDOSAttack_val)
{
    netsnmp_assert(NULL != mib_wtpDefenceDOSAttack_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpDefenceDOSAttack_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpDefenceDOSAttack enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wtpDefenceDOSAttack_val) {
        case INTERNAL_WTPDEFENCEDOSATTACK_DISABLE:
             *mib_wtpDefenceDOSAttack_val_ptr = WTPDEFENCEDOSATTACK_DISABLE;
             break;

        case INTERNAL_WTPDEFENCEDOSATTACK_ENABLE:
             *mib_wtpDefenceDOSAttack_val_ptr = WTPDEFENCEDOSATTACK_ENABLE;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wtpDefenceDOSAttack\n", raw_wtpDefenceDOSAttack_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wtpDefenceDOSAttack_map */

/**
 * Extract the current value of the wtpDefenceDOSAttack data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpDefenceDOSAttack_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpDefenceDOSAttack_get( dot11WtpParaTable_rowreq_ctx *rowreq_ctx, u_long * wtpDefenceDOSAttack_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpDefenceDOSAttack_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpDefenceDOSAttack_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpDefenceDOSAttack data.
 * set (* wtpDefenceDOSAttack_val_ptr ) from rowreq_ctx->data
 */
    (* wtpDefenceDOSAttack_val_ptr ) = rowreq_ctx->data.wtpDefenceDOSAttack;

    return MFD_SUCCESS;
} /* wtpDefenceDOSAttack_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpParaEntry.wtpIGMPSwitch
 * wtpIGMPSwitch is subid 12 of dot11WtpParaEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.5.1.12
 * Description:
IGMP switch.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  disable(0), enable(1)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpIGMPSwitch.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpIGMPSwitch_map(u_long *mib_wtpIGMPSwitch_val_ptr, u_long raw_wtpIGMPSwitch_val)
{
    netsnmp_assert(NULL != mib_wtpIGMPSwitch_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpIGMPSwitch_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpIGMPSwitch enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wtpIGMPSwitch_val) {
        case INTERNAL_WTPIGMPSWITCH_DISABLE:
             *mib_wtpIGMPSwitch_val_ptr = WTPIGMPSWITCH_DISABLE;
             break;

        case INTERNAL_WTPIGMPSWITCH_ENABLE:
             *mib_wtpIGMPSwitch_val_ptr = WTPIGMPSWITCH_ENABLE;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wtpIGMPSwitch\n", raw_wtpIGMPSwitch_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wtpIGMPSwitch_map */

/**
 * Extract the current value of the wtpIGMPSwitch data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpIGMPSwitch_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpIGMPSwitch_get( dot11WtpParaTable_rowreq_ctx *rowreq_ctx, u_long * wtpIGMPSwitch_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpIGMPSwitch_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpIGMPSwitch_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpIGMPSwitch data.
 * set (* wtpIGMPSwitch_val_ptr ) from rowreq_ctx->data
 */
    (* wtpIGMPSwitch_val_ptr ) = rowreq_ctx->data.wtpIGMPSwitch;

    return MFD_SUCCESS;
} /* wtpIGMPSwitch_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpParaEntry.wtpBridgingWorkMode
 * wtpBridgingWorkMode is subid 13 of dot11WtpParaEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.5.1.13
 * Description:
AP bridging work mode.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 3/8. Values:  normal(1), Bridge(2), SemiBridge(3)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpBridgingWorkMode.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpBridgingWorkMode_map(u_long *mib_wtpBridgingWorkMode_val_ptr, u_long raw_wtpBridgingWorkMode_val)
{
    netsnmp_assert(NULL != mib_wtpBridgingWorkMode_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpBridgingWorkMode_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpBridgingWorkMode enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wtpBridgingWorkMode_val) {
        case INTERNAL_WTPBRIDGINGWORKMODE_NORMAL:
             *mib_wtpBridgingWorkMode_val_ptr = WTPBRIDGINGWORKMODE_NORMAL;
             break;

        case INTERNAL_WTPBRIDGINGWORKMODE_BRIDGE:
             *mib_wtpBridgingWorkMode_val_ptr = WTPBRIDGINGWORKMODE_BRIDGE;
             break;

        case INTERNAL_WTPBRIDGINGWORKMODE_SEMIBRIDGE:
             *mib_wtpBridgingWorkMode_val_ptr = WTPBRIDGINGWORKMODE_SEMIBRIDGE;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wtpBridgingWorkMode\n", raw_wtpBridgingWorkMode_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wtpBridgingWorkMode_map */

/**
 * Extract the current value of the wtpBridgingWorkMode data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpBridgingWorkMode_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpBridgingWorkMode_get( dot11WtpParaTable_rowreq_ctx *rowreq_ctx, u_long * wtpBridgingWorkMode_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpBridgingWorkMode_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpBridgingWorkMode_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpBridgingWorkMode data.
 * set (* wtpBridgingWorkMode_val_ptr ) from rowreq_ctx->data
 */
    (* wtpBridgingWorkMode_val_ptr ) = rowreq_ctx->data.wtpBridgingWorkMode;

    return MFD_SUCCESS;
} /* wtpBridgingWorkMode_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpParaEntry.wtpCurrAPMode
 * wtpCurrAPMode is subid 14 of dot11WtpParaEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.5.1.14
 * Description:
AP work mode includes:
							normal:AP support wlan login service
							monitor:AP monitor wireless envirment
							semimonitor:semi-monitor mode,doing net monitor while disengagement.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  normal(1), monitor(2), SemiMonitor(3)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpCurrAPMode.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpCurrAPMode_map(u_long *mib_wtpCurrAPMode_val_ptr, u_long raw_wtpCurrAPMode_val)
{
    netsnmp_assert(NULL != mib_wtpCurrAPMode_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpCurrAPMode_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpCurrAPMode enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wtpCurrAPMode_val) {
        case INTERNAL_WTPCURRAPMODE_NORMAL:
             *mib_wtpCurrAPMode_val_ptr = WTPCURRAPMODE_NORMAL;
             break;

        case INTERNAL_WTPCURRAPMODE_MONITOR:
             *mib_wtpCurrAPMode_val_ptr = WTPCURRAPMODE_MONITOR;
             break;

        case INTERNAL_WTPCURRAPMODE_SEMIMONITOR:
             *mib_wtpCurrAPMode_val_ptr = WTPCURRAPMODE_SEMIMONITOR;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wtpCurrAPMode\n", raw_wtpCurrAPMode_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wtpCurrAPMode_map */

/**
 * Extract the current value of the wtpCurrAPMode data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpCurrAPMode_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpCurrAPMode_get( dot11WtpParaTable_rowreq_ctx *rowreq_ctx, u_long * wtpCurrAPMode_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpCurrAPMode_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpCurrAPMode_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpCurrAPMode data.
 * set (* wtpCurrAPMode_val_ptr ) from rowreq_ctx->data
 */
    (* wtpCurrAPMode_val_ptr ) = rowreq_ctx->data.wtpCurrAPMode;

    return MFD_SUCCESS;
} /* wtpCurrAPMode_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpParaEntry.wtpSupport11B
 * wtpSupport11B is subid 15 of dot11WtpParaEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.5.1.15
 * Description:
AP work mode includes:
							yes:AP support 11B
							no:AP not support 11B.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  yes(1), no(2)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpSupport11B.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpSupport11B_map(u_long *mib_wtpSupport11B_val_ptr, u_long raw_wtpSupport11B_val)
{
    netsnmp_assert(NULL != mib_wtpSupport11B_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpSupport11B_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpSupport11B enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wtpSupport11B_val) {
        case INTERNAL_WTPSUPPORT11B_YES:
             *mib_wtpSupport11B_val_ptr = WTPSUPPORT11B_YES;
             break;

        case INTERNAL_WTPSUPPORT11B_NO:
             *mib_wtpSupport11B_val_ptr = WTPSUPPORT11B_NO;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wtpSupport11B\n", raw_wtpSupport11B_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wtpSupport11B_map */

/**
 * Extract the current value of the wtpSupport11B data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpSupport11B_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpSupport11B_get( dot11WtpParaTable_rowreq_ctx *rowreq_ctx, u_long * wtpSupport11B_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpSupport11B_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpSupport11B_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpSupport11B data.
 * set (* wtpSupport11B_val_ptr ) from rowreq_ctx->data
 */
    (* wtpSupport11B_val_ptr ) = rowreq_ctx->data.wtpSupport11B;

    return MFD_SUCCESS;
} /* wtpSupport11B_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpParaEntry.wtpSupport11G
 * wtpSupport11G is subid 16 of dot11WtpParaEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.5.1.16
 * Description:
AP work mode includes:
							yes:AP support 11G
							no:AP not support 11G.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  yes(1), no(2)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpSupport11G.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpSupport11G_map(u_long *mib_wtpSupport11G_val_ptr, u_long raw_wtpSupport11G_val)
{
    netsnmp_assert(NULL != mib_wtpSupport11G_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpSupport11G_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpSupport11G enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wtpSupport11G_val) {
        case INTERNAL_WTPSUPPORT11G_YES:
             *mib_wtpSupport11G_val_ptr = WTPSUPPORT11G_YES;
             break;

        case INTERNAL_WTPSUPPORT11G_NO:
             *mib_wtpSupport11G_val_ptr = WTPSUPPORT11G_NO;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wtpSupport11G\n", raw_wtpSupport11G_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wtpSupport11G_map */

/**
 * Extract the current value of the wtpSupport11G data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpSupport11G_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpSupport11G_get( dot11WtpParaTable_rowreq_ctx *rowreq_ctx, u_long * wtpSupport11G_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpSupport11G_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpSupport11G_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpSupport11G data.
 * set (* wtpSupport11G_val_ptr ) from rowreq_ctx->data
 */
    (* wtpSupport11G_val_ptr ) = rowreq_ctx->data.wtpSupport11G;

    return MFD_SUCCESS;
} /* wtpSupport11G_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpParaEntry.wtpAccessTime
 * wtpAccessTime is subid 8 of dot11WtpParaEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.5.1.17
 * Description:
Receiver signal PWL.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpAccessTime.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpAccessTime_map(char **mib_wtpAccessTime_val_ptr_ptr, size_t *mib_wtpAccessTime_val_ptr_len_ptr, char *raw_wtpAccessTime_val_ptr, size_t raw_wtpAccessTime_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpAccessTime_val_ptr);
    netsnmp_assert((NULL != mib_wtpAccessTime_val_ptr_ptr) && (NULL != mib_wtpAccessTime_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpAccessTime_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpAccessTime non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpAccessTime_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpAccessTime_val_ptr_ptr) || (*mib_wtpAccessTime_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpAccessTime_val_ptr_ptr = realloc( *mib_wtpAccessTime_val_ptr_ptr, converted_len * sizeof(**mib_wtpAccessTime_val_ptr_ptr));
        if(NULL == *mib_wtpAccessTime_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpAccessTime_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpAccessTime_val_ptr_ptr, raw_wtpAccessTime_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpAccessTime_map */

/**
 * Extract the current value of the wtpAccessTime data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpAccessTime_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wtpAccessTime_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wtpAccessTime.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wtpAccessTime_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wtpAccessTime_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wtpAccessTime_get( dot11WtpParaTable_rowreq_ctx *rowreq_ctx, char **wtpAccessTime_val_ptr_ptr, size_t *wtpAccessTime_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != wtpAccessTime_val_ptr_ptr) && (NULL != *wtpAccessTime_val_ptr_ptr));
   netsnmp_assert( NULL != wtpAccessTime_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpAccessTime_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpAccessTime data.
 * set (* wtpAccessTime_val_ptr_ptr ) and (* wtpAccessTime_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for wtpAccessTime data
     */
    if ((NULL == (* wtpAccessTime_val_ptr_ptr )) ||
        ((* wtpAccessTime_val_ptr_len_ptr ) < (rowreq_ctx->data.wtpAccessTime_len * sizeof((* wtpAccessTime_val_ptr_ptr )[0])))) {
        /*
         * allocate space for wtpAccessTime data
         */
        (* wtpAccessTime_val_ptr_ptr ) = malloc(rowreq_ctx->data.wtpAccessTime_len * sizeof((* wtpAccessTime_val_ptr_ptr )[0]));
        if(NULL == (* wtpAccessTime_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* wtpAccessTime_val_ptr_len_ptr ) = rowreq_ctx->data.wtpAccessTime_len * sizeof((* wtpAccessTime_val_ptr_ptr )[0]);
    memcpy( (* wtpAccessTime_val_ptr_ptr ), rowreq_ctx->data.wtpAccessTime, (* wtpAccessTime_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* wtpAccessTime_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpParaEntry.wtpStartTime
 * wtpStartTime is subid 8 of dot11WtpParaEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.5.1.18
 * Description:
Receiver signal PWL.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpStartTime.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpStartTime_map(char **mib_wtpStartTime_val_ptr_ptr, size_t *mib_wtpStartTime_val_ptr_len_ptr, char *raw_wtpStartTime_val_ptr, size_t raw_wtpStartTime_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpStartTime_val_ptr);
    netsnmp_assert((NULL != mib_wtpStartTime_val_ptr_ptr) && (NULL != mib_wtpStartTime_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpStartTime_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpStartTime non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpStartTime_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpStartTime_val_ptr_ptr) || (*mib_wtpStartTime_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpStartTime_val_ptr_ptr = realloc( *mib_wtpStartTime_val_ptr_ptr, converted_len * sizeof(**mib_wtpStartTime_val_ptr_ptr));
        if(NULL == *mib_wtpStartTime_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpStartTime_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpStartTime_val_ptr_ptr, raw_wtpStartTime_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpStartTime_map */

/**
 * Extract the current value of the wtpStartTime data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpStartTime_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wtpStartTime_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wtpStartTime.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wtpStartTime_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wtpStartTime_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wtpStartTime_get( dot11WtpParaTable_rowreq_ctx *rowreq_ctx, char **wtpStartTime_val_ptr_ptr, size_t *wtpStartTime_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != wtpStartTime_val_ptr_ptr) && (NULL != *wtpStartTime_val_ptr_ptr));
   netsnmp_assert( NULL != wtpStartTime_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpStartTime_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpStartTime data.
 * set (* wtpStartTime_val_ptr_ptr ) and (* wtpStartTime_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for wtpStartTime data
     */
    if ((NULL == (* wtpStartTime_val_ptr_ptr )) ||
        ((* wtpStartTime_val_ptr_len_ptr ) < (rowreq_ctx->data.wtpStartTime_len * sizeof((* wtpStartTime_val_ptr_ptr )[0])))) {
        /*
         * allocate space for wtpStartTime data
         */
        (* wtpStartTime_val_ptr_ptr ) = malloc(rowreq_ctx->data.wtpStartTime_len * sizeof((* wtpStartTime_val_ptr_ptr )[0]));
        if(NULL == (* wtpStartTime_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* wtpStartTime_val_ptr_len_ptr ) = rowreq_ctx->data.wtpStartTime_len * sizeof((* wtpStartTime_val_ptr_ptr )[0]);
    memcpy( (* wtpStartTime_val_ptr_ptr ), rowreq_ctx->data.wtpStartTime, (* wtpStartTime_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* wtpStartTime_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpParaEntry.wtpImagadataTime
 * wtpImagadataTime is subid 8 of dot11WtpParaEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.5.1.19
 * Description:
Receiver signal PWL.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpImagadataTime.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpImagadataTime_map(char **mib_wtpImagadataTime_val_ptr_ptr, size_t *mib_wtpImagadataTime_val_ptr_len_ptr, char *raw_wtpImagadataTime_val_ptr, size_t raw_wtpImagadataTime_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpImagadataTime_val_ptr);
    netsnmp_assert((NULL != mib_wtpImagadataTime_val_ptr_ptr) && (NULL != mib_wtpImagadataTime_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpImagadataTime_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpImagadataTime non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpImagadataTime_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpImagadataTime_val_ptr_ptr) || (*mib_wtpImagadataTime_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpImagadataTime_val_ptr_ptr = realloc( *mib_wtpImagadataTime_val_ptr_ptr, converted_len * sizeof(**mib_wtpImagadataTime_val_ptr_ptr));
        if(NULL == *mib_wtpImagadataTime_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpImagadataTime_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpImagadataTime_val_ptr_ptr, raw_wtpImagadataTime_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpImagadataTime_map */

/**
 * Extract the current value of the wtpImagadataTime data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpImagadataTime_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wtpImagadataTime_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wtpImagadataTime.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wtpImagadataTime_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wtpImagadataTime_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wtpImagadataTime_get( dot11WtpParaTable_rowreq_ctx *rowreq_ctx, char **wtpImagadataTime_val_ptr_ptr, size_t *wtpImagadataTime_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != wtpImagadataTime_val_ptr_ptr) && (NULL != *wtpImagadataTime_val_ptr_ptr));
   netsnmp_assert( NULL != wtpImagadataTime_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpImagadataTime_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpImagadataTime data.
 * set (* wtpImagadataTime_val_ptr_ptr ) and (* wtpImagadataTime_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for wtpImagadataTime data
     */
    if ((NULL == (* wtpImagadataTime_val_ptr_ptr )) ||
        ((* wtpImagadataTime_val_ptr_len_ptr ) < (rowreq_ctx->data.wtpImagadataTime_len * sizeof((* wtpImagadataTime_val_ptr_ptr )[0])))) {
        /*
         * allocate space for wtpImagadataTime data
         */
        (* wtpImagadataTime_val_ptr_ptr ) = malloc(rowreq_ctx->data.wtpImagadataTime_len * sizeof((* wtpImagadataTime_val_ptr_ptr )[0]));
        if(NULL == (* wtpImagadataTime_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* wtpImagadataTime_val_ptr_len_ptr ) = rowreq_ctx->data.wtpImagadataTime_len * sizeof((* wtpImagadataTime_val_ptr_ptr )[0]);
    memcpy( (* wtpImagadataTime_val_ptr_ptr ), rowreq_ctx->data.wtpImagadataTime, (* wtpImagadataTime_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* wtpImagadataTime_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpParaEntry.wtpConfigUpdateTime
 * wtpConfigUpdateTime is subid 8 of dot11WtpParaEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.5.1.20
 * Description:
Receiver signal PWL.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpConfigUpdateTime.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpConfigUpdateTime_map(char **mib_wtpConfigUpdateTime_val_ptr_ptr, size_t *mib_wtpConfigUpdateTime_val_ptr_len_ptr, char *raw_wtpConfigUpdateTime_val_ptr, size_t raw_wtpConfigUpdateTime_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpConfigUpdateTime_val_ptr);
    netsnmp_assert((NULL != mib_wtpConfigUpdateTime_val_ptr_ptr) && (NULL != mib_wtpConfigUpdateTime_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpConfigUpdateTime_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpConfigUpdateTime non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpConfigUpdateTime_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpConfigUpdateTime_val_ptr_ptr) || (*mib_wtpConfigUpdateTime_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpConfigUpdateTime_val_ptr_ptr = realloc( *mib_wtpConfigUpdateTime_val_ptr_ptr, converted_len * sizeof(**mib_wtpConfigUpdateTime_val_ptr_ptr));
        if(NULL == *mib_wtpConfigUpdateTime_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpConfigUpdateTime_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpConfigUpdateTime_val_ptr_ptr, raw_wtpConfigUpdateTime_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpConfigUpdateTime_map */

/**
 * Extract the current value of the wtpConfigUpdateTime data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpConfigUpdateTime_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wtpConfigUpdateTime_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wtpConfigUpdateTime.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wtpConfigUpdateTime_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wtpConfigUpdateTime_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wtpConfigUpdateTime_get( dot11WtpParaTable_rowreq_ctx *rowreq_ctx, char **wtpConfigUpdateTime_val_ptr_ptr, size_t *wtpConfigUpdateTime_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != wtpConfigUpdateTime_val_ptr_ptr) && (NULL != *wtpConfigUpdateTime_val_ptr_ptr));
   netsnmp_assert( NULL != wtpConfigUpdateTime_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11WtpParaTable:wtpConfigUpdateTime_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpConfigUpdateTime data.
 * set (* wtpConfigUpdateTime_val_ptr_ptr ) and (* wtpConfigUpdateTime_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for wtpConfigUpdateTime data
     */
    if ((NULL == (* wtpConfigUpdateTime_val_ptr_ptr )) ||
        ((* wtpConfigUpdateTime_val_ptr_len_ptr ) < (rowreq_ctx->data.wtpConfigUpdateTime_len * sizeof((* wtpConfigUpdateTime_val_ptr_ptr )[0])))) {
        /*
         * allocate space for wtpConfigUpdateTime data
         */
        (* wtpConfigUpdateTime_val_ptr_ptr ) = malloc(rowreq_ctx->data.wtpConfigUpdateTime_len * sizeof((* wtpConfigUpdateTime_val_ptr_ptr )[0]));
        if(NULL == (* wtpConfigUpdateTime_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* wtpConfigUpdateTime_val_ptr_len_ptr ) = rowreq_ctx->data.wtpConfigUpdateTime_len * sizeof((* wtpConfigUpdateTime_val_ptr_ptr )[0]);
    memcpy( (* wtpConfigUpdateTime_val_ptr_ptr ), rowreq_ctx->data.wtpConfigUpdateTime, (* wtpConfigUpdateTime_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* wtpConfigUpdateTime_get */





/** @} */
