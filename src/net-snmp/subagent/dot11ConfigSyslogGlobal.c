/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.8 2004/10/14 12:57:34 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "dot11ConfigSyslogGlobal.h"
#include "ws_log_conf.h"
#include "autelanWtpGroup.h"

#include "ws_dbus_def.h"
#include "ws_dbus_list_interface.h"
#include "../dcli/src/lib/dcli_main.h"

#include "ac_manage_def.h"
#include "ac_manage_extend_interface.h"
#include "ac_manage_ntpsyslog_interface.h"

#define GLOBALENABLE   "2.25.2.1"
#define GLOBALLEVEL    "2.25.2.2"


/** Initializes the dot11ConfigSyslogGlobal module */
void
init_dot11ConfigSyslogGlobal(void)
{
    static oid SyslogServcEnableg_oid[128] = {0};
    static oid SyslogReportLevelg_oid[128] = {0};
    size_t	public_oid_len = 0;
	mad_dev_oid(SyslogServcEnableg_oid,GLOBALENABLE,&public_oid_len,enterprise_pvivate_oid);
	mad_dev_oid(SyslogReportLevelg_oid,GLOBALLEVEL,&public_oid_len,enterprise_pvivate_oid);

  DEBUGMSGTL(("dot11ConfigSyslogGlobal", "Initializing\n"));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SyslogServcEnableg", handle_SyslogServcEnableg,
                               SyslogServcEnableg_oid, public_oid_len,
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("SyslogReportLevelg", handle_SyslogReportLevelg,
                               SyslogReportLevelg_oid, public_oid_len,
                               HANDLER_CAN_RWRITE
        ));

	if_syslog_exist();

}

int
handle_SyslogServcEnableg(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    snmp_log(LOG_DEBUG, "enter handle_SyslogServcEnableg\n");

    switch(reqinfo->mode) {

        case MODE_GET:
		{
			int globalflag = 0 ;
			char newc[30] = {0};
			
			snmp_log(LOG_DEBUG, "enter get_first_xmlnode\n");
			get_first_xmlnode(XML_FPATH, NODE_LSTATUS, newc);
			snmp_log(LOG_DEBUG, "exit get_first_xmlnode,newc=%s\n", newc);
			
			if(0 == strcmp(newc, "")) {
				globalflag = 2;
			}
			else {
				if(0 == strcmp(newc, "start")) {
					globalflag = 1;
			    }		
				else {
					globalflag = 2;
			    }		
			}
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     (u_char *)&globalflag,
                                     sizeof(globalflag));
        }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
			{
				int ifstart = *requests->requestvb->val.integer;
				int i = 1;
				char syslog_status[10]={0};
				memset(syslog_status, 0, 10);
				/*restart syslog*/
				if (ifstart == 1)
				{
					strncpy( syslog_status, "start" ,sizeof(syslog_status));	
				}
				else
				{
					strncpy( syslog_status, "stop" ,sizeof(syslog_status)); 
				}
				
				instance_parameter *paraHead = NULL, *paraNode = NULL;
				list_instance_parameter(&paraHead, SNMPD_SLOT_CONNECT);
				for(paraNode = paraHead; paraNode; paraNode = paraNode->next) 
				{
					ac_manage_set_syslogstatus_rule(paraNode->connection, syslog_status,"all");					
				}
        	}
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SyslogServcEnableg\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

	snmp_log(LOG_DEBUG, "exit handle_SyslogServcEnableg\n");
    return SNMP_ERR_NOERROR;
}
int
handle_SyslogReportLevelg(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    snmp_log(LOG_DEBUG, "enter handle_SyslogReportLevelg\n");

    switch(reqinfo->mode) {

        case MODE_GET:
		{
			int level = 0;
			char newc[30] = {0};

			snmp_log(LOG_DEBUG, "enter get_first_xmlnode\n");
			get_first_xmlnode(XML_FPATH, NODE_FLEVEL, newc);
			snmp_log(LOG_DEBUG, "exit get_first_xmlnode,newc=%s\n", newc);
			
			if(strcmp(newc,"")==0)
			{
				level = 1;
			}
			else
			{
				level = strtoul(newc,0,10);
			}

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     (u_char *) &level,
                                      sizeof(level));
        }
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            break;

        case MODE_SET_RESERVE2:
            break;

        case MODE_SET_FREE:
            break;

        case MODE_SET_ACTION:
			{

				char flevel[20] = {0};
				snprintf(flevel,sizeof(flevel)-1,"%d",*requests->requestvb->val.integer);				
				mod_first_xmlnode(XML_FPATH, NODE_FLEVEL, flevel);
				
        	}
            break;

        case MODE_SET_COMMIT:
            break;

        case MODE_SET_UNDO:
            break;

        default:
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_SyslogReportLevelg\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

	snmp_log(LOG_DEBUG, "exit handle_SyslogReportLevelg\n");
    return SNMP_ERR_NOERROR;
}
