/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 12088 $ of $ 
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "dot11PortalBlackListTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement dot11PortalBlackListTable get routines.
 * TODO:240:M: Implement dot11PortalBlackListTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table dot11PortalBlackListTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * DOT11-AC-MIB::dot11PortalBlackListTable is subid 3 of dot11ConfigPortalServerGroup.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.3, length: 12
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement dot11PortalBlackListTable data context functions.
 */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 * @param BLid_val
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
dot11PortalBlackListTable_indexes_set_tbl_idx(dot11PortalBlackListTable_mib_index *tbl_idx, long BLid_val)
{
    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:dot11PortalBlackListTable_indexes_set_tbl_idx","called\n"));

    /* BLid(1)/INTEGER/ASN_INTEGER/long(long)//l/A/W/e/r/d/h */
    tbl_idx->BLid = BLid_val;
    

    return MFD_SUCCESS;
} /* dot11PortalBlackListTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
dot11PortalBlackListTable_indexes_set(dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx, long BLid_val)
{
    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:dot11PortalBlackListTable_indexes_set","called\n"));

    if(MFD_SUCCESS != dot11PortalBlackListTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
                                   , BLid_val
           ))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if(0 != dot11PortalBlackListTable_index_to_oid(&rowreq_ctx->oid_idx,
                                    &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* dot11PortalBlackListTable_indexes_set */


/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11PortalBlackListEntry.BLtype
 * BLtype is subid 2 of dot11PortalBlackListEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.3.1.2
 * Description:
black list type.
					if the black list type is ip,BLstartip must set to be applied to the black list.
					if the black list type is domain,domain url must set to be applied to the black list
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  ip(0), domain(1)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the BLtype data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param BLtype_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
BLtype_get( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx, u_long * BLtype_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != BLtype_val_ptr );


    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLtype_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the BLtype data.
 * copy (* BLtype_val_ptr ) from rowreq_ctx->data
 */
    (* BLtype_val_ptr ) = rowreq_ctx->data.BLtype;

    return MFD_SUCCESS;
} /* BLtype_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11PortalBlackListEntry.BLstartip
 * BLstartip is subid 3 of dot11PortalBlackListEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.3.1.3
 * Description:
black list start ip.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is IPADDR (based on perltype IPADDR)
 * The net-snmp type is ASN_IPADDRESS. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the BLstartip data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param BLstartip_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
BLstartip_get( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx, u_long * BLstartip_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != BLstartip_val_ptr );


    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLstartip_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the BLstartip data.
 * copy (* BLstartip_val_ptr ) from rowreq_ctx->data
 */
    (* BLstartip_val_ptr ) = rowreq_ctx->data.BLstartip;

    return MFD_SUCCESS;
} /* BLstartip_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11PortalBlackListEntry.BLendip
 * BLendip is subid 4 of dot11PortalBlackListEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.3.1.4
 * Description:
black list end ip,optional.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is IPADDR (based on perltype IPADDR)
 * The net-snmp type is ASN_IPADDRESS. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the BLendip data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param BLendip_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
BLendip_get( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx, u_long * BLendip_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != BLendip_val_ptr );


    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLendip_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the BLendip data.
 * copy (* BLendip_val_ptr ) from rowreq_ctx->data
 */
    (* BLendip_val_ptr ) = rowreq_ctx->data.BLendip;

    return MFD_SUCCESS;
} /* BLendip_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11PortalBlackListEntry.BLport
 * BLport is subid 5 of dot11PortalBlackListEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.3.1.5
 * Description:
black list port,the format is (all|PORT[,PORT]...),optional
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the BLport data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param BLport_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param BLport_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by BLport.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*BLport_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update BLport_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
BLport_get( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx, char **BLport_val_ptr_ptr, size_t *BLport_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != BLport_val_ptr_ptr) && (NULL != *BLport_val_ptr_ptr));
   netsnmp_assert( NULL != BLport_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLport_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the BLport data.
 * copy (* BLport_val_ptr_ptr ) data and (* BLport_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for BLport data
     */
    if ((NULL == (* BLport_val_ptr_ptr )) ||
        ((* BLport_val_ptr_len_ptr ) <
         (rowreq_ctx->data.BLport_len* sizeof(rowreq_ctx->data.BLport[0])))) {
        /*
         * allocate space for BLport data
         */
        (* BLport_val_ptr_ptr ) = malloc(rowreq_ctx->data.BLport_len* sizeof(rowreq_ctx->data.BLport[0]));
        if(NULL == (* BLport_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* BLport_val_ptr_len_ptr ) = rowreq_ctx->data.BLport_len* sizeof(rowreq_ctx->data.BLport[0]);
    memcpy( (* BLport_val_ptr_ptr ), rowreq_ctx->data.BLport, rowreq_ctx->data.BLport_len* sizeof(rowreq_ctx->data.BLport[0]) );

    return MFD_SUCCESS;
} /* BLport_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11PortalBlackListEntry.BLURL
 * BLURL is subid 6 of dot11PortalBlackListEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.3.1.6
 * Description:
black list URL.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the BLURL data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param BLURL_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param BLURL_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by BLURL.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*BLURL_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update BLURL_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
BLURL_get( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx, char **BLURL_val_ptr_ptr, size_t *BLURL_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != BLURL_val_ptr_ptr) && (NULL != *BLURL_val_ptr_ptr));
   netsnmp_assert( NULL != BLURL_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLURL_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the BLURL data.
 * copy (* BLURL_val_ptr_ptr ) data and (* BLURL_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for BLURL data
     */
    if ((NULL == (* BLURL_val_ptr_ptr )) ||
        ((* BLURL_val_ptr_len_ptr ) <
         (rowreq_ctx->data.BLURL_len* sizeof(rowreq_ctx->data.BLURL[0])))) {
        /*
         * allocate space for BLURL data
         */
        (* BLURL_val_ptr_ptr ) = malloc(rowreq_ctx->data.BLURL_len* sizeof(rowreq_ctx->data.BLURL[0]));
        if(NULL == (* BLURL_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* BLURL_val_ptr_len_ptr ) = rowreq_ctx->data.BLURL_len* sizeof(rowreq_ctx->data.BLURL[0]);
    memcpy( (* BLURL_val_ptr_ptr ), rowreq_ctx->data.BLURL, rowreq_ctx->data.BLURL_len* sizeof(rowreq_ctx->data.BLURL[0]) );

    return MFD_SUCCESS;
} /* BLURL_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11PortalBlackListEntry.BLRowStatus
 * BLRowStatus is subid 7 of dot11PortalBlackListEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.3.1.7
 * Description:
This variable is used to create, modify, and/or delete a row
			        	 in this table.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * Its syntax is RowStatus (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the BLRowStatus data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param BLRowStatus_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
BLRowStatus_get( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx, u_long * BLRowStatus_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != BLRowStatus_val_ptr );

    (* BLRowStatus_val_ptr ) = rowreq_ctx->data.BLRowStatus;

    return MFD_SUCCESS;
} /* BLRowStatus_get */



/** @} */
