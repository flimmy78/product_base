/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 12077 $ of $
 *
 * $Id:$
 *
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "dot11PortalBlackListTable.h"
#include "nm/app/eag/eag_errcode.h"
#include "nm/app/eag/eag_conf.h"
#include "nm/app/eag/eag_interface.h"
#include "ws_dbus_list_interface.h"
#include "dot11PortalBlackListTable.h"
#include "autelanWtpGroup.h"
#include <netinet/in.h>
#include "mibs_public.h"


#define IP_ADDR_LEN					24
#define IPRANGE_LEN					40
#define PORTSET_LEN					40

/*if eag is running, return 1*/
/*static int 
eag_ins_running_state(DBusConnection *connection, int hansitype, int insid)
{
	int ret = 0;
	struct eag_base_conf baseconf;		
	memset( &baseconf, 0, sizeof(baseconf));

	ret = eag_get_base_conf( connection, hansitype, insid, &baseconf );

	if( (EAG_RETURN_OK == ret) && (1 == baseconf.status) )
		ret = 1;
	else
		ret = 0;
	return ret;
}*/

static int 
captive_check_portset_format(const char *str)
{
	const char *p = NULL;
	char *tmp = NULL, *token = NULL;
	
	if (NULL == str || '\0' == str[0] || ',' == str[0]) 
		return 1;

	if (strlen(str) > PORTSET_LEN -1)
		return 1;
	
	if (strcmp(str, "all") == 0)
		return 0;
	
	for (p = str; *p; p++){
		if ((*p < '0' || *p > '9') && *p != ',')
			return 1;
		if (',' == *p && ',' == *(p+1))
			return 1;
	}
	if (',' ==  *(p-1))
		return 1;

	tmp = strdup(str);
	for (token = strtok(tmp, ","); token; token = strtok(NULL, ",")){
		int port = atoi(token);
		if (port <= 0 || port > 65535 || '0' == token[0]){
			free(tmp);
			return 1;
		}
	}

	free(tmp);
	return 0;
	
}

typedef struct {
	char iprange[IPRANGE_LEN];
	char portset[PORTSET_LEN];
} iprange_portset_t;

/** @defgroup data_set data_set: Routines to set data
 *
 * These routines are used to set the value for individual objects. The
 * row context is passed, along with the new value.
 * 
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table dot11PortalBlackListTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * DOT11-AC-MIB::dot11PortalBlackListTable is subid 3 of dot11ConfigPortalServerGroup.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.3, length: 12
*/
    /*
     * NOTE: if you update this chart, please update the versions in
     *       local/mib2c-conf.d/parent-set.m2i
     *       agent/mibgroup/helpers/baby_steps.c
     * while you're at it.
     */
    /*
     ***********************************************************************
     * Baby Steps Flow Chart (2004.06.05)                                  *
     *                                                                     *
     * +--------------+    +================+    U = unconditional path    *
     * |optional state|    ||required state||    S = path for success      *
     * +--------------+    +================+    E = path for error        *
     ***********************************************************************
     *
     *                        +--------------+
     *                        |     pre      |
     *                        |   request    |
     *                        +--------------+
     *                               | U
     * +-------------+        +==============+
     * |    row    |f|<-------||  object    ||
     * |  create   |1|      E ||  lookup    ||
     * +-------------+        +==============+
     *     E |   | S                 | S
     *       |   +------------------>|
     *       |                +==============+
     *       |              E ||   check    ||
     *       |<---------------||   values   ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |       +<-------||   undo     ||
     *       |       |      E ||   setup    ||
     *       |       |        +==============+
     *       |       |               | S
     *       |       |        +==============+
     *       |       |        ||    set     ||-------------------------->+
     *       |       |        ||   value    || E                         |
     *       |       |        +==============+                           |
     *       |       |               | S                                 |
     *       |       |        +--------------+                           |
     *       |       |        |    check     |-------------------------->|
     *       |       |        |  consistency | E                         |
     *       |       |        +--------------+                           |
     *       |       |               | S                                 |
     *       |       |        +==============+         +==============+  |
     *       |       |        ||   commit   ||-------->||     undo   ||  |
     *       |       |        ||            || E       ||    commit  ||  |
     *       |       |        +==============+         +==============+  |
     *       |       |               | S                     U |<--------+
     *       |       |        +--------------+         +==============+
     *       |       |        | irreversible |         ||    undo    ||
     *       |       |        |    commit    |         ||     set    ||
     *       |       |        +--------------+         +==============+
     *       |       |               | U                     U |
     *       |       +-------------->|<------------------------+
     *       |                +==============+
     *       |                ||   undo     ||
     *       |                ||  cleanup   ||
     *       |                +==============+
     *       +---------------------->| U
     *                               |
     *                          (err && f1)------------------->+
     *                               |                         |
     *                        +--------------+         +--------------+
     *                        |    post      |<--------|      row     |
     *                        |   request    |       U |    release   |
     *                        +--------------+         +--------------+
     *
     */

/**
 * Setup up context with information needed to undo a set request.
 *
 * This function will be called before the individual node undo setup
 * functions are called. If you need to do any undo setup that is not
 * related to a specific column, you can do it here.
 *
 * Note that the undo context has been allocated with
 * dot11PortalBlackListTable_allocate_data(), but may need extra
 * initialization similar to what you may have done in
 * dot11PortalBlackListTable_rowreq_ctx_init().
 * Note that an individual node's undo_setup function will only be called
 * if that node is being set to a new value.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in the node's undo_setup
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11PortalBlackListTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
dot11PortalBlackListTable_undo_setup( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:dot11PortalBlackListTable_undo_setup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> Setup dot11PortalBlackListTable undo.
     * set up dot11PortalBlackListTable undo information, in preparation for a set.
     * Undo storage is in (* BLRowStatus_val_ptr )*
     */

    return rc;
} /* dot11PortalBlackListTable_undo_setup */

/**
 * Undo a set request.
 *
 * This function will be called before the individual node undo
 * functions are called. If you need to do any undo that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo function will only be called
 * if that node is being set to a new value.
 *
 * If there is anything  specific to a particular column (e.g. releasing
 * memory for a string), you should do that setup in the node's undo
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11PortalBlackListTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
dot11PortalBlackListTable_undo( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:dot11PortalBlackListTable_undo","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> dot11PortalBlackListTable undo.
     * dot11PortalBlackListTable undo information, in response to a failed set.
     * Undo storage is in (* BLRowStatus_val_ptr )*
     */

    return rc;
} /* dot11PortalBlackListTable_undo_setup */

/**
 * Cleanup up context undo information.
 *
 * This function will be called after set/commit processing. If you
 * allocated any resources in undo_setup, this is the place to release
 * those resources.
 *
 * This function is called regardless of the success or failure of the set
 * request. If you need to perform different steps for cleanup depending
 * on success or failure, you can add a flag to the rowreq_ctx.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11PortalBlackListTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
dot11PortalBlackListTable_undo_cleanup( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:dot11PortalBlackListTable_undo_cleanup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:452:M: |-> Cleanup dot11PortalBlackListTable undo.
     * Undo storage is in (* BLRowStatus_val_ptr )*
     */

    return rc;
} /* dot11PortalBlackListTable_undo_cleanup */

/**
 * commit new values.
 *
 * At this point, you should have done everything you can to ensure that
 * this commit will not fail.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * dot11PortalBlackListTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param dot11PortalBlackListTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
dot11PortalBlackListTable_commit( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;
    int             save_flags;

    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:dot11PortalBlackListTable_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * save flags, then clear until we actually do something
     */
    save_flags = rowreq_ctx->column_set_flags;
    rowreq_ctx->column_set_flags = 0;

    if(RS_NOTREADY == rowreq_ctx->data.BLRowStatus ) {
        rowreq_ctx->data.BLRowStatus = RS_NOTINSERVICE;
    }
    /*
     * commit dot11PortalBlackListTable data
     * 1) check the column's flag in save_flags to see if it was set.
     * 2) clear the flag when you handle that column
     * 3) set the column's flag in column_set_flags if it needs undo
     *    processing in case of a failure.
     */
    if (save_flags & COLUMN_BLTYPE_FLAG) {
       save_flags &= ~COLUMN_BLTYPE_FLAG; /* clear BLtype */
       /*
        * TODO:482:o: |-> commit column BLtype.
        */
       rc = MFD_SUCCESS;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11PortalBlackListTable column BLtype commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo BLtype
             */
            rowreq_ctx->column_set_flags |= COLUMN_BLTYPE_FLAG;
       }
    }

    if (save_flags & COLUMN_BLSTARTIP_FLAG) {
       save_flags &= ~COLUMN_BLSTARTIP_FLAG; /* clear BLstartip */
       /*
        * TODO:482:o: |-> commit column BLstartip.
        */
       rc = MFD_SUCCESS;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11PortalBlackListTable column BLstartip commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo BLstartip
             */
            rowreq_ctx->column_set_flags |= COLUMN_BLSTARTIP_FLAG;
       }
    }

    if (save_flags & COLUMN_BLENDIP_FLAG) {
       save_flags &= ~COLUMN_BLENDIP_FLAG; /* clear BLendip */
       /*
        * TODO:482:o: |-> commit column BLendip.
        */
       rc = MFD_SUCCESS;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11PortalBlackListTable column BLendip commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo BLendip
             */
            rowreq_ctx->column_set_flags |= COLUMN_BLENDIP_FLAG;
       }
    }

    if (save_flags & COLUMN_BLPORT_FLAG) {
       save_flags &= ~COLUMN_BLPORT_FLAG; /* clear BLport */
       /*
        * TODO:482:o: |-> commit column BLport.
        */
       rc = MFD_SUCCESS;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11PortalBlackListTable column BLport commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo BLport
             */
            rowreq_ctx->column_set_flags |= COLUMN_BLPORT_FLAG;
       }
    }

    if (save_flags & COLUMN_BLURL_FLAG) {
       save_flags &= ~COLUMN_BLURL_FLAG; /* clear BLURL */
       /*
        * TODO:482:o: |-> commit column BLURL.
        */
       rc = MFD_SUCCESS;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11PortalBlackListTable column BLURL commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo BLURL
             */
            rowreq_ctx->column_set_flags |= COLUMN_BLURL_FLAG;
       }
    }

    if (save_flags & COLUMN_BLROWSTATUS_FLAG) {
        save_flags &= ~COLUMN_BLROWSTATUS_FLAG; /* clear BLRowStatus */
        switch(rowreq_ctx->data.BLRowStatus) {
            case RS_ACTIVE:
                {
					rc = -1;
					switch(rowreq_ctx->data.BLtype)
					{
						case 0:		/*ip*/
							{
								if(0 != rowreq_ctx->data.BLstartip)
							    {
								    void *connection = NULL;
								    if(SNMPD_DBUS_SUCCESS == get_instance_dbus_connection(rowreq_ctx->data.parameter, &connection, SNMPD_INSTANCE_MASTER_V3)) 
									{
										int ret = -1;
										RULE_TYPE type = RULE_IPADDR;
										iprange_portset_t item;
										char ipaddr_begin[IP_ADDR_LEN] = { 0 };
										char ipaddr_end[IP_ADDR_LEN] = { 0 };
										
//										if(eag_ins_running_state(connection, rowreq_ctx->data.parameter.local_id, rowreq_ctx->data.parameter.instance_id) == 1)
//										{
											memset(&item, 0, sizeof(item));
										
											INET_NTOA(rowreq_ctx->data.BLstartip, ipaddr_begin);
											INET_NTOA(rowreq_ctx->data.BLendip, ipaddr_end);
											if(rowreq_ctx->data.BLendip == 0)
											{
												strncpy(item.iprange, ipaddr_begin, IPRANGE_LEN-1);
											}
											else
											{
												snprintf(item.iprange, IPRANGE_LEN-1, "%s-%s", ipaddr_begin, ipaddr_end);
											}

											if(strcmp(rowreq_ctx->data.BLport,""))
											{
												if (captive_check_portset_format(rowreq_ctx->data.BLport) != 0)
												{
													break;
												}
												strncpy(item.portset, rowreq_ctx->data.BLport, PORTSET_LEN-1);
											}
											else
											{
												strncpy(item.portset, "all", PORTSET_LEN-1);
											}
							
											ret = eag_conf_captive_list( connection, rowreq_ctx->data.parameter.local_id,
																			rowreq_ctx->data.parameter.instance_id, 
																			type, item.iprange, item.portset, "", "", 
																			CP_ADD_LIST, CP_BLACK_LIST);
								
											snmp_log(LOG_DEBUG, "dot11PortalBlackListTable_commit: eag_conf_captive_list: ret = %d\n", ret);
											if(ret == EAG_RETURN_OK)
											{
												 if(rowreq_ctx->data.BLendip == 0)
												 {
												 	rowreq_ctx->data.BLendip = rowreq_ctx->data.BLstartip;
												 }
												 if(0 == strcmp(rowreq_ctx->data.BLport,""))
												 {
													 rowreq_ctx->data.BLport_len = MIN(sizeof(rowreq_ctx->data.BLport) - 1, strlen("all"));
													 memcpy( rowreq_ctx->data.BLport, "all", rowreq_ctx->data.BLport_len );
												 }
					
												 rc = MFD_SUCCESS;
					                             break;
											}
											else if(EAG_ERR_DBUS_FAILED == ret) 
											{
												close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
											}
//										}
								    }    					    
							   	}
							}
							break;	
						case 1:		/*domain*/
							{
								if(strcmp(rowreq_ctx->data.BLURL,"")!=0)
							    {
								    void *connection = NULL;
								    if(SNMPD_DBUS_SUCCESS == get_instance_dbus_connection(rowreq_ctx->data.parameter, &connection, SNMPD_INSTANCE_MASTER_V3)) 
									{
										int ret = -1;
										RULE_TYPE type = RULE_DOMAIN;
										char domain[256] = { 0 };
										
//										if(eag_ins_running_state(connection, rowreq_ctx->data.parameter.local_id, rowreq_ctx->data.parameter.instance_id) == 1)
//										{
											memset(&domain, 0, sizeof(domain));
											strncpy(domain, rowreq_ctx->data.BLURL, sizeof(domain)-1);										
			
											ret = eag_conf_captive_list( connection, rowreq_ctx->data.parameter.local_id,
																			rowreq_ctx->data.parameter.instance_id,
																			type, "", "", domain, "",
																			CP_ADD_LIST, CP_BLACK_LIST);
						
											snmp_log(LOG_DEBUG, "dot11PortalBlackListTable_commit: eag_conf_captive_list: ret = %d\n", ret);
											if(ret == EAG_RETURN_OK)
											{
												 rc = MFD_SUCCESS;
					                             break;
											}
											else if(EAG_ERR_DBUS_FAILED == ret) 
											{
												close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
											}
//										}										
								    }    					    

							   	}
							}
							break;
					}
                }
                break;

            case RS_CREATEANDWAIT:
                rowreq_ctx->data.BLRowStatus = RS_NOTREADY;
                rc = MFD_SUCCESS;
                break;
                
            case RS_DESTROY:  
                {
					rc = -1;
					void *connection = NULL;
                    if(SNMPD_DBUS_SUCCESS == get_instance_dbus_connection(rowreq_ctx->data.parameter, &connection, SNMPD_INSTANCE_MASTER_V3))
                    {
						int ret = -1;
						switch(rowreq_ctx->data.BLtype)
						{
							case 0: 	/*ip*/
								{
									RULE_TYPE type = RULE_IPADDR;
									iprange_portset_t item;
									char ipaddr_begin[IP_ADDR_LEN] = { 0 };
									char ipaddr_end[IP_ADDR_LEN] = { 0 };
									char intf[40];
//									if(eag_ins_running_state(connection, rowreq_ctx->data.parameter.local_id, rowreq_ctx->data.parameter.instance_id) == 1)
//									{
										memset(&item, 0, sizeof(item));
						
										INET_NTOA(rowreq_ctx->data.BLstartip, ipaddr_begin);
										INET_NTOA(rowreq_ctx->data.BLendip, ipaddr_end);
										if(rowreq_ctx->data.BLendip == 0)
										{
											strncpy(item.iprange, ipaddr_begin, IPRANGE_LEN-1);
										}
										else
										{
											snprintf(item.iprange, IPRANGE_LEN-1, "%s-%s", ipaddr_begin, ipaddr_end);
										}										

										if(strcmp(rowreq_ctx->data.BLport,""))
										{
											if (captive_check_portset_format(rowreq_ctx->data.BLport) != 0)
											{
												break;
											}
											strncpy(item.portset, rowreq_ctx->data.BLport, PORTSET_LEN-1);
										}
										else
										{
											strncpy(item.portset, "all", PORTSET_LEN-1);
										}
					
										ret = eag_conf_captive_list( connection, rowreq_ctx->data.parameter.local_id,
																		rowreq_ctx->data.parameter.instance_id, 
																		type, item.iprange, item.portset, "", rowreq_ctx->data.BLintf,
																		CP_DEL_LIST, CP_BLACK_LIST);
							
										snmp_log(LOG_DEBUG, "dot11PortalBlackListTable_commit: eag_conf_captive_list: ret = %d\n", ret);
										if(ret == EAG_RETURN_OK)
										{
											rc = MFD_SUCCESS;
				                            break;
										}
										else if(EAG_ERR_DBUS_FAILED == ret) 
										{
				                            close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
				                        }
//									}	
								}
								break;
							case 1: 	/*domain*/
								{
									RULE_TYPE type = RULE_DOMAIN;
									char domain[256] = { 0 };
						
//									if(eag_ins_running_state(connection, rowreq_ctx->data.parameter.local_id, rowreq_ctx->data.parameter.instance_id) == 1)
//									{
										memset(&domain, 0, sizeof(domain));
										strncpy(domain, rowreq_ctx->data.BLURL, sizeof(domain)-1);
				
										ret = eag_conf_captive_list( connection, rowreq_ctx->data.parameter.local_id,
																		rowreq_ctx->data.parameter.instance_id, 
																		type, "", "", domain, rowreq_ctx->data.BLintf, 
																		CP_DEL_LIST, CP_BLACK_LIST);
				
										snmp_log(LOG_DEBUG, "dot11PortalBlackListTable_commit: eag_conf_captive_list: ret = %d\n", ret);
										if(ret == EAG_RETURN_OK)
										{
											rc = MFD_SUCCESS;
				                            break;
										}
										else if(EAG_ERR_DBUS_FAILED == ret) 
										{
				                            close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
				                        }
//									}	
								}
								break;
						}
                    }
                }
				if(MFD_SUCCESS != rc)
				{
					rowreq_ctx->rowreq_flags &= ~MFD_ROW_DELETED;
				}
                break;
                
            default:
                break;
        }
       /*
        * TODO:482:o: |-> commit column BLRowStatus.
        */
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11PortalBlackListTable column BLRowStatus commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo BLRowStatus
             */
            rowreq_ctx->column_set_flags |= COLUMN_BLROWSTATUS_FLAG;
       }
    }

    /*
     * if we successfully commited this row, set the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags |= MFD_ROW_DIRTY;
    }

    if (save_flags) {
       snmp_log(LOG_ERR, "unhandled columns (0x%x) in commit\n", save_flags);
       return MFD_ERROR;
    }

    return rc;
} /* dot11PortalBlackListTable_commit */

/**
 * undo commit new values.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * dot11PortalBlackListTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param dot11PortalBlackListTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
dot11PortalBlackListTable_undo_commit( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:dot11PortalBlackListTable_undo_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:485:M: |-> Undo dot11PortalBlackListTable commit.
     * check the column's flag in rowreq_ctx->column_set_flags to see
     * if it was set during commit, then undo it.
     *
     * eg: if (rowreq_ctx->column_set_flags & COLUMN__FLAG) {}
     */

    
    /*
     * if we successfully un-commited this row, clear the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags &= ~MFD_ROW_DIRTY;
    }

    return rc;
} /* dot11PortalBlackListTable_undo_commit */

/*
 * TODO:440:M: Implement dot11PortalBlackListTable node value checks.
 * TODO:450:M: Implement dot11PortalBlackListTable undo functions.
 * TODO:460:M: Implement dot11PortalBlackListTable set functions.
 * TODO:480:M: Implement dot11PortalBlackListTable commit functions.
 */
/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11PortalBlackListEntry.BLtype
 * BLtype is subid 2 of dot11PortalBlackListEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.3.1.2
 * Description:
black list type.
					if the black list type is ip,BLstartip must set to be applied to the black list.
					if the black list type is domain,domain url must set to be applied to the black list
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  ip(0), domain(1)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param BLtype_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11PortalBlackListTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  ip(0), domain(1)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
BLtype_check_value( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx, u_long BLtype_val)
{
    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLtype_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid BLtype value.
     */

    if(RS_NOTINSERVICE == rowreq_ctx->data.BLRowStatus || RS_NOTREADY == rowreq_ctx->data.BLRowStatus)
	    return MFD_SUCCESS;
	else     
        return MFD_ERROR; /* BLtype value not illegal */
} /* BLtype_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11PortalBlackListTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11PortalBlackListTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
BLtype_undo_setup( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLtype_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup BLtype undo.
     */
    /*
     * copy BLtype data
     * set rowreq_ctx->undo->BLtype from rowreq_ctx->data.BLtype
     */
    rowreq_ctx->undo->BLtype = rowreq_ctx->data.BLtype;


    return MFD_SUCCESS;
} /* BLtype_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param BLtype_val
 *        A long containing the new value.
 */
int
BLtype_set( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx, u_long BLtype_val )
{

    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLtype_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set BLtype value.
     * set BLtype value in rowreq_ctx->data
     */
    rowreq_ctx->data.BLtype = BLtype_val;

    return MFD_SUCCESS;
} /* BLtype_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
BLtype_undo( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLtype_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up BLtype undo.
     */
    /*
     * copy BLtype data
     * set rowreq_ctx->data.BLtype from rowreq_ctx->undo->BLtype
     */
    rowreq_ctx->data.BLtype = rowreq_ctx->undo->BLtype;

    
    return MFD_SUCCESS;
} /* BLtype_undo */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11PortalBlackListEntry.BLstartip
 * BLstartip is subid 3 of dot11PortalBlackListEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.3.1.3
 * Description:
black list start ip.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is IPADDR (based on perltype IPADDR)
 * The net-snmp type is ASN_IPADDRESS. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param BLstartip_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11PortalBlackListTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_IPADDRESS
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
BLstartip_check_value( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx, u_long BLstartip_val)
{
    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLstartip_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid BLstartip value.
     */

    if(RS_NOTINSERVICE == rowreq_ctx->data.BLRowStatus || RS_NOTREADY == rowreq_ctx->data.BLRowStatus)
	    return MFD_SUCCESS;
	else     
        return MFD_ERROR; /* BLstartip value not illegal */
} /* BLstartip_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11PortalBlackListTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11PortalBlackListTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
BLstartip_undo_setup( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLstartip_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup BLstartip undo.
     */
    /*
     * copy BLstartip data
     * set rowreq_ctx->undo->BLstartip from rowreq_ctx->data.BLstartip
     */
    rowreq_ctx->undo->BLstartip = rowreq_ctx->data.BLstartip;


    return MFD_SUCCESS;
} /* BLstartip_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param BLstartip_val
 *        A u_long containing the new value.
 */
int
BLstartip_set( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx, u_long BLstartip_val )
{

    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLstartip_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set BLstartip value.
     * set BLstartip value in rowreq_ctx->data
     */
    rowreq_ctx->data.BLstartip = BLstartip_val;

    return MFD_SUCCESS;
} /* BLstartip_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
BLstartip_undo( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLstartip_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up BLstartip undo.
     */
    /*
     * copy BLstartip data
     * set rowreq_ctx->data.BLstartip from rowreq_ctx->undo->BLstartip
     */
    rowreq_ctx->data.BLstartip = rowreq_ctx->undo->BLstartip;

    
    return MFD_SUCCESS;
} /* BLstartip_undo */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11PortalBlackListEntry.BLendip
 * BLendip is subid 4 of dot11PortalBlackListEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.3.1.4
 * Description:
black list end ip,optional.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is IPADDR (based on perltype IPADDR)
 * The net-snmp type is ASN_IPADDRESS. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param BLendip_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11PortalBlackListTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_IPADDRESS
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
BLendip_check_value( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx, u_long BLendip_val)
{
    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLendip_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid BLendip value.
     */

    if(RS_NOTINSERVICE == rowreq_ctx->data.BLRowStatus || RS_NOTREADY == rowreq_ctx->data.BLRowStatus)
	    return MFD_SUCCESS;
	else     
        return MFD_ERROR; /* BLendip value not illegal */
} /* BLendip_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11PortalBlackListTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11PortalBlackListTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
BLendip_undo_setup( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLendip_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup BLendip undo.
     */
    /*
     * copy BLendip data
     * set rowreq_ctx->undo->BLendip from rowreq_ctx->data.BLendip
     */
    rowreq_ctx->undo->BLendip = rowreq_ctx->data.BLendip;


    return MFD_SUCCESS;
} /* BLendip_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param BLendip_val
 *        A u_long containing the new value.
 */
int
BLendip_set( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx, u_long BLendip_val )
{

    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLendip_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set BLendip value.
     * set BLendip value in rowreq_ctx->data
     */
    rowreq_ctx->data.BLendip = BLendip_val;

    return MFD_SUCCESS;
} /* BLendip_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
BLendip_undo( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLendip_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up BLendip undo.
     */
    /*
     * copy BLendip data
     * set rowreq_ctx->data.BLendip from rowreq_ctx->undo->BLendip
     */
    rowreq_ctx->data.BLendip = rowreq_ctx->undo->BLendip;

    
    return MFD_SUCCESS;
} /* BLendip_undo */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11PortalBlackListEntry.BLport
 * BLport is subid 5 of dot11PortalBlackListEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.3.1.5
 * Description:
black list port,the format is (all|PORT[,PORT]...),optional
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param BLport_val_ptr
 *        A char containing the new value.
 * @param BLport_val_ptr_len
 *        The size (in bytes) of the data pointed to by BLport_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11PortalBlackListTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is < sizeof(rowreq_ctx->data.BLport).
 *    The length is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
BLport_check_value( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx, char *BLport_val_ptr,  size_t BLport_val_ptr_len)
{
    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLport_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != BLport_val_ptr);

    /*
     * TODO:441:o: |-> Check for valid BLport value.
     */

    if(RS_NOTINSERVICE == rowreq_ctx->data.BLRowStatus || RS_NOTREADY == rowreq_ctx->data.BLRowStatus)
	    return MFD_SUCCESS;
	else     
        return MFD_ERROR; /* BLport value not illegal */
} /* BLport_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11PortalBlackListTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11PortalBlackListTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
BLport_undo_setup( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLport_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup BLport undo.
     */
    /*
     * copy BLport and BLport_len data
     * set rowreq_ctx->undo->BLport from rowreq_ctx->data.BLport
     */
    memcpy( rowreq_ctx->undo->BLport, rowreq_ctx->data.BLport,
            (rowreq_ctx->data.BLport_len * sizeof(rowreq_ctx->undo->BLport[0])));
    rowreq_ctx->undo->BLport_len = rowreq_ctx->data.BLport_len;


    return MFD_SUCCESS;
} /* BLport_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param BLport_val_ptr
 *        A char containing the new value.
 * @param BLport_val_ptr_len
 *        The size (in bytes) of the data pointed to by BLport_val_ptr
 */
int
BLport_set( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx, char *BLport_val_ptr,  size_t BLport_val_ptr_len )
{

    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLport_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != BLport_val_ptr);

    /*
     * TODO:461:M: |-> Set BLport value.
     * set BLport value in rowreq_ctx->data
     */
    memcpy( rowreq_ctx->data.BLport, BLport_val_ptr, BLport_val_ptr_len );
    /** convert bytes to number of char */
    rowreq_ctx->data.BLport_len = BLport_val_ptr_len / sizeof(BLport_val_ptr[0]);

    return MFD_SUCCESS;
} /* BLport_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
BLport_undo( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLport_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up BLport undo.
     */
    /*
     * copy BLport and BLport_len data
     * set rowreq_ctx->data.BLport from rowreq_ctx->undo->BLport
     */
    memcpy( rowreq_ctx->data.BLport, rowreq_ctx->undo->BLport,
            (rowreq_ctx->undo->BLport_len * sizeof(rowreq_ctx->data.BLport[0])));
    rowreq_ctx->data.BLport_len = rowreq_ctx->undo->BLport_len;

    
    return MFD_SUCCESS;
} /* BLport_undo */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11PortalBlackListEntry.BLURL
 * BLURL is subid 6 of dot11PortalBlackListEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.3.1.6
 * Description:
black list URL.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param BLURL_val_ptr
 *        A char containing the new value.
 * @param BLURL_val_ptr_len
 *        The size (in bytes) of the data pointed to by BLURL_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11PortalBlackListTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is < sizeof(rowreq_ctx->data.BLURL).
 *    The length is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
BLURL_check_value( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx, char *BLURL_val_ptr,  size_t BLURL_val_ptr_len)
{
    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLURL_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != BLURL_val_ptr);

    /*
     * TODO:441:o: |-> Check for valid BLURL value.
     */

    if(RS_NOTINSERVICE == rowreq_ctx->data.BLRowStatus || RS_NOTREADY == rowreq_ctx->data.BLRowStatus)
	    return MFD_SUCCESS;
	else     
        return MFD_ERROR; /* BLURL value not illegal */
} /* BLURL_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11PortalBlackListTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11PortalBlackListTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
BLURL_undo_setup( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLURL_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup BLURL undo.
     */
    /*
     * copy BLURL and BLURL_len data
     * set rowreq_ctx->undo->BLURL from rowreq_ctx->data.BLURL
     */
    memcpy( rowreq_ctx->undo->BLURL, rowreq_ctx->data.BLURL,
            (rowreq_ctx->data.BLURL_len * sizeof(rowreq_ctx->undo->BLURL[0])));
    rowreq_ctx->undo->BLURL_len = rowreq_ctx->data.BLURL_len;


    return MFD_SUCCESS;
} /* BLURL_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param BLURL_val_ptr
 *        A char containing the new value.
 * @param BLURL_val_ptr_len
 *        The size (in bytes) of the data pointed to by BLURL_val_ptr
 */
int
BLURL_set( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx, char *BLURL_val_ptr,  size_t BLURL_val_ptr_len )
{

    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLURL_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != BLURL_val_ptr);

    /*
     * TODO:461:M: |-> Set BLURL value.
     * set BLURL value in rowreq_ctx->data
     */
    memcpy( rowreq_ctx->data.BLURL, BLURL_val_ptr, BLURL_val_ptr_len );
    /** convert bytes to number of char */
    rowreq_ctx->data.BLURL_len = BLURL_val_ptr_len / sizeof(BLURL_val_ptr[0]);

    return MFD_SUCCESS;
} /* BLURL_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
BLURL_undo( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLURL_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up BLURL undo.
     */
    /*
     * copy BLURL and BLURL_len data
     * set rowreq_ctx->data.BLURL from rowreq_ctx->undo->BLURL
     */
    memcpy( rowreq_ctx->data.BLURL, rowreq_ctx->undo->BLURL,
            (rowreq_ctx->undo->BLURL_len * sizeof(rowreq_ctx->data.BLURL[0])));
    rowreq_ctx->data.BLURL_len = rowreq_ctx->undo->BLURL_len;

    
    return MFD_SUCCESS;
} /* BLURL_undo */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11PortalBlackListEntry.BLRowStatus
 * BLRowStatus is subid 7 of dot11PortalBlackListEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.3.1.7
 * Description:
This variable is used to create, modify, and/or delete a row
			        	 in this table.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * Its syntax is RowStatus (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param BLRowStatus_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11PortalBlackListTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
BLRowStatus_check_value( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx, u_long BLRowStatus_val)
{
    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLRowStatus_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid BLRowStatus value.
     */

    return MFD_SUCCESS; /* BLRowStatus value not illegal */
} /* BLRowStatus_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11PortalBlackListTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11PortalBlackListTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
BLRowStatus_undo_setup( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLRowStatus_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup BLRowStatus undo.
     */
    /*
     * copy BLRowStatus data
     * set rowreq_ctx->undo->BLRowStatus from rowreq_ctx->data.BLRowStatus
     */
    rowreq_ctx->undo->BLRowStatus = rowreq_ctx->data.BLRowStatus;


    return MFD_SUCCESS;
} /* BLRowStatus_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param BLRowStatus_val
 *        A long containing the new value.
 */
int
BLRowStatus_set( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx, u_long BLRowStatus_val )
{

    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLRowStatus_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set BLRowStatus value.
     * set BLRowStatus value in rowreq_ctx->data
     */
    int ret = MFD_SUCCESS;
    
    switch(BLRowStatus_val) {
    
        case RS_ACTIVE:         
        case RS_DESTROY:
            rowreq_ctx->data.BLRowStatus = BLRowStatus_val;
            ret = MFD_SUCCESS;
            break;
    
        case RS_NOTINSERVICE:
        case RS_NOTREADY:
        case RS_CREATEANDGO:
            ret = MFD_ERROR;
            break;
    
        case RS_CREATEANDWAIT:
            if(RS_NONEXISTENT == rowreq_ctx->data.BLRowStatus) {
                global_to_local_ID(&(rowreq_ctx->data.parameter), 
                                    rowreq_ctx->tbl_idx.BLid, 
                                    WIRELESS_MAX_NUM);
                rowreq_ctx->data.BLRowStatus = BLRowStatus_val;
                ret = MFD_SUCCESS;
            }
            else {
                ret = MFD_ERROR;
            }
            break;
    
        default:
            snmp_log(LOG_WARNING, "unknow %s in BLRowStatus_set", BLRowStatus_val);
            ret = MFD_ERROR;
            break;
    }

    return ret;
    
} /* BLRowStatus_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
BLRowStatus_undo( dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11PortalBlackListTable:BLRowStatus_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up BLRowStatus undo.
     */
    /*
     * copy BLRowStatus data
     * set rowreq_ctx->data.BLRowStatus from rowreq_ctx->undo->BLRowStatus
     */
    rowreq_ctx->data.BLRowStatus = rowreq_ctx->undo->BLRowStatus;

    
    return MFD_SUCCESS;
} /* BLRowStatus_undo */

/**
 * check dependencies
 *
 * This is useful for for tables which have dependencies between columns
 * (or rows, or tables). For example, two columns allocating a percentage
 * of something add up 100%.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * dot11PortalBlackListTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @retval MFD_SUCCESS all the changes to the row are legal
 * @retval MFD_ERROR   one or more changes are not legal
 *
 * (see README-table-dot11PortalBlackListTable if you don't have dependencies)
 */
int
dot11PortalBlackListTable_check_dependencies(dot11PortalBlackListTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;
    
    DEBUGMSGTL(("internal:dot11PortalBlackListTable:dot11PortalBlackListTable_check_dependencies","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:470:o: Check dot11PortalBlackListTable row dependencies.
     * check that all new value are legal and consistent with each other
     */
    /*
     * check RowStatus dependencies
     */
    if (rowreq_ctx->column_set_flags & COLUMN_BLROWSTATUS_FLAG) {
        /*
         * check for valid RowStatus transition (old, new)
         * (Note: move transition check to 
         *  to catch errors earlier)
         */
        rc = check_rowstatus_transition( rowreq_ctx->undo->BLRowStatus,
                                         rowreq_ctx->data.BLRowStatus );
        if (MFD_SUCCESS != rc)
            return rc;
        
        /*
         * row creation requirements
         */
        if (rowreq_ctx->rowreq_flags & MFD_ROW_CREATED) {
            if (ROWSTATUS_DESTROY ==  rowreq_ctx->data.BLRowStatus) {
                rowreq_ctx->rowreq_flags |= MFD_ROW_DELETED;
            }
            else if (ROWSTATUS_CREATEANDGO ==  rowreq_ctx->data.BLRowStatus) {
                if ((rowreq_ctx->column_set_flags & DOT11PORTALBLACKLISTTABLE_REQUIRED_COLS)
                    != DOT11PORTALBLACKLISTTABLE_REQUIRED_COLS) {
                    DEBUGMSGTL(("dot11PortalBlackListTable",
                                "required columns missing (0x%0x != 0x%0x)\n",
                                rowreq_ctx->column_set_flags, DOT11PORTALBLACKLISTTABLE_REQUIRED_COLS));
                    return MFD_CANNOT_CREATE_NOW;
                }
                rowreq_ctx->data.BLRowStatus = ROWSTATUS_ACTIVE;
            }
        } /* row creation */
        else {
            /*
             * row change requirements
             */
            /*
             * don't allow a destroy if any other value was changed, since
             * that might call data access routines with bad info.
             *
             * you may or may not require the row be notInService before it
             * can be destroyed.
             */
            if (ROWSTATUS_DESTROY == rowreq_ctx->data.BLRowStatus) {
                if (rowreq_ctx->column_set_flags & ~COLUMN_BLROWSTATUS_FLAG) {
                    DEBUGMSGTL(("dot11PortalBlackListTable",
                                "destroy must be only varbind for row\n"));
                    return MFD_NOT_VALID_NOW;
                }
                rowreq_ctx->rowreq_flags |= MFD_ROW_DELETED;

            } /* row destroy */
        } /* row change */
    }
    else {
        /*
         * must have row status to create a row
         */
        if (rowreq_ctx->rowreq_flags & MFD_ROW_CREATED) {
            DEBUGMSGTL(("dot11PortalBlackListTable",
                        "must use RowStatus to create rows\n"));
            return MFD_CANNOT_CREATE_NOW;
        }
    } /* row status not set */

    if ( MFD_SUCCESS != rc )
        return rc;

    return rc;
} /* dot11PortalBlackListTable_check_dependencies */

/** @} */
