/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.18 $ of : mfd-data-set.m2c,v $
 *
 * $Id:$
 *
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "wcpss/asd/asd.h"
#include "wcpss/wid/WID.h"
#include "dbus/wcpss/dcli_wid_wtp.h"
#include "dbus/wcpss/dcli_wid_wlan.h"
#include "ws_dcli_wlans.h"
#include "ws_sysinfo.h"
#include "ws_init_dbus.h"
#include <stdlib.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include "ws_init_dbus.h"
#include <dbus/dbus.h>
#include "sysdef/npd_sysdef.h"
#include "dbus/npd/npd_dbus_def.h"
#include "autelanWtpGroup.h"
#include "ws_security.h"
/* include our parent header */
#include "dot11WtpWAPIConfigTable.h"


/** @defgroup data_set data_set: Routines to set data
 *
 * These routines are used to set the value for individual objects. The
 * row context is passed, along with the new value.
 * 
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table dot11WtpWAPIConfigTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * dot11WtpWAPIConfigTable is subid 10 of wtpWAPI.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10, length: 12
*/
    /*
     * NOTE: if you update this chart, please update the versions in
     *       local/mib2c-conf.d/parent-set.m2i
     *       agent/mibgroup/helpers/baby_steps.c
     * while you're at it.
     */
    /*
     ***********************************************************************
     * Baby Steps Flow Chart (2004.06.05)                                  *
     *                                                                     *
     * +--------------+    +================+    U = unconditional path    *
     * |optional state|    ||required state||    S = path for success      *
     * +--------------+    +================+    E = path for error        *
     ***********************************************************************
     *
     *                        +--------------+
     *                        |     pre      |
     *                        |   request    |
     *                        +--------------+
     *                               | U
     *                        +==============+
     *       +----------------||  object    ||
     *       |              E ||  lookup    ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |              E ||   check    ||
     *       |<---------------||   values   ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |       +<-------||   undo     ||
     *       |       |      E ||   setup    ||
     *       |       |        +==============+
     *       |       |               | S
     *       |       |        +==============+
     *       |       |        ||    set     ||-------------------------->+
     *       |       |        ||   value    || E                         |
     *       |       |        +==============+                           |
     *       |       |               | S                                 |
     *       |       |        +--------------+                           |
     *       |       |        |    check     |-------------------------->|
     *       |       |        |  consistency | E                         |
     *       |       |        +--------------+                           |
     *       |       |               | S                                 |
     *       |       |        +==============+         +==============+  |
     *       |       |        ||   commit   ||-------->||     undo   ||  |
     *       |       |        ||            || E       ||    commit  ||  |
     *       |       |        +==============+         +==============+  |
     *       |       |               | S                     U |<--------+
     *       |       |        +--------------+         +==============+
     *       |       |        | irreversible |         ||    undo    ||
     *       |       |        |    commit    |         ||     set    ||
     *       |       |        +--------------+         +==============+
     *       |       |               | U                     U |
     *       |       +-------------->|<------------------------+
     *       |                +==============+
     *       |                ||   undo     ||
     *       |                ||  cleanup   ||
     *       |                +==============+
     *       +---------------------->| U
     *                        +--------------+
     *                        |    post      |
     *                        |   request    |
     *                        +--------------+
     *
     */

/**
 * Setup up context with information needed to undo a set request.
 *
 * This function will be called before the individual node undo setup
 * functions are called. If you need to do any undo setup that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo_setup function will only be called
 * if that node is being set to a new value.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in the node's undo_setup
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11WtpWAPIConfigTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
dot11WtpWAPIConfigTable_undo_setup( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:dot11WtpWAPIConfigTable_undo_setup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> Setup dot11WtpWAPIConfigTable undo.
     * set up dot11WtpWAPIConfigTable undo information, in preparation for a set.
     */

    return rc;
} /* dot11WtpWAPIConfigTable_undo_setup */

/**
 * Cleanup up context undo information.
 *
 * This function will be called after set/commit processing. If you
 * allocated any resources in undo_setup, this is the place to release
 * those resources.
 *
 * This function is called regardless of the success or failure of the set
 * request. If you need to perform different steps for cleanup depending
 * on success or failure, you can add a flag to the rowreq_ctx.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11WtpWAPIConfigTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
dot11WtpWAPIConfigTable_undo_cleanup( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:dot11WtpWAPIConfigTable_undo_cleanup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:452:M: |-> Cleanup dot11WtpWAPIConfigTable undo.
     */

    return rc;
} /* dot11WtpWAPIConfigTable_undo_cleanup */

/**
 * commit new values.
 *
 * At this point, you should have done everything you can to ensure that
 * this commit will not fail.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the FLAG_* bits can be found in
 * dot11WtpWAPIConfigTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param dot11WtpWAPIConfigTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
dot11WtpWAPIConfigTable_commit( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;
    int             save_flags;

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:dot11WtpWAPIConfigTable_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * save flags, then clear until we actually do something
     */
    save_flags = rowreq_ctx->column_set_flags;
    rowreq_ctx->column_set_flags = 0;

    /*
     * commit dot11WtpWAPIConfigTable data
     * 1) check the column's flag in save_flags to see if it was set.
     * 2) clear the flag when you handle that column
     * 3) set the column's flag in column_set_flags if it needs undo
     *    processing in case of a failure.
     */
    if (save_flags & FLAG_WTPWAPIENABLED) {
       save_flags &= ~FLAG_WTPWAPIENABLED; /* clear wtpWapiEnabled */
       /*
        * TODO:482:o: |-> commit column wtpWapiEnabled.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11WtpWAPIConfigTable column wtpWapiEnabled commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wtpWapiEnabled
             */
            rowreq_ctx->column_set_flags |= FLAG_WTPWAPIENABLED;
       }
    }

    if (save_flags & FLAG_WTPWAPIPREAUTHENABLED) {
       save_flags &= ~FLAG_WTPWAPIPREAUTHENABLED; /* clear wtpWapiPreauthEnabled */
       /*
        * TODO:482:o: |-> commit column wtpWapiPreauthEnabled.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11WtpWAPIConfigTable column wtpWapiPreauthEnabled commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wtpWapiPreauthEnabled
             */
            rowreq_ctx->column_set_flags |= FLAG_WTPWAPIPREAUTHENABLED;
       }
    }

    if (save_flags & FLAG_WTPWAPIUNICASTREKEYMETHOD) {
       save_flags &= ~FLAG_WTPWAPIUNICASTREKEYMETHOD; /* clear wtpWapiUnicastRekeyMethod */
       /*
        * TODO:482:o: |-> commit column wtpWapiUnicastRekeyMethod.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11WtpWAPIConfigTable column wtpWapiUnicastRekeyMethod commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wtpWapiUnicastRekeyMethod
             */
            rowreq_ctx->column_set_flags |= FLAG_WTPWAPIUNICASTREKEYMETHOD;
       }
    }

    if (save_flags & FLAG_WTPWAPIUNICASTREKEYTIME) {
       save_flags &= ~FLAG_WTPWAPIUNICASTREKEYTIME; /* clear wtpWapiUnicastRekeyTime */
       /*
        * TODO:482:o: |-> commit column wtpWapiUnicastRekeyTime.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11WtpWAPIConfigTable column wtpWapiUnicastRekeyTime commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wtpWapiUnicastRekeyTime
             */
            rowreq_ctx->column_set_flags |= FLAG_WTPWAPIUNICASTREKEYTIME;
       }
    }

    if (save_flags & FLAG_WTPWAPIUNICASTREKEYPACKETS) {
       save_flags &= ~FLAG_WTPWAPIUNICASTREKEYPACKETS; /* clear wtpWapiUnicastRekeyPackets */
       /*
        * TODO:482:o: |-> commit column wtpWapiUnicastRekeyPackets.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11WtpWAPIConfigTable column wtpWapiUnicastRekeyPackets commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wtpWapiUnicastRekeyPackets
             */
            rowreq_ctx->column_set_flags |= FLAG_WTPWAPIUNICASTREKEYPACKETS;
       }
    }

    if (save_flags & FLAG_WTPWAPIMULTICASTCIPHER) {
       save_flags &= ~FLAG_WTPWAPIMULTICASTCIPHER; /* clear wtpWapiMulticastCipher */
       /*
        * TODO:482:o: |-> commit column wtpWapiMulticastCipher.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11WtpWAPIConfigTable column wtpWapiMulticastCipher commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wtpWapiMulticastCipher
             */
            rowreq_ctx->column_set_flags |= FLAG_WTPWAPIMULTICASTCIPHER;
       }
    }

    if (save_flags & FLAG_WTPWAPIMULTICASTREKEYMETHOD) {
       save_flags &= ~FLAG_WTPWAPIMULTICASTREKEYMETHOD; /* clear wtpWapiMulticastRekeyMethod */
       /*
        * TODO:482:o: |-> commit column wtpWapiMulticastRekeyMethod.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11WtpWAPIConfigTable column wtpWapiMulticastRekeyMethod commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wtpWapiMulticastRekeyMethod
             */
            rowreq_ctx->column_set_flags |= FLAG_WTPWAPIMULTICASTREKEYMETHOD;
       }
    }

    if (save_flags & FLAG_WTPWAPIMULTICASTREKEYTIME) {
       save_flags &= ~FLAG_WTPWAPIMULTICASTREKEYTIME; /* clear wtpWapiMulticastRekeyTime */
       /*
        * TODO:482:o: |-> commit column wtpWapiMulticastRekeyTime.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11WtpWAPIConfigTable column wtpWapiMulticastRekeyTime commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wtpWapiMulticastRekeyTime
             */
            rowreq_ctx->column_set_flags |= FLAG_WTPWAPIMULTICASTREKEYTIME;
       }
    }

    if (save_flags & FLAG_WTPWAPIMULTICASTREKEYPACKETS) {
       save_flags &= ~FLAG_WTPWAPIMULTICASTREKEYPACKETS; /* clear wtpWapiMulticastRekeyPackets */
       /*
        * TODO:482:o: |-> commit column wtpWapiMulticastRekeyPackets.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11WtpWAPIConfigTable column wtpWapiMulticastRekeyPackets commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wtpWapiMulticastRekeyPackets
             */
            rowreq_ctx->column_set_flags |= FLAG_WTPWAPIMULTICASTREKEYPACKETS;
       }
    }

    if (save_flags & FLAG_WTPWAPIMULTICASTREKEYSTRICT) {
       save_flags &= ~FLAG_WTPWAPIMULTICASTREKEYSTRICT; /* clear wtpWapiMulticastRekeyStrict */
       /*
        * TODO:482:o: |-> commit column wtpWapiMulticastRekeyStrict.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11WtpWAPIConfigTable column wtpWapiMulticastRekeyStrict commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wtpWapiMulticastRekeyStrict
             */
            rowreq_ctx->column_set_flags |= FLAG_WTPWAPIMULTICASTREKEYSTRICT;
       }
    }

    if (save_flags & FLAG_WTPWAPIPSKVALUE) {
       save_flags &= ~FLAG_WTPWAPIPSKVALUE; /* clear wtpWapiPSKValue */
       /*
        * TODO:482:o: |-> commit column wtpWapiPSKValue.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11WtpWAPIConfigTable column wtpWapiPSKValue commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wtpWapiPSKValue
             */
            rowreq_ctx->column_set_flags |= FLAG_WTPWAPIPSKVALUE;
       }
    }

    if (save_flags & FLAG_WTPWAPIPSKPASSPHRASE) {
       save_flags &= ~FLAG_WTPWAPIPSKPASSPHRASE; /* clear wtpWapiPSKPassPhrase */
       /*
        * TODO:482:o: |-> commit column wtpWapiPSKPassPhrase.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11WtpWAPIConfigTable column wtpWapiPSKPassPhrase commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wtpWapiPSKPassPhrase
             */
            rowreq_ctx->column_set_flags |= FLAG_WTPWAPIPSKPASSPHRASE;
       }
    }

    if (save_flags & FLAG_WTPWAPICERTIFICATEUPDATECOUNT) {
       save_flags &= ~FLAG_WTPWAPICERTIFICATEUPDATECOUNT; /* clear wtpWapiCertificateUpdateCount */
       /*
        * TODO:482:o: |-> commit column wtpWapiCertificateUpdateCount.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11WtpWAPIConfigTable column wtpWapiCertificateUpdateCount commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wtpWapiCertificateUpdateCount
             */
            rowreq_ctx->column_set_flags |= FLAG_WTPWAPICERTIFICATEUPDATECOUNT;
       }
    }

    if (save_flags & FLAG_WTPWAPIMULTICASTUPDATECOUNT) {
       save_flags &= ~FLAG_WTPWAPIMULTICASTUPDATECOUNT; /* clear wtpWapiMulticastUpdateCount */
       /*
        * TODO:482:o: |-> commit column wtpWapiMulticastUpdateCount.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11WtpWAPIConfigTable column wtpWapiMulticastUpdateCount commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wtpWapiMulticastUpdateCount
             */
            rowreq_ctx->column_set_flags |= FLAG_WTPWAPIMULTICASTUPDATECOUNT;
       }
    }

    if (save_flags & FLAG_WTPWAPIUNICASTUPDATECOUNT) {
       save_flags &= ~FLAG_WTPWAPIUNICASTUPDATECOUNT; /* clear wtpWapiUnicastUpdateCount */
       /*
        * TODO:482:o: |-> commit column wtpWapiUnicastUpdateCount.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11WtpWAPIConfigTable column wtpWapiUnicastUpdateCount commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wtpWapiUnicastUpdateCount
             */
            rowreq_ctx->column_set_flags |= FLAG_WTPWAPIUNICASTUPDATECOUNT;
       }
    }

    if (save_flags & FLAG_WTPWAPIBKLIFETIME) {
       save_flags &= ~FLAG_WTPWAPIBKLIFETIME; /* clear wtpWapiBKLifetime */
       /*
        * TODO:482:o: |-> commit column wtpWapiBKLifetime.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11WtpWAPIConfigTable column wtpWapiBKLifetime commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wtpWapiBKLifetime
             */
            rowreq_ctx->column_set_flags |= FLAG_WTPWAPIBKLIFETIME;
       }
    }

    if (save_flags & FLAG_WTPWAPIBKREAUTHTHRESHOLD) {
       save_flags &= ~FLAG_WTPWAPIBKREAUTHTHRESHOLD; /* clear wtpWapiBKReauthThreshold */
       /*
        * TODO:482:o: |-> commit column wtpWapiBKReauthThreshold.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11WtpWAPIConfigTable column wtpWapiBKReauthThreshold commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wtpWapiBKReauthThreshold
             */
            rowreq_ctx->column_set_flags |= FLAG_WTPWAPIBKREAUTHTHRESHOLD;
       }
    }

    if (save_flags & FLAG_WTPWAPISATIMEOUT) {
       save_flags &= ~FLAG_WTPWAPISATIMEOUT; /* clear wtpWapiSATimeout */
       /*
        * TODO:482:o: |-> commit column wtpWapiSATimeout.
        */
       //rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"dot11WtpWAPIConfigTable column wtpWapiSATimeout commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo wtpWapiSATimeout
             */
            rowreq_ctx->column_set_flags |= FLAG_WTPWAPISATIMEOUT;
       }
    }

    if (save_flags) {
       snmp_log(LOG_ERR, "unhandled columns (0x%x) in commit\n", save_flags);
       return MFD_ERROR;
    }

    return rc;
} /* dot11WtpWAPIConfigTable_commit */

/**
 * undo commit new values.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the FLAG_* bits can be found in
 * dot11WtpWAPIConfigTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param dot11WtpWAPIConfigTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
dot11WtpWAPIConfigTable_undo_commit( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:dot11WtpWAPIConfigTable_undo_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:485:M: |-> Undo dot11WtpWAPIConfigTable commit.
     * check the column's flag in rowreq_ctx->column_set_flags to see
     * if it was set during commit, then undo it.
     *
     * eg: if (rowreq_ctx->column_set_flags & FLAG_) {}
     */

    return rc;
} /* dot11WtpWAPIConfigTable_undo_commit */

/*
 * TODO:420:r: Implement dot11WtpWAPIConfigTable index validation.
 */
/*
 * TODO:440:M: Implement dot11WtpWAPIConfigTable node value checks.
 * TODO:450:M: Implement dot11WtpWAPIConfigTable undo functions.
 * TODO:460:M: Implement dot11WtpWAPIConfigTable set functions.
 * TODO:480:M: Implement dot11WtpWAPIConfigTable commit functions.
 */
/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiEnabled
 * wtpWapiEnabled is subid 7 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.7
 * Description:
wtpWapiEnabled.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiEnabled_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11WtpWAPIConfigTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wtpWapiEnabled_check_value( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long wtpWapiEnabled_val)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiEnabled_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wtpWapiEnabled value.
     */

    return MFD_SUCCESS; /* wtpWapiEnabled value not illegal */
} /* wtpWapiEnabled_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11WtpWAPIConfigTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11WtpWAPIConfigTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wtpWapiEnabled_undo_setup( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiEnabled_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wtpWapiEnabled undo.
     */
    /*
     * copy wtpWapiEnabled data
     * set rowreq_ctx->undo->wtpWapiEnabled from rowreq_ctx->data.wtpWapiEnabled
     */
    rowreq_ctx->undo->wtpWapiEnabled = rowreq_ctx->data.wtpWapiEnabled;


    return MFD_SUCCESS;
} /* wtpWapiEnabled_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wtpWapiEnabled_val
 *        A long containing the new value.
 */
int
wtpWapiEnabled_set( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long wtpWapiEnabled_val )
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiEnabled_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:245:o: |-> Implement wtpWapiEnabled reverse mapping.
 * If the values for your data type don't exactly match the
 * possible values defined by the mib, you should map them here.
 */
    /*
    ***************************************************
    ***             START EXAMPLE CODE              ***
    ***---------------------------------------------***/
    switch(wtpWapiEnabled_val) {
        case TRUTHVALUE_TRUE:
             wtpWapiEnabled_val = INTERNAL_WTPWAPIENABLED_TRUE;
             break;

        case TRUTHVALUE_FALSE:
             wtpWapiEnabled_val = INTERNAL_WTPWAPIENABLED_FALSE;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't reverse map value %ld for wtpWapiEnabled\n", wtpWapiEnabled_val );
                 return SNMP_ERR_GENERR;
    }
    /*
    ***---------------------------------------------***
    ***              END  EXAMPLE CODE              ***
    ***************************************************/

    /*
     * TODO:461:M: |-> Set wtpWapiEnabled value.
     * set wtpWapiEnabled value in rowreq_ctx->data
     */
    void *connection = NULL;
    if(SNMPD_DBUS_ERROR == get_instance_dbus_connection(rowreq_ctx->data.parameter, &connection, SNMPD_INSTANCE_MASTER_V3))
        return MFD_ERROR;
        
	int rc = MFD_ERROR;
	int ret = 2;
	char input[DEFAULT_LEN] = { 0 };
	int ret_one = 2;
	int ret_two = 2;
	int ret_three = 2;									 
	int value = 0;
	ret = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"disable");
	if(ret == 1)
	{
		value = wtpWapiEnabled_val;

        
        memset(input, 0, sizeof(input));
		if ( value == 1 )
		{
			strncpy(input,"enable", sizeof(input) - 1);
		}
		else if( value == 2)
		{
			strncpy(input,"disable", sizeof(input) - 1);
		}
		ret_one = set_wapi_sub_attr_wapipreauth_cmd(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,input);
		if(ret_one == 1)
		{						 
			ret_two = apply_wlanID(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,rowreq_ctx->data.localWlanID);
			if (ret_two == 1)
			{
				ret_three = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"enable");
				if (ret_three == 1)
				{
					rowreq_ctx->data.wtpWapiEnabled = wtpWapiEnabled_val;
					rc = MFD_SUCCESS;
				}
				else
				{
				    if(SNMPD_CONNECTION_ERROR == ret_three) {
                        close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
            	    }
					rc = MFD_ERROR;
				}
			}	
			else
			{
			    if(SNMPD_CONNECTION_ERROR == ret_two) {
                    close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
        	    }
				rc = MFD_ERROR;
			}								 	     
		}
		else 
		{
		    if(SNMPD_CONNECTION_ERROR == ret_one) {
                close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
    	    }
			rc = MFD_ERROR;
		}
	}
	else 
	{
	    if(SNMPD_CONNECTION_ERROR == ret) {
            close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
	    }
		rc = MFD_ERROR;
	}

    return rc;
} /* wtpWapiEnabled_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wtpWapiEnabled_undo( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiEnabled_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wtpWapiEnabled undo.
     */
    /*
     * copy wtpWapiEnabled data
     * set rowreq_ctx->data.wtpWapiEnabled from rowreq_ctx->undo->wtpWapiEnabled
     */
    rowreq_ctx->data.wtpWapiEnabled = rowreq_ctx->undo->wtpWapiEnabled;

    
    return MFD_SUCCESS;
} /* wtpWapiEnabled_undo */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiPreauthEnabled
 * wtpWapiPreauthEnabled is subid 8 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.8
 * Description:
wtpWapiPreauthEnabled.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiPreauthEnabled_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11WtpWAPIConfigTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wtpWapiPreauthEnabled_check_value( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long wtpWapiPreauthEnabled_val)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiPreauthEnabled_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wtpWapiPreauthEnabled value.
     */

    return MFD_SUCCESS; /* wtpWapiPreauthEnabled value not illegal */
} /* wtpWapiPreauthEnabled_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11WtpWAPIConfigTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11WtpWAPIConfigTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wtpWapiPreauthEnabled_undo_setup( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiPreauthEnabled_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wtpWapiPreauthEnabled undo.
     */
    /*
     * copy wtpWapiPreauthEnabled data
     * set rowreq_ctx->undo->wtpWapiPreauthEnabled from rowreq_ctx->data.wtpWapiPreauthEnabled
     */
    rowreq_ctx->undo->wtpWapiPreauthEnabled = rowreq_ctx->data.wtpWapiPreauthEnabled;


    return MFD_SUCCESS;
} /* wtpWapiPreauthEnabled_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wtpWapiPreauthEnabled_val
 *        A long containing the new value.
 */
int
wtpWapiPreauthEnabled_set( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long wtpWapiPreauthEnabled_val )
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiPreauthEnabled_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:245:o: |-> Implement wtpWapiPreauthEnabled reverse mapping.
 * If the values for your data type don't exactly match the
 * possible values defined by the mib, you should map them here.
 */
    /*
    ***************************************************
    ***             START EXAMPLE CODE              ***
    ***---------------------------------------------***/
    switch(wtpWapiPreauthEnabled_val) {
        case TRUTHVALUE_TRUE:
             wtpWapiPreauthEnabled_val = INTERNAL_WTPWAPIPREAUTHENABLED_TRUE;
             break;

        case TRUTHVALUE_FALSE:
             wtpWapiPreauthEnabled_val = INTERNAL_WTPWAPIPREAUTHENABLED_FALSE;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't reverse map value %ld for wtpWapiPreauthEnabled\n", wtpWapiPreauthEnabled_val );
                 return SNMP_ERR_GENERR;
    }
    /*
    ***---------------------------------------------***
    ***              END  EXAMPLE CODE              ***
    ***************************************************/

    /*
     * TODO:461:M: |-> Set wtpWapiPreauthEnabled value.
     * set wtpWapiPreauthEnabled value in rowreq_ctx->data
     */
    void *connection = NULL;
    if(SNMPD_DBUS_ERROR == get_instance_dbus_connection(rowreq_ctx->data.parameter, &connection, SNMPD_INSTANCE_MASTER_V3))
        return MFD_ERROR;
        
	int ret = 2;
	char input[DEFAULT_LEN] = { 0 };
	int ret_one = 2;
	int ret_two = 2;
	int ret_three = 2;									 
	int value = 0;
	int rc = MFD_ERROR;
	ret = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"disable");
	if(ret == 1)
	{
		value = wtpWapiPreauthEnabled_val;
		
        memset(input, 0, sizeof(input));
		if ( value == 1 )
		{
			strncpy(input,"enable", sizeof(input) - 1);
		}
		else if( value == 2)
		{
			strncpy(input,"disable", sizeof(input) - 1);
		}
		ret_one = set_wapi_sub_attr_wapipreauth_cmd(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,input);
		if(ret_one == 1)
		{						 
			ret_two = apply_wlanID(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,rowreq_ctx->data.localWlanID);
			if (ret_two == 1)
			{
				ret_three = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"enable");
				if (ret_three == 1)
				{
					rowreq_ctx->data.wtpWapiPreauthEnabled = wtpWapiPreauthEnabled_val;
					rc = MFD_SUCCESS;
				}
				else
				{
				    if(SNMPD_CONNECTION_ERROR == ret_three) {
                        close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
            	    }
					rc = MFD_ERROR;
				}
			}	
			else
			{
			    if(SNMPD_CONNECTION_ERROR == ret_two) {
                    close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
        	    }
				rc = MFD_ERROR;
			}								 	     
		}
		else 
		{
		    if(SNMPD_CONNECTION_ERROR == ret_one) {
                close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
    	    }
			rc = MFD_ERROR;
		}
	}
	else 
	{
	    if(SNMPD_CONNECTION_ERROR == ret) {
            close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
	    }
		rc = MFD_ERROR;
	}

    return rc;
} /* wtpWapiPreauthEnabled_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wtpWapiPreauthEnabled_undo( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiPreauthEnabled_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wtpWapiPreauthEnabled undo.
     */
    /*
     * copy wtpWapiPreauthEnabled data
     * set rowreq_ctx->data.wtpWapiPreauthEnabled from rowreq_ctx->undo->wtpWapiPreauthEnabled
     */
    rowreq_ctx->data.wtpWapiPreauthEnabled = rowreq_ctx->undo->wtpWapiPreauthEnabled;

    
    return MFD_SUCCESS;
} /* wtpWapiPreauthEnabled_undo */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiUnicastRekeyMethod
 * wtpWapiUnicastRekeyMethod is subid 10 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.10
 * Description:
wtpWapiUnicastKeysSupported.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  disabled(1), timeBased(2), packetBased(3), timepacket_Based(4)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiUnicastRekeyMethod_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11WtpWAPIConfigTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  disabled(1), timeBased(2), packetBased(3), timepacket_Based(4)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wtpWapiUnicastRekeyMethod_check_value( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long wtpWapiUnicastRekeyMethod_val)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastRekeyMethod_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wtpWapiUnicastRekeyMethod value.
     */

    return MFD_SUCCESS; /* wtpWapiUnicastRekeyMethod value not illegal */
} /* wtpWapiUnicastRekeyMethod_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11WtpWAPIConfigTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11WtpWAPIConfigTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wtpWapiUnicastRekeyMethod_undo_setup( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastRekeyMethod_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wtpWapiUnicastRekeyMethod undo.
     */
    /*
     * copy wtpWapiUnicastRekeyMethod data
     * set rowreq_ctx->undo->wtpWapiUnicastRekeyMethod from rowreq_ctx->data.wtpWapiUnicastRekeyMethod
     */
    rowreq_ctx->undo->wtpWapiUnicastRekeyMethod = rowreq_ctx->data.wtpWapiUnicastRekeyMethod;


    return MFD_SUCCESS;
} /* wtpWapiUnicastRekeyMethod_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wtpWapiUnicastRekeyMethod_val
 *        A long containing the new value.
 */
int
wtpWapiUnicastRekeyMethod_set( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long wtpWapiUnicastRekeyMethod_val )
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastRekeyMethod_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:245:o: |-> Implement wtpWapiUnicastRekeyMethod reverse mapping.
 * If the values for your data type don't exactly match the
 * possible values defined by the mib, you should map them here.
 */
    /*
    ***************************************************
    ***             START EXAMPLE CODE              ***
    ***---------------------------------------------***/
    switch(wtpWapiUnicastRekeyMethod_val) {
        case WTPWAPIUNICASTREKEYMETHOD_DISABLED:
             wtpWapiUnicastRekeyMethod_val = INTERNAL_WTPWAPIUNICASTREKEYMETHOD_DISABLED;
             break;

        case WTPWAPIUNICASTREKEYMETHOD_TIMEBASED:
             wtpWapiUnicastRekeyMethod_val = INTERNAL_WTPWAPIUNICASTREKEYMETHOD_TIMEBASED;
             break;

        case WTPWAPIUNICASTREKEYMETHOD_PACKETBASED:
             wtpWapiUnicastRekeyMethod_val = INTERNAL_WTPWAPIUNICASTREKEYMETHOD_PACKETBASED;
             break;

        case WTPWAPIUNICASTREKEYMETHOD_TIMEPACKET_BASED:
             wtpWapiUnicastRekeyMethod_val = INTERNAL_WTPWAPIUNICASTREKEYMETHOD_TIMEPACKET_BASED;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't reverse map value %ld for wtpWapiUnicastRekeyMethod\n", wtpWapiUnicastRekeyMethod_val );
                 return SNMP_ERR_GENERR;
    }
    /*
    ***---------------------------------------------***
    ***              END  EXAMPLE CODE              ***
    ***************************************************/

    /*
     * TODO:461:M: |-> Set wtpWapiUnicastRekeyMethod value.
     * set wtpWapiUnicastRekeyMethod value in rowreq_ctx->data
     */
    void *connection = NULL;
    if(SNMPD_DBUS_ERROR == get_instance_dbus_connection(rowreq_ctx->data.parameter, &connection, SNMPD_INSTANCE_MASTER_V3))
        return MFD_ERROR;
        
	int ret = 2;
	char input[DEFAULT_LEN] = { 0 };
	int ret_one = 2;
	int ret_two = 2;
	int ret_three = 2;									 
	int value = 0;
	int rc  = MFD_ERROR;
	ret = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"disable");
	value = wtpWapiUnicastRekeyMethod_val;

	memset(input,0,DEFAULT_LEN);
	if ( value == WTPWAPIUNICASTREKEYMETHOD_DISABLED )
	{
		strncpy(input,"disable", sizeof(input) - 1);
	}
	else if( value == WTPWAPIUNICASTREKEYMETHOD_TIMEBASED)
	{
		strncpy(input,"time_based", sizeof(input) - 1);
	}
	else if( value == WTPWAPIUNICASTREKEYMETHOD_PACKETBASED)
	{
		strncpy(input,"packet_based", sizeof(input) - 1);
	}
	else if( value == WTPWAPIUNICASTREKEYMETHOD_TIMEPACKET_BASED )
	{
		strncpy(input,"both_based", sizeof(input) - 1);
	}
	if(ret == 1)
	{
		ret_one = set_wapi_ucast_rekey_method_cmd_func(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,"unicast",input);
		if(ret_one == 1)
		{						 
			ret_two = apply_wlanID(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,rowreq_ctx->data.localWlanID);
			if (ret_two == 1)
			{
				ret_three = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"enable");
				if (ret_three == 1)
				{
    				rowreq_ctx->data.wtpWapiUnicastRekeyMethod= wtpWapiUnicastRekeyMethod_val;
					rc = MFD_SUCCESS;
				}
				else
				{
				    if(SNMPD_CONNECTION_ERROR == ret_three) {
                        close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
            	    }
					rc  = MFD_ERROR;
				}
			}	
			else
			{
			    if(SNMPD_CONNECTION_ERROR == ret_two) {
                    close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
        	    }
				rc  = MFD_ERROR;
			}								 	     
		}
		else 
		{
		    if(SNMPD_CONNECTION_ERROR == ret_one) {
                close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
    	    }
			rc  = MFD_ERROR;
		}
	}
	else 
	{
	    if(SNMPD_CONNECTION_ERROR == ret) {
            close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
	    }
		rc = MFD_ERROR;
	}

    return rc;
} /* wtpWapiUnicastRekeyMethod_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wtpWapiUnicastRekeyMethod_undo( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastRekeyMethod_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wtpWapiUnicastRekeyMethod undo.
     */
    /*
     * copy wtpWapiUnicastRekeyMethod data
     * set rowreq_ctx->data.wtpWapiUnicastRekeyMethod from rowreq_ctx->undo->wtpWapiUnicastRekeyMethod
     */
    rowreq_ctx->data.wtpWapiUnicastRekeyMethod = rowreq_ctx->undo->wtpWapiUnicastRekeyMethod;

    
    return MFD_SUCCESS;
} /* wtpWapiUnicastRekeyMethod_undo */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiUnicastRekeyTime
 * wtpWapiUnicastRekeyTime is subid 11 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.11
 * Description:
wtpWapiUnicastRekeyTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiUnicastRekeyTime_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11WtpWAPIConfigTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wtpWapiUnicastRekeyTime_check_value( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long wtpWapiUnicastRekeyTime_val)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastRekeyTime_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wtpWapiUnicastRekeyTime value.
     */

    return MFD_SUCCESS; /* wtpWapiUnicastRekeyTime value not illegal */
} /* wtpWapiUnicastRekeyTime_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11WtpWAPIConfigTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11WtpWAPIConfigTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wtpWapiUnicastRekeyTime_undo_setup( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastRekeyTime_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wtpWapiUnicastRekeyTime undo.
     */
    /*
     * copy wtpWapiUnicastRekeyTime data
     * set rowreq_ctx->undo->wtpWapiUnicastRekeyTime from rowreq_ctx->data.wtpWapiUnicastRekeyTime
     */
    rowreq_ctx->undo->wtpWapiUnicastRekeyTime = rowreq_ctx->data.wtpWapiUnicastRekeyTime;


    return MFD_SUCCESS;
} /* wtpWapiUnicastRekeyTime_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wtpWapiUnicastRekeyTime_val
 *        A u_long containing the new value.
 */
int
wtpWapiUnicastRekeyTime_set( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long wtpWapiUnicastRekeyTime_val )
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastRekeyTime_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:245:o: |-> Implement wtpWapiUnicastRekeyTime reverse mapping.
 * If the values for your data type don't exactly match the
 * possible values defined by the mib, you should map them here.
 */
    /*
     * TODO:461:M: |-> Set wtpWapiUnicastRekeyTime value.
     * set wtpWapiUnicastRekeyTime value in rowreq_ctx->data
     */
    void *connection = NULL;
    if(SNMPD_DBUS_ERROR == get_instance_dbus_connection(rowreq_ctx->data.parameter, &connection, SNMPD_INSTANCE_MASTER_V3))
        return MFD_ERROR;
        
	int ret = 2;
	char input[DEFAULT_LEN] = { 0 };
	int ret_one = 2;
	int ret_two = 2;
	int ret_three = 2;									 
	int value = 0;
	int rc = MFD_ERROR;
	ret = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"disable");
	if(ret == 1)
	{
		value = wtpWapiUnicastRekeyTime_val;	
		
        memset(input, 0, sizeof(input));
		snprintf(input, sizeof(input) - 1, "%d", value);
		ret_one = set_wapi_rekey_para_cmd_func(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,"unicast","time",input);
		if(ret_one == 1)
		{						 
			ret_two = apply_wlanID(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,rowreq_ctx->data.localWlanID);
			if (ret_two == 1)
			{
				ret_three = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"enable");
				if (ret_three == 1)
				{
					rowreq_ctx->data.wtpWapiUnicastRekeyTime = wtpWapiUnicastRekeyTime_val;
					rc = MFD_SUCCESS;
				}
				else
				{
				    if(SNMPD_CONNECTION_ERROR == ret_three) {
                        close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
            	    }
					rc = MFD_ERROR;
				}
			}	
			else
			{
			    if(SNMPD_CONNECTION_ERROR == ret_two) {
                    close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
        	    }
				rc = MFD_ERROR;
			}								 	     
		}
		else 
		{
		    if(SNMPD_CONNECTION_ERROR == ret_one) {
                close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
    	    }
			rc = MFD_ERROR;
		}
	}
	else 
	{
	    if(SNMPD_CONNECTION_ERROR == ret) {
            close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
	    }
		rc = MFD_ERROR;
	}
	
    return rc;
} /* wtpWapiUnicastRekeyTime_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wtpWapiUnicastRekeyTime_undo( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastRekeyTime_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wtpWapiUnicastRekeyTime undo.
     */
    /*
     * copy wtpWapiUnicastRekeyTime data
     * set rowreq_ctx->data.wtpWapiUnicastRekeyTime from rowreq_ctx->undo->wtpWapiUnicastRekeyTime
     */
    rowreq_ctx->data.wtpWapiUnicastRekeyTime = rowreq_ctx->undo->wtpWapiUnicastRekeyTime;

    
    return MFD_SUCCESS;
} /* wtpWapiUnicastRekeyTime_undo */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiUnicastRekeyPackets
 * wtpWapiUnicastRekeyPackets is subid 12 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.12
 * Description:
wtpWapiUnicastRekeyPackets.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiUnicastRekeyPackets_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11WtpWAPIConfigTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wtpWapiUnicastRekeyPackets_check_value( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long wtpWapiUnicastRekeyPackets_val)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastRekeyPackets_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wtpWapiUnicastRekeyPackets value.
     */

    return MFD_SUCCESS; /* wtpWapiUnicastRekeyPackets value not illegal */
} /* wtpWapiUnicastRekeyPackets_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11WtpWAPIConfigTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11WtpWAPIConfigTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wtpWapiUnicastRekeyPackets_undo_setup( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastRekeyPackets_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wtpWapiUnicastRekeyPackets undo.
     */
    /*
     * copy wtpWapiUnicastRekeyPackets data
     * set rowreq_ctx->undo->wtpWapiUnicastRekeyPackets from rowreq_ctx->data.wtpWapiUnicastRekeyPackets
     */
    rowreq_ctx->undo->wtpWapiUnicastRekeyPackets = rowreq_ctx->data.wtpWapiUnicastRekeyPackets;


    return MFD_SUCCESS;
} /* wtpWapiUnicastRekeyPackets_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wtpWapiUnicastRekeyPackets_val
 *        A u_long containing the new value.
 */
int
wtpWapiUnicastRekeyPackets_set( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long wtpWapiUnicastRekeyPackets_val )
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastRekeyPackets_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:245:o: |-> Implement wtpWapiUnicastRekeyPackets reverse mapping.
 * If the values for your data type don't exactly match the
 * possible values defined by the mib, you should map them here.
 */
    /*
     * TODO:461:M: |-> Set wtpWapiUnicastRekeyPackets value.
     * set wtpWapiUnicastRekeyPackets value in rowreq_ctx->data
     */
     
    void *connection = NULL;
    if(SNMPD_DBUS_ERROR == get_instance_dbus_connection(rowreq_ctx->data.parameter, &connection, SNMPD_INSTANCE_MASTER_V3))
        return MFD_ERROR;
        
    char id[10] = { 0 };
	snprintf(id, sizeof(id) - 1, "%d", rowreq_ctx->data.localWlanID);
	int ret = 0;
	int rc = MFD_ERROR;
	struct dcli_security *sec;

	ret = show_wlanid_security_wapi_config_cmd(rowreq_ctx->data.parameter, connection,id,&sec);
	if(ret == 1)
    {
		rowreq_ctx->data.wtpWapiUnicastRekeyPackets = sec->wapi_ucast_rekey_para_t;
		rc = MFD_SUCCESS;
	}
	else
	{
	    if(SNMPD_CONNECTION_ERROR == ret) {
            close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
	    }
		rc = MFD_ERROR;
	}
	Free_wlanid_security_wapi_info(sec);
	
    return rc;
} /* wtpWapiUnicastRekeyPackets_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wtpWapiUnicastRekeyPackets_undo( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastRekeyPackets_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wtpWapiUnicastRekeyPackets undo.
     */
    /*
     * copy wtpWapiUnicastRekeyPackets data
     * set rowreq_ctx->data.wtpWapiUnicastRekeyPackets from rowreq_ctx->undo->wtpWapiUnicastRekeyPackets
     */
    rowreq_ctx->data.wtpWapiUnicastRekeyPackets = rowreq_ctx->undo->wtpWapiUnicastRekeyPackets;

    
    return MFD_SUCCESS;
} /* wtpWapiUnicastRekeyPackets_undo */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiMulticastCipher
 * wtpWapiMulticastCipher is subid 13 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.13
 * Description:
wtpWapiMulticastCipher.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiMulticastCipher_val_ptr
 *        A char containing the new value.
 * @param wtpWapiMulticastCipher_val_ptr_len
 *        The size (in bytes) of the data pointed to by wtpWapiMulticastCipher_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11WtpWAPIConfigTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wtpWapiMulticastCipher_check_value( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, char *wtpWapiMulticastCipher_val_ptr,  size_t wtpWapiMulticastCipher_val_ptr_len)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastCipher_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != wtpWapiMulticastCipher_val_ptr);

    /*
     * TODO:441:o: |-> Check for valid wtpWapiMulticastCipher value.
     */

    return MFD_SUCCESS; /* wtpWapiMulticastCipher value not illegal */
} /* wtpWapiMulticastCipher_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11WtpWAPIConfigTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11WtpWAPIConfigTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wtpWapiMulticastCipher_undo_setup( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastCipher_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wtpWapiMulticastCipher undo.
     */
    /*
     * copy wtpWapiMulticastCipher and wtpWapiMulticastCipher_len data
     * set rowreq_ctx->undo->wtpWapiMulticastCipher from rowreq_ctx->data.wtpWapiMulticastCipher
     */
    memcpy( rowreq_ctx->undo->wtpWapiMulticastCipher, rowreq_ctx->data.wtpWapiMulticastCipher,
            (rowreq_ctx->data.wtpWapiMulticastCipher_len * sizeof(rowreq_ctx->undo->wtpWapiMulticastCipher[0])));
    rowreq_ctx->undo->wtpWapiMulticastCipher_len = rowreq_ctx->data.wtpWapiMulticastCipher_len;


    return MFD_SUCCESS;
} /* wtpWapiMulticastCipher_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wtpWapiMulticastCipher_val_ptr
 *        A char containing the new value.
 * @param wtpWapiMulticastCipher_val_ptr_len
 *        The size (in bytes) of the data pointed to by wtpWapiMulticastCipher_val_ptr
 */
int
wtpWapiMulticastCipher_set( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, char *wtpWapiMulticastCipher_val_ptr,  size_t wtpWapiMulticastCipher_val_ptr_len )
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastCipher_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != wtpWapiMulticastCipher_val_ptr);

/*
 * TODO:245:o: |-> Implement wtpWapiMulticastCipher reverse mapping.
 * If the values for your data type don't exactly match the
 * possible values defined by the mib, you should map them here.
 */
    /*
     * TODO:461:M: |-> Set wtpWapiMulticastCipher value.
     * set wtpWapiMulticastCipher value in rowreq_ctx->data
     */
    void *connection = NULL;
    if(SNMPD_DBUS_ERROR == get_instance_dbus_connection(rowreq_ctx->data.parameter, &connection, SNMPD_INSTANCE_MASTER_V3))
        return MFD_ERROR;
        
	int ret = 2;
	int rc = MFD_ERROR;
	char input[DEFAULT_LEN] = { 0 };
	int ret_one = 2;
	int ret_two = 2;
	int ret_three = 2;	
	
	memset(input, 0, sizeof(input));
	strncpy(input,wtpWapiMulticastCipher_val_ptr,wtpWapiMulticastCipher_val_ptr_len);
	ret = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"disable");
	if(ret == 1)
	{					
		ret_one = set_wapi_sub_attr_multicast_cipher_cmd(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,input);
		if(ret_one == 1)
		{						 
			ret_two = apply_wlanID(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,rowreq_ctx->data.localWlanID);
			if (ret_two == 1)
			{
				ret_three = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"enable");
				if (ret_three == 1)
				{
				    memcpy( rowreq_ctx->data.wtpWapiMulticastCipher, wtpWapiMulticastCipher_val_ptr, wtpWapiMulticastCipher_val_ptr_len );
				    rowreq_ctx->data.wtpWapiMulticastCipher_len = wtpWapiMulticastCipher_val_ptr_len / sizeof(wtpWapiMulticastCipher_val_ptr[0]);
					rc = MFD_SUCCESS;
				}		
				else
				{
            	    if(SNMPD_CONNECTION_ERROR == ret_three) {
                        close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
            	    }
					rc = MFD_ERROR;
				}								 	     
			}
			else 
			{
                if(SNMPD_CONNECTION_ERROR == ret_two) {
                    close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
                }
                rc = MFD_ERROR; 
			}
		}
		else 
		{
		    if(SNMPD_CONNECTION_ERROR == ret_one) {
                close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
            }
			rc = MFD_ERROR;
		}
	}
	else 
	{
	    if(SNMPD_CONNECTION_ERROR == ret) {
            close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
	    }
		rc = MFD_ERROR;
	}
	
    return rc;
} /* wtpWapiMulticastCipher_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wtpWapiMulticastCipher_undo( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastCipher_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wtpWapiMulticastCipher undo.
     */
    /*
     * copy wtpWapiMulticastCipher and wtpWapiMulticastCipher_len data
     * set rowreq_ctx->data.wtpWapiMulticastCipher from rowreq_ctx->undo->wtpWapiMulticastCipher
     */
    memcpy( rowreq_ctx->data.wtpWapiMulticastCipher, rowreq_ctx->undo->wtpWapiMulticastCipher,
            (rowreq_ctx->undo->wtpWapiMulticastCipher_len * sizeof(rowreq_ctx->data.wtpWapiMulticastCipher[0])));
    rowreq_ctx->data.wtpWapiMulticastCipher_len = rowreq_ctx->undo->wtpWapiMulticastCipher_len;

    
    return MFD_SUCCESS;
} /* wtpWapiMulticastCipher_undo */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiMulticastRekeyMethod
 * wtpWapiMulticastRekeyMethod is subid 14 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.14
 * Description:
wtpWapiMulticastRekeyMethod.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiMulticastRekeyMethod_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11WtpWAPIConfigTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wtpWapiMulticastRekeyMethod_check_value( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, long wtpWapiMulticastRekeyMethod_val)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastRekeyMethod_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wtpWapiMulticastRekeyMethod value.
     */

    return MFD_SUCCESS; /* wtpWapiMulticastRekeyMethod value not illegal */
} /* wtpWapiMulticastRekeyMethod_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11WtpWAPIConfigTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11WtpWAPIConfigTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wtpWapiMulticastRekeyMethod_undo_setup( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastRekeyMethod_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wtpWapiMulticastRekeyMethod undo.
     */
    /*
     * copy wtpWapiMulticastRekeyMethod data
     * set rowreq_ctx->undo->wtpWapiMulticastRekeyMethod from rowreq_ctx->data.wtpWapiMulticastRekeyMethod
     */
    rowreq_ctx->undo->wtpWapiMulticastRekeyMethod = rowreq_ctx->data.wtpWapiMulticastRekeyMethod;


    return MFD_SUCCESS;
} /* wtpWapiMulticastRekeyMethod_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wtpWapiMulticastRekeyMethod_val
 *        A long containing the new value.
 */
int
wtpWapiMulticastRekeyMethod_set( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, long wtpWapiMulticastRekeyMethod_val )
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastRekeyMethod_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:245:o: |-> Implement wtpWapiMulticastRekeyMethod reverse mapping.
 * If the values for your data type don't exactly match the
 * possible values defined by the mib, you should map them here.
 */
    /*
     * TODO:461:M: |-> Set wtpWapiMulticastRekeyMethod value.
     * set wtpWapiMulticastRekeyMethod value in rowreq_ctx->data
     */
    void *connection = NULL;
    if(SNMPD_DBUS_ERROR == get_instance_dbus_connection(rowreq_ctx->data.parameter, &connection, SNMPD_INSTANCE_MASTER_V3))
        return MFD_ERROR;
        
	int ret = 2;
	char input[DEFAULT_LEN] = { 0 };
	int ret_one = 2;
	int ret_two = 2;
	int ret_three = 2;									 
	int value = 0;
	int rc  = MFD_ERROR;
	ret = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"disable");
	value = wtpWapiMulticastRekeyMethod_val;

	memset(input,0,DEFAULT_LEN);
	if ( value == 1 )
	{
		strncpy(input,"disable", sizeof(input) - 1);
	}
	else if( value == 2)
	{
		strncpy(input,"time_based", sizeof(input) - 1);
	}
	else if( value == 3)
	{
		strncpy(input,"packet_based", sizeof(input) - 1);
	}
	else if( value ==4 )
	{
		strncpy(input,"both_based", sizeof(input) - 1);
	}
	if(ret == 1)
	{

		ret_one = set_wapi_ucast_rekey_method_cmd_func(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,"multicast",input);
		if(ret_one == 1)
		{						 
			ret_two = apply_wlanID(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,rowreq_ctx->data.localWlanID);
			if (ret_two == 1)
			{
				ret_three = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"enable");
				if (ret_three == 1)
				{
    				rowreq_ctx->data.wtpWapiMulticastRekeyMethod = wtpWapiMulticastRekeyMethod_val;
					rc = MFD_SUCCESS;
				}
				else
				{
				    if(SNMPD_CONNECTION_ERROR == ret_three) {
                        close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
            	    }
					rc  = MFD_ERROR;
				}
			}	
			else
			{
			    if(SNMPD_CONNECTION_ERROR == ret_two) {
                    close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
        	    }
				rc  = MFD_ERROR;
			}								 	     
		}
		else 
		{
		    if(SNMPD_CONNECTION_ERROR == ret_one) {
                close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
    	    }
			rc  = MFD_ERROR;
		}
	}
	else 
	{
	    if(SNMPD_CONNECTION_ERROR == ret) {
            close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
	    }
		rc  = MFD_ERROR;
	}

    return rc;
} /* wtpWapiMulticastRekeyMethod_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wtpWapiMulticastRekeyMethod_undo( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastRekeyMethod_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wtpWapiMulticastRekeyMethod undo.
     */
    /*
     * copy wtpWapiMulticastRekeyMethod data
     * set rowreq_ctx->data.wtpWapiMulticastRekeyMethod from rowreq_ctx->undo->wtpWapiMulticastRekeyMethod
     */
    rowreq_ctx->data.wtpWapiMulticastRekeyMethod = rowreq_ctx->undo->wtpWapiMulticastRekeyMethod;

    
    return MFD_SUCCESS;
} /* wtpWapiMulticastRekeyMethod_undo */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiMulticastRekeyTime
 * wtpWapiMulticastRekeyTime is subid 15 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.15
 * Description:
wtpWapiMulticastRekeyTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiMulticastRekeyTime_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11WtpWAPIConfigTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wtpWapiMulticastRekeyTime_check_value( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long wtpWapiMulticastRekeyTime_val)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastRekeyTime_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wtpWapiMulticastRekeyTime value.
     */

    return MFD_SUCCESS; /* wtpWapiMulticastRekeyTime value not illegal */
} /* wtpWapiMulticastRekeyTime_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11WtpWAPIConfigTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11WtpWAPIConfigTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wtpWapiMulticastRekeyTime_undo_setup( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastRekeyTime_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wtpWapiMulticastRekeyTime undo.
     */
    /*
     * copy wtpWapiMulticastRekeyTime data
     * set rowreq_ctx->undo->wtpWapiMulticastRekeyTime from rowreq_ctx->data.wtpWapiMulticastRekeyTime
     */
    rowreq_ctx->undo->wtpWapiMulticastRekeyTime = rowreq_ctx->data.wtpWapiMulticastRekeyTime;


    return MFD_SUCCESS;
} /* wtpWapiMulticastRekeyTime_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wtpWapiMulticastRekeyTime_val
 *        A u_long containing the new value.
 */
int
wtpWapiMulticastRekeyTime_set( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long wtpWapiMulticastRekeyTime_val )
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastRekeyTime_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:245:o: |-> Implement wtpWapiMulticastRekeyTime reverse mapping.
 * If the values for your data type don't exactly match the
 * possible values defined by the mib, you should map them here.
 */
    /*
     * TODO:461:M: |-> Set wtpWapiMulticastRekeyTime value.
     * set wtpWapiMulticastRekeyTime value in rowreq_ctx->data
     */
    void *connection = NULL;
    if(SNMPD_DBUS_ERROR == get_instance_dbus_connection(rowreq_ctx->data.parameter, &connection, SNMPD_INSTANCE_MASTER_V3))
        return MFD_ERROR;
        
	int ret = 2;
	char input[DEFAULT_LEN] = { 0 };
	int ret_one = 2;
	int ret_two = 2;
	int ret_three = 2;									 
	int value = 0;
	int rc = MFD_ERROR;
	ret = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"disable");
	if(ret == 1)
	{
		value = wtpWapiMulticastRekeyTime_val;
		
        memset(input, 0, sizeof(input));
		snprintf(input, sizeof(input) - 1, "%d", value);
		ret_one = set_wapi_rekey_para_cmd_func(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,"multicast","time",input);
		if(ret_one == 1)
		{						 
			ret_two = apply_wlanID(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,rowreq_ctx->data.localWlanID);
			if (ret_two == 1)
			{
				ret_three = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"enable");
				if (ret_three == 1)
				{
    				rowreq_ctx->data.wtpWapiMulticastRekeyTime = wtpWapiMulticastRekeyTime_val;
					rc = MFD_SUCCESS;
				}
				else
				{
				    if(SNMPD_CONNECTION_ERROR == ret_three) {
                        close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
            	    }
					rc = MFD_ERROR;
				}
			}	
			else
			{
			    if(SNMPD_CONNECTION_ERROR == ret_two) {
                    close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
        	    }
				rc = MFD_ERROR;
			}								 	     
		}
		else 
		{
		    if(SNMPD_CONNECTION_ERROR == ret_one) {
                close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
    	    }
			rc = MFD_ERROR;
		}
	}
	else 
	{
	    if(SNMPD_CONNECTION_ERROR == ret) {
            close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
	    }
		rc = MFD_ERROR;
	}

    return rc;
} /* wtpWapiMulticastRekeyTime_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wtpWapiMulticastRekeyTime_undo( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastRekeyTime_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wtpWapiMulticastRekeyTime undo.
     */
    /*
     * copy wtpWapiMulticastRekeyTime data
     * set rowreq_ctx->data.wtpWapiMulticastRekeyTime from rowreq_ctx->undo->wtpWapiMulticastRekeyTime
     */
    rowreq_ctx->data.wtpWapiMulticastRekeyTime = rowreq_ctx->undo->wtpWapiMulticastRekeyTime;

    
    return MFD_SUCCESS;
} /* wtpWapiMulticastRekeyTime_undo */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiMulticastRekeyPackets
 * wtpWapiMulticastRekeyPackets is subid 16 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.16
 * Description:
wtpWapiMulticastRekeyPackets.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiMulticastRekeyPackets_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11WtpWAPIConfigTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wtpWapiMulticastRekeyPackets_check_value( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long wtpWapiMulticastRekeyPackets_val)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastRekeyPackets_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wtpWapiMulticastRekeyPackets value.
     */

    return MFD_SUCCESS; /* wtpWapiMulticastRekeyPackets value not illegal */
} /* wtpWapiMulticastRekeyPackets_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11WtpWAPIConfigTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11WtpWAPIConfigTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wtpWapiMulticastRekeyPackets_undo_setup( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastRekeyPackets_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wtpWapiMulticastRekeyPackets undo.
     */
    /*
     * copy wtpWapiMulticastRekeyPackets data
     * set rowreq_ctx->undo->wtpWapiMulticastRekeyPackets from rowreq_ctx->data.wtpWapiMulticastRekeyPackets
     */
    rowreq_ctx->undo->wtpWapiMulticastRekeyPackets = rowreq_ctx->data.wtpWapiMulticastRekeyPackets;


    return MFD_SUCCESS;
} /* wtpWapiMulticastRekeyPackets_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wtpWapiMulticastRekeyPackets_val
 *        A u_long containing the new value.
 */
int
wtpWapiMulticastRekeyPackets_set( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long wtpWapiMulticastRekeyPackets_val )
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastRekeyPackets_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:245:o: |-> Implement wtpWapiMulticastRekeyPackets reverse mapping.
 * If the values for your data type don't exactly match the
 * possible values defined by the mib, you should map them here.
 */
    /*
     * TODO:461:M: |-> Set wtpWapiMulticastRekeyPackets value.
     * set wtpWapiMulticastRekeyPackets value in rowreq_ctx->data
     */
    void *connection = NULL;
    if(SNMPD_DBUS_ERROR == get_instance_dbus_connection(rowreq_ctx->data.parameter, &connection, SNMPD_INSTANCE_MASTER_V3))
        return MFD_ERROR;
        
	int ret = 2;
	char input[DEFAULT_LEN] = { 0 };
	int ret_one = 2;
	int ret_two = 2;
	int ret_three = 2;	
	int ret_four = 2;
	int value = 0;
	int rc = MFD_ERROR;
	ret = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"disable");
	if(ret == 1)
	{  
		ret_four = set_wapi_ucast_rekey_method_cmd_func(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,"multicast","both_based");
		value = wtpWapiMulticastRekeyPackets_val;
		
        memset(input, 0, sizeof(input));
		snprintf(input, sizeof(input) - 1, "%d", value);
		ret_one = set_wapi_rekey_para_cmd_func(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,"multicast","packet",input);
		if((ret_one == 1)&&(ret_four == 1))
		{						 
			ret_two = apply_wlanID(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,rowreq_ctx->data.localWlanID);
			if (ret_two == 1)
			{
				ret_three = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"enable");
				if (ret_three == 1)
				{
   					 rowreq_ctx->data.wtpWapiMulticastRekeyPackets = wtpWapiMulticastRekeyPackets_val;
					 rc = MFD_SUCCESS;
				}
				else
				{
				    if(SNMPD_CONNECTION_ERROR == ret_three) {
                        close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
            	    }
					rc = MFD_ERROR;
				}
			}	
			else
			{
			    if(SNMPD_CONNECTION_ERROR == ret_two) {
                    close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
        	    }
				rc = MFD_ERROR;
			}								 	     
		}
		else 
		{
		    if(SNMPD_CONNECTION_ERROR == ret_four || SNMPD_CONNECTION_ERROR == ret_one) {
                close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
    	    }
			rc = MFD_ERROR;
		}
	}
	else 
	{
	    if(SNMPD_CONNECTION_ERROR == ret) {
            close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
	    }
		rc = MFD_ERROR;
	}

    return rc;
} /* wtpWapiMulticastRekeyPackets_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wtpWapiMulticastRekeyPackets_undo( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastRekeyPackets_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wtpWapiMulticastRekeyPackets undo.
     */
    /*
     * copy wtpWapiMulticastRekeyPackets data
     * set rowreq_ctx->data.wtpWapiMulticastRekeyPackets from rowreq_ctx->undo->wtpWapiMulticastRekeyPackets
     */
    rowreq_ctx->data.wtpWapiMulticastRekeyPackets = rowreq_ctx->undo->wtpWapiMulticastRekeyPackets;

    
    return MFD_SUCCESS;
} /* wtpWapiMulticastRekeyPackets_undo */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiMulticastRekeyStrict
 * wtpWapiMulticastRekeyStrict is subid 17 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.17
 * Description:
wtpWapiMulticastRekeyStrict.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiMulticastRekeyStrict_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11WtpWAPIConfigTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wtpWapiMulticastRekeyStrict_check_value( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long wtpWapiMulticastRekeyStrict_val)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastRekeyStrict_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wtpWapiMulticastRekeyStrict value.
     */

    return MFD_SUCCESS; /* wtpWapiMulticastRekeyStrict value not illegal */
} /* wtpWapiMulticastRekeyStrict_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11WtpWAPIConfigTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11WtpWAPIConfigTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wtpWapiMulticastRekeyStrict_undo_setup( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastRekeyStrict_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wtpWapiMulticastRekeyStrict undo.
     */
    /*
     * copy wtpWapiMulticastRekeyStrict data
     * set rowreq_ctx->undo->wtpWapiMulticastRekeyStrict from rowreq_ctx->data.wtpWapiMulticastRekeyStrict
     */
    rowreq_ctx->undo->wtpWapiMulticastRekeyStrict = rowreq_ctx->data.wtpWapiMulticastRekeyStrict;


    return MFD_SUCCESS;
} /* wtpWapiMulticastRekeyStrict_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wtpWapiMulticastRekeyStrict_val
 *        A long containing the new value.
 */
int
wtpWapiMulticastRekeyStrict_set( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long wtpWapiMulticastRekeyStrict_val )
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastRekeyStrict_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:245:o: |-> Implement wtpWapiMulticastRekeyStrict reverse mapping.
 * If the values for your data type don't exactly match the
 * possible values defined by the mib, you should map them here.
 */
    /*
    ***************************************************
    ***             START EXAMPLE CODE              ***
    ***---------------------------------------------***/
    switch(wtpWapiMulticastRekeyStrict_val) {
        case TRUTHVALUE_TRUE:
             wtpWapiMulticastRekeyStrict_val = INTERNAL_WTPWAPIMULTICASTREKEYSTRICT_TRUE;
             break;

        case TRUTHVALUE_FALSE:
             wtpWapiMulticastRekeyStrict_val = INTERNAL_WTPWAPIMULTICASTREKEYSTRICT_FALSE;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't reverse map value %ld for wtpWapiMulticastRekeyStrict\n", wtpWapiMulticastRekeyStrict_val );
                 return SNMP_ERR_GENERR;
    }
    /*
    ***---------------------------------------------***
    ***              END  EXAMPLE CODE              ***
    ***************************************************/

    /*
     * TODO:461:M: |-> Set wtpWapiMulticastRekeyStrict value.
     * set wtpWapiMulticastRekeyStrict value in rowreq_ctx->data
     */
    void *connection = NULL;
    if(SNMPD_DBUS_ERROR == get_instance_dbus_connection(rowreq_ctx->data.parameter, &connection, SNMPD_INSTANCE_MASTER_V3))
        return MFD_ERROR;
        
	int ret = 2;
	char input[DEFAULT_LEN] = { 0 };
	int ret_one = 2;
	int ret_two = 2;
	int ret_three = 2;									 
	int value = 0;
	int rc = MFD_ERROR;
	ret = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"disable");
	if(ret == 1)
	{
		value = wtpWapiMulticastRekeyStrict_val;
		
        memset(input, 0, sizeof(input));
		if ( value == 1 )
		{
			strncpy(input, "enable", sizeof(input) - 1);
		}
		else if( value == 2)
		{
			strncpy(input, "disable", sizeof(input) - 1);
		}
		ret_one = set_wapi_sub_attr_multicaserekeystrict_cmd(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,input);
		if(ret_one == 1)
		{						 
			ret_two = apply_wlanID(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,rowreq_ctx->data.localWlanID);
			if (ret_two == 1)
			{
				ret_three = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"enable");
				if (ret_three == 1)
				{
    				rowreq_ctx->data.wtpWapiMulticastRekeyStrict = wtpWapiMulticastRekeyStrict_val;
					rc = MFD_SUCCESS;
				}
				else
				{
				    if(SNMPD_CONNECTION_ERROR == ret_three) {
                        close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
            	    }
					rc = MFD_ERROR;
				}
			}	
			else
			{
			    if(SNMPD_CONNECTION_ERROR == ret_two) {
                    close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
        	    }
				rc = MFD_ERROR;
			}								 	     
		}
		else 
		{
		    if(SNMPD_CONNECTION_ERROR == ret_one) {
                close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
    	    }
			rc = MFD_ERROR;
		}
	}
	else 
	{
	    if(SNMPD_CONNECTION_ERROR == ret) {
            close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
	    }
		rc = MFD_ERROR;
	}

    return rc;
} /* wtpWapiMulticastRekeyStrict_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wtpWapiMulticastRekeyStrict_undo( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastRekeyStrict_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wtpWapiMulticastRekeyStrict undo.
     */
    /*
     * copy wtpWapiMulticastRekeyStrict data
     * set rowreq_ctx->data.wtpWapiMulticastRekeyStrict from rowreq_ctx->undo->wtpWapiMulticastRekeyStrict
     */
    rowreq_ctx->data.wtpWapiMulticastRekeyStrict = rowreq_ctx->undo->wtpWapiMulticastRekeyStrict;

    
    return MFD_SUCCESS;
} /* wtpWapiMulticastRekeyStrict_undo */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiPSKValue
 * wtpWapiPSKValue is subid 18 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.18
 * Description:
wtpWapiPSKValue.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiPSKValue_val_ptr
 *        A char containing the new value.
 * @param wtpWapiPSKValue_val_ptr_len
 *        The size (in bytes) of the data pointed to by wtpWapiPSKValue_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11WtpWAPIConfigTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wtpWapiPSKValue_check_value( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, char *wtpWapiPSKValue_val_ptr,  size_t wtpWapiPSKValue_val_ptr_len)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiPSKValue_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != wtpWapiPSKValue_val_ptr);

    /*
     * TODO:441:o: |-> Check for valid wtpWapiPSKValue value.
     */

    return MFD_SUCCESS; /* wtpWapiPSKValue value not illegal */
} /* wtpWapiPSKValue_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11WtpWAPIConfigTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11WtpWAPIConfigTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wtpWapiPSKValue_undo_setup( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiPSKValue_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wtpWapiPSKValue undo.
     */
    /*
     * copy wtpWapiPSKValue and wtpWapiPSKValue_len data
     * set rowreq_ctx->undo->wtpWapiPSKValue from rowreq_ctx->data.wtpWapiPSKValue
     */
    memcpy( rowreq_ctx->undo->wtpWapiPSKValue, rowreq_ctx->data.wtpWapiPSKValue,
            (rowreq_ctx->data.wtpWapiPSKValue_len * sizeof(rowreq_ctx->undo->wtpWapiPSKValue[0])));
    rowreq_ctx->undo->wtpWapiPSKValue_len = rowreq_ctx->data.wtpWapiPSKValue_len;


    return MFD_SUCCESS;
} /* wtpWapiPSKValue_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wtpWapiPSKValue_val_ptr
 *        A char containing the new value.
 * @param wtpWapiPSKValue_val_ptr_len
 *        The size (in bytes) of the data pointed to by wtpWapiPSKValue_val_ptr
 */
int
wtpWapiPSKValue_set( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, char *wtpWapiPSKValue_val_ptr,  size_t wtpWapiPSKValue_val_ptr_len )
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiPSKValue_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != wtpWapiPSKValue_val_ptr);

/*
 * TODO:245:o: |-> Implement wtpWapiPSKValue reverse mapping.
 * If the values for your data type don't exactly match the
 * possible values defined by the mib, you should map them here.
 */
    /*
     * TODO:461:M: |-> Set wtpWapiPSKValue value.
     * set wtpWapiPSKValue value in rowreq_ctx->data
     */
    void *connection = NULL;
    if(SNMPD_DBUS_ERROR == get_instance_dbus_connection(rowreq_ctx->data.parameter, &connection, SNMPD_INSTANCE_MASTER_V3))
        return MFD_ERROR;
        
	int value = -1;
	int ret = 2;
	int rc = MFD_ERROR;
	int ret_two = 2;
	char input_string[256] = { 0 };
	strncpy(input_string,wtpWapiPSKValue_val_ptr, MIN(wtpWapiPSKValue_val_ptr_len, sizeof(input_string) - 1 ));
	ret = security_key(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,input_string,"HEX");
	if(ret == 1)
	{
		ret_two = apply_wlanID(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,rowreq_ctx->data.SecurityID);
		if (ret_two == 1)
		{
		    memcpy( rowreq_ctx->data.wtpWapiPSKValue, wtpWapiPSKValue_val_ptr, wtpWapiPSKValue_val_ptr_len );
		    rowreq_ctx->data.wtpWapiPSKValue_len = wtpWapiPSKValue_val_ptr_len / sizeof(wtpWapiPSKValue_val_ptr[0]);
			rc = MFD_SUCCESS;
		}	
		else
		{
		    if(SNMPD_CONNECTION_ERROR == ret_two) {
                close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
    	    }
			rc = MFD_ERROR;
		}
	}			      
	else
	{   
	    if(SNMPD_CONNECTION_ERROR == ret) {
            close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
	    }
		rc = MFD_ERROR;
	}

    return rc;
} /* wtpWapiPSKValue_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wtpWapiPSKValue_undo( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiPSKValue_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wtpWapiPSKValue undo.
     */
    /*
     * copy wtpWapiPSKValue and wtpWapiPSKValue_len data
     * set rowreq_ctx->data.wtpWapiPSKValue from rowreq_ctx->undo->wtpWapiPSKValue
     */
    memcpy( rowreq_ctx->data.wtpWapiPSKValue, rowreq_ctx->undo->wtpWapiPSKValue,
            (rowreq_ctx->undo->wtpWapiPSKValue_len * sizeof(rowreq_ctx->data.wtpWapiPSKValue[0])));
    rowreq_ctx->data.wtpWapiPSKValue_len = rowreq_ctx->undo->wtpWapiPSKValue_len;

    
    return MFD_SUCCESS;
} /* wtpWapiPSKValue_undo */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiPSKPassPhrase
 * wtpWapiPSKPassPhrase is subid 19 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.19
 * Description:
wtpWapiPSKPassPhrase.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiPSKPassPhrase_val_ptr
 *        A char containing the new value.
 * @param wtpWapiPSKPassPhrase_val_ptr_len
 *        The size (in bytes) of the data pointed to by wtpWapiPSKPassPhrase_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11WtpWAPIConfigTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wtpWapiPSKPassPhrase_check_value( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, char *wtpWapiPSKPassPhrase_val_ptr,  size_t wtpWapiPSKPassPhrase_val_ptr_len)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiPSKPassPhrase_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != wtpWapiPSKPassPhrase_val_ptr);

    /*
     * TODO:441:o: |-> Check for valid wtpWapiPSKPassPhrase value.
     */

    return MFD_SUCCESS; /* wtpWapiPSKPassPhrase value not illegal */
} /* wtpWapiPSKPassPhrase_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11WtpWAPIConfigTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11WtpWAPIConfigTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wtpWapiPSKPassPhrase_undo_setup( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiPSKPassPhrase_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wtpWapiPSKPassPhrase undo.
     */
    /*
     * copy wtpWapiPSKPassPhrase and wtpWapiPSKPassPhrase_len data
     * set rowreq_ctx->undo->wtpWapiPSKPassPhrase from rowreq_ctx->data.wtpWapiPSKPassPhrase
     */
    memcpy( rowreq_ctx->undo->wtpWapiPSKPassPhrase, rowreq_ctx->data.wtpWapiPSKPassPhrase,
            (rowreq_ctx->data.wtpWapiPSKPassPhrase_len * sizeof(rowreq_ctx->undo->wtpWapiPSKPassPhrase[0])));
    rowreq_ctx->undo->wtpWapiPSKPassPhrase_len = rowreq_ctx->data.wtpWapiPSKPassPhrase_len;


    return MFD_SUCCESS;
} /* wtpWapiPSKPassPhrase_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wtpWapiPSKPassPhrase_val_ptr
 *        A char containing the new value.
 * @param wtpWapiPSKPassPhrase_val_ptr_len
 *        The size (in bytes) of the data pointed to by wtpWapiPSKPassPhrase_val_ptr
 */
int
wtpWapiPSKPassPhrase_set( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, char *wtpWapiPSKPassPhrase_val_ptr,  size_t wtpWapiPSKPassPhrase_val_ptr_len )
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiPSKPassPhrase_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != wtpWapiPSKPassPhrase_val_ptr);

/*
 * TODO:245:o: |-> Implement wtpWapiPSKPassPhrase reverse mapping.
 * If the values for your data type don't exactly match the
 * possible values defined by the mib, you should map them here.
 */
    /*
     * TODO:461:M: |-> Set wtpWapiPSKPassPhrase value.
     * set wtpWapiPSKPassPhrase value in rowreq_ctx->data
     */
    void *connection = NULL;
    if(SNMPD_DBUS_ERROR == get_instance_dbus_connection(rowreq_ctx->data.parameter, &connection, SNMPD_INSTANCE_MASTER_V3))
        return MFD_ERROR;
        
	int value = -1;
	int ret = 2;
	int ret_two = 2;
	int rc = MFD_ERROR;
	char input_string[256] = { 0 };
	strncpy(input_string,wtpWapiPSKPassPhrase_val_ptr, MIN(wtpWapiPSKPassPhrase_val_ptr_len, sizeof(input_string) - 1));
	ret = security_key(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,input_string,"ASCII");
	if(ret == 1)
	{
		ret_two = apply_wlanID(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,rowreq_ctx->data.SecurityID);
		if (ret_two == 1)
		{
		    memcpy( rowreq_ctx->data.wtpWapiPSKPassPhrase, wtpWapiPSKPassPhrase_val_ptr, wtpWapiPSKPassPhrase_val_ptr_len );
		    rowreq_ctx->data.wtpWapiPSKPassPhrase_len = wtpWapiPSKPassPhrase_val_ptr_len / sizeof(wtpWapiPSKPassPhrase_val_ptr[0]);
			rc = MFD_SUCCESS;
		}	
		else
		{
		    if(SNMPD_CONNECTION_ERROR == ret_two) {
                close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
    	    }
			rc = MFD_ERROR;
		}
	}			      
	else
	{   
	    if(SNMPD_CONNECTION_ERROR == ret) {
            close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
	    }
		rc = MFD_ERROR;
	}

    return rc;
} /* wtpWapiPSKPassPhrase_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wtpWapiPSKPassPhrase_undo( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiPSKPassPhrase_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wtpWapiPSKPassPhrase undo.
     */
    /*
     * copy wtpWapiPSKPassPhrase and wtpWapiPSKPassPhrase_len data
     * set rowreq_ctx->data.wtpWapiPSKPassPhrase from rowreq_ctx->undo->wtpWapiPSKPassPhrase
     */
    memcpy( rowreq_ctx->data.wtpWapiPSKPassPhrase, rowreq_ctx->undo->wtpWapiPSKPassPhrase,
            (rowreq_ctx->undo->wtpWapiPSKPassPhrase_len * sizeof(rowreq_ctx->data.wtpWapiPSKPassPhrase[0])));
    rowreq_ctx->data.wtpWapiPSKPassPhrase_len = rowreq_ctx->undo->wtpWapiPSKPassPhrase_len;

    
    return MFD_SUCCESS;
} /* wtpWapiPSKPassPhrase_undo */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiCertificateUpdateCount
 * wtpWapiCertificateUpdateCount is subid 20 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.20
 * Description:
wtpWapiCertificateUpdateCount.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiCertificateUpdateCount_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11WtpWAPIConfigTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wtpWapiCertificateUpdateCount_check_value( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long wtpWapiCertificateUpdateCount_val)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiCertificateUpdateCount_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wtpWapiCertificateUpdateCount value.
     */

    return MFD_SUCCESS; /* wtpWapiCertificateUpdateCount value not illegal */
} /* wtpWapiCertificateUpdateCount_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11WtpWAPIConfigTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11WtpWAPIConfigTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wtpWapiCertificateUpdateCount_undo_setup( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiCertificateUpdateCount_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wtpWapiCertificateUpdateCount undo.
     */
    /*
     * copy wtpWapiCertificateUpdateCount data
     * set rowreq_ctx->undo->wtpWapiCertificateUpdateCount from rowreq_ctx->data.wtpWapiCertificateUpdateCount
     */
    rowreq_ctx->undo->wtpWapiCertificateUpdateCount = rowreq_ctx->data.wtpWapiCertificateUpdateCount;


    return MFD_SUCCESS;
} /* wtpWapiCertificateUpdateCount_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wtpWapiCertificateUpdateCount_val
 *        A u_long containing the new value.
 */
int
wtpWapiCertificateUpdateCount_set( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long wtpWapiCertificateUpdateCount_val )
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiCertificateUpdateCount_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:245:o: |-> Implement wtpWapiCertificateUpdateCount reverse mapping.
 * If the values for your data type don't exactly match the
 * possible values defined by the mib, you should map them here.
 */
    /*
     * TODO:461:M: |-> Set wtpWapiCertificateUpdateCount value.
     * set wtpWapiCertificateUpdateCount value in rowreq_ctx->data
     */
    void *connection = NULL;
    if(SNMPD_DBUS_ERROR == get_instance_dbus_connection(rowreq_ctx->data.parameter, &connection, SNMPD_INSTANCE_MASTER_V3))
        return MFD_ERROR;
        
	int ret = 2;
	char input[DEFAULT_LEN] = { 0 };
	int ret_one = 2;
	int ret_two = 2;
	int ret_three = 2;	
	int rc = MFD_ERROR;

	ret = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"disable");
	if(ret == 1)
	{
		memset(input, 0, sizeof(input));
		snprintf(input, sizeof(input) - 1, "%d", wtpWapiCertificateUpdateCount_val);
		ret_one = set_wapi_sub_attr_certificateupdatecount_cmd(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,input);
		if(ret_one == 1)
		{						 
			ret_two = apply_wlanID(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,rowreq_ctx->data.localWlanID);
			if (ret_two == 1)
			{
				ret_three = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"enable");
				if (ret_three == 1)
				{
    				rowreq_ctx->data.wtpWapiCertificateUpdateCount = wtpWapiCertificateUpdateCount_val;
					rc = MFD_SUCCESS;
				}
				else
				{
				    if(SNMPD_CONNECTION_ERROR == ret_three) {
                        close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
            	    }
					rc = MFD_ERROR;
				}
			}	
			else
			{
			    if(SNMPD_CONNECTION_ERROR == ret_two) {
                    close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
        	    }
				rc = MFD_ERROR;
			}								 	     
		}
		else 
		{
		    if(SNMPD_CONNECTION_ERROR == ret_one) {
                close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
    	    }
			rc = MFD_ERROR;
		}
	}
	else 
	{
	    if(SNMPD_CONNECTION_ERROR == ret) {
            close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
	    }
		rc = MFD_ERROR;
	}

    return rc;
} /* wtpWapiCertificateUpdateCount_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wtpWapiCertificateUpdateCount_undo( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiCertificateUpdateCount_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wtpWapiCertificateUpdateCount undo.
     */
    /*
     * copy wtpWapiCertificateUpdateCount data
     * set rowreq_ctx->data.wtpWapiCertificateUpdateCount from rowreq_ctx->undo->wtpWapiCertificateUpdateCount
     */
    rowreq_ctx->data.wtpWapiCertificateUpdateCount = rowreq_ctx->undo->wtpWapiCertificateUpdateCount;

    
    return MFD_SUCCESS;
} /* wtpWapiCertificateUpdateCount_undo */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiMulticastUpdateCount
 * wtpWapiMulticastUpdateCount is subid 21 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.21
 * Description:
wtpWapiMulticastUpdateCount.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiMulticastUpdateCount_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11WtpWAPIConfigTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wtpWapiMulticastUpdateCount_check_value( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long wtpWapiMulticastUpdateCount_val)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastUpdateCount_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wtpWapiMulticastUpdateCount value.
     */

    return MFD_SUCCESS; /* wtpWapiMulticastUpdateCount value not illegal */
} /* wtpWapiMulticastUpdateCount_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11WtpWAPIConfigTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11WtpWAPIConfigTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wtpWapiMulticastUpdateCount_undo_setup( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastUpdateCount_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wtpWapiMulticastUpdateCount undo.
     */
    /*
     * copy wtpWapiMulticastUpdateCount data
     * set rowreq_ctx->undo->wtpWapiMulticastUpdateCount from rowreq_ctx->data.wtpWapiMulticastUpdateCount
     */
    rowreq_ctx->undo->wtpWapiMulticastUpdateCount = rowreq_ctx->data.wtpWapiMulticastUpdateCount;


    return MFD_SUCCESS;
} /* wtpWapiMulticastUpdateCount_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wtpWapiMulticastUpdateCount_val
 *        A u_long containing the new value.
 */
int
wtpWapiMulticastUpdateCount_set( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long wtpWapiMulticastUpdateCount_val )
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastUpdateCount_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:245:o: |-> Implement wtpWapiMulticastUpdateCount reverse mapping.
 * If the values for your data type don't exactly match the
 * possible values defined by the mib, you should map them here.
 */
    /*
     * TODO:461:M: |-> Set wtpWapiMulticastUpdateCount value.
     * set wtpWapiMulticastUpdateCount value in rowreq_ctx->data
     */
    void *connection = NULL;
    if(SNMPD_DBUS_ERROR == get_instance_dbus_connection(rowreq_ctx->data.parameter, &connection, SNMPD_INSTANCE_MASTER_V3))
        return MFD_ERROR;
        
	int ret = 2;
	char input[DEFAULT_LEN] = { 0 };
	int ret_one = 2;
	int ret_two = 2;
	int ret_three = 2;									 
	int rc = MFD_ERROR;
	ret = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"disable");
	if(ret == 1)
	{
		memset(input, 0, sizeof(input));
		snprintf(input, sizeof(input) - 1,"%d", wtpWapiMulticastUpdateCount_val);
		ret_one = set_wapi_sub_attr_multicastupdatecount_cmd(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,input);
		if(ret_one == 1)
		{						 
			ret_two = apply_wlanID(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,rowreq_ctx->data.localWlanID);
			if (ret_two == 1)
			{
				ret_three = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"enable");
				if (ret_three == 1)
				{
    				rowreq_ctx->data.wtpWapiMulticastUpdateCount = wtpWapiMulticastUpdateCount_val;
					rc = MFD_SUCCESS;
				}
				else
				{
				    if(SNMPD_CONNECTION_ERROR == ret_three) {
                        close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
            	    }
					rc = MFD_ERROR;
				}
			}	
			else
			{
			    if(SNMPD_CONNECTION_ERROR == ret_two) {
                    close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
        	    }
				rc = MFD_ERROR;
			}								 	     
		}
		else 
		{
		    if(SNMPD_CONNECTION_ERROR == ret_one) {
                close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
    	    }
			rc = MFD_ERROR;
		}
	}
	else 
	{
	    if(SNMPD_CONNECTION_ERROR == ret) {
            close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
	    }
		rc = MFD_ERROR;
	}

    return rc;
} /* wtpWapiMulticastUpdateCount_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wtpWapiMulticastUpdateCount_undo( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastUpdateCount_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wtpWapiMulticastUpdateCount undo.
     */
    /*
     * copy wtpWapiMulticastUpdateCount data
     * set rowreq_ctx->data.wtpWapiMulticastUpdateCount from rowreq_ctx->undo->wtpWapiMulticastUpdateCount
     */
    rowreq_ctx->data.wtpWapiMulticastUpdateCount = rowreq_ctx->undo->wtpWapiMulticastUpdateCount;

    
    return MFD_SUCCESS;
} /* wtpWapiMulticastUpdateCount_undo */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiUnicastUpdateCount
 * wtpWapiUnicastUpdateCount is subid 22 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.22
 * Description:
wtpWapiUnicastUpdateCount.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiUnicastUpdateCount_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11WtpWAPIConfigTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wtpWapiUnicastUpdateCount_check_value( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long wtpWapiUnicastUpdateCount_val)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastUpdateCount_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wtpWapiUnicastUpdateCount value.
     */

    return MFD_SUCCESS; /* wtpWapiUnicastUpdateCount value not illegal */
} /* wtpWapiUnicastUpdateCount_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11WtpWAPIConfigTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11WtpWAPIConfigTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wtpWapiUnicastUpdateCount_undo_setup( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastUpdateCount_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wtpWapiUnicastUpdateCount undo.
     */
    /*
     * copy wtpWapiUnicastUpdateCount data
     * set rowreq_ctx->undo->wtpWapiUnicastUpdateCount from rowreq_ctx->data.wtpWapiUnicastUpdateCount
     */
    rowreq_ctx->undo->wtpWapiUnicastUpdateCount = rowreq_ctx->data.wtpWapiUnicastUpdateCount;


    return MFD_SUCCESS;
} /* wtpWapiUnicastUpdateCount_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wtpWapiUnicastUpdateCount_val
 *        A u_long containing the new value.
 */
int
wtpWapiUnicastUpdateCount_set( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long wtpWapiUnicastUpdateCount_val )
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastUpdateCount_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:245:o: |-> Implement wtpWapiUnicastUpdateCount reverse mapping.
 * If the values for your data type don't exactly match the
 * possible values defined by the mib, you should map them here.
 */
    /*
     * TODO:461:M: |-> Set wtpWapiUnicastUpdateCount value.
     * set wtpWapiUnicastUpdateCount value in rowreq_ctx->data
     */
    void *connection = NULL;
    if(SNMPD_DBUS_ERROR == get_instance_dbus_connection(rowreq_ctx->data.parameter, &connection, SNMPD_INSTANCE_MASTER_V3))
        return MFD_ERROR;
        
	int ret = 2;
	char input[DEFAULT_LEN] = { 0 };
	int ret_one = 2;
	int ret_two = 2;
	int ret_three = 2;		
	int rc = MFD_ERROR;
	ret = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"disable");
	if(ret == 1)
	{
		memset(input, 0, sizeof(input));
		snprintf(input, sizeof(input) - 1, "%d", wtpWapiUnicastUpdateCount_val);
		ret_one = set_wapi_sub_attr_unicastupdatecount_cmd(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,input);
		if(ret_one == 1)
		{						 
			ret_two = apply_wlanID(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,rowreq_ctx->data.localWlanID);
			if (ret_two == 1)
			{
				ret_three = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"enable");
				if (ret_three == 1)
				{
    				rowreq_ctx->data.wtpWapiUnicastUpdateCount = wtpWapiUnicastUpdateCount_val;
					rc = MFD_SUCCESS;
				}
				else
				{
				    if(SNMPD_CONNECTION_ERROR == ret_three) {
                        close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
            	    }
					rc = MFD_ERROR;
				}
			}	
			else
			{
			    if(SNMPD_CONNECTION_ERROR == ret_two) {
                    close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
        	    }
				rc = MFD_ERROR;
			}								 	     
		}
		else 
		{
		    if(SNMPD_CONNECTION_ERROR == ret_one) {
                close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
    	    }
			rc = MFD_ERROR;
		}
	}
	else 
	{
	    if(SNMPD_CONNECTION_ERROR == ret) {
            close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
	    }
		rc = MFD_ERROR;
	}

    return rc;
} /* wtpWapiUnicastUpdateCount_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wtpWapiUnicastUpdateCount_undo( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastUpdateCount_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wtpWapiUnicastUpdateCount undo.
     */
    /*
     * copy wtpWapiUnicastUpdateCount data
     * set rowreq_ctx->data.wtpWapiUnicastUpdateCount from rowreq_ctx->undo->wtpWapiUnicastUpdateCount
     */
    rowreq_ctx->data.wtpWapiUnicastUpdateCount = rowreq_ctx->undo->wtpWapiUnicastUpdateCount;

    
    return MFD_SUCCESS;
} /* wtpWapiUnicastUpdateCount_undo */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiBKLifetime
 * wtpWapiBKLifetime is subid 24 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.24
 * Description:
wtpWapiBKLifetime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiBKLifetime_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11WtpWAPIConfigTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wtpWapiBKLifetime_check_value( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long wtpWapiBKLifetime_val)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiBKLifetime_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wtpWapiBKLifetime value.
     */

    return MFD_SUCCESS; /* wtpWapiBKLifetime value not illegal */
} /* wtpWapiBKLifetime_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11WtpWAPIConfigTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11WtpWAPIConfigTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wtpWapiBKLifetime_undo_setup( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiBKLifetime_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wtpWapiBKLifetime undo.
     */
    /*
     * copy wtpWapiBKLifetime data
     * set rowreq_ctx->undo->wtpWapiBKLifetime from rowreq_ctx->data.wtpWapiBKLifetime
     */
    rowreq_ctx->undo->wtpWapiBKLifetime = rowreq_ctx->data.wtpWapiBKLifetime;


    return MFD_SUCCESS;
} /* wtpWapiBKLifetime_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wtpWapiBKLifetime_val
 *        A u_long containing the new value.
 */
int
wtpWapiBKLifetime_set( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long wtpWapiBKLifetime_val )
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiBKLifetime_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:245:o: |-> Implement wtpWapiBKLifetime reverse mapping.
 * If the values for your data type don't exactly match the
 * possible values defined by the mib, you should map them here.
 */
    /*
     * TODO:461:M: |-> Set wtpWapiBKLifetime value.
     * set wtpWapiBKLifetime value in rowreq_ctx->data
     */
    void *connection = NULL;
    if(SNMPD_DBUS_ERROR == get_instance_dbus_connection(rowreq_ctx->data.parameter, &connection, SNMPD_INSTANCE_MASTER_V3))
        return MFD_ERROR;
        
	int ret = 2;
	char input[DEFAULT_LEN] = { 0 };
	int ret_one = 2;
	int ret_two = 2;
	int ret_three = 2;	
	int rc = MFD_ERROR;

	ret = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"disable");
	if(ret == 1)
	{
		memset(input, 0, sizeof(input));
		snprintf(input, sizeof(input) - 1,"%d", wtpWapiBKLifetime_val);
		ret_one = set_wapi_sub_attr_bklifetime_cmd(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,input);
		if(ret_one == 1)
		{						 
			ret_two = apply_wlanID(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,rowreq_ctx->data.localWlanID);
			if (ret_two == 1)
			{
				ret_three = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"enable");
				if (ret_three == 1)
				{
    				rowreq_ctx->data.wtpWapiBKLifetime = wtpWapiBKLifetime_val;
					rc = MFD_SUCCESS;
				}
				else
				{
				    if(SNMPD_CONNECTION_ERROR == ret_three) {
                        close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
            	    }
					rc = MFD_ERROR;
				}
			}	
			else
			{
			    if(SNMPD_CONNECTION_ERROR == ret_two) {
                    close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
        	    }
				rc = MFD_ERROR;
			}								 	     
		}
		else 
		{
		    if(SNMPD_CONNECTION_ERROR == ret_one) {
                close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
    	    }
			rc = MFD_ERROR;
		}
	}
	else 
	{
	    if(SNMPD_CONNECTION_ERROR == ret) {
            close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
	    }
		rc = MFD_ERROR;
	}

    return rc;
} /* wtpWapiBKLifetime_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wtpWapiBKLifetime_undo( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiBKLifetime_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wtpWapiBKLifetime undo.
     */
    /*
     * copy wtpWapiBKLifetime data
     * set rowreq_ctx->data.wtpWapiBKLifetime from rowreq_ctx->undo->wtpWapiBKLifetime
     */
    rowreq_ctx->data.wtpWapiBKLifetime = rowreq_ctx->undo->wtpWapiBKLifetime;

    
    return MFD_SUCCESS;
} /* wtpWapiBKLifetime_undo */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiBKReauthThreshold
 * wtpWapiBKReauthThreshold is subid 25 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.25
 * Description:
wtpWapiBKReauthThreshold.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiBKReauthThreshold_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11WtpWAPIConfigTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wtpWapiBKReauthThreshold_check_value( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long wtpWapiBKReauthThreshold_val)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiBKReauthThreshold_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wtpWapiBKReauthThreshold value.
     */

    return MFD_SUCCESS; /* wtpWapiBKReauthThreshold value not illegal */
} /* wtpWapiBKReauthThreshold_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11WtpWAPIConfigTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11WtpWAPIConfigTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wtpWapiBKReauthThreshold_undo_setup( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiBKReauthThreshold_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wtpWapiBKReauthThreshold undo.
     */
    /*
     * copy wtpWapiBKReauthThreshold data
     * set rowreq_ctx->undo->wtpWapiBKReauthThreshold from rowreq_ctx->data.wtpWapiBKReauthThreshold
     */
    rowreq_ctx->undo->wtpWapiBKReauthThreshold = rowreq_ctx->data.wtpWapiBKReauthThreshold;


    return MFD_SUCCESS;
} /* wtpWapiBKReauthThreshold_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wtpWapiBKReauthThreshold_val
 *        A u_long containing the new value.
 */
int
wtpWapiBKReauthThreshold_set( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long wtpWapiBKReauthThreshold_val )
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiBKReauthThreshold_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:245:o: |-> Implement wtpWapiBKReauthThreshold reverse mapping.
 * If the values for your data type don't exactly match the
 * possible values defined by the mib, you should map them here.
 */
    /*
     * TODO:461:M: |-> Set wtpWapiBKReauthThreshold value.
     * set wtpWapiBKReauthThreshold value in rowreq_ctx->data
     */
    void *connection = NULL;
    if(SNMPD_DBUS_ERROR == get_instance_dbus_connection(rowreq_ctx->data.parameter, &connection, SNMPD_INSTANCE_MASTER_V3))
        return MFD_ERROR;
        
	int ret = 2;
	char input[DEFAULT_LEN] = { 0 };
	int ret_one = 2;
	int ret_two = 2;
	int ret_three = 2;		
	int rc = MFD_ERROR;

	ret = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"disable");
	if(ret == 1)
	{
		memset(input, 0, sizeof(input));
		snprintf(input, sizeof(input) - 1, "%d", wtpWapiBKReauthThreshold_val);
		ret_one = set_wapi_sub_attr_bkreauththreshold_cmd(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,input);
		if(ret_one == 1)
		{						 
			ret_two = apply_wlanID(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,rowreq_ctx->data.localWlanID);
			if (ret_two == 1)
			{
				ret_three = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"enable");
				if (ret_three == 1)
				{
				    rowreq_ctx->data.wtpWapiBKReauthThreshold = wtpWapiBKReauthThreshold_val;
					rc = MFD_SUCCESS;
				}
				else
				{
				    if(SNMPD_CONNECTION_ERROR == ret_three) {
                        close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
            	    }
					rc = MFD_ERROR;
				}
			}	
			else
			{   
			    if(SNMPD_CONNECTION_ERROR == ret_two) {
                    close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
        	    }
				rc = MFD_ERROR;
			}								 	     
		}
		else 
		{
		    if(SNMPD_CONNECTION_ERROR == ret_one) {
                close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
    	    }
			rc = MFD_ERROR;
		}
	}
	else 
	{
	    if(SNMPD_CONNECTION_ERROR == ret) {
            close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
	    }
		rc = MFD_ERROR;
	}

    return rc;
} /* wtpWapiBKReauthThreshold_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wtpWapiBKReauthThreshold_undo( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiBKReauthThreshold_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wtpWapiBKReauthThreshold undo.
     */
    /*
     * copy wtpWapiBKReauthThreshold data
     * set rowreq_ctx->data.wtpWapiBKReauthThreshold from rowreq_ctx->undo->wtpWapiBKReauthThreshold
     */
    rowreq_ctx->data.wtpWapiBKReauthThreshold = rowreq_ctx->undo->wtpWapiBKReauthThreshold;

    
    return MFD_SUCCESS;
} /* wtpWapiBKReauthThreshold_undo */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiSATimeout
 * wtpWapiSATimeout is subid 26 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.26
 * Description:
wtpWapiSATimeout.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiSATimeout_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * dot11WtpWAPIConfigTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
wtpWapiSATimeout_check_value( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long wtpWapiSATimeout_val)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiSATimeout_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid wtpWapiSATimeout value.
     */

    return MFD_SUCCESS; /* wtpWapiSATimeout value not illegal */
} /* wtpWapiSATimeout_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (dot11WtpWAPIConfigTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * dot11WtpWAPIConfigTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
wtpWapiSATimeout_undo_setup( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiSATimeout_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup wtpWapiSATimeout undo.
     */
    /*
     * copy wtpWapiSATimeout data
     * set rowreq_ctx->undo->wtpWapiSATimeout from rowreq_ctx->data.wtpWapiSATimeout
     */
    rowreq_ctx->undo->wtpWapiSATimeout = rowreq_ctx->data.wtpWapiSATimeout;


    return MFD_SUCCESS;
} /* wtpWapiSATimeout_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param wtpWapiSATimeout_val
 *        A u_long containing the new value.
 */
int
wtpWapiSATimeout_set( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long wtpWapiSATimeout_val )
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiSATimeout_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:245:o: |-> Implement wtpWapiSATimeout reverse mapping.
 * If the values for your data type don't exactly match the
 * possible values defined by the mib, you should map them here.
 */
    /*
     * TODO:461:M: |-> Set wtpWapiSATimeout value.
     * set wtpWapiSATimeout value in rowreq_ctx->data
     */
    void *connection = NULL;
    if(SNMPD_DBUS_ERROR == get_instance_dbus_connection(rowreq_ctx->data.parameter, &connection, SNMPD_INSTANCE_MASTER_V3))
        return MFD_ERROR;
        
	int ret = 2;
	char input[DEFAULT_LEN] = { 0 };
	int ret_one = 2;
	int ret_two = 2;
	int ret_three = 2;	
	int rc = MFD_ERROR;

	ret = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"disable");
	if(ret == 1)
	{
		memset(input, 0, sizeof(input));
		snprintf(input, sizeof(input) - 1, "%d", wtpWapiSATimeout_val);
		ret_one = set_wapi_sub_attr_satimeout_cmd(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,input);
		if(ret_one == 1)
		{						 
			ret_two = apply_wlanID(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.SecurityID,rowreq_ctx->data.localWlanID);
			if (ret_two == 1)
			{
				ret_three = config_wlan_service(rowreq_ctx->data.parameter, connection,rowreq_ctx->data.localWlanID,"enable");
				if (ret_three == 1)
				{
   					rowreq_ctx->data.wtpWapiSATimeout = wtpWapiSATimeout_val;
					rc = MFD_SUCCESS;
				}
				else
				{
				    if(SNMPD_CONNECTION_ERROR == ret_three) {
                        close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
            	    }
					rc = MFD_ERROR;
				}
			}	
			else
			{
			    if(SNMPD_CONNECTION_ERROR == ret_two) {
                    close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
        	    }
				rc = MFD_ERROR;
			}								 	     
		}
		else 
		{
		    if(SNMPD_CONNECTION_ERROR == ret_one) {
                close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
    	    }
			rc = MFD_ERROR;
		}
	}
	else 
	{   
	    if(SNMPD_CONNECTION_ERROR == ret) {
            close_slot_dbus_connection(rowreq_ctx->data.parameter.slot_id);
	    }
		rc = MFD_ERROR;
	}

    return rc;
} /* wtpWapiSATimeout_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
wtpWapiSATimeout_undo( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiSATimeout_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up wtpWapiSATimeout undo.
     */
    /*
     * copy wtpWapiSATimeout data
     * set rowreq_ctx->data.wtpWapiSATimeout from rowreq_ctx->undo->wtpWapiSATimeout
     */
    rowreq_ctx->data.wtpWapiSATimeout = rowreq_ctx->undo->wtpWapiSATimeout;

    
    return MFD_SUCCESS;
} /* wtpWapiSATimeout_undo */

/**
 * check dependencies
 *
 * This is useful for for tables which have dependencies between columns
 * (or rows, or tables). For example, two columns allocating a percentage
 * of something add up 100%.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the FLAG_* bits can be found in
 * dot11WtpWAPIConfigTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @retval MFD_SUCCESS all the changes to the row are legal
 * @retval MFD_ERROR   one or more changes are not legal
 *
 * (see README-table-dot11WtpWAPIConfigTable if you don't have dependencies)
 */
int
dot11WtpWAPIConfigTable_check_dependencies(dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;
    
    DEBUGMSGTL(("internal:dot11WtpWAPIConfigTable:dot11WtpWAPIConfigTable_check_dependencies","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:470:o: Check dot11WtpWAPIConfigTable row dependencies.
     * check that all new value are legal and consistent with each other
     */
    return rc;
} /* dot11WtpWAPIConfigTable_check_dependencies */

/** @} */
