/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.18.2.1 $ of : mfd-data-get.m2c,v $ 
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "dot11WtpWAPIConfigTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement dot11WtpWAPIConfigTable get routines.
 * TODO:240:M: Implement dot11WtpWAPIConfigTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table dot11WtpWAPIConfigTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * dot11WtpWAPIConfigTable is subid 10 of wtpWAPI.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10, length: 12
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement dot11WtpWAPIConfigTable data context functions.
 */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.WapiWlanID
 * WapiWlanID is subid 1 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.1
 * Description:
WapiWlanID.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-WapiWlanID.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
WapiWlanID_map_wwconfig(long *mib_WapiWlanID_val_ptr, long raw_WapiWlanID_val)
{
    netsnmp_assert(NULL != mib_WapiWlanID_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:WapiWlanID_map_wwconfig","called\n"));
    
    /*
     * TODO:241:o: |-> Implement WapiWlanID mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_WapiWlanID_val_ptr) = raw_WapiWlanID_val;

    return MFD_SUCCESS;
} /* WapiWlanID_map_wwconfig */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
dot11WtpWAPIConfigTable_indexes_set_tbl_idx(dot11WtpWAPIConfigTable_mib_index *tbl_idx, long WapiWlanID_val)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:dot11WtpWAPIConfigTable_indexes_set_tbl_idx","called\n"));

    /* WapiWlanID(1)/INTEGER/ASN_INTEGER/long(long)//l/A/w/e/r/d/h */
    tbl_idx->WapiWlanID = WapiWlanID_val;
    

    return MFD_SUCCESS;
} /* dot11WtpWAPIConfigTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
dot11WtpWAPIConfigTable_indexes_set(dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, long WapiWlanID_val)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:dot11WtpWAPIConfigTable_indexes_set","called\n"));

    if(MFD_SUCCESS != dot11WtpWAPIConfigTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
                                   , WapiWlanID_val
           ))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if(0 != dot11WtpWAPIConfigTable_index_to_oid(&rowreq_ctx->oid_idx,
                                    &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* dot11WtpWAPIConfigTable_indexes_set */


/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiConfigVersion
 * wtpWapiConfigVersion is subid 2 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.2
 * Description:
wtpWapiConfigVersion.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiConfigVersion.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiConfigVersion_map(long *mib_wtpWapiConfigVersion_val_ptr, long raw_wtpWapiConfigVersion_val)
{
    netsnmp_assert(NULL != mib_wtpWapiConfigVersion_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiConfigVersion_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiConfigVersion mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWapiConfigVersion_val_ptr) = raw_wtpWapiConfigVersion_val;

    return MFD_SUCCESS;
} /* wtpWapiConfigVersion_map */

/**
 * Extract the current value of the wtpWapiConfigVersion data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiConfigVersion_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiConfigVersion_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, long * wtpWapiConfigVersion_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiConfigVersion_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiConfigVersion_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiConfigVersion data.
 * set (* wtpWapiConfigVersion_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiConfigVersion_val_ptr ) = rowreq_ctx->data.wtpWapiConfigVersion;

    return MFD_SUCCESS;
} /* wtpWapiConfigVersion_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiControlledAuthenControlenabled
 * wtpWapiControlledAuthenControlenabled is subid 3 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.3
 * Description:
wtpWapiControlledAuthenControlenabled.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiControlledAuthenControlenabled.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiControlledAuthenControlenabled_map(u_long *mib_wtpWapiControlledAuthenControlenabled_val_ptr, u_long raw_wtpWapiControlledAuthenControlenabled_val)
{
    netsnmp_assert(NULL != mib_wtpWapiControlledAuthenControlenabled_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiControlledAuthenControlenabled_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiControlledAuthenControlenabled enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wtpWapiControlledAuthenControlenabled_val) {
        case INTERNAL_WTPWAPICONTROLLEDAUTHENCONTROLENABLED_TRUE:
             *mib_wtpWapiControlledAuthenControlenabled_val_ptr = TRUTHVALUE_TRUE;
             break;

        case INTERNAL_WTPWAPICONTROLLEDAUTHENCONTROLENABLED_FALSE:
             *mib_wtpWapiControlledAuthenControlenabled_val_ptr = TRUTHVALUE_FALSE;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wtpWapiControlledAuthenControlenabled\n", raw_wtpWapiControlledAuthenControlenabled_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wtpWapiControlledAuthenControlenabled_map */

/**
 * Extract the current value of the wtpWapiControlledAuthenControlenabled data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiControlledAuthenControlenabled_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiControlledAuthenControlenabled_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiControlledAuthenControlenabled_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiControlledAuthenControlenabled_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiControlledAuthenControlenabled_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiControlledAuthenControlenabled data.
 * set (* wtpWapiControlledAuthenControlenabled_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiControlledAuthenControlenabled_val_ptr ) = rowreq_ctx->data.wtpWapiControlledAuthenControlenabled;

    return MFD_SUCCESS;
} /* wtpWapiControlledAuthenControlenabled_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiControlledPortControl
 * wtpWapiControlledPortControl is subid 4 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.4
 * Description:
wtpWapiControlledPortControl.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiControlledPortControl.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiControlledPortControl_map(char **mib_wtpWapiControlledPortControl_val_ptr_ptr, size_t *mib_wtpWapiControlledPortControl_val_ptr_len_ptr, char *raw_wtpWapiControlledPortControl_val_ptr, size_t raw_wtpWapiControlledPortControl_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpWapiControlledPortControl_val_ptr);
    netsnmp_assert((NULL != mib_wtpWapiControlledPortControl_val_ptr_ptr) && (NULL != mib_wtpWapiControlledPortControl_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiControlledPortControl_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpWapiControlledPortControl non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpWapiControlledPortControl_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpWapiControlledPortControl_val_ptr_ptr) || (*mib_wtpWapiControlledPortControl_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpWapiControlledPortControl_val_ptr_ptr = realloc( *mib_wtpWapiControlledPortControl_val_ptr_ptr, converted_len * sizeof(**mib_wtpWapiControlledPortControl_val_ptr_ptr));
        if(NULL == *mib_wtpWapiControlledPortControl_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpWapiControlledPortControl_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpWapiControlledPortControl_val_ptr_ptr, raw_wtpWapiControlledPortControl_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpWapiControlledPortControl_map */

/**
 * Extract the current value of the wtpWapiControlledPortControl data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiControlledPortControl_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wtpWapiControlledPortControl_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wtpWapiControlledPortControl.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wtpWapiControlledPortControl_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wtpWapiControlledPortControl_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wtpWapiControlledPortControl_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, char **wtpWapiControlledPortControl_val_ptr_ptr, size_t *wtpWapiControlledPortControl_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != wtpWapiControlledPortControl_val_ptr_ptr) && (NULL != *wtpWapiControlledPortControl_val_ptr_ptr));
   netsnmp_assert( NULL != wtpWapiControlledPortControl_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiControlledPortControl_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiControlledPortControl data.
 * set (* wtpWapiControlledPortControl_val_ptr_ptr ) and (* wtpWapiControlledPortControl_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for wtpWapiControlledPortControl data
     */
    if ((NULL == (* wtpWapiControlledPortControl_val_ptr_ptr )) ||
        ((* wtpWapiControlledPortControl_val_ptr_len_ptr ) < (rowreq_ctx->data.wtpWapiControlledPortControl_len * sizeof((* wtpWapiControlledPortControl_val_ptr_ptr )[0])))) {
        /*
         * allocate space for wtpWapiControlledPortControl data
         */
        (* wtpWapiControlledPortControl_val_ptr_ptr ) = malloc(rowreq_ctx->data.wtpWapiControlledPortControl_len * sizeof((* wtpWapiControlledPortControl_val_ptr_ptr )[0]));
        if(NULL == (* wtpWapiControlledPortControl_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* wtpWapiControlledPortControl_val_ptr_len_ptr ) = rowreq_ctx->data.wtpWapiControlledPortControl_len * sizeof((* wtpWapiControlledPortControl_val_ptr_ptr )[0]);
    memcpy( (* wtpWapiControlledPortControl_val_ptr_ptr ), rowreq_ctx->data.wtpWapiControlledPortControl, (* wtpWapiControlledPortControl_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* wtpWapiControlledPortControl_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiWPIOptionImplement
 * wtpWapiWPIOptionImplement is subid 5 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.5
 * Description:
wtpWapiWPIOptionImplement.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiWPIOptionImplement.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiWPIOptionImplement_map(u_long *mib_wtpWapiWPIOptionImplement_val_ptr, u_long raw_wtpWapiWPIOptionImplement_val)
{
    netsnmp_assert(NULL != mib_wtpWapiWPIOptionImplement_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiWPIOptionImplement_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiWPIOptionImplement enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wtpWapiWPIOptionImplement_val) {
        case INTERNAL_WTPWAPIWPIOPTIONIMPLEMENT_TRUE:
             *mib_wtpWapiWPIOptionImplement_val_ptr = TRUTHVALUE_TRUE;
             break;

        case INTERNAL_WTPWAPIWPIOPTIONIMPLEMENT_FALSE:
             *mib_wtpWapiWPIOptionImplement_val_ptr = TRUTHVALUE_FALSE;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wtpWapiWPIOptionImplement\n", raw_wtpWapiWPIOptionImplement_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wtpWapiWPIOptionImplement_map */

/**
 * Extract the current value of the wtpWapiWPIOptionImplement data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiWPIOptionImplement_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiWPIOptionImplement_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiWPIOptionImplement_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiWPIOptionImplement_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiWPIOptionImplement_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiWPIOptionImplement data.
 * set (* wtpWapiWPIOptionImplement_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiWPIOptionImplement_val_ptr ) = rowreq_ctx->data.wtpWapiWPIOptionImplement;

    return MFD_SUCCESS;
} /* wtpWapiWPIOptionImplement_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiWPIPreauthImplemented
 * wtpWapiWPIPreauthImplemented is subid 6 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.6
 * Description:
wtpWapiWPIPreauthImplemented.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiWPIPreauthImplemented.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiWPIPreauthImplemented_map(u_long *mib_wtpWapiWPIPreauthImplemented_val_ptr, u_long raw_wtpWapiWPIPreauthImplemented_val)
{
    netsnmp_assert(NULL != mib_wtpWapiWPIPreauthImplemented_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiWPIPreauthImplemented_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiWPIPreauthImplemented enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wtpWapiWPIPreauthImplemented_val) {
        case INTERNAL_WTPWAPIWPIPREAUTHIMPLEMENTED_TRUE:
             *mib_wtpWapiWPIPreauthImplemented_val_ptr = TRUTHVALUE_TRUE;
             break;

        case INTERNAL_WTPWAPIWPIPREAUTHIMPLEMENTED_FALSE:
             *mib_wtpWapiWPIPreauthImplemented_val_ptr = TRUTHVALUE_FALSE;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wtpWapiWPIPreauthImplemented\n", raw_wtpWapiWPIPreauthImplemented_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wtpWapiWPIPreauthImplemented_map */

/**
 * Extract the current value of the wtpWapiWPIPreauthImplemented data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiWPIPreauthImplemented_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiWPIPreauthImplemented_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiWPIPreauthImplemented_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiWPIPreauthImplemented_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiWPIPreauthImplemented_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiWPIPreauthImplemented data.
 * set (* wtpWapiWPIPreauthImplemented_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiWPIPreauthImplemented_val_ptr ) = rowreq_ctx->data.wtpWapiWPIPreauthImplemented;

    return MFD_SUCCESS;
} /* wtpWapiWPIPreauthImplemented_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiEnabled
 * wtpWapiEnabled is subid 7 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.7
 * Description:
wtpWapiEnabled.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiEnabled.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiEnabled_map(u_long *mib_wtpWapiEnabled_val_ptr, u_long raw_wtpWapiEnabled_val)
{
    netsnmp_assert(NULL != mib_wtpWapiEnabled_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiEnabled_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiEnabled enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wtpWapiEnabled_val) {
        case INTERNAL_WTPWAPIENABLED_TRUE:
             *mib_wtpWapiEnabled_val_ptr = TRUTHVALUE_TRUE;
             break;

        case INTERNAL_WTPWAPIENABLED_FALSE:
             *mib_wtpWapiEnabled_val_ptr = TRUTHVALUE_FALSE;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wtpWapiEnabled\n", raw_wtpWapiEnabled_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wtpWapiEnabled_map */

/**
 * Extract the current value of the wtpWapiEnabled data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiEnabled_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiEnabled_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiEnabled_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiEnabled_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiEnabled_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiEnabled data.
 * set (* wtpWapiEnabled_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiEnabled_val_ptr ) = rowreq_ctx->data.wtpWapiEnabled;

    return MFD_SUCCESS;
} /* wtpWapiEnabled_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiPreauthEnabled
 * wtpWapiPreauthEnabled is subid 8 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.8
 * Description:
wtpWapiPreauthEnabled.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiPreauthEnabled.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiPreauthEnabled_map(u_long *mib_wtpWapiPreauthEnabled_val_ptr, u_long raw_wtpWapiPreauthEnabled_val)
{
    netsnmp_assert(NULL != mib_wtpWapiPreauthEnabled_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiPreauthEnabled_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiPreauthEnabled enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wtpWapiPreauthEnabled_val) {
        case INTERNAL_WTPWAPIPREAUTHENABLED_TRUE:
             *mib_wtpWapiPreauthEnabled_val_ptr = TRUTHVALUE_TRUE;
             break;

        case INTERNAL_WTPWAPIPREAUTHENABLED_FALSE:
             *mib_wtpWapiPreauthEnabled_val_ptr = TRUTHVALUE_FALSE;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wtpWapiPreauthEnabled\n", raw_wtpWapiPreauthEnabled_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wtpWapiPreauthEnabled_map */

/**
 * Extract the current value of the wtpWapiPreauthEnabled data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiPreauthEnabled_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiPreauthEnabled_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiPreauthEnabled_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiPreauthEnabled_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiPreauthEnabled_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiPreauthEnabled data.
 * set (* wtpWapiPreauthEnabled_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiPreauthEnabled_val_ptr ) = rowreq_ctx->data.wtpWapiPreauthEnabled;

    return MFD_SUCCESS;
} /* wtpWapiPreauthEnabled_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiUnicastKeysSupported
 * wtpWapiUnicastKeysSupported is subid 9 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.9
 * Description:
wtpWapiUnicastKeysSupported.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiUnicastKeysSupported.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiUnicastKeysSupported_map(u_long *mib_wtpWapiUnicastKeysSupported_val_ptr, u_long raw_wtpWapiUnicastKeysSupported_val)
{
    netsnmp_assert(NULL != mib_wtpWapiUnicastKeysSupported_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastKeysSupported_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiUnicastKeysSupported mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWapiUnicastKeysSupported_val_ptr) = raw_wtpWapiUnicastKeysSupported_val;

    return MFD_SUCCESS;
} /* wtpWapiUnicastKeysSupported_map */

/**
 * Extract the current value of the wtpWapiUnicastKeysSupported data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiUnicastKeysSupported_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiUnicastKeysSupported_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiUnicastKeysSupported_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiUnicastKeysSupported_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastKeysSupported_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiUnicastKeysSupported data.
 * set (* wtpWapiUnicastKeysSupported_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiUnicastKeysSupported_val_ptr ) = rowreq_ctx->data.wtpWapiUnicastKeysSupported;

    return MFD_SUCCESS;
} /* wtpWapiUnicastKeysSupported_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiUnicastRekeyMethod
 * wtpWapiUnicastRekeyMethod is subid 10 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.10
 * Description:
wtpWapiUnicastKeysSupported.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  disabled(1), timeBased(2), packetBased(3), timepacket_Based(4)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiUnicastRekeyMethod.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiUnicastRekeyMethod_map(u_long *mib_wtpWapiUnicastRekeyMethod_val_ptr, u_long raw_wtpWapiUnicastRekeyMethod_val)
{
    netsnmp_assert(NULL != mib_wtpWapiUnicastRekeyMethod_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastRekeyMethod_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiUnicastRekeyMethod enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wtpWapiUnicastRekeyMethod_val) {
        case INTERNAL_WTPWAPIUNICASTREKEYMETHOD_DISABLED:
             *mib_wtpWapiUnicastRekeyMethod_val_ptr = WTPWAPIUNICASTREKEYMETHOD_DISABLED;
             break;

        case INTERNAL_WTPWAPIUNICASTREKEYMETHOD_TIMEBASED:
             *mib_wtpWapiUnicastRekeyMethod_val_ptr = WTPWAPIUNICASTREKEYMETHOD_TIMEBASED;
             break;

        case INTERNAL_WTPWAPIUNICASTREKEYMETHOD_PACKETBASED:
             *mib_wtpWapiUnicastRekeyMethod_val_ptr = WTPWAPIUNICASTREKEYMETHOD_PACKETBASED;
             break;

        case INTERNAL_WTPWAPIUNICASTREKEYMETHOD_TIMEPACKET_BASED:
             *mib_wtpWapiUnicastRekeyMethod_val_ptr = WTPWAPIUNICASTREKEYMETHOD_TIMEPACKET_BASED;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wtpWapiUnicastRekeyMethod\n", raw_wtpWapiUnicastRekeyMethod_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wtpWapiUnicastRekeyMethod_map */

/**
 * Extract the current value of the wtpWapiUnicastRekeyMethod data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiUnicastRekeyMethod_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiUnicastRekeyMethod_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiUnicastRekeyMethod_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiUnicastRekeyMethod_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastRekeyMethod_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiUnicastRekeyMethod data.
 * set (* wtpWapiUnicastRekeyMethod_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiUnicastRekeyMethod_val_ptr ) = rowreq_ctx->data.wtpWapiUnicastRekeyMethod;

    return MFD_SUCCESS;
} /* wtpWapiUnicastRekeyMethod_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiUnicastRekeyTime
 * wtpWapiUnicastRekeyTime is subid 11 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.11
 * Description:
wtpWapiUnicastRekeyTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiUnicastRekeyTime.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiUnicastRekeyTime_map(u_long *mib_wtpWapiUnicastRekeyTime_val_ptr, u_long raw_wtpWapiUnicastRekeyTime_val)
{
    netsnmp_assert(NULL != mib_wtpWapiUnicastRekeyTime_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastRekeyTime_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiUnicastRekeyTime mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWapiUnicastRekeyTime_val_ptr) = raw_wtpWapiUnicastRekeyTime_val;

    return MFD_SUCCESS;
} /* wtpWapiUnicastRekeyTime_map */

/**
 * Extract the current value of the wtpWapiUnicastRekeyTime data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiUnicastRekeyTime_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiUnicastRekeyTime_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiUnicastRekeyTime_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiUnicastRekeyTime_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastRekeyTime_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiUnicastRekeyTime data.
 * set (* wtpWapiUnicastRekeyTime_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiUnicastRekeyTime_val_ptr ) = rowreq_ctx->data.wtpWapiUnicastRekeyTime;

    return MFD_SUCCESS;
} /* wtpWapiUnicastRekeyTime_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiUnicastRekeyPackets
 * wtpWapiUnicastRekeyPackets is subid 12 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.12
 * Description:
wtpWapiUnicastRekeyPackets.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiUnicastRekeyPackets.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiUnicastRekeyPackets_map(u_long *mib_wtpWapiUnicastRekeyPackets_val_ptr, u_long raw_wtpWapiUnicastRekeyPackets_val)
{
    netsnmp_assert(NULL != mib_wtpWapiUnicastRekeyPackets_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastRekeyPackets_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiUnicastRekeyPackets mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWapiUnicastRekeyPackets_val_ptr) = raw_wtpWapiUnicastRekeyPackets_val;

    return MFD_SUCCESS;
} /* wtpWapiUnicastRekeyPackets_map */

/**
 * Extract the current value of the wtpWapiUnicastRekeyPackets data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiUnicastRekeyPackets_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiUnicastRekeyPackets_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiUnicastRekeyPackets_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiUnicastRekeyPackets_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastRekeyPackets_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiUnicastRekeyPackets data.
 * set (* wtpWapiUnicastRekeyPackets_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiUnicastRekeyPackets_val_ptr ) = rowreq_ctx->data.wtpWapiUnicastRekeyPackets;

    return MFD_SUCCESS;
} /* wtpWapiUnicastRekeyPackets_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiMulticastCipher
 * wtpWapiMulticastCipher is subid 13 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.13
 * Description:
wtpWapiMulticastCipher.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiMulticastCipher.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiMulticastCipher_map(char **mib_wtpWapiMulticastCipher_val_ptr_ptr, size_t *mib_wtpWapiMulticastCipher_val_ptr_len_ptr, char *raw_wtpWapiMulticastCipher_val_ptr, size_t raw_wtpWapiMulticastCipher_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpWapiMulticastCipher_val_ptr);
    netsnmp_assert((NULL != mib_wtpWapiMulticastCipher_val_ptr_ptr) && (NULL != mib_wtpWapiMulticastCipher_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastCipher_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpWapiMulticastCipher non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpWapiMulticastCipher_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpWapiMulticastCipher_val_ptr_ptr) || (*mib_wtpWapiMulticastCipher_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpWapiMulticastCipher_val_ptr_ptr = realloc( *mib_wtpWapiMulticastCipher_val_ptr_ptr, converted_len * sizeof(**mib_wtpWapiMulticastCipher_val_ptr_ptr));
        if(NULL == *mib_wtpWapiMulticastCipher_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpWapiMulticastCipher_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpWapiMulticastCipher_val_ptr_ptr, raw_wtpWapiMulticastCipher_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpWapiMulticastCipher_map */

/**
 * Extract the current value of the wtpWapiMulticastCipher data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiMulticastCipher_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wtpWapiMulticastCipher_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wtpWapiMulticastCipher.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wtpWapiMulticastCipher_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wtpWapiMulticastCipher_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wtpWapiMulticastCipher_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, char **wtpWapiMulticastCipher_val_ptr_ptr, size_t *wtpWapiMulticastCipher_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != wtpWapiMulticastCipher_val_ptr_ptr) && (NULL != *wtpWapiMulticastCipher_val_ptr_ptr));
   netsnmp_assert( NULL != wtpWapiMulticastCipher_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastCipher_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiMulticastCipher data.
 * set (* wtpWapiMulticastCipher_val_ptr_ptr ) and (* wtpWapiMulticastCipher_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for wtpWapiMulticastCipher data
     */
    if ((NULL == (* wtpWapiMulticastCipher_val_ptr_ptr )) ||
        ((* wtpWapiMulticastCipher_val_ptr_len_ptr ) < (rowreq_ctx->data.wtpWapiMulticastCipher_len * sizeof((* wtpWapiMulticastCipher_val_ptr_ptr )[0])))) {
        /*
         * allocate space for wtpWapiMulticastCipher data
         */
        (* wtpWapiMulticastCipher_val_ptr_ptr ) = malloc(rowreq_ctx->data.wtpWapiMulticastCipher_len * sizeof((* wtpWapiMulticastCipher_val_ptr_ptr )[0]));
        if(NULL == (* wtpWapiMulticastCipher_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* wtpWapiMulticastCipher_val_ptr_len_ptr ) = rowreq_ctx->data.wtpWapiMulticastCipher_len * sizeof((* wtpWapiMulticastCipher_val_ptr_ptr )[0]);
    memcpy( (* wtpWapiMulticastCipher_val_ptr_ptr ), rowreq_ctx->data.wtpWapiMulticastCipher, (* wtpWapiMulticastCipher_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* wtpWapiMulticastCipher_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiMulticastRekeyMethod
 * wtpWapiMulticastRekeyMethod is subid 14 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.14
 * Description:
wtpWapiMulticastRekeyMethod.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiMulticastRekeyMethod.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiMulticastRekeyMethod_map(long *mib_wtpWapiMulticastRekeyMethod_val_ptr, long raw_wtpWapiMulticastRekeyMethod_val)
{
    netsnmp_assert(NULL != mib_wtpWapiMulticastRekeyMethod_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastRekeyMethod_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiMulticastRekeyMethod mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWapiMulticastRekeyMethod_val_ptr) = raw_wtpWapiMulticastRekeyMethod_val;

    return MFD_SUCCESS;
} /* wtpWapiMulticastRekeyMethod_map */

/**
 * Extract the current value of the wtpWapiMulticastRekeyMethod data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiMulticastRekeyMethod_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiMulticastRekeyMethod_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, long * wtpWapiMulticastRekeyMethod_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiMulticastRekeyMethod_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastRekeyMethod_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiMulticastRekeyMethod data.
 * set (* wtpWapiMulticastRekeyMethod_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiMulticastRekeyMethod_val_ptr ) = rowreq_ctx->data.wtpWapiMulticastRekeyMethod;

    return MFD_SUCCESS;
} /* wtpWapiMulticastRekeyMethod_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiMulticastRekeyTime
 * wtpWapiMulticastRekeyTime is subid 15 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.15
 * Description:
wtpWapiMulticastRekeyTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiMulticastRekeyTime.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiMulticastRekeyTime_map(u_long *mib_wtpWapiMulticastRekeyTime_val_ptr, u_long raw_wtpWapiMulticastRekeyTime_val)
{
    netsnmp_assert(NULL != mib_wtpWapiMulticastRekeyTime_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastRekeyTime_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiMulticastRekeyTime mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWapiMulticastRekeyTime_val_ptr) = raw_wtpWapiMulticastRekeyTime_val;

    return MFD_SUCCESS;
} /* wtpWapiMulticastRekeyTime_map */

/**
 * Extract the current value of the wtpWapiMulticastRekeyTime data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiMulticastRekeyTime_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiMulticastRekeyTime_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiMulticastRekeyTime_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiMulticastRekeyTime_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastRekeyTime_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiMulticastRekeyTime data.
 * set (* wtpWapiMulticastRekeyTime_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiMulticastRekeyTime_val_ptr ) = rowreq_ctx->data.wtpWapiMulticastRekeyTime;

    return MFD_SUCCESS;
} /* wtpWapiMulticastRekeyTime_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiMulticastRekeyPackets
 * wtpWapiMulticastRekeyPackets is subid 16 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.16
 * Description:
wtpWapiMulticastRekeyPackets.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiMulticastRekeyPackets.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiMulticastRekeyPackets_map(u_long *mib_wtpWapiMulticastRekeyPackets_val_ptr, u_long raw_wtpWapiMulticastRekeyPackets_val)
{
    netsnmp_assert(NULL != mib_wtpWapiMulticastRekeyPackets_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastRekeyPackets_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiMulticastRekeyPackets mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWapiMulticastRekeyPackets_val_ptr) = raw_wtpWapiMulticastRekeyPackets_val;

    return MFD_SUCCESS;
} /* wtpWapiMulticastRekeyPackets_map */

/**
 * Extract the current value of the wtpWapiMulticastRekeyPackets data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiMulticastRekeyPackets_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiMulticastRekeyPackets_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiMulticastRekeyPackets_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiMulticastRekeyPackets_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastRekeyPackets_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiMulticastRekeyPackets data.
 * set (* wtpWapiMulticastRekeyPackets_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiMulticastRekeyPackets_val_ptr ) = rowreq_ctx->data.wtpWapiMulticastRekeyPackets;

    return MFD_SUCCESS;
} /* wtpWapiMulticastRekeyPackets_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiMulticastRekeyStrict
 * wtpWapiMulticastRekeyStrict is subid 17 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.17
 * Description:
wtpWapiMulticastRekeyStrict.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiMulticastRekeyStrict.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiMulticastRekeyStrict_map(u_long *mib_wtpWapiMulticastRekeyStrict_val_ptr, u_long raw_wtpWapiMulticastRekeyStrict_val)
{
    netsnmp_assert(NULL != mib_wtpWapiMulticastRekeyStrict_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastRekeyStrict_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiMulticastRekeyStrict enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wtpWapiMulticastRekeyStrict_val) {
        case INTERNAL_WTPWAPIMULTICASTREKEYSTRICT_TRUE:
             *mib_wtpWapiMulticastRekeyStrict_val_ptr = TRUTHVALUE_TRUE;
             break;

        case INTERNAL_WTPWAPIMULTICASTREKEYSTRICT_FALSE:
             *mib_wtpWapiMulticastRekeyStrict_val_ptr = TRUTHVALUE_FALSE;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wtpWapiMulticastRekeyStrict\n", raw_wtpWapiMulticastRekeyStrict_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wtpWapiMulticastRekeyStrict_map */

/**
 * Extract the current value of the wtpWapiMulticastRekeyStrict data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiMulticastRekeyStrict_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiMulticastRekeyStrict_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiMulticastRekeyStrict_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiMulticastRekeyStrict_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastRekeyStrict_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiMulticastRekeyStrict data.
 * set (* wtpWapiMulticastRekeyStrict_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiMulticastRekeyStrict_val_ptr ) = rowreq_ctx->data.wtpWapiMulticastRekeyStrict;

    return MFD_SUCCESS;
} /* wtpWapiMulticastRekeyStrict_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiPSKValue
 * wtpWapiPSKValue is subid 18 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.18
 * Description:
wtpWapiPSKValue.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiPSKValue.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiPSKValue_map(char **mib_wtpWapiPSKValue_val_ptr_ptr, size_t *mib_wtpWapiPSKValue_val_ptr_len_ptr, char *raw_wtpWapiPSKValue_val_ptr, size_t raw_wtpWapiPSKValue_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpWapiPSKValue_val_ptr);
    netsnmp_assert((NULL != mib_wtpWapiPSKValue_val_ptr_ptr) && (NULL != mib_wtpWapiPSKValue_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiPSKValue_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpWapiPSKValue non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpWapiPSKValue_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpWapiPSKValue_val_ptr_ptr) || (*mib_wtpWapiPSKValue_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpWapiPSKValue_val_ptr_ptr = realloc( *mib_wtpWapiPSKValue_val_ptr_ptr, converted_len * sizeof(**mib_wtpWapiPSKValue_val_ptr_ptr));
        if(NULL == *mib_wtpWapiPSKValue_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpWapiPSKValue_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpWapiPSKValue_val_ptr_ptr, raw_wtpWapiPSKValue_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpWapiPSKValue_map */

/**
 * Extract the current value of the wtpWapiPSKValue data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiPSKValue_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wtpWapiPSKValue_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wtpWapiPSKValue.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wtpWapiPSKValue_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wtpWapiPSKValue_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wtpWapiPSKValue_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, char **wtpWapiPSKValue_val_ptr_ptr, size_t *wtpWapiPSKValue_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != wtpWapiPSKValue_val_ptr_ptr) && (NULL != *wtpWapiPSKValue_val_ptr_ptr));
   netsnmp_assert( NULL != wtpWapiPSKValue_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiPSKValue_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiPSKValue data.
 * set (* wtpWapiPSKValue_val_ptr_ptr ) and (* wtpWapiPSKValue_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for wtpWapiPSKValue data
     */
    if ((NULL == (* wtpWapiPSKValue_val_ptr_ptr )) ||
        ((* wtpWapiPSKValue_val_ptr_len_ptr ) < (rowreq_ctx->data.wtpWapiPSKValue_len * sizeof((* wtpWapiPSKValue_val_ptr_ptr )[0])))) {
        /*
         * allocate space for wtpWapiPSKValue data
         */
        (* wtpWapiPSKValue_val_ptr_ptr ) = malloc(rowreq_ctx->data.wtpWapiPSKValue_len * sizeof((* wtpWapiPSKValue_val_ptr_ptr )[0]));
        if(NULL == (* wtpWapiPSKValue_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* wtpWapiPSKValue_val_ptr_len_ptr ) = rowreq_ctx->data.wtpWapiPSKValue_len * sizeof((* wtpWapiPSKValue_val_ptr_ptr )[0]);
    memcpy( (* wtpWapiPSKValue_val_ptr_ptr ), rowreq_ctx->data.wtpWapiPSKValue, (* wtpWapiPSKValue_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* wtpWapiPSKValue_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiPSKPassPhrase
 * wtpWapiPSKPassPhrase is subid 19 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.19
 * Description:
wtpWapiPSKPassPhrase.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiPSKPassPhrase.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiPSKPassPhrase_map(char **mib_wtpWapiPSKPassPhrase_val_ptr_ptr, size_t *mib_wtpWapiPSKPassPhrase_val_ptr_len_ptr, char *raw_wtpWapiPSKPassPhrase_val_ptr, size_t raw_wtpWapiPSKPassPhrase_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpWapiPSKPassPhrase_val_ptr);
    netsnmp_assert((NULL != mib_wtpWapiPSKPassPhrase_val_ptr_ptr) && (NULL != mib_wtpWapiPSKPassPhrase_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiPSKPassPhrase_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpWapiPSKPassPhrase non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpWapiPSKPassPhrase_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpWapiPSKPassPhrase_val_ptr_ptr) || (*mib_wtpWapiPSKPassPhrase_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpWapiPSKPassPhrase_val_ptr_ptr = realloc( *mib_wtpWapiPSKPassPhrase_val_ptr_ptr, converted_len * sizeof(**mib_wtpWapiPSKPassPhrase_val_ptr_ptr));
        if(NULL == *mib_wtpWapiPSKPassPhrase_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpWapiPSKPassPhrase_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpWapiPSKPassPhrase_val_ptr_ptr, raw_wtpWapiPSKPassPhrase_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpWapiPSKPassPhrase_map */

/**
 * Extract the current value of the wtpWapiPSKPassPhrase data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiPSKPassPhrase_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wtpWapiPSKPassPhrase_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wtpWapiPSKPassPhrase.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wtpWapiPSKPassPhrase_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wtpWapiPSKPassPhrase_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wtpWapiPSKPassPhrase_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, char **wtpWapiPSKPassPhrase_val_ptr_ptr, size_t *wtpWapiPSKPassPhrase_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != wtpWapiPSKPassPhrase_val_ptr_ptr) && (NULL != *wtpWapiPSKPassPhrase_val_ptr_ptr));
   netsnmp_assert( NULL != wtpWapiPSKPassPhrase_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiPSKPassPhrase_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiPSKPassPhrase data.
 * set (* wtpWapiPSKPassPhrase_val_ptr_ptr ) and (* wtpWapiPSKPassPhrase_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for wtpWapiPSKPassPhrase data
     */
    if ((NULL == (* wtpWapiPSKPassPhrase_val_ptr_ptr )) ||
        ((* wtpWapiPSKPassPhrase_val_ptr_len_ptr ) < (rowreq_ctx->data.wtpWapiPSKPassPhrase_len * sizeof((* wtpWapiPSKPassPhrase_val_ptr_ptr )[0])))) {
        /*
         * allocate space for wtpWapiPSKPassPhrase data
         */
        (* wtpWapiPSKPassPhrase_val_ptr_ptr ) = malloc(rowreq_ctx->data.wtpWapiPSKPassPhrase_len * sizeof((* wtpWapiPSKPassPhrase_val_ptr_ptr )[0]));
        if(NULL == (* wtpWapiPSKPassPhrase_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* wtpWapiPSKPassPhrase_val_ptr_len_ptr ) = rowreq_ctx->data.wtpWapiPSKPassPhrase_len * sizeof((* wtpWapiPSKPassPhrase_val_ptr_ptr )[0]);
    memcpy( (* wtpWapiPSKPassPhrase_val_ptr_ptr ), rowreq_ctx->data.wtpWapiPSKPassPhrase, (* wtpWapiPSKPassPhrase_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* wtpWapiPSKPassPhrase_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiCertificateUpdateCount
 * wtpWapiCertificateUpdateCount is subid 20 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.20
 * Description:
wtpWapiCertificateUpdateCount.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiCertificateUpdateCount.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiCertificateUpdateCount_map(u_long *mib_wtpWapiCertificateUpdateCount_val_ptr, u_long raw_wtpWapiCertificateUpdateCount_val)
{
    netsnmp_assert(NULL != mib_wtpWapiCertificateUpdateCount_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiCertificateUpdateCount_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiCertificateUpdateCount mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWapiCertificateUpdateCount_val_ptr) = raw_wtpWapiCertificateUpdateCount_val;

    return MFD_SUCCESS;
} /* wtpWapiCertificateUpdateCount_map */

/**
 * Extract the current value of the wtpWapiCertificateUpdateCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiCertificateUpdateCount_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiCertificateUpdateCount_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiCertificateUpdateCount_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiCertificateUpdateCount_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiCertificateUpdateCount_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiCertificateUpdateCount data.
 * set (* wtpWapiCertificateUpdateCount_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiCertificateUpdateCount_val_ptr ) = rowreq_ctx->data.wtpWapiCertificateUpdateCount;

    return MFD_SUCCESS;
} /* wtpWapiCertificateUpdateCount_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiMulticastUpdateCount
 * wtpWapiMulticastUpdateCount is subid 21 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.21
 * Description:
wtpWapiMulticastUpdateCount.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiMulticastUpdateCount.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiMulticastUpdateCount_map(u_long *mib_wtpWapiMulticastUpdateCount_val_ptr, u_long raw_wtpWapiMulticastUpdateCount_val)
{
    netsnmp_assert(NULL != mib_wtpWapiMulticastUpdateCount_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastUpdateCount_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiMulticastUpdateCount mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWapiMulticastUpdateCount_val_ptr) = raw_wtpWapiMulticastUpdateCount_val;

    return MFD_SUCCESS;
} /* wtpWapiMulticastUpdateCount_map */

/**
 * Extract the current value of the wtpWapiMulticastUpdateCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiMulticastUpdateCount_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiMulticastUpdateCount_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiMulticastUpdateCount_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiMulticastUpdateCount_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastUpdateCount_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiMulticastUpdateCount data.
 * set (* wtpWapiMulticastUpdateCount_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiMulticastUpdateCount_val_ptr ) = rowreq_ctx->data.wtpWapiMulticastUpdateCount;

    return MFD_SUCCESS;
} /* wtpWapiMulticastUpdateCount_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiUnicastUpdateCount
 * wtpWapiUnicastUpdateCount is subid 22 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.22
 * Description:
wtpWapiUnicastUpdateCount.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiUnicastUpdateCount.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiUnicastUpdateCount_map(u_long *mib_wtpWapiUnicastUpdateCount_val_ptr, u_long raw_wtpWapiUnicastUpdateCount_val)
{
    netsnmp_assert(NULL != mib_wtpWapiUnicastUpdateCount_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastUpdateCount_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiUnicastUpdateCount mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWapiUnicastUpdateCount_val_ptr) = raw_wtpWapiUnicastUpdateCount_val;

    return MFD_SUCCESS;
} /* wtpWapiUnicastUpdateCount_map */

/**
 * Extract the current value of the wtpWapiUnicastUpdateCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiUnicastUpdateCount_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiUnicastUpdateCount_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiUnicastUpdateCount_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiUnicastUpdateCount_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastUpdateCount_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiUnicastUpdateCount data.
 * set (* wtpWapiUnicastUpdateCount_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiUnicastUpdateCount_val_ptr ) = rowreq_ctx->data.wtpWapiUnicastUpdateCount;

    return MFD_SUCCESS;
} /* wtpWapiUnicastUpdateCount_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiMulticastCipherSize
 * wtpWapiMulticastCipherSize is subid 23 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.23
 * Description:
wtpWapiMulticastCipherSize.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiMulticastCipherSize.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiMulticastCipherSize_map(u_long *mib_wtpWapiMulticastCipherSize_val_ptr, u_long raw_wtpWapiMulticastCipherSize_val)
{
    netsnmp_assert(NULL != mib_wtpWapiMulticastCipherSize_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastCipherSize_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiMulticastCipherSize mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWapiMulticastCipherSize_val_ptr) = raw_wtpWapiMulticastCipherSize_val;

    return MFD_SUCCESS;
} /* wtpWapiMulticastCipherSize_map */

/**
 * Extract the current value of the wtpWapiMulticastCipherSize data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiMulticastCipherSize_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiMulticastCipherSize_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiMulticastCipherSize_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiMulticastCipherSize_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastCipherSize_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiMulticastCipherSize data.
 * set (* wtpWapiMulticastCipherSize_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiMulticastCipherSize_val_ptr ) = rowreq_ctx->data.wtpWapiMulticastCipherSize;

    return MFD_SUCCESS;
} /* wtpWapiMulticastCipherSize_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiBKLifetime
 * wtpWapiBKLifetime is subid 24 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.24
 * Description:
wtpWapiBKLifetime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiBKLifetime.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiBKLifetime_map(u_long *mib_wtpWapiBKLifetime_val_ptr, u_long raw_wtpWapiBKLifetime_val)
{
    netsnmp_assert(NULL != mib_wtpWapiBKLifetime_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiBKLifetime_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiBKLifetime mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWapiBKLifetime_val_ptr) = raw_wtpWapiBKLifetime_val;

    return MFD_SUCCESS;
} /* wtpWapiBKLifetime_map */

/**
 * Extract the current value of the wtpWapiBKLifetime data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiBKLifetime_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiBKLifetime_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiBKLifetime_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiBKLifetime_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiBKLifetime_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiBKLifetime data.
 * set (* wtpWapiBKLifetime_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiBKLifetime_val_ptr ) = rowreq_ctx->data.wtpWapiBKLifetime;

    return MFD_SUCCESS;
} /* wtpWapiBKLifetime_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiBKReauthThreshold
 * wtpWapiBKReauthThreshold is subid 25 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.25
 * Description:
wtpWapiBKReauthThreshold.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiBKReauthThreshold.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiBKReauthThreshold_map(u_long *mib_wtpWapiBKReauthThreshold_val_ptr, u_long raw_wtpWapiBKReauthThreshold_val)
{
    netsnmp_assert(NULL != mib_wtpWapiBKReauthThreshold_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiBKReauthThreshold_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiBKReauthThreshold mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWapiBKReauthThreshold_val_ptr) = raw_wtpWapiBKReauthThreshold_val;

    return MFD_SUCCESS;
} /* wtpWapiBKReauthThreshold_map */

/**
 * Extract the current value of the wtpWapiBKReauthThreshold data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiBKReauthThreshold_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiBKReauthThreshold_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiBKReauthThreshold_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiBKReauthThreshold_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiBKReauthThreshold_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiBKReauthThreshold data.
 * set (* wtpWapiBKReauthThreshold_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiBKReauthThreshold_val_ptr ) = rowreq_ctx->data.wtpWapiBKReauthThreshold;

    return MFD_SUCCESS;
} /* wtpWapiBKReauthThreshold_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiSATimeout
 * wtpWapiSATimeout is subid 26 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.26
 * Description:
wtpWapiSATimeout.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiSATimeout.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiSATimeout_map(u_long *mib_wtpWapiSATimeout_val_ptr, u_long raw_wtpWapiSATimeout_val)
{
    netsnmp_assert(NULL != mib_wtpWapiSATimeout_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiSATimeout_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiSATimeout mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWapiSATimeout_val_ptr) = raw_wtpWapiSATimeout_val;

    return MFD_SUCCESS;
} /* wtpWapiSATimeout_map */

/**
 * Extract the current value of the wtpWapiSATimeout data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiSATimeout_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiSATimeout_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiSATimeout_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiSATimeout_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiSATimeout_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiSATimeout data.
 * set (* wtpWapiSATimeout_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiSATimeout_val_ptr ) = rowreq_ctx->data.wtpWapiSATimeout;

    return MFD_SUCCESS;
} /* wtpWapiSATimeout_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiAuthSuiteSelected
 * wtpWapiAuthSuiteSelected is subid 27 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.27
 * Description:
wtpWapiAuthSuiteSelected.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiAuthSuiteSelected.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiAuthSuiteSelected_map(char **mib_wtpWapiAuthSuiteSelected_val_ptr_ptr, size_t *mib_wtpWapiAuthSuiteSelected_val_ptr_len_ptr, char *raw_wtpWapiAuthSuiteSelected_val_ptr, size_t raw_wtpWapiAuthSuiteSelected_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpWapiAuthSuiteSelected_val_ptr);
    netsnmp_assert((NULL != mib_wtpWapiAuthSuiteSelected_val_ptr_ptr) && (NULL != mib_wtpWapiAuthSuiteSelected_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiAuthSuiteSelected_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpWapiAuthSuiteSelected non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpWapiAuthSuiteSelected_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpWapiAuthSuiteSelected_val_ptr_ptr) || (*mib_wtpWapiAuthSuiteSelected_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpWapiAuthSuiteSelected_val_ptr_ptr = realloc( *mib_wtpWapiAuthSuiteSelected_val_ptr_ptr, converted_len * sizeof(**mib_wtpWapiAuthSuiteSelected_val_ptr_ptr));
        if(NULL == *mib_wtpWapiAuthSuiteSelected_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpWapiAuthSuiteSelected_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpWapiAuthSuiteSelected_val_ptr_ptr, raw_wtpWapiAuthSuiteSelected_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpWapiAuthSuiteSelected_map */

/**
 * Extract the current value of the wtpWapiAuthSuiteSelected data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiAuthSuiteSelected_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wtpWapiAuthSuiteSelected_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wtpWapiAuthSuiteSelected.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wtpWapiAuthSuiteSelected_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wtpWapiAuthSuiteSelected_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wtpWapiAuthSuiteSelected_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, char **wtpWapiAuthSuiteSelected_val_ptr_ptr, size_t *wtpWapiAuthSuiteSelected_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != wtpWapiAuthSuiteSelected_val_ptr_ptr) && (NULL != *wtpWapiAuthSuiteSelected_val_ptr_ptr));
   netsnmp_assert( NULL != wtpWapiAuthSuiteSelected_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiAuthSuiteSelected_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiAuthSuiteSelected data.
 * set (* wtpWapiAuthSuiteSelected_val_ptr_ptr ) and (* wtpWapiAuthSuiteSelected_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for wtpWapiAuthSuiteSelected data
     */
    if ((NULL == (* wtpWapiAuthSuiteSelected_val_ptr_ptr )) ||
        ((* wtpWapiAuthSuiteSelected_val_ptr_len_ptr ) < (rowreq_ctx->data.wtpWapiAuthSuiteSelected_len * sizeof((* wtpWapiAuthSuiteSelected_val_ptr_ptr )[0])))) {
        /*
         * allocate space for wtpWapiAuthSuiteSelected data
         */
        (* wtpWapiAuthSuiteSelected_val_ptr_ptr ) = malloc(rowreq_ctx->data.wtpWapiAuthSuiteSelected_len * sizeof((* wtpWapiAuthSuiteSelected_val_ptr_ptr )[0]));
        if(NULL == (* wtpWapiAuthSuiteSelected_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* wtpWapiAuthSuiteSelected_val_ptr_len_ptr ) = rowreq_ctx->data.wtpWapiAuthSuiteSelected_len * sizeof((* wtpWapiAuthSuiteSelected_val_ptr_ptr )[0]);
    memcpy( (* wtpWapiAuthSuiteSelected_val_ptr_ptr ), rowreq_ctx->data.wtpWapiAuthSuiteSelected, (* wtpWapiAuthSuiteSelected_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* wtpWapiAuthSuiteSelected_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiUnicastCipherSelected
 * wtpWapiUnicastCipherSelected is subid 28 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.28
 * Description:
wtpWapiUnicastCipherSelected.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiUnicastCipherSelected.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiUnicastCipherSelected_map(char **mib_wtpWapiUnicastCipherSelected_val_ptr_ptr, size_t *mib_wtpWapiUnicastCipherSelected_val_ptr_len_ptr, char *raw_wtpWapiUnicastCipherSelected_val_ptr, size_t raw_wtpWapiUnicastCipherSelected_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpWapiUnicastCipherSelected_val_ptr);
    netsnmp_assert((NULL != mib_wtpWapiUnicastCipherSelected_val_ptr_ptr) && (NULL != mib_wtpWapiUnicastCipherSelected_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastCipherSelected_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpWapiUnicastCipherSelected non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpWapiUnicastCipherSelected_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpWapiUnicastCipherSelected_val_ptr_ptr) || (*mib_wtpWapiUnicastCipherSelected_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpWapiUnicastCipherSelected_val_ptr_ptr = realloc( *mib_wtpWapiUnicastCipherSelected_val_ptr_ptr, converted_len * sizeof(**mib_wtpWapiUnicastCipherSelected_val_ptr_ptr));
        if(NULL == *mib_wtpWapiUnicastCipherSelected_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpWapiUnicastCipherSelected_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpWapiUnicastCipherSelected_val_ptr_ptr, raw_wtpWapiUnicastCipherSelected_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpWapiUnicastCipherSelected_map */

/**
 * Extract the current value of the wtpWapiUnicastCipherSelected data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiUnicastCipherSelected_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wtpWapiUnicastCipherSelected_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wtpWapiUnicastCipherSelected.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wtpWapiUnicastCipherSelected_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wtpWapiUnicastCipherSelected_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wtpWapiUnicastCipherSelected_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, char **wtpWapiUnicastCipherSelected_val_ptr_ptr, size_t *wtpWapiUnicastCipherSelected_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != wtpWapiUnicastCipherSelected_val_ptr_ptr) && (NULL != *wtpWapiUnicastCipherSelected_val_ptr_ptr));
   netsnmp_assert( NULL != wtpWapiUnicastCipherSelected_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastCipherSelected_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiUnicastCipherSelected data.
 * set (* wtpWapiUnicastCipherSelected_val_ptr_ptr ) and (* wtpWapiUnicastCipherSelected_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for wtpWapiUnicastCipherSelected data
     */
    if ((NULL == (* wtpWapiUnicastCipherSelected_val_ptr_ptr )) ||
        ((* wtpWapiUnicastCipherSelected_val_ptr_len_ptr ) < (rowreq_ctx->data.wtpWapiUnicastCipherSelected_len * sizeof((* wtpWapiUnicastCipherSelected_val_ptr_ptr )[0])))) {
        /*
         * allocate space for wtpWapiUnicastCipherSelected data
         */
        (* wtpWapiUnicastCipherSelected_val_ptr_ptr ) = malloc(rowreq_ctx->data.wtpWapiUnicastCipherSelected_len * sizeof((* wtpWapiUnicastCipherSelected_val_ptr_ptr )[0]));
        if(NULL == (* wtpWapiUnicastCipherSelected_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* wtpWapiUnicastCipherSelected_val_ptr_len_ptr ) = rowreq_ctx->data.wtpWapiUnicastCipherSelected_len * sizeof((* wtpWapiUnicastCipherSelected_val_ptr_ptr )[0]);
    memcpy( (* wtpWapiUnicastCipherSelected_val_ptr_ptr ), rowreq_ctx->data.wtpWapiUnicastCipherSelected, (* wtpWapiUnicastCipherSelected_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* wtpWapiUnicastCipherSelected_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiMulticastCipherSelected
 * wtpWapiMulticastCipherSelected is subid 29 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.29
 * Description:
wtpWapiMulticastCipherSelected.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiMulticastCipherSelected.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiMulticastCipherSelected_map(char **mib_wtpWapiMulticastCipherSelected_val_ptr_ptr, size_t *mib_wtpWapiMulticastCipherSelected_val_ptr_len_ptr, char *raw_wtpWapiMulticastCipherSelected_val_ptr, size_t raw_wtpWapiMulticastCipherSelected_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpWapiMulticastCipherSelected_val_ptr);
    netsnmp_assert((NULL != mib_wtpWapiMulticastCipherSelected_val_ptr_ptr) && (NULL != mib_wtpWapiMulticastCipherSelected_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastCipherSelected_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpWapiMulticastCipherSelected non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpWapiMulticastCipherSelected_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpWapiMulticastCipherSelected_val_ptr_ptr) || (*mib_wtpWapiMulticastCipherSelected_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpWapiMulticastCipherSelected_val_ptr_ptr = realloc( *mib_wtpWapiMulticastCipherSelected_val_ptr_ptr, converted_len * sizeof(**mib_wtpWapiMulticastCipherSelected_val_ptr_ptr));
        if(NULL == *mib_wtpWapiMulticastCipherSelected_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpWapiMulticastCipherSelected_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpWapiMulticastCipherSelected_val_ptr_ptr, raw_wtpWapiMulticastCipherSelected_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpWapiMulticastCipherSelected_map */

/**
 * Extract the current value of the wtpWapiMulticastCipherSelected data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiMulticastCipherSelected_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wtpWapiMulticastCipherSelected_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wtpWapiMulticastCipherSelected.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wtpWapiMulticastCipherSelected_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wtpWapiMulticastCipherSelected_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wtpWapiMulticastCipherSelected_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, char **wtpWapiMulticastCipherSelected_val_ptr_ptr, size_t *wtpWapiMulticastCipherSelected_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != wtpWapiMulticastCipherSelected_val_ptr_ptr) && (NULL != *wtpWapiMulticastCipherSelected_val_ptr_ptr));
   netsnmp_assert( NULL != wtpWapiMulticastCipherSelected_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastCipherSelected_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiMulticastCipherSelected data.
 * set (* wtpWapiMulticastCipherSelected_val_ptr_ptr ) and (* wtpWapiMulticastCipherSelected_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for wtpWapiMulticastCipherSelected data
     */
    if ((NULL == (* wtpWapiMulticastCipherSelected_val_ptr_ptr )) ||
        ((* wtpWapiMulticastCipherSelected_val_ptr_len_ptr ) < (rowreq_ctx->data.wtpWapiMulticastCipherSelected_len * sizeof((* wtpWapiMulticastCipherSelected_val_ptr_ptr )[0])))) {
        /*
         * allocate space for wtpWapiMulticastCipherSelected data
         */
        (* wtpWapiMulticastCipherSelected_val_ptr_ptr ) = malloc(rowreq_ctx->data.wtpWapiMulticastCipherSelected_len * sizeof((* wtpWapiMulticastCipherSelected_val_ptr_ptr )[0]));
        if(NULL == (* wtpWapiMulticastCipherSelected_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* wtpWapiMulticastCipherSelected_val_ptr_len_ptr ) = rowreq_ctx->data.wtpWapiMulticastCipherSelected_len * sizeof((* wtpWapiMulticastCipherSelected_val_ptr_ptr )[0]);
    memcpy( (* wtpWapiMulticastCipherSelected_val_ptr_ptr ), rowreq_ctx->data.wtpWapiMulticastCipherSelected, (* wtpWapiMulticastCipherSelected_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* wtpWapiMulticastCipherSelected_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiBKIDUsed
 * wtpWapiBKIDUsed is subid 30 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.30
 * Description:
wtpWapiBKIDUsed.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiBKIDUsed.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiBKIDUsed_map(char **mib_wtpWapiBKIDUsed_val_ptr_ptr, size_t *mib_wtpWapiBKIDUsed_val_ptr_len_ptr, char *raw_wtpWapiBKIDUsed_val_ptr, size_t raw_wtpWapiBKIDUsed_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpWapiBKIDUsed_val_ptr);
    netsnmp_assert((NULL != mib_wtpWapiBKIDUsed_val_ptr_ptr) && (NULL != mib_wtpWapiBKIDUsed_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiBKIDUsed_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpWapiBKIDUsed non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpWapiBKIDUsed_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpWapiBKIDUsed_val_ptr_ptr) || (*mib_wtpWapiBKIDUsed_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpWapiBKIDUsed_val_ptr_ptr = realloc( *mib_wtpWapiBKIDUsed_val_ptr_ptr, converted_len * sizeof(**mib_wtpWapiBKIDUsed_val_ptr_ptr));
        if(NULL == *mib_wtpWapiBKIDUsed_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpWapiBKIDUsed_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpWapiBKIDUsed_val_ptr_ptr, raw_wtpWapiBKIDUsed_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpWapiBKIDUsed_map */

/**
 * Extract the current value of the wtpWapiBKIDUsed data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiBKIDUsed_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wtpWapiBKIDUsed_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wtpWapiBKIDUsed.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wtpWapiBKIDUsed_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wtpWapiBKIDUsed_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wtpWapiBKIDUsed_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, char **wtpWapiBKIDUsed_val_ptr_ptr, size_t *wtpWapiBKIDUsed_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != wtpWapiBKIDUsed_val_ptr_ptr) && (NULL != *wtpWapiBKIDUsed_val_ptr_ptr));
   netsnmp_assert( NULL != wtpWapiBKIDUsed_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiBKIDUsed_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiBKIDUsed data.
 * set (* wtpWapiBKIDUsed_val_ptr_ptr ) and (* wtpWapiBKIDUsed_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for wtpWapiBKIDUsed data
     */
    if ((NULL == (* wtpWapiBKIDUsed_val_ptr_ptr )) ||
        ((* wtpWapiBKIDUsed_val_ptr_len_ptr ) < (rowreq_ctx->data.wtpWapiBKIDUsed_len * sizeof((* wtpWapiBKIDUsed_val_ptr_ptr )[0])))) {
        /*
         * allocate space for wtpWapiBKIDUsed data
         */
        (* wtpWapiBKIDUsed_val_ptr_ptr ) = malloc(rowreq_ctx->data.wtpWapiBKIDUsed_len * sizeof((* wtpWapiBKIDUsed_val_ptr_ptr )[0]));
        if(NULL == (* wtpWapiBKIDUsed_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* wtpWapiBKIDUsed_val_ptr_len_ptr ) = rowreq_ctx->data.wtpWapiBKIDUsed_len * sizeof((* wtpWapiBKIDUsed_val_ptr_ptr )[0]);
    memcpy( (* wtpWapiBKIDUsed_val_ptr_ptr ), rowreq_ctx->data.wtpWapiBKIDUsed, (* wtpWapiBKIDUsed_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* wtpWapiBKIDUsed_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiAuthSuiteRequested
 * wtpWapiAuthSuiteRequested is subid 31 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.31
 * Description:
wtpWapiAuthSuiteRequested.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiAuthSuiteRequested.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiAuthSuiteRequested_map(char **mib_wtpWapiAuthSuiteRequested_val_ptr_ptr, size_t *mib_wtpWapiAuthSuiteRequested_val_ptr_len_ptr, char *raw_wtpWapiAuthSuiteRequested_val_ptr, size_t raw_wtpWapiAuthSuiteRequested_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpWapiAuthSuiteRequested_val_ptr);
    netsnmp_assert((NULL != mib_wtpWapiAuthSuiteRequested_val_ptr_ptr) && (NULL != mib_wtpWapiAuthSuiteRequested_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiAuthSuiteRequested_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpWapiAuthSuiteRequested non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpWapiAuthSuiteRequested_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpWapiAuthSuiteRequested_val_ptr_ptr) || (*mib_wtpWapiAuthSuiteRequested_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpWapiAuthSuiteRequested_val_ptr_ptr = realloc( *mib_wtpWapiAuthSuiteRequested_val_ptr_ptr, converted_len * sizeof(**mib_wtpWapiAuthSuiteRequested_val_ptr_ptr));
        if(NULL == *mib_wtpWapiAuthSuiteRequested_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpWapiAuthSuiteRequested_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpWapiAuthSuiteRequested_val_ptr_ptr, raw_wtpWapiAuthSuiteRequested_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpWapiAuthSuiteRequested_map */

/**
 * Extract the current value of the wtpWapiAuthSuiteRequested data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiAuthSuiteRequested_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wtpWapiAuthSuiteRequested_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wtpWapiAuthSuiteRequested.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wtpWapiAuthSuiteRequested_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wtpWapiAuthSuiteRequested_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wtpWapiAuthSuiteRequested_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, char **wtpWapiAuthSuiteRequested_val_ptr_ptr, size_t *wtpWapiAuthSuiteRequested_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != wtpWapiAuthSuiteRequested_val_ptr_ptr) && (NULL != *wtpWapiAuthSuiteRequested_val_ptr_ptr));
   netsnmp_assert( NULL != wtpWapiAuthSuiteRequested_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiAuthSuiteRequested_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiAuthSuiteRequested data.
 * set (* wtpWapiAuthSuiteRequested_val_ptr_ptr ) and (* wtpWapiAuthSuiteRequested_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for wtpWapiAuthSuiteRequested data
     */
    if ((NULL == (* wtpWapiAuthSuiteRequested_val_ptr_ptr )) ||
        ((* wtpWapiAuthSuiteRequested_val_ptr_len_ptr ) < (rowreq_ctx->data.wtpWapiAuthSuiteRequested_len * sizeof((* wtpWapiAuthSuiteRequested_val_ptr_ptr )[0])))) {
        /*
         * allocate space for wtpWapiAuthSuiteRequested data
         */
        (* wtpWapiAuthSuiteRequested_val_ptr_ptr ) = malloc(rowreq_ctx->data.wtpWapiAuthSuiteRequested_len * sizeof((* wtpWapiAuthSuiteRequested_val_ptr_ptr )[0]));
        if(NULL == (* wtpWapiAuthSuiteRequested_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* wtpWapiAuthSuiteRequested_val_ptr_len_ptr ) = rowreq_ctx->data.wtpWapiAuthSuiteRequested_len * sizeof((* wtpWapiAuthSuiteRequested_val_ptr_ptr )[0]);
    memcpy( (* wtpWapiAuthSuiteRequested_val_ptr_ptr ), rowreq_ctx->data.wtpWapiAuthSuiteRequested, (* wtpWapiAuthSuiteRequested_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* wtpWapiAuthSuiteRequested_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiUnicastCipherRequested
 * wtpWapiUnicastCipherRequested is subid 32 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.32
 * Description:
wtpWapiUnicastCipherRequested.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiUnicastCipherRequested.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiUnicastCipherRequested_map(char **mib_wtpWapiUnicastCipherRequested_val_ptr_ptr, size_t *mib_wtpWapiUnicastCipherRequested_val_ptr_len_ptr, char *raw_wtpWapiUnicastCipherRequested_val_ptr, size_t raw_wtpWapiUnicastCipherRequested_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpWapiUnicastCipherRequested_val_ptr);
    netsnmp_assert((NULL != mib_wtpWapiUnicastCipherRequested_val_ptr_ptr) && (NULL != mib_wtpWapiUnicastCipherRequested_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastCipherRequested_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpWapiUnicastCipherRequested non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpWapiUnicastCipherRequested_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpWapiUnicastCipherRequested_val_ptr_ptr) || (*mib_wtpWapiUnicastCipherRequested_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpWapiUnicastCipherRequested_val_ptr_ptr = realloc( *mib_wtpWapiUnicastCipherRequested_val_ptr_ptr, converted_len * sizeof(**mib_wtpWapiUnicastCipherRequested_val_ptr_ptr));
        if(NULL == *mib_wtpWapiUnicastCipherRequested_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpWapiUnicastCipherRequested_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpWapiUnicastCipherRequested_val_ptr_ptr, raw_wtpWapiUnicastCipherRequested_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpWapiUnicastCipherRequested_map */

/**
 * Extract the current value of the wtpWapiUnicastCipherRequested data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiUnicastCipherRequested_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wtpWapiUnicastCipherRequested_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wtpWapiUnicastCipherRequested.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wtpWapiUnicastCipherRequested_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wtpWapiUnicastCipherRequested_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wtpWapiUnicastCipherRequested_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, char **wtpWapiUnicastCipherRequested_val_ptr_ptr, size_t *wtpWapiUnicastCipherRequested_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != wtpWapiUnicastCipherRequested_val_ptr_ptr) && (NULL != *wtpWapiUnicastCipherRequested_val_ptr_ptr));
   netsnmp_assert( NULL != wtpWapiUnicastCipherRequested_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiUnicastCipherRequested_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiUnicastCipherRequested data.
 * set (* wtpWapiUnicastCipherRequested_val_ptr_ptr ) and (* wtpWapiUnicastCipherRequested_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for wtpWapiUnicastCipherRequested data
     */
    if ((NULL == (* wtpWapiUnicastCipherRequested_val_ptr_ptr )) ||
        ((* wtpWapiUnicastCipherRequested_val_ptr_len_ptr ) < (rowreq_ctx->data.wtpWapiUnicastCipherRequested_len * sizeof((* wtpWapiUnicastCipherRequested_val_ptr_ptr )[0])))) {
        /*
         * allocate space for wtpWapiUnicastCipherRequested data
         */
        (* wtpWapiUnicastCipherRequested_val_ptr_ptr ) = malloc(rowreq_ctx->data.wtpWapiUnicastCipherRequested_len * sizeof((* wtpWapiUnicastCipherRequested_val_ptr_ptr )[0]));
        if(NULL == (* wtpWapiUnicastCipherRequested_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* wtpWapiUnicastCipherRequested_val_ptr_len_ptr ) = rowreq_ctx->data.wtpWapiUnicastCipherRequested_len * sizeof((* wtpWapiUnicastCipherRequested_val_ptr_ptr )[0]);
    memcpy( (* wtpWapiUnicastCipherRequested_val_ptr_ptr ), rowreq_ctx->data.wtpWapiUnicastCipherRequested, (* wtpWapiUnicastCipherRequested_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* wtpWapiUnicastCipherRequested_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIConfigEntry.wtpWapiMulticastCipherRequested
 * wtpWapiMulticastCipherRequested is subid 33 of dot11WtpWAPIConfigEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.10.10.1.33
 * Description:
wtpWapiMulticastCipherRequested.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiMulticastCipherRequested.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiMulticastCipherRequested_map(char **mib_wtpWapiMulticastCipherRequested_val_ptr_ptr, size_t *mib_wtpWapiMulticastCipherRequested_val_ptr_len_ptr, char *raw_wtpWapiMulticastCipherRequested_val_ptr, size_t raw_wtpWapiMulticastCipherRequested_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpWapiMulticastCipherRequested_val_ptr);
    netsnmp_assert((NULL != mib_wtpWapiMulticastCipherRequested_val_ptr_ptr) && (NULL != mib_wtpWapiMulticastCipherRequested_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastCipherRequested_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpWapiMulticastCipherRequested non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpWapiMulticastCipherRequested_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpWapiMulticastCipherRequested_val_ptr_ptr) || (*mib_wtpWapiMulticastCipherRequested_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpWapiMulticastCipherRequested_val_ptr_ptr = realloc( *mib_wtpWapiMulticastCipherRequested_val_ptr_ptr, converted_len * sizeof(**mib_wtpWapiMulticastCipherRequested_val_ptr_ptr));
        if(NULL == *mib_wtpWapiMulticastCipherRequested_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpWapiMulticastCipherRequested_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpWapiMulticastCipherRequested_val_ptr_ptr, raw_wtpWapiMulticastCipherRequested_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpWapiMulticastCipherRequested_map */

/**
 * Extract the current value of the wtpWapiMulticastCipherRequested data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiMulticastCipherRequested_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wtpWapiMulticastCipherRequested_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wtpWapiMulticastCipherRequested.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wtpWapiMulticastCipherRequested_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wtpWapiMulticastCipherRequested_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wtpWapiMulticastCipherRequested_get( dot11WtpWAPIConfigTable_rowreq_ctx *rowreq_ctx, char **wtpWapiMulticastCipherRequested_val_ptr_ptr, size_t *wtpWapiMulticastCipherRequested_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != wtpWapiMulticastCipherRequested_val_ptr_ptr) && (NULL != *wtpWapiMulticastCipherRequested_val_ptr_ptr));
   netsnmp_assert( NULL != wtpWapiMulticastCipherRequested_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIConfigTable:wtpWapiMulticastCipherRequested_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiMulticastCipherRequested data.
 * set (* wtpWapiMulticastCipherRequested_val_ptr_ptr ) and (* wtpWapiMulticastCipherRequested_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for wtpWapiMulticastCipherRequested data
     */
    if ((NULL == (* wtpWapiMulticastCipherRequested_val_ptr_ptr )) ||
        ((* wtpWapiMulticastCipherRequested_val_ptr_len_ptr ) < (rowreq_ctx->data.wtpWapiMulticastCipherRequested_len * sizeof((* wtpWapiMulticastCipherRequested_val_ptr_ptr )[0])))) {
        /*
         * allocate space for wtpWapiMulticastCipherRequested data
         */
        (* wtpWapiMulticastCipherRequested_val_ptr_ptr ) = malloc(rowreq_ctx->data.wtpWapiMulticastCipherRequested_len * sizeof((* wtpWapiMulticastCipherRequested_val_ptr_ptr )[0]));
        if(NULL == (* wtpWapiMulticastCipherRequested_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* wtpWapiMulticastCipherRequested_val_ptr_len_ptr ) = rowreq_ctx->data.wtpWapiMulticastCipherRequested_len * sizeof((* wtpWapiMulticastCipherRequested_val_ptr_ptr )[0]);
    memcpy( (* wtpWapiMulticastCipherRequested_val_ptr_ptr ), rowreq_ctx->data.wtpWapiMulticastCipherRequested, (* wtpWapiMulticastCipherRequested_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* wtpWapiMulticastCipherRequested_get */



/** @} */
