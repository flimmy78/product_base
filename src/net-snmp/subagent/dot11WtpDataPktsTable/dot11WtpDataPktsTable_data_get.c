/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.18.2.1 $ of : mfd-data-get.m2c,v $ 
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "dot11WtpDataPktsTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement dot11WtpDataPktsTable get routines.
 * TODO:240:M: Implement dot11WtpDataPktsTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table dot11WtpDataPktsTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * dot11WtpDataPktsTable is subid 3 of wtpStats.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.3, length: 12
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement dot11WtpDataPktsTable data context functions.
 */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpInfoEntry.wtpMacAddr
 * wtpMacAddr is subid 1 of dot11WtpInfoEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.1.1.1.1
 * Description:
AP mac.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is Dot11BaseWtpIdTC (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max )
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpMacAddr.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpMacAddr_dot11WtpDataPktsTable_map(char **mib_wtpMacAddr_val_ptr_ptr, size_t *mib_wtpMacAddr_val_ptr_len_ptr, char *raw_wtpMacAddr_val_ptr, size_t raw_wtpMacAddr_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpMacAddr_val_ptr);
    netsnmp_assert((NULL != mib_wtpMacAddr_val_ptr_ptr) && (NULL != mib_wtpMacAddr_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpMacAddr_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpMacAddr non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpMacAddr_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpMacAddr_val_ptr_ptr) || (*mib_wtpMacAddr_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpMacAddr_val_ptr_ptr = realloc( *mib_wtpMacAddr_val_ptr_ptr, converted_len * sizeof(**mib_wtpMacAddr_val_ptr_ptr));
        if(NULL == *mib_wtpMacAddr_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpMacAddr_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpMacAddr_val_ptr_ptr, raw_wtpMacAddr_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpMacAddr_map */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
dot11WtpDataPktsTable_indexes_set_tbl_idx(dot11WtpDataPktsTable_mib_index *tbl_idx, char *wtpMacAddr_val_ptr,  size_t wtpMacAddr_val_ptr_len)
{
    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:dot11WtpDataPktsTable_indexes_set_tbl_idx","called\n"));

    /* wtpMacAddr(1)/Dot11BaseWtpIdTC/ASN_OCTET_STR/char(char)//L/A/w/e/r/d/h */
     tbl_idx->wtpMacAddr_len = sizeof(tbl_idx->wtpMacAddr);
    /*
     * make sure there is enough space for wtpMacAddr data
     */
    if ((NULL == tbl_idx->wtpMacAddr) ||
        (tbl_idx->wtpMacAddr_len < (wtpMacAddr_val_ptr_len * sizeof(tbl_idx->wtpMacAddr[0])))) {
        snmp_log(LOG_ERR,"not enough space for value\n");
        return MFD_ERROR;
    }
    tbl_idx->wtpMacAddr_len = wtpMacAddr_val_ptr_len * sizeof(tbl_idx->wtpMacAddr[0]);
    memcpy( tbl_idx->wtpMacAddr, wtpMacAddr_val_ptr, tbl_idx->wtpMacAddr_len );
    

    return MFD_SUCCESS;
} /* dot11WtpDataPktsTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
dot11WtpDataPktsTable_indexes_set(dot11WtpDataPktsTable_rowreq_ctx *rowreq_ctx, char *wtpMacAddr_val_ptr,  size_t wtpMacAddr_val_ptr_len)
{
    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:dot11WtpDataPktsTable_indexes_set","called\n"));

    if(MFD_SUCCESS != dot11WtpDataPktsTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
                                   , wtpMacAddr_val_ptr, wtpMacAddr_val_ptr_len
           ))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if(0 != dot11WtpDataPktsTable_index_to_oid(&rowreq_ctx->oid_idx,
                                    &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* dot11WtpDataPktsTable_indexes_set */


/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpDataPktsEntry.wtpWirelessMacRxAllByte
 * wtpWirelessMacRxAllByte is subid 1 of dot11WtpDataPktsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.3.1.1
 * Description:
On the wireless side,the received right bytes of package in the MAC level.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessMacRxAllByte.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessMacRxAllByte_map(unsigned long long *mib_wtpWirelessMacRxAllByte_val_ptr, unsigned long long raw_wtpWirelessMacRxAllByte_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessMacRxAllByte_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWirelessMacRxAllByte_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessMacRxAllByte mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWirelessMacRxAllByte_val_ptr) = raw_wtpWirelessMacRxAllByte_val;

    return MFD_SUCCESS;
} /* wtpWirelessMacRxAllByte_map */

/**
 * Extract the current value of the wtpWirelessMacRxAllByte data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessMacRxAllByte_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelessMacRxAllByte_get( dot11WtpDataPktsTable_rowreq_ctx *rowreq_ctx, unsigned long long * wtpWirelessMacRxAllByte_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelessMacRxAllByte_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWirelessMacRxAllByte_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessMacRxAllByte data.
 * set (* wtpWirelessMacRxAllByte_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWirelessMacRxAllByte_val_ptr ) = rowreq_ctx->data.wtpWirelessMacRxAllByte;

    return MFD_SUCCESS;
} /* wtpWirelessMacRxAllByte_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpDataPktsEntry.wtpWirelessMacTxAllByte
 * wtpWirelessMacTxAllByte is subid 2 of dot11WtpDataPktsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.3.1.2
 * Description:
On the wireless side,all the sent bytes of package in the MAC level.(KB)
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessMacTxAllByte.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessMacTxAllByte_map(unsigned long long *mib_wtpWirelessMacTxAllByte_val_ptr, unsigned long long raw_wtpWirelessMacTxAllByte_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessMacTxAllByte_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWirelessMacTxAllByte_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessMacTxAllByte mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWirelessMacTxAllByte_val_ptr) = raw_wtpWirelessMacTxAllByte_val;

    return MFD_SUCCESS;
} /* wtpWirelessMacTxAllByte_map */

/**
 * Extract the current value of the wtpWirelessMacTxAllByte data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessMacTxAllByte_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelessMacTxAllByte_get( dot11WtpDataPktsTable_rowreq_ctx *rowreq_ctx, unsigned long long * wtpWirelessMacTxAllByte_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelessMacTxAllByte_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWirelessMacTxAllByte_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessMacTxAllByte data.
 * set (* wtpWirelessMacTxAllByte_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWirelessMacTxAllByte_val_ptr ) = rowreq_ctx->data.wtpWirelessMacTxAllByte;

    return MFD_SUCCESS;
} /* wtpWirelessMacTxAllByte_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpDataPktsEntry.wtpWirelessMacRxPack
 * wtpWirelessMacRxPack is subid 3 of dot11WtpDataPktsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.3.1.3
 * Description:
On the wireless side,all the received packages in the MAC level.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessMacRxPack.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessMacRxPack_map(u_long *mib_wtpWirelessMacRxPack_val_ptr, u_long raw_wtpWirelessMacRxPack_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessMacRxPack_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWirelessMacRxPack_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessMacRxPack mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWirelessMacRxPack_val_ptr) = raw_wtpWirelessMacRxPack_val;

    return MFD_SUCCESS;
} /* wtpWirelessMacRxPack_map */

/**
 * Extract the current value of the wtpWirelessMacRxPack data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessMacRxPack_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelessMacRxPack_get( dot11WtpDataPktsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWirelessMacRxPack_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelessMacRxPack_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWirelessMacRxPack_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessMacRxPack data.
 * set (* wtpWirelessMacRxPack_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWirelessMacRxPack_val_ptr ) = rowreq_ctx->data.wtpWirelessMacRxPack;

    return MFD_SUCCESS;
} /* wtpWirelessMacRxPack_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpDataPktsEntry.wtpWirelessMacRxErrPack
 * wtpWirelessMacRxErrPack is subid 4 of dot11WtpDataPktsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.3.1.4
 * Description:
On the wireless side,the received error package in the MAC level.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessMacRxErrPack.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessMacRxErrPack_map(u_long *mib_wtpWirelessMacRxErrPack_val_ptr, u_long raw_wtpWirelessMacRxErrPack_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessMacRxErrPack_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWirelessMacRxErrPack_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessMacRxErrPack mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWirelessMacRxErrPack_val_ptr) = raw_wtpWirelessMacRxErrPack_val;

    return MFD_SUCCESS;
} /* wtpWirelessMacRxErrPack_map */

/**
 * Extract the current value of the wtpWirelessMacRxErrPack data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessMacRxErrPack_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelessMacRxErrPack_get( dot11WtpDataPktsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWirelessMacRxErrPack_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelessMacRxErrPack_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWirelessMacRxErrPack_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessMacRxErrPack data.
 * set (* wtpWirelessMacRxErrPack_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWirelessMacRxErrPack_val_ptr ) = rowreq_ctx->data.wtpWirelessMacRxErrPack;

    return MFD_SUCCESS;
} /* wtpWirelessMacRxErrPack_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpDataPktsEntry.wtpWiredMacRxAllByte
 * wtpWiredMacRxAllByte is subid 5 of dot11WtpDataPktsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.3.1.5
 * Description:
On the wire side,the received right bytes of package in the MAC level.(KB)
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWiredMacRxAllByte.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWiredMacRxAllByte_map(unsigned long long *mib_wtpWiredMacRxAllByte_val_ptr, unsigned long long raw_wtpWiredMacRxAllByte_val)
{
    netsnmp_assert(NULL != mib_wtpWiredMacRxAllByte_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWiredMacRxAllByte_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWiredMacRxAllByte mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWiredMacRxAllByte_val_ptr) = raw_wtpWiredMacRxAllByte_val;

    return MFD_SUCCESS;
} /* wtpWiredMacRxAllByte_map */

/**
 * Extract the current value of the wtpWiredMacRxAllByte data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWiredMacRxAllByte_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWiredMacRxAllByte_get( dot11WtpDataPktsTable_rowreq_ctx *rowreq_ctx, unsigned long long * wtpWiredMacRxAllByte_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWiredMacRxAllByte_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWiredMacRxAllByte_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWiredMacRxAllByte data.
 * set (* wtpWiredMacRxAllByte_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWiredMacRxAllByte_val_ptr ) = rowreq_ctx->data.wtpWiredMacRxAllByte;

    return MFD_SUCCESS;
} /* wtpWiredMacRxAllByte_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpDataPktsEntry.wtpWiredMacTxAllByte
 * wtpWiredMacTxAllByte is subid 6 of dot11WtpDataPktsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.3.1.6
 * Description:
On the wire side,all the sent bytes of package in the MAC level.(KB)
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWiredMacTxAllByte.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWiredMacTxAllByte_map(unsigned long long *mib_wtpWiredMacTxAllByte_val_ptr, unsigned long long raw_wtpWiredMacTxAllByte_val)
{
    netsnmp_assert(NULL != mib_wtpWiredMacTxAllByte_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWiredMacTxAllByte_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWiredMacTxAllByte mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWiredMacTxAllByte_val_ptr) = raw_wtpWiredMacTxAllByte_val;

    return MFD_SUCCESS;
} /* wtpWiredMacTxAllByte_map */

/**
 * Extract the current value of the wtpWiredMacTxAllByte data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWiredMacTxAllByte_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWiredMacTxAllByte_get( dot11WtpDataPktsTable_rowreq_ctx *rowreq_ctx, unsigned long long * wtpWiredMacTxAllByte_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWiredMacTxAllByte_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWiredMacTxAllByte_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWiredMacTxAllByte data.
 * set (* wtpWiredMacTxAllByte_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWiredMacTxAllByte_val_ptr ) = rowreq_ctx->data.wtpWiredMacTxAllByte;

    return MFD_SUCCESS;
} /* wtpWiredMacTxAllByte_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpDataPktsEntry.wtpWiredMacRxErrPack
 * wtpWiredMacRxErrPack is subid 7 of dot11WtpDataPktsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.3.1.7
 * Description:
On the wire side,the received error number of package in the MAC level.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWiredMacRxErrPack.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWiredMacRxErrPack_map(u_long *mib_wtpWiredMacRxErrPack_val_ptr, u_long raw_wtpWiredMacRxErrPack_val)
{
    netsnmp_assert(NULL != mib_wtpWiredMacRxErrPack_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWiredMacRxErrPack_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWiredMacRxErrPack mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWiredMacRxErrPack_val_ptr) = raw_wtpWiredMacRxErrPack_val;

    return MFD_SUCCESS;
} /* wtpWiredMacRxErrPack_map */

/**
 * Extract the current value of the wtpWiredMacRxErrPack data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWiredMacRxErrPack_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWiredMacRxErrPack_get( dot11WtpDataPktsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWiredMacRxErrPack_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWiredMacRxErrPack_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWiredMacRxErrPack_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWiredMacRxErrPack data.
 * set (* wtpWiredMacRxErrPack_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWiredMacRxErrPack_val_ptr ) = rowreq_ctx->data.wtpWiredMacRxErrPack;

    return MFD_SUCCESS;
} /* wtpWiredMacRxErrPack_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpDataPktsEntry.wtpWirelessMacTxDropPkts
 * wtpWirelessMacTxDropPkts is subid 8 of dot11WtpDataPktsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.3.1.8
 * Description:
On the Wireless side,all the send drop package in the MAC level.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessMacTxDropPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessMacTxDropPkts_map(u_long *mib_wtpWirelessMacTxDropPkts_val_ptr, u_long raw_wtpWirelessMacTxDropPkts_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessMacTxDropPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWirelessMacTxDropPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessMacTxDropPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWirelessMacTxDropPkts_val_ptr) = raw_wtpWirelessMacTxDropPkts_val;

    return MFD_SUCCESS;
} /* wtpWirelessMacTxDropPkts_map */

/**
 * Extract the current value of the wtpWirelessMacTxDropPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessMacTxDropPkts_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelessMacTxDropPkts_get( dot11WtpDataPktsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWirelessMacTxDropPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelessMacTxDropPkts_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWirelessMacTxDropPkts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessMacTxDropPkts data.
 * set (* wtpWirelessMacTxDropPkts_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWirelessMacTxDropPkts_val_ptr ) = rowreq_ctx->data.wtpWirelessMacTxDropPkts;

    return MFD_SUCCESS;
} /* wtpWirelessMacTxDropPkts_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpDataPktsEntry.wtpWirelessMacTxPack
 * wtpWirelessMacTxPack is subid 9 of dot11WtpDataPktsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.3.1.9
 * Description:
On the wireless side,the send  number of package in the MAC level.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessMacTxPack.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessMacTxPack_map(u_long *mib_wtpWirelessMacTxPack_val_ptr, u_long raw_wtpWirelessMacTxPack_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessMacTxPack_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWirelessMacTxPack_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessMacTxPack mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWirelessMacTxPack_val_ptr) = raw_wtpWirelessMacTxPack_val;

    return MFD_SUCCESS;
} /* wtpWirelessMacTxPack_map */

/**
 * Extract the current value of the wtpWirelessMacTxPack data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessMacTxPack_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelessMacTxPack_get( dot11WtpDataPktsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWirelessMacTxPack_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelessMacTxPack_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWirelessMacTxPack_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessMacTxPack data.
 * set (* wtpWirelessMacTxPack_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWirelessMacTxPack_val_ptr ) = rowreq_ctx->data.wtpWirelessMacTxPack;

    return MFD_SUCCESS;
} /* wtpWirelessMacTxPack_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpDataPktsEntry.wtpWirelessMacTxErrPack
 * wtpWirelessMacTxErrPack is subid 10 of dot11WtpDataPktsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.3.1.10
 * Description:
On the wireless side,the send error package in the MAC level.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessMacTxErrPack.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessMacTxErrPack_map(u_long *mib_wtpWirelessMacTxErrPack_val_ptr, u_long raw_wtpWirelessMacTxErrPack_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessMacTxErrPack_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWirelessMacTxErrPack_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessMacTxErrPack mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWirelessMacTxErrPack_val_ptr) = raw_wtpWirelessMacTxErrPack_val;

    return MFD_SUCCESS;
} /* wtpWirelessMacTxErrPack_map */

/**
 * Extract the current value of the wtpWirelessMacTxErrPack data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessMacTxErrPack_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelessMacTxErrPack_get( dot11WtpDataPktsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWirelessMacTxErrPack_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelessMacTxErrPack_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWirelessMacTxErrPack_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessMacTxErrPack data.
 * set (* wtpWirelessMacTxErrPack_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWirelessMacTxErrPack_val_ptr ) = rowreq_ctx->data.wtpWirelessMacTxErrPack;

    return MFD_SUCCESS;
} /* wtpWirelessMacTxErrPack_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpDataPktsEntry.wtpWirelessMacRxRightPack
 * wtpWirelessMacRxRightPack is subid 11 of dot11WtpDataPktsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.3.1.11
 * Description:
On the wireless side,the received right package in the MAC level.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessMacRxRightPack.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessMacRxRightPack_map(u_long *mib_wtpWirelessMacRxRightPack_val_ptr, u_long raw_wtpWirelessMacRxRightPack_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessMacRxRightPack_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWirelessMacRxRightPack_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessMacRxRightPack mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWirelessMacRxRightPack_val_ptr) = raw_wtpWirelessMacRxRightPack_val;

    return MFD_SUCCESS;
} /* wtpWirelessMacRxRightPack_map */

/**
 * Extract the current value of the wtpWirelessMacRxRightPack data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessMacRxRightPack_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelessMacRxRightPack_get( dot11WtpDataPktsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWirelessMacRxRightPack_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelessMacRxRightPack_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWirelessMacRxRightPack_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessMacRxRightPack data.
 * set (* wtpWirelessMacRxRightPack_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWirelessMacRxRightPack_val_ptr ) = rowreq_ctx->data.wtpWirelessMacRxRightPack;

    return MFD_SUCCESS;
} /* wtpWirelessMacRxRightPack_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpDataPktsEntry.wtpWirelessMacTxRightPack
 * wtpWirelessMacTxRightPack is subid 12 of dot11WtpDataPktsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.3.1.12
 * Description:
On the wireless side,the send right package in the MAC level.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessMacTxRightPack.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessMacTxRightPack_map(u_long *mib_wtpWirelessMacTxRightPack_val_ptr, u_long raw_wtpWirelessMacTxRightPack_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessMacTxRightPack_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWirelessMacTxRightPack_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessMacTxRightPack mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWirelessMacTxRightPack_val_ptr) = raw_wtpWirelessMacTxRightPack_val;

    return MFD_SUCCESS;
} /* wtpWirelessMacTxRightPack_map */

/**
 * Extract the current value of the wtpWirelessMacTxRightPack data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessMacTxRightPack_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelessMacTxRightPack_get( dot11WtpDataPktsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWirelessMacTxRightPack_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelessMacTxRightPack_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWirelessMacTxRightPack_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessMacTxRightPack data.
 * set (* wtpWirelessMacTxRightPack_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWirelessMacTxRightPack_val_ptr ) = rowreq_ctx->data.wtpWirelessMacTxRightPack;

    return MFD_SUCCESS;
} /* wtpWirelessMacTxRightPack_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpDataPktsEntry.wtpWiredMacRxPack
 * wtpWiredMacRxPack is subid 13 of dot11WtpDataPktsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.3.1.13
 * Description:
On the wire side,the received  package in the MAC level.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWiredMacRxPack.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWiredMacRxPack_map(u_long *mib_wtpWiredMacRxPack_val_ptr, u_long raw_wtpWiredMacRxPack_val)
{
    netsnmp_assert(NULL != mib_wtpWiredMacRxPack_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWiredMacRxPack_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWiredMacRxPack mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWiredMacRxPack_val_ptr) = raw_wtpWiredMacRxPack_val;

    return MFD_SUCCESS;
} /* wtpWiredMacRxPack_map */

/**
 * Extract the current value of the wtpWiredMacRxPack data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWiredMacRxPack_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWiredMacRxPack_get( dot11WtpDataPktsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWiredMacRxPack_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWiredMacRxPack_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWiredMacRxPack_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWiredMacRxPack data.
 * set (* wtpWiredMacRxPack_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWiredMacRxPack_val_ptr ) = rowreq_ctx->data.wtpWiredMacRxPack;

    return MFD_SUCCESS;
} /* wtpWiredMacRxPack_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpDataPktsEntry.wtpWiredMacRxRightPack
 * wtpWiredMacRxRightPack is subid 14 of dot11WtpDataPktsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.3.1.14
 * Description:
On the wire side,the send right package in the MAC level.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWiredMacRxRightPack.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWiredMacRxRightPack_map(u_long *mib_wtpWiredMacRxRightPack_val_ptr, u_long raw_wtpWiredMacRxRightPack_val)
{
    netsnmp_assert(NULL != mib_wtpWiredMacRxRightPack_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWiredMacRxRightPack_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWiredMacRxRightPack mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWiredMacRxRightPack_val_ptr) = raw_wtpWiredMacRxRightPack_val;

    return MFD_SUCCESS;
} /* wtpWiredMacRxRightPack_map */

/**
 * Extract the current value of the wtpWiredMacRxRightPack data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWiredMacRxRightPack_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWiredMacRxRightPack_get( dot11WtpDataPktsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWiredMacRxRightPack_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWiredMacRxRightPack_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWiredMacRxRightPack_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWiredMacRxRightPack data.
 * set (* wtpWiredMacRxRightPack_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWiredMacRxRightPack_val_ptr ) = rowreq_ctx->data.wtpWiredMacRxRightPack;

    return MFD_SUCCESS;
} /* wtpWiredMacRxRightPack_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpDataPktsEntry.wtpWiredMacTxPack
 * wtpWiredMacTxPack is subid 15 of dot11WtpDataPktsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.3.1.15
 * Description:
On the wire side,the send  package in the MAC level.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWiredMacTxPack.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWiredMacTxPack_map(u_long *mib_wtpWiredMacTxPack_val_ptr, u_long raw_wtpWiredMacTxPack_val)
{
    netsnmp_assert(NULL != mib_wtpWiredMacTxPack_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWiredMacTxPack_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWiredMacTxPack mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWiredMacTxPack_val_ptr) = raw_wtpWiredMacTxPack_val;

    return MFD_SUCCESS;
} /* wtpWiredMacTxPack_map */

/**
 * Extract the current value of the wtpWiredMacTxPack data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWiredMacTxPack_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWiredMacTxPack_get( dot11WtpDataPktsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWiredMacTxPack_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWiredMacTxPack_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWiredMacTxPack_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWiredMacTxPack data.
 * set (* wtpWiredMacTxPack_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWiredMacTxPack_val_ptr ) = rowreq_ctx->data.wtpWiredMacTxPack;

    return MFD_SUCCESS;
} /* wtpWiredMacTxPack_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpDataPktsEntry.wtpWiredMacTxErrPack
 * wtpWiredMacTxErrPack is subid 16 of dot11WtpDataPktsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.3.1.16
 * Description:
On the wire side,the send error package in the MAC level.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWiredMacTxErrPack.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWiredMacTxErrPack_map(u_long *mib_wtpWiredMacTxErrPack_val_ptr, u_long raw_wtpWiredMacTxErrPack_val)
{
    netsnmp_assert(NULL != mib_wtpWiredMacTxErrPack_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWiredMacTxErrPack_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWiredMacTxErrPack mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWiredMacTxErrPack_val_ptr) = raw_wtpWiredMacTxErrPack_val;

    return MFD_SUCCESS;
} /* wtpWiredMacTxErrPack_map */

/**
 * Extract the current value of the wtpWiredMacTxErrPack data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWiredMacTxErrPack_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWiredMacTxErrPack_get( dot11WtpDataPktsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWiredMacTxErrPack_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWiredMacTxErrPack_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWiredMacTxErrPack_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWiredMacTxErrPack data.
 * set (* wtpWiredMacTxErrPack_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWiredMacTxErrPack_val_ptr ) = rowreq_ctx->data.wtpWiredMacTxErrPack;

    return MFD_SUCCESS;
} /* wtpWiredMacTxErrPack_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpDataPktsEntry.wtpWiredMacTxRightPack
 * wtpWiredMacTxRightPack is subid 17 of dot11WtpDataPktsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.3.1.17
 * Description:
On the wire side,the send right package in the MAC level.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWiredMacTxRightPack.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWiredMacTxRightPack_map(u_long *mib_wtpWiredMacTxRightPack_val_ptr, u_long raw_wtpWiredMacTxRightPack_val)
{
    netsnmp_assert(NULL != mib_wtpWiredMacTxRightPack_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWiredMacTxRightPack_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWiredMacTxRightPack mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWiredMacTxRightPack_val_ptr) = raw_wtpWiredMacTxRightPack_val;

    return MFD_SUCCESS;
} /* wtpWiredMacTxRightPack_map */

/**
 * Extract the current value of the wtpWiredMacTxRightPack data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWiredMacTxRightPack_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWiredMacTxRightPack_get( dot11WtpDataPktsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWiredMacTxRightPack_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWiredMacTxRightPack_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWiredMacTxRightPack_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWiredMacTxRightPack data.
 * set (* wtpWiredMacTxRightPack_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWiredMacTxRightPack_val_ptr ) = rowreq_ctx->data.wtpWiredMacTxRightPack;

    return MFD_SUCCESS;
} /* wtpWiredMacTxRightPack_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpDataPktsEntry.wtpWirelessradioRecvBytes
 * wtpWirelessradioRecvBytes is subid 18 of dot11WtpDataPktsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.3.1.18
 * Description:
On the wireless side,the send right package in the MAC level.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessradioRecvBytes.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessradioRecvBytes_map(u_long *mib_wtpWirelessradioRecvBytes_val_ptr, u_long raw_wtpWirelessradioRecvBytes_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessradioRecvBytes_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWirelessradioRecvBytes_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessradioRecvBytes mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWirelessradioRecvBytes_val_ptr) = raw_wtpWirelessradioRecvBytes_val;

    return MFD_SUCCESS;
} /* wtpWirelessradioRecvBytes_map */

/**
 * Extract the current value of the wtpWirelessradioRecvBytes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessradioRecvBytes_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelessradioRecvBytes_get( dot11WtpDataPktsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWirelessradioRecvBytes_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelessradioRecvBytes_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWirelessradioRecvBytes_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelessradioRecvBytes data.
 * set (* wtpWirelessradioRecvBytes_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWirelessradioRecvBytes_val_ptr ) = rowreq_ctx->data.wtpWirelessradioRecvBytes;

    return MFD_SUCCESS;
} /* wtpWirelessradioRecvBytes_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpDataPktsEntry.wtpWirelesscoreRecvBytes
 * wtpWirelesscoreRecvBytes is subid 19 of dot11WtpDataPktsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.3.1.19
 * Description:
On the wireless side,the send right package in the MAC level.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelesscoreRecvBytes.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelesscoreRecvBytes_map(unsigned long long *mib_wtpWirelesscoreRecvBytes_val_ptr, unsigned long long raw_wtpWirelesscoreRecvBytes_val)
{
    netsnmp_assert(NULL != mib_wtpWirelesscoreRecvBytes_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWirelesscoreRecvBytes_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelesscoreRecvBytes mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWirelesscoreRecvBytes_val_ptr) = raw_wtpWirelesscoreRecvBytes_val;

    return MFD_SUCCESS;
} /* wtpWirelesscoreRecvBytes_map */

/**
 * Extract the current value of the wtpWirelesscoreRecvBytes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelesscoreRecvBytes_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelesscoreRecvBytes_get( dot11WtpDataPktsTable_rowreq_ctx *rowreq_ctx, unsigned long long * wtpWirelesscoreRecvBytes_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelesscoreRecvBytes_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWirelesscoreRecvBytes_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWirelesscoreRecvBytes data.
 * set (* wtpWirelesscoreRecvBytes_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWirelesscoreRecvBytes_val_ptr ) = rowreq_ctx->data.wtpWirelesscoreRecvBytes;

    return MFD_SUCCESS;
} /* wtpWirelesscoreRecvBytes_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpDataPktsEntry.wtpWirelessRxFlowByte
 * wtpWirelessRxFlowByte is subid 20 of dot11WtpDataPktsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.3.1.20
 * Description:
The received bytes on the wireless side,the data is not cleared if AP restart.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessRxFlowByte.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessRxFlowByte_map(unsigned long long *mib_wtpWirelessRxFlowByte_val_ptr, unsigned long long raw_wtpWirelessRxFlowByte_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessRxFlowByte_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWirelessRxFlowByte_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessRxFlowByte mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWirelessRxFlowByte_val_ptr) = raw_wtpWirelessRxFlowByte_val;

    return MFD_SUCCESS;
} /* wtpWirelessRxFlowByte_map */

/**
 * Extract the current value of the wtpWirelessRxFlowByte data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessRxFlowByte_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelessRxFlowByte_get( dot11WtpDataPktsTable_rowreq_ctx *rowreq_ctx, unsigned long long * wtpWirelessRxFlowByte_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelessRxFlowByte_val_ptr );

/*
 * TODO:231:o: |-> copy wtpWirelessRxFlowByte data.
 * get (* wtpWirelessRxFlowByte_val_ptr ).low and (* wtpWirelessRxFlowByte_val_ptr ).high from rowreq_ctx->data
 */
    (* wtpWirelessRxFlowByte_val_ptr ) = rowreq_ctx->data.wtpWirelessRxFlowByte;
    //(* wtpWirelessRxFlowByte_val_ptr ).low = rowreq_ctx->data.wtpWirelessRxFlowByte.low;


    return MFD_SUCCESS;
} /* wtpWirelessRxFlowByte_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpDataPktsEntry.wtpWirelessSendFlowByte
 * wtpWirelessSendFlowByte is subid 21 of dot11WtpDataPktsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.2.3.1.21
 * Description:
The sent bytes on the wireless side,the data is not cleared if AP restart.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessSendFlowByte.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessTxFlowByte_map(unsigned long long *mib_wtpWirelessTxFlowByte_val_ptr, unsigned long long raw_wtpWirelessTxFlowByte_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessTxFlowByte_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpDataPktsTable:wtpWirelessTxFlowByte_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessTxFlowByte mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWirelessTxFlowByte_val_ptr) = raw_wtpWirelessTxFlowByte_val;

    return MFD_SUCCESS;
} /* wtpWirelessTxFlowByte_map */

/**
 * Extract the current value of the wtpWirelessTxFlowByte data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWirelessTxFlowByte_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWirelessTxFlowByte_get( dot11WtpDataPktsTable_rowreq_ctx *rowreq_ctx, unsigned long long * wtpWirelessTxFlowByte_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWirelessTxFlowByte_val_ptr );

/*
 * TODO:231:o: |-> copy wtpWirelessTxFlowByte data.
 * get (* wtpWirelessTxFlowByte_val_ptr ).low and (* wtpWirelessTxFlowByte_val_ptr ).high from rowreq_ctx->data
 */
    (* wtpWirelessTxFlowByte_val_ptr ) = rowreq_ctx->data.wtpWirelessTxFlowByte;
    //(* wtpWirelessTxFlowByte_val_ptr ).low = rowreq_ctx->data.wtpWirelessTxFlowByte.low;


    return MFD_SUCCESS;
} /* wtpWirelessTxFlowByte_get */



/** @} */
