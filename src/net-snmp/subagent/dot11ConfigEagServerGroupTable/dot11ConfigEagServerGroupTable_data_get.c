/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.18.2.1 $ of : mfd-data-get.m2c,v $ 
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "dot11ConfigEagServerGroupTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement dot11ConfigEagServerGroupTable get routines.
 * TODO:240:M: Implement dot11ConfigEagServerGroupTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table dot11ConfigEagServerGroupTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * dot11ConfigEagServerGroupTable is subid 4 of dot11ConfigPortalServerGroup.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.4, length: 12
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement dot11ConfigEagServerGroupTable data context functions.
 */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigEagServerGroupEntry.InstanceId
 * InstanceId is subid 1 of dot11ConfigEagServerGroupEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.4.1.1
 * Description:
eag instance index.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-InstanceId.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
InstanceId_eagservergroup_map(long *mib_InstanceId_val_ptr, long raw_InstanceId_val)
{
    netsnmp_assert(NULL != mib_InstanceId_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:InstanceId_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement InstanceId mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_InstanceId_val_ptr) = raw_InstanceId_val;

    return MFD_SUCCESS;
} /* InstanceId_map */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
dot11ConfigEagServerGroupTable_indexes_set_tbl_idx(dot11ConfigEagServerGroupTable_mib_index *tbl_idx, long InstanceId_val)
{
    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:dot11ConfigEagServerGroupTable_indexes_set_tbl_idx","called\n"));

    /* InstanceId(1)/INTEGER/ASN_INTEGER/long(long)//l/A/w/e/r/d/h */
    tbl_idx->InstanceId = InstanceId_val;
    

    return MFD_SUCCESS;
} /* dot11ConfigEagServerGroupTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
dot11ConfigEagServerGroupTable_indexes_set(dot11ConfigEagServerGroupTable_rowreq_ctx *rowreq_ctx, long InstanceId_val)
{
    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:dot11ConfigEagServerGroupTable_indexes_set","called\n"));

    if(MFD_SUCCESS != dot11ConfigEagServerGroupTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
                                   , InstanceId_val
           ))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if(0 != dot11ConfigEagServerGroupTable_index_to_oid(&rowreq_ctx->oid_idx,
                                    &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* dot11ConfigEagServerGroupTable_indexes_set */


/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigEagServerGroupEntry.RedirListen
 * RedirListen is subid 2 of dot11ConfigEagServerGroupEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.4.1.2
 * Description:
eag redirListen ip.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is IPADDR (based on perltype IPADDR)
 * The net-snmp type is ASN_IPADDRESS. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-RedirListen.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
RedirListen_eagservergroup_map(u_long *mib_RedirListen_val_ptr, u_long raw_RedirListen_val)
{
    netsnmp_assert(NULL != mib_RedirListen_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:RedirListen_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement RedirListen mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_RedirListen_val_ptr) = raw_RedirListen_val;

    return MFD_SUCCESS;
} /* RedirListen_map */

/**
 * Extract the current value of the RedirListen data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param RedirListen_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
RedirListen_get( dot11ConfigEagServerGroupTable_rowreq_ctx *rowreq_ctx, u_long * RedirListen_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != RedirListen_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:RedirListen_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the RedirListen data.
 * set (* RedirListen_val_ptr ) from rowreq_ctx->data
 */
    (* RedirListen_val_ptr ) = rowreq_ctx->data.RedirListen;

    return MFD_SUCCESS;
} /* RedirListen_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigEagServerGroupEntry.RedirListenPort
 * RedirListenPort is subid 3 of dot11ConfigEagServerGroupEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.4.1.3
 * Description:
eag redirListen Port.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-RedirListenPort.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
RedirListenPort_eagservergroup_map(long *mib_RedirListenPort_val_ptr, long raw_RedirListenPort_val)
{
    netsnmp_assert(NULL != mib_RedirListenPort_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:RedirListenPort_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement RedirListenPort mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_RedirListenPort_val_ptr) = raw_RedirListenPort_val;

    return MFD_SUCCESS;
} /* RedirListenPort_map */

/**
 * Extract the current value of the RedirListenPort data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param RedirListenPort_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
RedirListenPort_get( dot11ConfigEagServerGroupTable_rowreq_ctx *rowreq_ctx, long * RedirListenPort_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != RedirListenPort_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:RedirListenPort_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the RedirListenPort data.
 * set (* RedirListenPort_val_ptr ) from rowreq_ctx->data
 */
    (* RedirListenPort_val_ptr ) = rowreq_ctx->data.RedirListenPort;

    return MFD_SUCCESS;
} /* RedirListenPort_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigEagServerGroupEntry.EagEnable
 * EagEnable is subid 4 of dot11ConfigEagServerGroupEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.4.1.4
 * Description:
Whether to open the eag service.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-EagEnable.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
EagEnable_eagservergroup_map(u_long *mib_EagEnable_val_ptr, u_long raw_EagEnable_val)
{
    netsnmp_assert(NULL != mib_EagEnable_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:EagEnable_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement EagEnable enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_EagEnable_val) {
        case INTERNAL_EAGENABLE_TRUE:
             *mib_EagEnable_val_ptr = EAGENABLE_TRUE;
             break;

        case INTERNAL_EAGENABLE_FALSE:
             *mib_EagEnable_val_ptr = EAGENABLE_FALSE;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for EagEnable\n", raw_EagEnable_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* EagEnable_map */

/**
 * Extract the current value of the EagEnable data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param EagEnable_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
EagEnable_get( dot11ConfigEagServerGroupTable_rowreq_ctx *rowreq_ctx, u_long * EagEnable_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != EagEnable_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:EagEnable_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the EagEnable data.
 * set (* EagEnable_val_ptr ) from rowreq_ctx->data
 */
    (* EagEnable_val_ptr ) = rowreq_ctx->data.EagEnable;

    return MFD_SUCCESS;
} /* EagEnable_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigEagServerGroupEntry.IdleTimeFunction
 * IdleTimeFunction is subid 5 of dot11ConfigEagServerGroupEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.4.1.5
 * Description:
Whether to open the idle time function.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-IdleTimeFunction.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
IdleTimeFunction_eagservergroup_map(u_long *mib_IdleTimeFunction_val_ptr, u_long raw_IdleTimeFunction_val)
{
    netsnmp_assert(NULL != mib_IdleTimeFunction_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:IdleTimeFunction_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement IdleTimeFunction enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_IdleTimeFunction_val) {
        case INTERNAL_IDLETIMEFUNCTION_TRUE:
             *mib_IdleTimeFunction_val_ptr = IDLETIMEFUNCTION_TRUE;
             break;

        case INTERNAL_IDLETIMEFUNCTION_FALSE:
             *mib_IdleTimeFunction_val_ptr = IDLETIMEFUNCTION_FALSE;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for IdleTimeFunction\n", raw_IdleTimeFunction_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* IdleTimeFunction_map */

/**
 * Extract the current value of the IdleTimeFunction data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param IdleTimeFunction_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
IdleTimeFunction_get( dot11ConfigEagServerGroupTable_rowreq_ctx *rowreq_ctx, u_long * IdleTimeFunction_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != IdleTimeFunction_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:IdleTimeFunction_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the IdleTimeFunction data.
 * set (* IdleTimeFunction_val_ptr ) from rowreq_ctx->data
 */
    (* IdleTimeFunction_val_ptr ) = rowreq_ctx->data.IdleTimeFunction;

    return MFD_SUCCESS;
} /* IdleTimeFunction_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigEagServerGroupEntry.DebugLog
 * DebugLog is subid 6 of dot11ConfigEagServerGroupEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.4.1.6
 * Description:
Whether to open the debug log.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-DebugLog.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
DebugLog_eagservergroup_map(u_long *mib_DebugLog_val_ptr, u_long raw_DebugLog_val)
{
    netsnmp_assert(NULL != mib_DebugLog_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:DebugLog_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement DebugLog enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_DebugLog_val) {
        case INTERNAL_DEBUGLOG_TRUE:
             *mib_DebugLog_val_ptr = DEBUGLOG_TRUE;
             break;

        case INTERNAL_DEBUGLOG_FALSE:
             *mib_DebugLog_val_ptr = DEBUGLOG_FALSE;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for DebugLog\n", raw_DebugLog_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* DebugLog_map */

/**
 * Extract the current value of the DebugLog data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param DebugLog_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
DebugLog_get( dot11ConfigEagServerGroupTable_rowreq_ctx *rowreq_ctx, u_long * DebugLog_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != DebugLog_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:DebugLog_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the DebugLog data.
 * set (* DebugLog_val_ptr ) from rowreq_ctx->data
 */
    (* DebugLog_val_ptr ) = rowreq_ctx->data.DebugLog;

    return MFD_SUCCESS;
} /* DebugLog_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigEagServerGroupEntry.JustAllowWirelessUserLogin
 * JustAllowWirelessUserLogin is subid 7 of dot11ConfigEagServerGroupEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.4.1.7
 * Description:
Just Allow Wireless User Login.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-JustAllowWirelessUserLogin.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
JustAllowWirelessUserLogin_eagservergroup_map(u_long *mib_JustAllowWirelessUserLogin_val_ptr, u_long raw_JustAllowWirelessUserLogin_val)
{
    netsnmp_assert(NULL != mib_JustAllowWirelessUserLogin_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:JustAllowWirelessUserLogin_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement JustAllowWirelessUserLogin enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_JustAllowWirelessUserLogin_val) {
        case INTERNAL_JUSTALLOWWIRELESSUSERLOGIN_TRUE:
             *mib_JustAllowWirelessUserLogin_val_ptr = JUSTALLOWWIRELESSUSERLOGIN_TRUE;
             break;

        case INTERNAL_JUSTALLOWWIRELESSUSERLOGIN_FALSE:
             *mib_JustAllowWirelessUserLogin_val_ptr = JUSTALLOWWIRELESSUSERLOGIN_FALSE;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for JustAllowWirelessUserLogin\n", raw_JustAllowWirelessUserLogin_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* JustAllowWirelessUserLogin_map */

/**
 * Extract the current value of the JustAllowWirelessUserLogin data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param JustAllowWirelessUserLogin_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
JustAllowWirelessUserLogin_get( dot11ConfigEagServerGroupTable_rowreq_ctx *rowreq_ctx, u_long * JustAllowWirelessUserLogin_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != JustAllowWirelessUserLogin_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:JustAllowWirelessUserLogin_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the JustAllowWirelessUserLogin data.
 * set (* JustAllowWirelessUserLogin_val_ptr ) from rowreq_ctx->data
 */
    (* JustAllowWirelessUserLogin_val_ptr ) = rowreq_ctx->data.JustAllowWirelessUserLogin;

    return MFD_SUCCESS;
} /* JustAllowWirelessUserLogin_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigEagServerGroupEntry.RadiusAcctInterval
 * RadiusAcctInterval is subid 8 of dot11ConfigEagServerGroupEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.4.1.8
 * Description:
Radius acct interval.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-RadiusAcctInterval.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
RadiusAcctInterval_eagservergroup_map(long *mib_RadiusAcctInterval_val_ptr, long raw_RadiusAcctInterval_val)
{
    netsnmp_assert(NULL != mib_RadiusAcctInterval_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:RadiusAcctInterval_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement RadiusAcctInterval mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_RadiusAcctInterval_val_ptr) = raw_RadiusAcctInterval_val;

    return MFD_SUCCESS;
} /* RadiusAcctInterval_map */

/**
 * Extract the current value of the RadiusAcctInterval data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param RadiusAcctInterval_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
RadiusAcctInterval_get( dot11ConfigEagServerGroupTable_rowreq_ctx *rowreq_ctx, long * RadiusAcctInterval_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != RadiusAcctInterval_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:RadiusAcctInterval_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the RadiusAcctInterval data.
 * set (* RadiusAcctInterval_val_ptr ) from rowreq_ctx->data
 */
    (* RadiusAcctInterval_val_ptr ) = rowreq_ctx->data.RadiusAcctInterval;

    return MFD_SUCCESS;
} /* RadiusAcctInterval_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigEagServerGroupEntry.MaxIdleTime
 * MaxIdleTime is subid 9 of dot11ConfigEagServerGroupEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.4.1.9
 * Description:
Max Idle Time.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-MaxIdleTime.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
MaxIdleTime_eagservergroup_map(long *mib_MaxIdleTime_val_ptr, long raw_MaxIdleTime_val)
{
    netsnmp_assert(NULL != mib_MaxIdleTime_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:MaxIdleTime_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement MaxIdleTime mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_MaxIdleTime_val_ptr) = raw_MaxIdleTime_val;

    return MFD_SUCCESS;
} /* MaxIdleTime_map */

/**
 * Extract the current value of the MaxIdleTime data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param MaxIdleTime_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
MaxIdleTime_get( dot11ConfigEagServerGroupTable_rowreq_ctx *rowreq_ctx, long * MaxIdleTime_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != MaxIdleTime_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:MaxIdleTime_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the MaxIdleTime data.
 * set (* MaxIdleTime_val_ptr ) from rowreq_ctx->data
 */
    (* MaxIdleTime_val_ptr ) = rowreq_ctx->data.MaxIdleTime;

    return MFD_SUCCESS;
} /* MaxIdleTime_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigEagServerGroupEntry.MaxIdleFlow
 * MaxIdleFlow is subid 10 of dot11ConfigEagServerGroupEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.4.1.10
 * Description:
Max Idle Flow.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-MaxIdleFlow.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
MaxIdleFlow_eagservergroup_map(long *mib_MaxIdleFlow_val_ptr, long raw_MaxIdleFlow_val)
{
    netsnmp_assert(NULL != mib_MaxIdleFlow_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:MaxIdleFlow_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement MaxIdleFlow mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_MaxIdleFlow_val_ptr) = raw_MaxIdleFlow_val;

    return MFD_SUCCESS;
} /* MaxIdleFlow_map */

/**
 * Extract the current value of the MaxIdleFlow data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param MaxIdleFlow_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
MaxIdleFlow_get( dot11ConfigEagServerGroupTable_rowreq_ctx *rowreq_ctx, long * MaxIdleFlow_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != MaxIdleFlow_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:MaxIdleFlow_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the MaxIdleFlow data.
 * set (* MaxIdleFlow_val_ptr ) from rowreq_ctx->data
 */
    (* MaxIdleFlow_val_ptr ) = rowreq_ctx->data.MaxIdleFlow;

    return MFD_SUCCESS;
} /* MaxIdleFlow_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigEagServerGroupEntry.VrrpId
 * VrrpId is subid 11 of dot11ConfigEagServerGroupEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.4.1.11
 * Description:
Vrrp id.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-VrrpId.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
VrrpId_eagservergroup_map(long *mib_VrrpId_val_ptr, long raw_VrrpId_val)
{
    netsnmp_assert(NULL != mib_VrrpId_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:VrrpId_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement VrrpId mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_VrrpId_val_ptr) = raw_VrrpId_val;

    return MFD_SUCCESS;
} /* VrrpId_map */

/**
 * Extract the current value of the VrrpId data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param VrrpId_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
VrrpId_get( dot11ConfigEagServerGroupTable_rowreq_ctx *rowreq_ctx, long * VrrpId_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != VrrpId_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:VrrpId_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the VrrpId data.
 * set (* VrrpId_val_ptr ) from rowreq_ctx->data
 */
    (* VrrpId_val_ptr ) = rowreq_ctx->data.VrrpId;

    return MFD_SUCCESS;
} /* VrrpId_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigEagServerGroupEntry.PortalInteractivePort
 * PortalInteractivePort is subid 12 of dot11ConfigEagServerGroupEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.4.1.12
 * Description:
Portal interactive port.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-PortalInteractivePort.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
PortalInteractivePort_eagservergroup_map(long *mib_PortalInteractivePort_val_ptr, long raw_PortalInteractivePort_val)
{
    netsnmp_assert(NULL != mib_PortalInteractivePort_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:PortalInteractivePort_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement PortalInteractivePort mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_PortalInteractivePort_val_ptr) = raw_PortalInteractivePort_val;

    return MFD_SUCCESS;
} /* PortalInteractivePort_map */

/**
 * Extract the current value of the PortalInteractivePort data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param PortalInteractivePort_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
PortalInteractivePort_get( dot11ConfigEagServerGroupTable_rowreq_ctx *rowreq_ctx, long * PortalInteractivePort_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != PortalInteractivePort_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:PortalInteractivePort_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the PortalInteractivePort data.
 * set (* PortalInteractivePort_val_ptr ) from rowreq_ctx->data
 */
    (* PortalInteractivePort_val_ptr ) = rowreq_ctx->data.PortalInteractivePort;

    return MFD_SUCCESS;
} /* PortalInteractivePort_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigEagServerGroupEntry.MaxHttpResponse
 * MaxHttpResponse is subid 13 of dot11ConfigEagServerGroupEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.4.1.13
 * Description:
Max http response per 5 seconds.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-MaxHttpResponse.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
MaxHttpResponse_eagservergroup_map(long *mib_MaxHttpResponse_val_ptr, long raw_MaxHttpResponse_val)
{
    netsnmp_assert(NULL != mib_MaxHttpResponse_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:MaxHttpResponse_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement MaxHttpResponse mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_MaxHttpResponse_val_ptr) = raw_MaxHttpResponse_val;

    return MFD_SUCCESS;
} /* MaxHttpResponse_map */

/**
 * Extract the current value of the MaxHttpResponse data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param MaxHttpResponse_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
MaxHttpResponse_get( dot11ConfigEagServerGroupTable_rowreq_ctx *rowreq_ctx, long * MaxHttpResponse_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != MaxHttpResponse_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:MaxHttpResponse_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the MaxHttpResponse data.
 * set (* MaxHttpResponse_val_ptr ) from rowreq_ctx->data
 */
    (* MaxHttpResponse_val_ptr ) = rowreq_ctx->data.MaxHttpResponse;

    return MFD_SUCCESS;
} /* MaxHttpResponse_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigEagServerGroupEntry.AutoCreateUserSession
 * AutoCreateUserSession is subid 14 of dot11ConfigEagServerGroupEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.2.23.4.1.14
 * Description:
Auto create user session.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-AutoCreateUserSession.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
AutoCreateUserSession_eagservergroup_map(u_long *mib_AutoCreateUserSession_val_ptr, u_long raw_AutoCreateUserSession_val)
{
    netsnmp_assert(NULL != mib_AutoCreateUserSession_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:AutoCreateUserSession_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement AutoCreateUserSession enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_AutoCreateUserSession_val) {
        case INTERNAL_AUTOCREATEUSERSESSION_TRUE:
             *mib_AutoCreateUserSession_val_ptr = AUTOCREATEUSERSESSION_TRUE;
             break;

        case INTERNAL_AUTOCREATEUSERSESSION_FALSE:
             *mib_AutoCreateUserSession_val_ptr = AUTOCREATEUSERSESSION_FALSE;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for AutoCreateUserSession\n", raw_AutoCreateUserSession_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* AutoCreateUserSession_map */

/**
 * Extract the current value of the AutoCreateUserSession data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param AutoCreateUserSession_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
AutoCreateUserSession_get( dot11ConfigEagServerGroupTable_rowreq_ctx *rowreq_ctx, u_long * AutoCreateUserSession_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != AutoCreateUserSession_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigEagServerGroupTable:AutoCreateUserSession_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the AutoCreateUserSession data.
 * set (* AutoCreateUserSession_val_ptr ) from rowreq_ctx->data
 */
    (* AutoCreateUserSession_val_ptr ) = rowreq_ctx->data.AutoCreateUserSession;

    return MFD_SUCCESS;
} /* AutoCreateUserSession_get */



/** @} */
