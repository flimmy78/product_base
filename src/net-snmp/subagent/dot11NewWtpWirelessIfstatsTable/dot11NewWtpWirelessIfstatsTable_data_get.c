/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.18.2.1 $ of : mfd-data-get.m2c,v $ 
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "dot11NewWtpWirelessIfstatsTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement dot11NewWtpWirelessIfstatsTable get routines.
 * TODO:240:M: Implement dot11NewWtpWirelessIfstatsTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table dot11NewWtpWirelessIfstatsTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * dot11NewWtpWirelessIfstatsTable is subid 8 of wtpInterface.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8, length: 12
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement dot11NewWtpWirelessIfstatsTable data context functions.
 */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpInfoEntry.wtpMacAddr
 * wtpMacAddr is subid 1 of dot11WtpInfoEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.1.1.1.1
 * Description:
AP mac.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is Dot11BaseWtpIdTC (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max )
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpMacAddr.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpMacAddr_dot11NewWtpWirelessIfstatsTable_map(char **mib_wtpMacAddr_val_ptr_ptr, size_t *mib_wtpMacAddr_val_ptr_len_ptr, char *raw_wtpMacAddr_val_ptr, size_t raw_wtpMacAddr_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpMacAddr_val_ptr);
    netsnmp_assert((NULL != mib_wtpMacAddr_val_ptr_ptr) && (NULL != mib_wtpMacAddr_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:wtpMacAddr_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpMacAddr non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpMacAddr_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpMacAddr_val_ptr_ptr) || (*mib_wtpMacAddr_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpMacAddr_val_ptr_ptr = realloc( *mib_wtpMacAddr_val_ptr_ptr, converted_len * sizeof(**mib_wtpMacAddr_val_ptr_ptr));
        if(NULL == *mib_wtpMacAddr_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpMacAddr_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpMacAddr_val_ptr_ptr, raw_wtpMacAddr_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpMacAddr_map */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWirelessIfEntry.wtpWirelessIfIndex
 * wtpWirelessIfIndex is subid 1 of dot11WtpWirelessIfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.3.1.1
 * Description:
Wireless interface index.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessIfIndex.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessIfIndex_dot11NewWtpWirelessIfstatsTable_map(long *mib_wtpWirelessIfIndex_val_ptr, long raw_wtpWirelessIfIndex_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessIfIndex_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:wtpWirelessIfIndex_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessIfIndex mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWirelessIfIndex_val_ptr) = raw_wtpWirelessIfIndex_val;

    return MFD_SUCCESS;
} /* wtpWirelessIfIndex_map */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewWirelessWlanID
 * NewWirelessWlanID is subid 1 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.1
 * Description:
WlanID.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewWirelessWlanID.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewWirelessWlanID_map(long *mib_NewWirelessWlanID_val_ptr, long raw_NewWirelessWlanID_val)
{
    netsnmp_assert(NULL != mib_NewWirelessWlanID_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewWirelessWlanID_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewWirelessWlanID mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewWirelessWlanID_val_ptr) = raw_NewWirelessWlanID_val;

    return MFD_SUCCESS;
} /* NewWirelessWlanID_map */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
dot11NewWtpWirelessIfstatsTable_indexes_set_tbl_idx(dot11NewWtpWirelessIfstatsTable_mib_index *tbl_idx, char *wtpMacAddr_val_ptr,  size_t wtpMacAddr_val_ptr_len, long wtpWirelessIfIndex_val, long NewWirelessWlanID_val)
{
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:dot11NewWtpWirelessIfstatsTable_indexes_set_tbl_idx","called\n"));

    /* wtpMacAddr(1)/Dot11BaseWtpIdTC/ASN_OCTET_STR/char(char)//L/A/w/e/r/d/h */
     tbl_idx->wtpMacAddr_len = sizeof(tbl_idx->wtpMacAddr);
    /*
     * make sure there is enough space for wtpMacAddr data
     */
    if ((NULL == tbl_idx->wtpMacAddr) ||
        (tbl_idx->wtpMacAddr_len < (wtpMacAddr_val_ptr_len * sizeof(tbl_idx->wtpMacAddr[0])))) {
        snmp_log(LOG_ERR,"not enough space for value\n");
        return MFD_ERROR;
    }
    tbl_idx->wtpMacAddr_len = wtpMacAddr_val_ptr_len * sizeof(tbl_idx->wtpMacAddr[0]);
    memcpy( tbl_idx->wtpMacAddr, wtpMacAddr_val_ptr, tbl_idx->wtpMacAddr_len );
    
    /* wtpWirelessIfIndex(1)/INTEGER/ASN_INTEGER/long(long)//l/A/w/e/r/d/h */
    tbl_idx->wtpWirelessIfIndex = wtpWirelessIfIndex_val;
    
    /* NewWirelessWlanID(1)/INTEGER/ASN_INTEGER/long(long)//l/A/w/e/r/d/h */
    tbl_idx->NewWirelessWlanID = NewWirelessWlanID_val;
    

    return MFD_SUCCESS;
} /* dot11NewWtpWirelessIfstatsTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
dot11NewWtpWirelessIfstatsTable_indexes_set(dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, char *wtpMacAddr_val_ptr,  size_t wtpMacAddr_val_ptr_len, long wtpWirelessIfIndex_val, long NewWirelessWlanID_val)
{
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:dot11NewWtpWirelessIfstatsTable_indexes_set","called\n"));

    if(MFD_SUCCESS != dot11NewWtpWirelessIfstatsTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
                                   , wtpMacAddr_val_ptr, wtpMacAddr_val_ptr_len
                                   , wtpWirelessIfIndex_val
                                   , NewWirelessWlanID_val
           ))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if(0 != dot11NewWtpWirelessIfstatsTable_index_to_oid(&rowreq_ctx->oid_idx,
                                    &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* dot11NewWtpWirelessIfstatsTable_indexes_set */


/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfAvgRxSignalStrength
 * NewwirelessIfAvgRxSignalStrength is subid 2 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.2
 * Description:
The average received signal strength.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfAvgRxSignalStrength.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfAvgRxSignalStrength_map(long *mib_NewwirelessIfAvgRxSignalStrength_val_ptr, long raw_NewwirelessIfAvgRxSignalStrength_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfAvgRxSignalStrength_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfAvgRxSignalStrength_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfAvgRxSignalStrength mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfAvgRxSignalStrength_val_ptr) = raw_NewwirelessIfAvgRxSignalStrength_val;

    return MFD_SUCCESS;
} /* NewwirelessIfAvgRxSignalStrength_map */

/**
 * Extract the current value of the NewwirelessIfAvgRxSignalStrength data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfAvgRxSignalStrength_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfAvgRxSignalStrength_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, long * NewwirelessIfAvgRxSignalStrength_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfAvgRxSignalStrength_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfAvgRxSignalStrength_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfAvgRxSignalStrength data.
 * set (* NewwirelessIfAvgRxSignalStrength_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfAvgRxSignalStrength_val_ptr ) = rowreq_ctx->data.NewwirelessIfAvgRxSignalStrength;

    return MFD_SUCCESS;
} /* NewwirelessIfAvgRxSignalStrength_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfHighestRxSignalStrength
 * NewwirelessIfHighestRxSignalStrength is subid 3 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.3
 * Description:
Receive the maximum signal strength.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfHighestRxSignalStrength.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfHighestRxSignalStrength_map(long *mib_NewwirelessIfHighestRxSignalStrength_val_ptr, long raw_NewwirelessIfHighestRxSignalStrength_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfHighestRxSignalStrength_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfHighestRxSignalStrength_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfHighestRxSignalStrength mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfHighestRxSignalStrength_val_ptr) = raw_NewwirelessIfHighestRxSignalStrength_val;

    return MFD_SUCCESS;
} /* NewwirelessIfHighestRxSignalStrength_map */

/**
 * Extract the current value of the NewwirelessIfHighestRxSignalStrength data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfHighestRxSignalStrength_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfHighestRxSignalStrength_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, long * NewwirelessIfHighestRxSignalStrength_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfHighestRxSignalStrength_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfHighestRxSignalStrength_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfHighestRxSignalStrength data.
 * set (* NewwirelessIfHighestRxSignalStrength_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfHighestRxSignalStrength_val_ptr ) = rowreq_ctx->data.NewwirelessIfHighestRxSignalStrength;

    return MFD_SUCCESS;
} /* NewwirelessIfHighestRxSignalStrength_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfLowestRxSignalStrength
 * NewwirelessIfLowestRxSignalStrength is subid 4 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.4
 * Description:
Receive the minimum signal strength.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfLowestRxSignalStrength.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfLowestRxSignalStrength_map(long *mib_NewwirelessIfLowestRxSignalStrength_val_ptr, long raw_NewwirelessIfLowestRxSignalStrength_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfLowestRxSignalStrength_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfLowestRxSignalStrength_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfLowestRxSignalStrength mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfLowestRxSignalStrength_val_ptr) = raw_NewwirelessIfLowestRxSignalStrength_val;

    return MFD_SUCCESS;
} /* NewwirelessIfLowestRxSignalStrength_map */

/**
 * Extract the current value of the NewwirelessIfLowestRxSignalStrength data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfLowestRxSignalStrength_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfLowestRxSignalStrength_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, long * NewwirelessIfLowestRxSignalStrength_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfLowestRxSignalStrength_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfLowestRxSignalStrength_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfLowestRxSignalStrength data.
 * set (* NewwirelessIfLowestRxSignalStrength_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfLowestRxSignalStrength_val_ptr ) = rowreq_ctx->data.NewwirelessIfLowestRxSignalStrength;

    return MFD_SUCCESS;
} /* NewwirelessIfLowestRxSignalStrength_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfUpdownTimes
 * NewwirelessIfUpdownTimes is subid 5 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.5
 * Description:
Wireless interface updown times.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfUpdownTimes.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfUpdownTimes_map(u_long *mib_NewwirelessIfUpdownTimes_val_ptr, u_long raw_NewwirelessIfUpdownTimes_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfUpdownTimes_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfUpdownTimes_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfUpdownTimes mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfUpdownTimes_val_ptr) = raw_NewwirelessIfUpdownTimes_val;

    return MFD_SUCCESS;
} /* NewwirelessIfUpdownTimes_map */

/**
 * Extract the current value of the NewwirelessIfUpdownTimes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfUpdownTimes_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfUpdownTimes_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfUpdownTimes_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfUpdownTimes_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfUpdownTimes_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfUpdownTimes data.
 * set (* NewwirelessIfUpdownTimes_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfUpdownTimes_val_ptr ) = rowreq_ctx->data.NewwirelessIfUpdownTimes;

    return MFD_SUCCESS;
} /* NewwirelessIfUpdownTimes_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfChStatsNumStations
 * NewwirelessIfChStatsNumStations is subid 6 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.6
 * Description:
The terminals number which use the channel.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfChStatsNumStations.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfChStatsNumStations_map(long *mib_NewwirelessIfChStatsNumStations_val_ptr, long raw_NewwirelessIfChStatsNumStations_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfChStatsNumStations_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfChStatsNumStations_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfChStatsNumStations mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfChStatsNumStations_val_ptr) = raw_NewwirelessIfChStatsNumStations_val;

    return MFD_SUCCESS;
} /* NewwirelessIfChStatsNumStations_map */

/**
 * Extract the current value of the NewwirelessIfChStatsNumStations data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfChStatsNumStations_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfChStatsNumStations_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, long * NewwirelessIfChStatsNumStations_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfChStatsNumStations_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfChStatsNumStations_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfChStatsNumStations data.
 * set (* NewwirelessIfChStatsNumStations_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfChStatsNumStations_val_ptr ) = rowreq_ctx->data.NewwirelessIfChStatsNumStations;

    return MFD_SUCCESS;
} /* NewwirelessIfChStatsNumStations_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfTxSignalPkts
 * NewwirelessIfTxSignalPkts is subid 7 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.7
 * Description:
The number of signaling packets which.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfTxSignalPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfTxSignalPkts_map(u_long *mib_NewwirelessIfTxSignalPkts_val_ptr, u_long raw_NewwirelessIfTxSignalPkts_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfTxSignalPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfTxSignalPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfTxSignalPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfTxSignalPkts_val_ptr) = raw_NewwirelessIfTxSignalPkts_val;

    return MFD_SUCCESS;
} /* NewwirelessIfTxSignalPkts_map */

/**
 * Extract the current value of the NewwirelessIfTxSignalPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfTxSignalPkts_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfTxSignalPkts_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfTxSignalPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfTxSignalPkts_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfTxSignalPkts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfTxSignalPkts data.
 * set (* NewwirelessIfTxSignalPkts_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfTxSignalPkts_val_ptr ) = rowreq_ctx->data.NewwirelessIfTxSignalPkts;

    return MFD_SUCCESS;
} /* NewwirelessIfTxSignalPkts_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfRxSignalPkts
 * NewwirelessIfRxSignalPkts is subid 8 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.8
 * Description:
The number of signaling packets which received.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfRxSignalPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfRxSignalPkts_map(u_long *mib_NewwirelessIfRxSignalPkts_val_ptr, u_long raw_NewwirelessIfRxSignalPkts_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfRxSignalPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfRxSignalPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfRxSignalPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfRxSignalPkts_val_ptr) = raw_NewwirelessIfRxSignalPkts_val;

    return MFD_SUCCESS;
} /* NewwirelessIfRxSignalPkts_map */

/**
 * Extract the current value of the NewwirelessIfRxSignalPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfRxSignalPkts_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfRxSignalPkts_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfRxSignalPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfRxSignalPkts_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfRxSignalPkts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfRxSignalPkts data.
 * set (* NewwirelessIfRxSignalPkts_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfRxSignalPkts_val_ptr ) = rowreq_ctx->data.NewwirelessIfRxSignalPkts;

    return MFD_SUCCESS;
} /* NewwirelessIfRxSignalPkts_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfTxDataPkts
 * NewwirelessIfTxDataPkts is subid 9 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.9
 * Description:
The number of data packets which transmited.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfTxDataPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfTxDataPkts_map(u_long *mib_NewwirelessIfTxDataPkts_val_ptr, u_long raw_NewwirelessIfTxDataPkts_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfTxDataPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfTxDataPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfTxDataPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfTxDataPkts_val_ptr) = raw_NewwirelessIfTxDataPkts_val;

    return MFD_SUCCESS;
} /* NewwirelessIfTxDataPkts_map */

/**
 * Extract the current value of the NewwirelessIfTxDataPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfTxDataPkts_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfTxDataPkts_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfTxDataPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfTxDataPkts_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfTxDataPkts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfTxDataPkts data.
 * set (* NewwirelessIfTxDataPkts_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfTxDataPkts_val_ptr ) = rowreq_ctx->data.NewwirelessIfTxDataPkts;

    return MFD_SUCCESS;
} /* NewwirelessIfTxDataPkts_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfRxDataPkts
 * NewwirelessIfRxDataPkts is subid 10 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.10
 * Description:
The number of data packets which received.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfRxDataPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfRxDataPkts_map(u_long *mib_NewwirelessIfRxDataPkts_val_ptr, u_long raw_NewwirelessIfRxDataPkts_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfRxDataPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfRxDataPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfRxDataPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfRxDataPkts_val_ptr) = raw_NewwirelessIfRxDataPkts_val;

    return MFD_SUCCESS;
} /* NewwirelessIfRxDataPkts_map */

/**
 * Extract the current value of the NewwirelessIfRxDataPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfRxDataPkts_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfRxDataPkts_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfRxDataPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfRxDataPkts_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfRxDataPkts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfRxDataPkts data.
 * set (* NewwirelessIfRxDataPkts_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfRxDataPkts_val_ptr ) = rowreq_ctx->data.NewwirelessIfRxDataPkts;

    return MFD_SUCCESS;
} /* NewwirelessIfRxDataPkts_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfUplinkDataOctets
 * NewwirelessIfUplinkDataOctets is subid 11 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.11
 * Description:
Number of bytes received.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfUplinkDataOctets.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfTxbytes_map(unsigned long long *mib_NewwirelessIfTxbytes_val_ptr, unsigned long long raw_NewwirelessIfTxbytes_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfTxbytes_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfTxbytes_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfUplinkDataOctets mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfTxbytes_val_ptr) = raw_NewwirelessIfTxbytes_val;

    return MFD_SUCCESS;
} /* NewwirelessIfUplinkDataOctets_map */

/**
 * Extract the current value of the NewwirelessIfUplinkDataOctets data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfUplinkDataOctets_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfTxbytes_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, unsigned long long  * NewwirelessIfTxbytes_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfTxbytes_val_ptr );

/*
 * TODO:231:o: |-> copy NewwirelessIfUplinkDataOctets data.
 * get (* NewwirelessIfUplinkDataOctets_val_ptr ).low and (* NewwirelessIfUplinkDataOctets_val_ptr ).high from rowreq_ctx->data
 */
    (* NewwirelessIfTxbytes_val_ptr ) = rowreq_ctx->data.NewwirelessIfTxbytes;
    //(* NewwirelessIfUplinkDataOctets_val_ptr ).low = rowreq_ctx->data.NewwirelessIfUplinkDataOctets.low;

	//* NewwirelessIfUplinkDataOctets_val_ptr = rowreq_ctx->data.NewwirelessIfUplinkDataOctets;


    return MFD_SUCCESS;
} /* NewwirelessIfUplinkDataOctets_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfDwlinkDataOctets
 * NewwirelessIfDwlinkDataOctets is subid 12 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.12
 * Description:
Number of bytes sent.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfDwlinkDataOctets.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfRxbytes_map(unsigned long long *mib_NewwirelessIfRxbytes_val_ptr, unsigned long long raw_NewwirelessIfRxbytes_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfRxbytes_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfRxbytes_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfDwlinkDataOctets mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfRxbytes_val_ptr) = raw_NewwirelessIfRxbytes_val;

    return MFD_SUCCESS;
} /* NewwirelessIfDwlinkDataOctets_map */

/**
 * Extract the current value of the NewwirelessIfDwlinkDataOctets data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfDwlinkDataOctets_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfRxbytes_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, unsigned long long * NewwirelessIfRxbytes_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfRxbytes_val_ptr );

/*
 * TODO:231:o: |-> copy NewwirelessIfDwlinkDataOctets data.
 * get (* NewwirelessIfDwlinkDataOctets_val_ptr ).low and (* NewwirelessIfDwlinkDataOctets_val_ptr ).high from rowreq_ctx->data
 */
    (* NewwirelessIfRxbytes_val_ptr ) = rowreq_ctx->data.NewwirelessIfRxbytes;
    //(* NewwirelessIfDwlinkDataOctets_val_ptr ).low = rowreq_ctx->data.NewwirelessIfDwlinkDataOctets.low;

	//* NewwirelessIfDwlinkDataOctets_val_ptr = rowreq_ctx->data.NewwirelessIfDwlinkDataOctets;


    return MFD_SUCCESS;
} /* NewwirelessIfDwlinkDataOctets_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfChStatsDwlinkTotRetryPkts
 * NewwirelessIfChStatsDwlinkTotRetryPkts is subid 13 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.13
 * Description:
Retransmission packets number.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfChStatsDwlinkTotRetryPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfChStatsDwlinkTotRetryPkts_map(u_long *mib_NewwirelessIfChStatsDwlinkTotRetryPkts_val_ptr, u_long raw_NewwirelessIfChStatsDwlinkTotRetryPkts_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfChStatsDwlinkTotRetryPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfChStatsDwlinkTotRetryPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfChStatsDwlinkTotRetryPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfChStatsDwlinkTotRetryPkts_val_ptr) = raw_NewwirelessIfChStatsDwlinkTotRetryPkts_val;

    return MFD_SUCCESS;
} /* NewwirelessIfChStatsDwlinkTotRetryPkts_map */

/**
 * Extract the current value of the NewwirelessIfChStatsDwlinkTotRetryPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfChStatsDwlinkTotRetryPkts_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfChStatsDwlinkTotRetryPkts_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfChStatsDwlinkTotRetryPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfChStatsDwlinkTotRetryPkts_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfChStatsDwlinkTotRetryPkts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfChStatsDwlinkTotRetryPkts data.
 * set (* NewwirelessIfChStatsDwlinkTotRetryPkts_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfChStatsDwlinkTotRetryPkts_val_ptr ) = rowreq_ctx->data.NewwirelessIfChStatsDwlinkTotRetryPkts;

    return MFD_SUCCESS;
} /* NewwirelessIfChStatsDwlinkTotRetryPkts_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfChStatsUplinkUniFrameCnt
 * NewwirelessIfChStatsUplinkUniFrameCnt is subid 14 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.14
 * Description:
.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfChStatsUplinkUniFrameCnt.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfChStatsUplinkUniFrameCnt_map(unsigned long long *mib_NewwirelessIfChStatsUplinkUniFrameCnt_val_ptr, unsigned long long raw_NewwirelessIfChStatsUplinkUniFrameCnt_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfChStatsUplinkUniFrameCnt_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfChStatsUplinkUniFrameCnt_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfChStatsUplinkUniFrameCnt mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfChStatsUplinkUniFrameCnt_val_ptr) = raw_NewwirelessIfChStatsUplinkUniFrameCnt_val;

    return MFD_SUCCESS;
} /* NewwirelessIfChStatsUplinkUniFrameCnt_map */

/**
 * Extract the current value of the NewwirelessIfChStatsUplinkUniFrameCnt data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfChStatsUplinkUniFrameCnt_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfChStatsUplinkUniFrameCnt_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, unsigned long long * NewwirelessIfChStatsUplinkUniFrameCnt_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfChStatsUplinkUniFrameCnt_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfChStatsUplinkUniFrameCnt_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfChStatsUplinkUniFrameCnt data.
 * set (* NewwirelessIfChStatsUplinkUniFrameCnt_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfChStatsUplinkUniFrameCnt_val_ptr ) = rowreq_ctx->data.NewwirelessIfChStatsUplinkUniFrameCnt;

    return MFD_SUCCESS;
} /* NewwirelessIfChStatsUplinkUniFrameCnt_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfChStatsDwlinkUniFrameCnt
 * NewwirelessIfChStatsDwlinkUniFrameCnt is subid 15 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.15
 * Description:
.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfChStatsDwlinkUniFrameCnt.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfChStatsDwlinkUniFrameCnt_map(unsigned long long *mib_NewwirelessIfChStatsDwlinkUniFrameCnt_val_ptr, unsigned long long raw_NewwirelessIfChStatsDwlinkUniFrameCnt_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfChStatsDwlinkUniFrameCnt_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfChStatsDwlinkUniFrameCnt_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfChStatsDwlinkUniFrameCnt mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfChStatsDwlinkUniFrameCnt_val_ptr) = raw_NewwirelessIfChStatsDwlinkUniFrameCnt_val;

    return MFD_SUCCESS;
} /* NewwirelessIfChStatsDwlinkUniFrameCnt_map */

/**
 * Extract the current value of the NewwirelessIfChStatsDwlinkUniFrameCnt data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfChStatsDwlinkUniFrameCnt_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfChStatsDwlinkUniFrameCnt_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, unsigned long long * NewwirelessIfChStatsDwlinkUniFrameCnt_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfChStatsDwlinkUniFrameCnt_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfChStatsDwlinkUniFrameCnt_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfChStatsDwlinkUniFrameCnt data.
 * set (* NewwirelessIfChStatsDwlinkUniFrameCnt_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfChStatsDwlinkUniFrameCnt_val_ptr ) = rowreq_ctx->data.NewwirelessIfChStatsDwlinkUniFrameCnt;

    return MFD_SUCCESS;
} /* NewwirelessIfChStatsDwlinkUniFrameCnt_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfUpChStatsFrameNonUniFrameCnt
 * NewwirelessIfUpChStatsFrameNonUniFrameCnt is subid 16 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.16
 * Description:
.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfUpChStatsFrameNonUniFrameCnt.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfUpChStatsFrameNonUniFrameCnt_map(u_long *mib_NewwirelessIfUpChStatsFrameNonUniFrameCnt_val_ptr, u_long raw_NewwirelessIfUpChStatsFrameNonUniFrameCnt_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfUpChStatsFrameNonUniFrameCnt_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfUpChStatsFrameNonUniFrameCnt_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfUpChStatsFrameNonUniFrameCnt mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfUpChStatsFrameNonUniFrameCnt_val_ptr) = raw_NewwirelessIfUpChStatsFrameNonUniFrameCnt_val;

    return MFD_SUCCESS;
} /* NewwirelessIfUpChStatsFrameNonUniFrameCnt_map */

/**
 * Extract the current value of the NewwirelessIfUpChStatsFrameNonUniFrameCnt data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfUpChStatsFrameNonUniFrameCnt_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfUpChStatsFrameNonUniFrameCnt_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfUpChStatsFrameNonUniFrameCnt_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfUpChStatsFrameNonUniFrameCnt_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfUpChStatsFrameNonUniFrameCnt_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfUpChStatsFrameNonUniFrameCnt data.
 * set (* NewwirelessIfUpChStatsFrameNonUniFrameCnt_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfUpChStatsFrameNonUniFrameCnt_val_ptr ) = rowreq_ctx->data.NewwirelessIfUpChStatsFrameNonUniFrameCnt;

    return MFD_SUCCESS;
} /* NewwirelessIfUpChStatsFrameNonUniFrameCnt_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfDownChStatsFrameNonUniFrameCnt
 * NewwirelessIfDownChStatsFrameNonUniFrameCnt is subid 17 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.17
 * Description:
.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfDownChStatsFrameNonUniFrameCnt.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfDownChStatsFrameNonUniFrameCnt_map(u_long *mib_NewwirelessIfDownChStatsFrameNonUniFrameCnt_val_ptr, u_long raw_NewwirelessIfDownChStatsFrameNonUniFrameCnt_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfDownChStatsFrameNonUniFrameCnt_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfDownChStatsFrameNonUniFrameCnt_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfDownChStatsFrameNonUniFrameCnt mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfDownChStatsFrameNonUniFrameCnt_val_ptr) = raw_NewwirelessIfDownChStatsFrameNonUniFrameCnt_val;

    return MFD_SUCCESS;
} /* NewwirelessIfDownChStatsFrameNonUniFrameCnt_map */

/**
 * Extract the current value of the NewwirelessIfDownChStatsFrameNonUniFrameCnt data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfDownChStatsFrameNonUniFrameCnt_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfDownChStatsFrameNonUniFrameCnt_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfDownChStatsFrameNonUniFrameCnt_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfDownChStatsFrameNonUniFrameCnt_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfDownChStatsFrameNonUniFrameCnt_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfDownChStatsFrameNonUniFrameCnt data.
 * set (* NewwirelessIfDownChStatsFrameNonUniFrameCnt_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfDownChStatsFrameNonUniFrameCnt_val_ptr ) = rowreq_ctx->data.NewwirelessIfDownChStatsFrameNonUniFrameCnt;

    return MFD_SUCCESS;
} /* NewwirelessIfDownChStatsFrameNonUniFrameCnt_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfChStatsPhyErrPkts
 * NewwirelessIfChStatsPhyErrPkts is subid 18 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.18
 * Description:
.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfChStatsPhyErrPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfChStatsPhyErrPkts_map(u_long *mib_NewwirelessIfChStatsPhyErrPkts_val_ptr, u_long raw_NewwirelessIfChStatsPhyErrPkts_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfChStatsPhyErrPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfChStatsPhyErrPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfChStatsPhyErrPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfChStatsPhyErrPkts_val_ptr) = raw_NewwirelessIfChStatsPhyErrPkts_val;

    return MFD_SUCCESS;
} /* NewwirelessIfChStatsPhyErrPkts_map */

/**
 * Extract the current value of the NewwirelessIfChStatsPhyErrPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfChStatsPhyErrPkts_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfChStatsPhyErrPkts_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfChStatsPhyErrPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfChStatsPhyErrPkts_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfChStatsPhyErrPkts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfChStatsPhyErrPkts data.
 * set (* NewwirelessIfChStatsPhyErrPkts_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfChStatsPhyErrPkts_val_ptr ) = rowreq_ctx->data.NewwirelessIfChStatsPhyErrPkts;

    return MFD_SUCCESS;
} /* NewwirelessIfChStatsPhyErrPkts_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfChStatsMacFcsErrPkts
 * NewwirelessIfChStatsMacFcsErrPkts is subid 19 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.19
 * Description:
.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfChStatsMacFcsErrPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfChStatsMacFcsErrPkts_map(u_long *mib_NewwirelessIfChStatsMacFcsErrPkts_val_ptr, u_long raw_NewwirelessIfChStatsMacFcsErrPkts_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfChStatsMacFcsErrPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfChStatsMacFcsErrPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfChStatsMacFcsErrPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfChStatsMacFcsErrPkts_val_ptr) = raw_NewwirelessIfChStatsMacFcsErrPkts_val;

    return MFD_SUCCESS;
} /* NewwirelessIfChStatsMacFcsErrPkts_map */

/**
 * Extract the current value of the NewwirelessIfChStatsMacFcsErrPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfChStatsMacFcsErrPkts_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfChStatsMacFcsErrPkts_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfChStatsMacFcsErrPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfChStatsMacFcsErrPkts_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfChStatsMacFcsErrPkts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfChStatsMacFcsErrPkts data.
 * set (* NewwirelessIfChStatsMacFcsErrPkts_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfChStatsMacFcsErrPkts_val_ptr ) = rowreq_ctx->data.NewwirelessIfChStatsMacFcsErrPkts;

    return MFD_SUCCESS;
} /* NewwirelessIfChStatsMacFcsErrPkts_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfChStatsMacMicErrPkts
 * NewwirelessIfChStatsMacMicErrPkts is subid 20 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.20
 * Description:
.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfChStatsMacMicErrPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfChStatsMacMicErrPkts_map(u_long *mib_NewwirelessIfChStatsMacMicErrPkts_val_ptr, u_long raw_NewwirelessIfChStatsMacMicErrPkts_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfChStatsMacMicErrPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfChStatsMacMicErrPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfChStatsMacMicErrPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfChStatsMacMicErrPkts_val_ptr) = raw_NewwirelessIfChStatsMacMicErrPkts_val;

    return MFD_SUCCESS;
} /* NewwirelessIfChStatsMacMicErrPkts_map */

/**
 * Extract the current value of the NewwirelessIfChStatsMacMicErrPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfChStatsMacMicErrPkts_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfChStatsMacMicErrPkts_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfChStatsMacMicErrPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfChStatsMacMicErrPkts_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfChStatsMacMicErrPkts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfChStatsMacMicErrPkts data.
 * set (* NewwirelessIfChStatsMacMicErrPkts_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfChStatsMacMicErrPkts_val_ptr ) = rowreq_ctx->data.NewwirelessIfChStatsMacMicErrPkts;

    return MFD_SUCCESS;
} /* NewwirelessIfChStatsMacMicErrPkts_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfChStatsMacDecryptErrPkts
 * NewwirelessIfChStatsMacDecryptErrPkts is subid 21 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.21
 * Description:
.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfChStatsMacDecryptErrPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfChStatsMacDecryptErrPkts_map(u_long *mib_NewwirelessIfChStatsMacDecryptErrPkts_val_ptr, u_long raw_NewwirelessIfChStatsMacDecryptErrPkts_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfChStatsMacDecryptErrPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfChStatsMacDecryptErrPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfChStatsMacDecryptErrPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfChStatsMacDecryptErrPkts_val_ptr) = raw_NewwirelessIfChStatsMacDecryptErrPkts_val;

    return MFD_SUCCESS;
} /* NewwirelessIfChStatsMacDecryptErrPkts_map */

/**
 * Extract the current value of the NewwirelessIfChStatsMacDecryptErrPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfChStatsMacDecryptErrPkts_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfChStatsMacDecryptErrPkts_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfChStatsMacDecryptErrPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfChStatsMacDecryptErrPkts_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfChStatsMacDecryptErrPkts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfChStatsMacDecryptErrPkts data.
 * set (* NewwirelessIfChStatsMacDecryptErrPkts_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfChStatsMacDecryptErrPkts_val_ptr ) = rowreq_ctx->data.NewwirelessIfChStatsMacDecryptErrPkts;

    return MFD_SUCCESS;
} /* NewwirelessIfChStatsMacDecryptErrPkts_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfChStatsFrameErrorCnt
 * NewwirelessIfChStatsFrameErrorCnt is subid 21 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.21
 * Description:
.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfChStatsFrameErrorCnt.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfChStatsFrameErrorCnt_map(u_long *mib_NewwirelessIfChStatsFrameErrorCnt_val_ptr, u_long raw_NewwirelessIfChStatsFrameErrorCnt_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfChStatsFrameErrorCnt_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfChStatsFrameErrorCnt_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfChStatsFrameErrorCnt mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfChStatsFrameErrorCnt_val_ptr) = raw_NewwirelessIfChStatsFrameErrorCnt_val;

    return MFD_SUCCESS;
} /* NewwirelessIfChStatsFrameErrorCnt_map */

/**
 * Extract the current value of the NewwirelessIfChStatsFrameErrorCnt data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfChStatsFrameErrorCnt_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfChStatsFrameErrorCnt_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfChStatsFrameErrorCnt_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfChStatsFrameErrorCnt_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfChStatsFrameErrorCnt_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfChStatsFrameErrorCnt data.
 * set (* NewwirelessIfChStatsFrameErrorCnt_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfChStatsFrameErrorCnt_val_ptr ) = rowreq_ctx->data.NewwirelessIfChStatsFrameErrorCnt;

    return MFD_SUCCESS;
} /* NewwirelessIfChStatsFrameErrorCnt_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfChStatsFrameRetryCnt
 * NewwirelessIfChStatsFrameRetryCnt is subid 23 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.23
 * Description:
.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfChStatsFrameRetryCnt.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfChStatsFrameRetryCnt_map(u_long *mib_NewwirelessIfChStatsFrameRetryCnt_val_ptr, u_long raw_NewwirelessIfChStatsFrameRetryCnt_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfChStatsFrameRetryCnt_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfChStatsFrameRetryCnt_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfChStatsFrameRetryCnt mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfChStatsFrameRetryCnt_val_ptr) = raw_NewwirelessIfChStatsFrameRetryCnt_val;

    return MFD_SUCCESS;
} /* NewwirelessIfChStatsFrameRetryCnt_map */

/**
 * Extract the current value of the NewwirelessIfChStatsFrameRetryCnt data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfChStatsFrameRetryCnt_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfChStatsFrameRetryCnt_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfChStatsFrameRetryCnt_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfChStatsFrameRetryCnt_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfChStatsFrameRetryCnt_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfChStatsFrameRetryCnt data.
 * set (* NewwirelessIfChStatsFrameRetryCnt_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfChStatsFrameRetryCnt_val_ptr ) = rowreq_ctx->data.NewwirelessIfChStatsFrameRetryCnt;

    return MFD_SUCCESS;
} /* NewwirelessIfChStatsFrameRetryCnt_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfApChStatsFrameFragRate
 * NewwirelessIfApChStatsFrameFragRate is subid 24 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.24
 * Description:
.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfApChStatsFrameFragRate.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfApChStatsFrameFragRate_map(u_long *mib_NewwirelessIfApChStatsFrameFragRate_val_ptr, u_long raw_NewwirelessIfApChStatsFrameFragRate_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfApChStatsFrameFragRate_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfApChStatsFrameFragRate_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfApChStatsFrameFragRate mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfApChStatsFrameFragRate_val_ptr) = raw_NewwirelessIfApChStatsFrameFragRate_val;

    return MFD_SUCCESS;
} /* NewwirelessIfApChStatsFrameFragRate_map */

/**
 * Extract the current value of the NewwirelessIfApChStatsFrameFragRate data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfApChStatsFrameFragRate_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfApChStatsFrameFragRate_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfApChStatsFrameFragRate_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfApChStatsFrameFragRate_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfApChStatsFrameFragRate_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfApChStatsFrameFragRate data.
 * set (* NewwirelessIfApChStatsFrameFragRate_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfApChStatsFrameFragRate_val_ptr ) = rowreq_ctx->data.NewwirelessIfApChStatsFrameFragRate;

    return MFD_SUCCESS;
} /* NewwirelessIfApChStatsFrameFragRate_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfRxMgmtFrameCnt
 * NewwirelessIfRxMgmtFrameCnt is subid 25 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.25
 * Description:
.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfRxMgmtFrameCnt.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfRxMgmtFrameCnt_map(u_long *mib_NewwirelessIfRxMgmtFrameCnt_val_ptr, u_long raw_NewwirelessIfRxMgmtFrameCnt_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfRxMgmtFrameCnt_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfRxMgmtFrameCnt_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfRxMgmtFrameCnt mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfRxMgmtFrameCnt_val_ptr) = raw_NewwirelessIfRxMgmtFrameCnt_val;

    return MFD_SUCCESS;
} /* NewwirelessIfRxMgmtFrameCnt_map */

/**
 * Extract the current value of the NewwirelessIfRxMgmtFrameCnt data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfRxMgmtFrameCnt_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfRxMgmtFrameCnt_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfRxMgmtFrameCnt_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfRxMgmtFrameCnt_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfRxMgmtFrameCnt_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfRxMgmtFrameCnt data.
 * set (* NewwirelessIfRxMgmtFrameCnt_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfRxMgmtFrameCnt_val_ptr ) = rowreq_ctx->data.NewwirelessIfRxMgmtFrameCnt;

    return MFD_SUCCESS;
} /* NewwirelessIfRxMgmtFrameCnt_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfRxCtrlFrameCnt
 * NewwirelessIfRxCtrlFrameCnt is subid 26 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.26
 * Description:
.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfRxCtrlFrameCnt.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfRxCtrlFrameCnt_map(u_long *mib_NewwirelessIfRxCtrlFrameCnt_val_ptr, u_long raw_NewwirelessIfRxCtrlFrameCnt_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfRxCtrlFrameCnt_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfRxCtrlFrameCnt_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfRxCtrlFrameCnt mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfRxCtrlFrameCnt_val_ptr) = raw_NewwirelessIfRxCtrlFrameCnt_val;

    return MFD_SUCCESS;
} /* NewwirelessIfRxCtrlFrameCnt_map */

/**
 * Extract the current value of the NewwirelessIfRxCtrlFrameCnt data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfRxCtrlFrameCnt_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfRxCtrlFrameCnt_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfRxCtrlFrameCnt_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfRxCtrlFrameCnt_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfRxCtrlFrameCnt_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfRxCtrlFrameCnt data.
 * set (* NewwirelessIfRxCtrlFrameCnt_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfRxCtrlFrameCnt_val_ptr ) = rowreq_ctx->data.NewwirelessIfRxCtrlFrameCnt;

    return MFD_SUCCESS;
} /* NewwirelessIfRxCtrlFrameCnt_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfRxDataFrameCnt
 * NewwirelessIfRxDataFrameCnt is subid 27 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.27
 * Description:
.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfRxDataFrameCnt.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfRxDataFrameCnt_map(u_long *mib_NewwirelessIfRxDataFrameCnt_val_ptr, u_long raw_NewwirelessIfRxDataFrameCnt_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfRxDataFrameCnt_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfRxDataFrameCnt_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfRxDataFrameCnt mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfRxDataFrameCnt_val_ptr) = raw_NewwirelessIfRxDataFrameCnt_val;

    return MFD_SUCCESS;
} /* NewwirelessIfRxDataFrameCnt_map */

/**
 * Extract the current value of the NewwirelessIfRxDataFrameCnt data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfRxDataFrameCnt_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfRxDataFrameCnt_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfRxDataFrameCnt_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfRxDataFrameCnt_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfRxDataFrameCnt_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfRxDataFrameCnt data.
 * set (* NewwirelessIfRxDataFrameCnt_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfRxDataFrameCnt_val_ptr ) = rowreq_ctx->data.NewwirelessIfRxDataFrameCnt;

    return MFD_SUCCESS;
} /* NewwirelessIfRxDataFrameCnt_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfRxAuthenFrameCnt
 * NewwirelessIfRxAuthenFrameCnt is subid 28 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.28
 * Description:
.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfRxAuthenFrameCnt.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfRxAuthenFrameCnt_map(u_long *mib_NewwirelessIfRxAuthenFrameCnt_val_ptr, u_long raw_NewwirelessIfRxAuthenFrameCnt_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfRxAuthenFrameCnt_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfRxAuthenFrameCnt_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfRxAuthenFrameCnt mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfRxAuthenFrameCnt_val_ptr) = raw_NewwirelessIfRxAuthenFrameCnt_val;

    return MFD_SUCCESS;
} /* NewwirelessIfRxAuthenFrameCnt_map */

/**
 * Extract the current value of the NewwirelessIfRxAuthenFrameCnt data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfRxAuthenFrameCnt_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfRxAuthenFrameCnt_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfRxAuthenFrameCnt_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfRxAuthenFrameCnt_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfRxAuthenFrameCnt_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfRxAuthenFrameCnt data.
 * set (* NewwirelessIfRxAuthenFrameCnt_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfRxAuthenFrameCnt_val_ptr ) = rowreq_ctx->data.NewwirelessIfRxAuthenFrameCnt;

    return MFD_SUCCESS;
} /* NewwirelessIfRxAuthenFrameCnt_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfRxAssociateFrameCnt
 * NewwirelessIfRxAssociateFrameCnt is subid 29 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.29
 * Description:
.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfRxAssociateFrameCnt.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfRxAssociateFrameCnt_map(u_long *mib_NewwirelessIfRxAssociateFrameCnt_val_ptr, u_long raw_NewwirelessIfRxAssociateFrameCnt_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfRxAssociateFrameCnt_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfRxAssociateFrameCnt_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfRxAssociateFrameCnt mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfRxAssociateFrameCnt_val_ptr) = raw_NewwirelessIfRxAssociateFrameCnt_val;

    return MFD_SUCCESS;
} /* NewwirelessIfRxAssociateFrameCnt_map */

/**
 * Extract the current value of the NewwirelessIfRxAssociateFrameCnt data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfRxAssociateFrameCnt_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfRxAssociateFrameCnt_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfRxAssociateFrameCnt_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfRxAssociateFrameCnt_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfRxAssociateFrameCnt_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfRxAssociateFrameCnt data.
 * set (* NewwirelessIfRxAssociateFrameCnt_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfRxAssociateFrameCnt_val_ptr ) = rowreq_ctx->data.NewwirelessIfRxAssociateFrameCnt;

    return MFD_SUCCESS;
} /* NewwirelessIfRxAssociateFrameCnt_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfTxMgmtFrameCnt
 * NewwirelessIfTxMgmtFrameCnt is subid 30 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.30
 * Description:
.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfTxMgmtFrameCnt.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfTxMgmtFrameCnt_map(u_long *mib_NewwirelessIfTxMgmtFrameCnt_val_ptr, u_long raw_NewwirelessIfTxMgmtFrameCnt_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfTxMgmtFrameCnt_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfTxMgmtFrameCnt_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfTxMgmtFrameCnt mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfTxMgmtFrameCnt_val_ptr) = raw_NewwirelessIfTxMgmtFrameCnt_val;

    return MFD_SUCCESS;
} /* NewwirelessIfTxMgmtFrameCnt_map */

/**
 * Extract the current value of the NewwirelessIfTxMgmtFrameCnt data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfTxMgmtFrameCnt_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfTxMgmtFrameCnt_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfTxMgmtFrameCnt_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfTxMgmtFrameCnt_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfTxMgmtFrameCnt_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfTxMgmtFrameCnt data.
 * set (* NewwirelessIfTxMgmtFrameCnt_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfTxMgmtFrameCnt_val_ptr ) = rowreq_ctx->data.NewwirelessIfTxMgmtFrameCnt;

    return MFD_SUCCESS;
} /* NewwirelessIfTxMgmtFrameCnt_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfTxCtrlFrameCnt
 * NewwirelessIfTxCtrlFrameCnt is subid 31 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.31
 * Description:
.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfTxCtrlFrameCnt.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfTxCtrlFrameCnt_map(u_long *mib_NewwirelessIfTxCtrlFrameCnt_val_ptr, u_long raw_NewwirelessIfTxCtrlFrameCnt_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfTxCtrlFrameCnt_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfTxCtrlFrameCnt_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfTxCtrlFrameCnt mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfTxCtrlFrameCnt_val_ptr) = raw_NewwirelessIfTxCtrlFrameCnt_val;

    return MFD_SUCCESS;
} /* NewwirelessIfTxCtrlFrameCnt_map */

/**
 * Extract the current value of the NewwirelessIfTxCtrlFrameCnt data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfTxCtrlFrameCnt_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfTxCtrlFrameCnt_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfTxCtrlFrameCnt_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfTxCtrlFrameCnt_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfTxCtrlFrameCnt_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfTxCtrlFrameCnt data.
 * set (* NewwirelessIfTxCtrlFrameCnt_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfTxCtrlFrameCnt_val_ptr ) = rowreq_ctx->data.NewwirelessIfTxCtrlFrameCnt;

    return MFD_SUCCESS;
} /* NewwirelessIfTxCtrlFrameCnt_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfTxDataFrameCnt
 * NewwirelessIfTxDataFrameCnt is subid 32 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.32
 * Description:
.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfTxDataFrameCnt.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfTxDataFrameCnt_map(u_long *mib_NewwirelessIfTxDataFrameCnt_val_ptr, u_long raw_NewwirelessIfTxDataFrameCnt_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfTxDataFrameCnt_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfTxDataFrameCnt_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfTxDataFrameCnt mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfTxDataFrameCnt_val_ptr) = raw_NewwirelessIfTxDataFrameCnt_val;

    return MFD_SUCCESS;
} /* NewwirelessIfTxDataFrameCnt_map */

/**
 * Extract the current value of the NewwirelessIfTxDataFrameCnt data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfTxDataFrameCnt_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfTxDataFrameCnt_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfTxDataFrameCnt_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfTxDataFrameCnt_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfTxDataFrameCnt_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfTxDataFrameCnt data.
 * set (* NewwirelessIfTxDataFrameCnt_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfTxDataFrameCnt_val_ptr ) = rowreq_ctx->data.NewwirelessIfTxDataFrameCnt;

    return MFD_SUCCESS;
} /* NewwirelessIfTxDataFrameCnt_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfTxAuthenFrameCnt
 * NewwirelessIfTxAuthenFrameCnt is subid 33 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.33
 * Description:
.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfTxAuthenFrameCnt.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfTxAuthenFrameCnt_map(u_long *mib_NewwirelessIfTxAuthenFrameCnt_val_ptr, u_long raw_NewwirelessIfTxAuthenFrameCnt_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfTxAuthenFrameCnt_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfTxAuthenFrameCnt_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfTxAuthenFrameCnt mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfTxAuthenFrameCnt_val_ptr) = raw_NewwirelessIfTxAuthenFrameCnt_val;

    return MFD_SUCCESS;
} /* NewwirelessIfTxAuthenFrameCnt_map */

/**
 * Extract the current value of the NewwirelessIfTxAuthenFrameCnt data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfTxAuthenFrameCnt_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfTxAuthenFrameCnt_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfTxAuthenFrameCnt_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfTxAuthenFrameCnt_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfTxAuthenFrameCnt_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfTxAuthenFrameCnt data.
 * set (* NewwirelessIfTxAuthenFrameCnt_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfTxAuthenFrameCnt_val_ptr ) = rowreq_ctx->data.NewwirelessIfTxAuthenFrameCnt;

    return MFD_SUCCESS;
} /* NewwirelessIfTxAuthenFrameCnt_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfTxAssociateFrameCnt
 * NewwirelessIfTxAssociateFrameCnt is subid 34 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.3.8.1.34
 * Description:
.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfTxAssociateFrameCnt.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfTxAssociateFrameCnt_map(u_long *mib_NewwirelessIfTxAssociateFrameCnt_val_ptr, u_long raw_NewwirelessIfTxAssociateFrameCnt_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfTxAssociateFrameCnt_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfTxAssociateFrameCnt_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfTxAssociateFrameCnt mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfTxAssociateFrameCnt_val_ptr) = raw_NewwirelessIfTxAssociateFrameCnt_val;

    return MFD_SUCCESS;
} /* NewwirelessIfTxAssociateFrameCnt_map */

/**
 * Extract the current value of the NewwirelessIfTxAssociateFrameCnt data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfTxAssociateFrameCnt_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfTxAssociateFrameCnt_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfTxAssociateFrameCnt_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfTxAssociateFrameCnt_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfTxAssociateFrameCnt_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfTxAssociateFrameCnt data.
 * set (* NewwirelessIfTxAssociateFrameCnt_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfTxAssociateFrameCnt_val_ptr ) = rowreq_ctx->data.NewwirelessIfTxAssociateFrameCnt;

    return MFD_SUCCESS;
} /* NewwirelessIfTxAssociateFrameCnt_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfSuccAssociatedNum
 * NewwirelessIfSuccAssociatedNum is subid 35 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.8.1.35
 * Description:
.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-NewwirelessIfSuccAssociatedNum.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
NewwirelessIfSuccAssociatedNum_map(u_long *mib_NewwirelessIfSuccAssociatedNum_val_ptr, u_long raw_NewwirelessIfSuccAssociatedNum_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfSuccAssociatedNum_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfSuccAssociatedNum_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfSuccAssociatedNum mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfSuccAssociatedNum_val_ptr) = raw_NewwirelessIfSuccAssociatedNum_val;

    return MFD_SUCCESS;
} /* NewwirelessIfSuccAssociatedNum_map */

/**
 * Extract the current value of the NewwirelessIfSuccAssociatedNum data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfSuccAssociatedNum_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
NewwirelessIfSuccAssociatedNum_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfSuccAssociatedNum_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfSuccAssociatedNum_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfSuccAssociatedNum_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfSuccAssociatedNum data.
 * set (* NewwirelessIfSuccAssociatedNum_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfSuccAssociatedNum_val_ptr ) = rowreq_ctx->data.NewwirelessIfSuccAssociatedNum;

    return MFD_SUCCESS;
} /* NewwirelessIfSuccAssociatedNum_get */

int
NewwirelessIfallApUserOnlineTime_map(u_long *mib_NewwirelessIfallApUserOnlineTime_val_ptr, u_long raw_NewwirelessIfallApUserOnlineTime_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfallApUserOnlineTime_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfallApUserOnlineTime_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfallApUserOnlineTime mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfallApUserOnlineTime_val_ptr) = raw_NewwirelessIfallApUserOnlineTime_val;

    return MFD_SUCCESS;
}
int
NewwirelessIfallApUserOnlineTime_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfallApUserOnlineTime_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfallApUserOnlineTime_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfallApUserOnlineTime_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfallApUserOnlineTime data.
 * copy (* NewwirelessIfallApUserOnlineTime_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfallApUserOnlineTime_val_ptr ) = rowreq_ctx->data.NewwirelessIfallApUserOnlineTime;

    return MFD_SUCCESS;
} /* NewwirelessIfallApUserOnlineTime_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfApUserLostConnectionCnt
 * NewwirelessIfApUserLostConnectionCnt is subid 36 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.8.1.36
 * Description:
 The total fail number of AP.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the NewwirelessIfApUserLostConnectionCnt data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfApUserLostConnectionCnt_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
 int
NewwirelessIfApUserLostConnectionCnt_map(u_long *mib_NewwirelessIfApUserLostConnectionCnt_val_ptr, u_long raw_NewwirelessIfApUserLostConnectionCnt_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfApUserLostConnectionCnt_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfApUserLostConnectionCnt_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfApUserLostConnectionCnt mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfApUserLostConnectionCnt_val_ptr) = raw_NewwirelessIfApUserLostConnectionCnt_val;

    return MFD_SUCCESS;
}
int
NewwirelessIfApUserLostConnectionCnt_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfApUserLostConnectionCnt_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfApUserLostConnectionCnt_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfApUserLostConnectionCnt_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfApUserLostConnectionCnt data.
 * copy (* NewwirelessIfApUserLostConnectionCnt_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfApUserLostConnectionCnt_val_ptr ) = rowreq_ctx->data.NewwirelessIfApUserLostConnectionCnt;

    return MFD_SUCCESS;
} /* NewwirelessIfApUserLostConnectionCnt_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfApAuthReqCnt
 * NewwirelessIfApAuthReqCnt is subid 37 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.8.1.37
 * Description:
 The total request number of AP.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the NewwirelessIfApAuthReqCnt data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfApAuthReqCnt_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */

 int
NewwirelessIfApAuthReqCnt_map(u_long *mib_NewwirelessIfApAuthReqCnt_val_ptr, u_long raw_NewwirelessIfApAuthReqCnt_val)
{
    netsnmp_assert(NULL != mib_NewwirelessIfApAuthReqCnt_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfApAuthReqCnt_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement NewwirelessIfApAuthReqCnt mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_NewwirelessIfApAuthReqCnt_val_ptr) = raw_NewwirelessIfApAuthReqCnt_val;

    return MFD_SUCCESS;
}

int
NewwirelessIfApAuthReqCnt_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfApAuthReqCnt_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfApAuthReqCnt_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfApAuthReqCnt_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfApAuthReqCnt data.
 * copy (* NewwirelessIfApAuthReqCnt_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfApAuthReqCnt_val_ptr ) = rowreq_ctx->data.NewwirelessIfApAuthReqCnt;

    return MFD_SUCCESS;
} /* NewwirelessIfApAuthReqCnt_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfApAuthSucCnt
 * NewwirelessIfApAuthSucCnt is subid 38 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.8.1.38
 * Description:
 The total request success number of AP.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the NewwirelessIfApAuthSucCnt data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfApAuthSucCnt_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
 int
NewwirelessIfApAuthSucCnt_map(u_long *mib_NewwirelessIfApAuthSucCnt_val_ptr, u_long raw_NewwirelessIfApAuthSucCnt_val)
{
	netsnmp_assert(NULL != mib_NewwirelessIfApAuthSucCnt_val_ptr);
	
	DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfApAuthSucCnt_map","called\n"));
	
	/*
	 * TODO:241:o: |-> Implement NewwirelessIfApAuthSucCnt mapping.
	 * If the values for your data type don't exactly match the
	 * possible values defined by the mib, you should map them here.
	 */
	(*mib_NewwirelessIfApAuthSucCnt_val_ptr) = raw_NewwirelessIfApAuthSucCnt_val;

	return MFD_SUCCESS;
}

int
NewwirelessIfApAuthSucCnt_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfApAuthSucCnt_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfApAuthSucCnt_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfApAuthSucCnt_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfApAuthSucCnt data.
 * copy (* NewwirelessIfApAuthSucCnt_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfApAuthSucCnt_val_ptr ) = rowreq_ctx->data.NewwirelessIfApAuthSucCnt;

    return MFD_SUCCESS;
} /* NewwirelessIfApAuthSucCnt_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11NewWtpWirelessIfstatsEntry.NewwirelessIfApAuthFailCnt
 * NewwirelessIfApAuthFailCnt is subid 39 of dot11NewWtpWirelessIfstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.8.1.39
 * Description:
 The total request fail number of AP.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the NewwirelessIfApAuthFailCnt data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param NewwirelessIfApAuthFailCnt_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */

 int
NewwirelessIfApAuthFailCnt_map(u_long *mib_NewwirelessIfApAuthFailCnt_val_ptr, u_long raw_NewwirelessIfApAuthFailCnt_val)
{
	netsnmp_assert(NULL != mib_NewwirelessIfApAuthFailCnt_val_ptr);
	
	DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfApAuthFailCnt_map","called\n"));
	
	/*
	 * TODO:241:o: |-> Implement NewwirelessIfApAuthFailCnt mapping.
	 * If the values for your data type don't exactly match the
	 * possible values defined by the mib, you should map them here.
	 */
	(*mib_NewwirelessIfApAuthFailCnt_val_ptr) = raw_NewwirelessIfApAuthFailCnt_val;

	return MFD_SUCCESS;
}

int
NewwirelessIfApAuthFailCnt_get( dot11NewWtpWirelessIfstatsTable_rowreq_ctx *rowreq_ctx, u_long * NewwirelessIfApAuthFailCnt_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != NewwirelessIfApAuthFailCnt_val_ptr );


    DEBUGMSGTL(("verbose:dot11NewWtpWirelessIfstatsTable:NewwirelessIfApAuthFailCnt_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the NewwirelessIfApAuthFailCnt data.
 * copy (* NewwirelessIfApAuthFailCnt_val_ptr ) from rowreq_ctx->data
 */
    (* NewwirelessIfApAuthFailCnt_val_ptr ) = rowreq_ctx->data.NewwirelessIfApAuthFailCnt;

    return MFD_SUCCESS;
} /* NewwirelessIfApAuthFailCnt_get */


/** @} */
