/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.18.2.1 $ of : mfd-data-get.m2c,v $ 
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "dot11WtpWAPIPerformanceStatsTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement dot11WtpWAPIPerformanceStatsTable get routines.
 * TODO:240:M: Implement dot11WtpWAPIPerformanceStatsTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table dot11WtpWAPIPerformanceStatsTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * dot11WtpWAPIPerformanceStatsTable is subid 4 of wtpWAPI.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.33050.6.1.1.10.4, length: 12
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement dot11WtpWAPIPerformanceStatsTable data context functions.
 */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIPerformanceStatsEntry.staMacAddr
 * staMacAddr is subid 1 of dot11WtpWAPIPerformanceStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.10.4.1.1
 * Description:
staMacAddr.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-staMacAddr.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
staMacAddr_dot11WtpWAPIPerformanceStatsTable_map(char **mib_staMacAddr_val_ptr_ptr, size_t *mib_staMacAddr_val_ptr_len_ptr, char *raw_staMacAddr_val_ptr, size_t raw_staMacAddr_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_staMacAddr_val_ptr);
    netsnmp_assert((NULL != mib_staMacAddr_val_ptr_ptr) && (NULL != mib_staMacAddr_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:staMacAddr_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement staMacAddr non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_staMacAddr_val_ptr_len; /* assume equal */
    if((NULL == *mib_staMacAddr_val_ptr_ptr) || (*mib_staMacAddr_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_staMacAddr_val_ptr_ptr = realloc( *mib_staMacAddr_val_ptr_ptr, converted_len * sizeof(**mib_staMacAddr_val_ptr_ptr));
        if(NULL == *mib_staMacAddr_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_staMacAddr_val_ptr_len_ptr = converted_len;
    memcpy( *mib_staMacAddr_val_ptr_ptr, raw_staMacAddr_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* staMacAddr_map */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
dot11WtpWAPIPerformanceStatsTable_indexes_set_tbl_idx(dot11WtpWAPIPerformanceStatsTable_mib_index *tbl_idx, char *staMacAddr_val_ptr,  size_t staMacAddr_val_ptr_len)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:dot11WtpWAPIPerformanceStatsTable_indexes_set_tbl_idx","called\n"));

    /* staMacAddr(1)/DisplayString/ASN_OCTET_STR/char(char)//L/A/w/e/R/d/H */
     tbl_idx->staMacAddr_len = sizeof(tbl_idx->staMacAddr);
    /*
     * make sure there is enough space for staMacAddr data
     */
    if ((NULL == tbl_idx->staMacAddr) ||
        (tbl_idx->staMacAddr_len < (staMacAddr_val_ptr_len * sizeof(tbl_idx->staMacAddr[0])))) {
        snmp_log(LOG_ERR,"not enough space for value\n");
        return MFD_ERROR;
    }
    tbl_idx->staMacAddr_len = staMacAddr_val_ptr_len * sizeof(tbl_idx->staMacAddr[0]);
    memcpy( tbl_idx->staMacAddr, staMacAddr_val_ptr, tbl_idx->staMacAddr_len );
    

    return MFD_SUCCESS;
} /* dot11WtpWAPIPerformanceStatsTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
dot11WtpWAPIPerformanceStatsTable_indexes_set(dot11WtpWAPIPerformanceStatsTable_rowreq_ctx *rowreq_ctx, char *staMacAddr_val_ptr,  size_t staMacAddr_val_ptr_len)
{
    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:dot11WtpWAPIPerformanceStatsTable_indexes_set","called\n"));

    if(MFD_SUCCESS != dot11WtpWAPIPerformanceStatsTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
                                   , staMacAddr_val_ptr, staMacAddr_val_ptr_len
           ))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if(0 != dot11WtpWAPIPerformanceStatsTable_index_to_oid(&rowreq_ctx->oid_idx,
                                    &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* dot11WtpWAPIPerformanceStatsTable_indexes_set */


/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIPerformanceStatsEntry.wtpWapiVersion
 * wtpWapiVersion is subid 2 of dot11WtpWAPIPerformanceStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.10.4.1.2
 * Description:
Wapi version.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiVersion.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiVersion_map(long *mib_wtpWapiVersion_val_ptr, long raw_wtpWapiVersion_val)
{
    netsnmp_assert(NULL != mib_wtpWapiVersion_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiVersion_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiVersion mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWapiVersion_val_ptr) = raw_wtpWapiVersion_val;

    return MFD_SUCCESS;
} /* wtpWapiVersion_map */

/**
 * Extract the current value of the wtpWapiVersion data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiVersion_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiVersion_get( dot11WtpWAPIPerformanceStatsTable_rowreq_ctx *rowreq_ctx, long * wtpWapiVersion_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiVersion_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiVersion_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiVersion data.
 * set (* wtpWapiVersion_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiVersion_val_ptr ) = rowreq_ctx->data.wtpWapiVersion;

    return MFD_SUCCESS;
} /* wtpWapiVersion_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIPerformanceStatsEntry.wtpWapiControlledPortStatus
 * wtpWapiControlledPortStatus is subid 3 of dot11WtpWAPIPerformanceStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.10.4.1.3
 * Description:
Authentication controled port status.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiControlledPortStatus.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiControlledPortStatus_map(u_long *mib_wtpWapiControlledPortStatus_val_ptr, u_long raw_wtpWapiControlledPortStatus_val)
{
    netsnmp_assert(NULL != mib_wtpWapiControlledPortStatus_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiControlledPortStatus_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiControlledPortStatus enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wtpWapiControlledPortStatus_val) {
        case INTERNAL_WTPWAPICONTROLLEDPORTSTATUS_TRUE:
             *mib_wtpWapiControlledPortStatus_val_ptr = TRUTHVALUE_TRUE;
             break;

        case INTERNAL_WTPWAPICONTROLLEDPORTSTATUS_FALSE:
             *mib_wtpWapiControlledPortStatus_val_ptr = TRUTHVALUE_FALSE;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wtpWapiControlledPortStatus\n", raw_wtpWapiControlledPortStatus_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wtpWapiControlledPortStatus_map */

/**
 * Extract the current value of the wtpWapiControlledPortStatus data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiControlledPortStatus_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiControlledPortStatus_get( dot11WtpWAPIPerformanceStatsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiControlledPortStatus_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiControlledPortStatus_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiControlledPortStatus_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiControlledPortStatus data.
 * set (* wtpWapiControlledPortStatus_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiControlledPortStatus_val_ptr ) = rowreq_ctx->data.wtpWapiControlledPortStatus;

    return MFD_SUCCESS;
} /* wtpWapiControlledPortStatus_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIPerformanceStatsEntry.wtpWapiSelectedUnicastCipher
 * wtpWapiSelectedUnicastCipher is subid 4 of dot11WtpWAPIPerformanceStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.10.4.1.4
 * Description:
Selected unicast encryption cipher.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiSelectedUnicastCipher.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiSelectedUnicastCipher_map(char **mib_wtpWapiSelectedUnicastCipher_val_ptr_ptr, size_t *mib_wtpWapiSelectedUnicastCipher_val_ptr_len_ptr, char *raw_wtpWapiSelectedUnicastCipher_val_ptr, size_t raw_wtpWapiSelectedUnicastCipher_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpWapiSelectedUnicastCipher_val_ptr);
    netsnmp_assert((NULL != mib_wtpWapiSelectedUnicastCipher_val_ptr_ptr) && (NULL != mib_wtpWapiSelectedUnicastCipher_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiSelectedUnicastCipher_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpWapiSelectedUnicastCipher non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpWapiSelectedUnicastCipher_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpWapiSelectedUnicastCipher_val_ptr_ptr) || (*mib_wtpWapiSelectedUnicastCipher_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpWapiSelectedUnicastCipher_val_ptr_ptr = realloc( *mib_wtpWapiSelectedUnicastCipher_val_ptr_ptr, converted_len * sizeof(**mib_wtpWapiSelectedUnicastCipher_val_ptr_ptr));
        if(NULL == *mib_wtpWapiSelectedUnicastCipher_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpWapiSelectedUnicastCipher_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpWapiSelectedUnicastCipher_val_ptr_ptr, raw_wtpWapiSelectedUnicastCipher_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpWapiSelectedUnicastCipher_map */

/**
 * Extract the current value of the wtpWapiSelectedUnicastCipher data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiSelectedUnicastCipher_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wtpWapiSelectedUnicastCipher_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wtpWapiSelectedUnicastCipher.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wtpWapiSelectedUnicastCipher_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wtpWapiSelectedUnicastCipher_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wtpWapiSelectedUnicastCipher_get( dot11WtpWAPIPerformanceStatsTable_rowreq_ctx *rowreq_ctx, char **wtpWapiSelectedUnicastCipher_val_ptr_ptr, size_t *wtpWapiSelectedUnicastCipher_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != wtpWapiSelectedUnicastCipher_val_ptr_ptr) && (NULL != *wtpWapiSelectedUnicastCipher_val_ptr_ptr));
   netsnmp_assert( NULL != wtpWapiSelectedUnicastCipher_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiSelectedUnicastCipher_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiSelectedUnicastCipher data.
 * set (* wtpWapiSelectedUnicastCipher_val_ptr_ptr ) and (* wtpWapiSelectedUnicastCipher_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for wtpWapiSelectedUnicastCipher data
     */
    if ((NULL == (* wtpWapiSelectedUnicastCipher_val_ptr_ptr )) ||
        ((* wtpWapiSelectedUnicastCipher_val_ptr_len_ptr ) < (rowreq_ctx->data.wtpWapiSelectedUnicastCipher_len * sizeof((* wtpWapiSelectedUnicastCipher_val_ptr_ptr )[0])))) {
        /*
         * allocate space for wtpWapiSelectedUnicastCipher data
         */
        (* wtpWapiSelectedUnicastCipher_val_ptr_ptr ) = malloc(rowreq_ctx->data.wtpWapiSelectedUnicastCipher_len * sizeof((* wtpWapiSelectedUnicastCipher_val_ptr_ptr )[0]));
        if(NULL == (* wtpWapiSelectedUnicastCipher_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* wtpWapiSelectedUnicastCipher_val_ptr_len_ptr ) = rowreq_ctx->data.wtpWapiSelectedUnicastCipher_len * sizeof((* wtpWapiSelectedUnicastCipher_val_ptr_ptr )[0]);
    memcpy( (* wtpWapiSelectedUnicastCipher_val_ptr_ptr ), rowreq_ctx->data.wtpWapiSelectedUnicastCipher, (* wtpWapiSelectedUnicastCipher_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* wtpWapiSelectedUnicastCipher_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIPerformanceStatsEntry.wtpWapiWPIReplayCounters
 * wtpWapiWPIReplayCounters is subid 5 of dot11WtpWAPIPerformanceStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.10.4.1.5
 * Description:
The amount of WPI MPDU which droped because of response response mechanism.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiWPIReplayCounters.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiWPIReplayCounters_map(u_long *mib_wtpWapiWPIReplayCounters_val_ptr, u_long raw_wtpWapiWPIReplayCounters_val)
{
    netsnmp_assert(NULL != mib_wtpWapiWPIReplayCounters_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiWPIReplayCounters_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiWPIReplayCounters mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWapiWPIReplayCounters_val_ptr) = raw_wtpWapiWPIReplayCounters_val;

    return MFD_SUCCESS;
} /* wtpWapiWPIReplayCounters_map */

/**
 * Extract the current value of the wtpWapiWPIReplayCounters data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiWPIReplayCounters_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiWPIReplayCounters_get( dot11WtpWAPIPerformanceStatsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiWPIReplayCounters_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiWPIReplayCounters_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiWPIReplayCounters_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiWPIReplayCounters data.
 * set (* wtpWapiWPIReplayCounters_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiWPIReplayCounters_val_ptr ) = rowreq_ctx->data.wtpWapiWPIReplayCounters;

    return MFD_SUCCESS;
} /* wtpWapiWPIReplayCounters_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIPerformanceStatsEntry.wtpWapiWPIDecryptableErrors
 * wtpWapiWPIDecryptableErrors is subid 6 of dot11WtpWAPIPerformanceStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.10.4.1.6
 * Description:
The amount of WPI MPDU which droped because of invalid key.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiWPIDecryptableErrors.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiWPIDecryptableErrors_map(u_long *mib_wtpWapiWPIDecryptableErrors_val_ptr, u_long raw_wtpWapiWPIDecryptableErrors_val)
{
    netsnmp_assert(NULL != mib_wtpWapiWPIDecryptableErrors_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiWPIDecryptableErrors_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiWPIDecryptableErrors mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWapiWPIDecryptableErrors_val_ptr) = raw_wtpWapiWPIDecryptableErrors_val;

    return MFD_SUCCESS;
} /* wtpWapiWPIDecryptableErrors_map */

/**
 * Extract the current value of the wtpWapiWPIDecryptableErrors data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiWPIDecryptableErrors_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiWPIDecryptableErrors_get( dot11WtpWAPIPerformanceStatsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiWPIDecryptableErrors_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiWPIDecryptableErrors_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiWPIDecryptableErrors_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiWPIDecryptableErrors data.
 * set (* wtpWapiWPIDecryptableErrors_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiWPIDecryptableErrors_val_ptr ) = rowreq_ctx->data.wtpWapiWPIDecryptableErrors;

    return MFD_SUCCESS;
} /* wtpWapiWPIDecryptableErrors_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIPerformanceStatsEntry.wtpWapiWPIMICErrors
 * wtpWapiWPIMICErrors is subid 7 of dot11WtpWAPIPerformanceStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.10.4.1.7
 * Description:
The amount of WPI MPDU which droped because of mic check failure.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiWPIMICErrors.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiWPIMICErrors_map(u_long *mib_wtpWapiWPIMICErrors_val_ptr, u_long raw_wtpWapiWPIMICErrors_val)
{
    netsnmp_assert(NULL != mib_wtpWapiWPIMICErrors_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiWPIMICErrors_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiWPIMICErrors mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWapiWPIMICErrors_val_ptr) = raw_wtpWapiWPIMICErrors_val;

    return MFD_SUCCESS;
} /* wtpWapiWPIMICErrors_map */

/**
 * Extract the current value of the wtpWapiWPIMICErrors data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiWPIMICErrors_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiWPIMICErrors_get( dot11WtpWAPIPerformanceStatsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiWPIMICErrors_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiWPIMICErrors_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiWPIMICErrors_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiWPIMICErrors data.
 * set (* wtpWapiWPIMICErrors_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiWPIMICErrors_val_ptr ) = rowreq_ctx->data.wtpWapiWPIMICErrors;

    return MFD_SUCCESS;
} /* wtpWapiWPIMICErrors_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIPerformanceStatsEntry.wtpWapiWAISignatureErrors
 * wtpWapiWAISignatureErrors is subid 8 of dot11WtpWAPIPerformanceStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.10.4.1.8
 * Description:
The amount of WAI data packets of signed error.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiWAISignatureErrors.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiWAISignatureErrors_map(u_long *mib_wtpWapiWAISignatureErrors_val_ptr, u_long raw_wtpWapiWAISignatureErrors_val)
{
    netsnmp_assert(NULL != mib_wtpWapiWAISignatureErrors_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiWAISignatureErrors_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiWAISignatureErrors mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWapiWAISignatureErrors_val_ptr) = raw_wtpWapiWAISignatureErrors_val;

    return MFD_SUCCESS;
} /* wtpWapiWAISignatureErrors_map */

/**
 * Extract the current value of the wtpWapiWAISignatureErrors data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiWAISignatureErrors_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiWAISignatureErrors_get( dot11WtpWAPIPerformanceStatsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiWAISignatureErrors_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiWAISignatureErrors_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiWAISignatureErrors_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiWAISignatureErrors data.
 * set (* wtpWapiWAISignatureErrors_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiWAISignatureErrors_val_ptr ) = rowreq_ctx->data.wtpWapiWAISignatureErrors;

    return MFD_SUCCESS;
} /* wtpWapiWAISignatureErrors_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIPerformanceStatsEntry.wtpWapiWAIHMACErrors
 * wtpWapiWAIHMACErrors is subid 9 of dot11WtpWAPIPerformanceStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.10.4.1.9
 * Description:
Authentication key WAI validation failure the number of packets.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiWAIHMACErrors.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiWAIHMACErrors_map(u_long *mib_wtpWapiWAIHMACErrors_val_ptr, u_long raw_wtpWapiWAIHMACErrors_val)
{
    netsnmp_assert(NULL != mib_wtpWapiWAIHMACErrors_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiWAIHMACErrors_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiWAIHMACErrors mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWapiWAIHMACErrors_val_ptr) = raw_wtpWapiWAIHMACErrors_val;

    return MFD_SUCCESS;
} /* wtpWapiWAIHMACErrors_map */

/**
 * Extract the current value of the wtpWapiWAIHMACErrors data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiWAIHMACErrors_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiWAIHMACErrors_get( dot11WtpWAPIPerformanceStatsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiWAIHMACErrors_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiWAIHMACErrors_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiWAIHMACErrors_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiWAIHMACErrors data.
 * set (* wtpWapiWAIHMACErrors_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiWAIHMACErrors_val_ptr ) = rowreq_ctx->data.wtpWapiWAIHMACErrors;

    return MFD_SUCCESS;
} /* wtpWapiWAIHMACErrors_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIPerformanceStatsEntry.wtpWapiWAIAuthResultFailures
 * wtpWapiWAIAuthResultFailures is subid 10 of dot11WtpWAPIPerformanceStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.10.4.1.10
 * Description:
The number of WAI failed authentication.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiWAIAuthResultFailures.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiWAIAuthResultFailures_map(u_long *mib_wtpWapiWAIAuthResultFailures_val_ptr, u_long raw_wtpWapiWAIAuthResultFailures_val)
{
    netsnmp_assert(NULL != mib_wtpWapiWAIAuthResultFailures_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiWAIAuthResultFailures_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiWAIAuthResultFailures mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWapiWAIAuthResultFailures_val_ptr) = raw_wtpWapiWAIAuthResultFailures_val;

    return MFD_SUCCESS;
} /* wtpWapiWAIAuthResultFailures_map */

/**
 * Extract the current value of the wtpWapiWAIAuthResultFailures data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiWAIAuthResultFailures_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiWAIAuthResultFailures_get( dot11WtpWAPIPerformanceStatsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiWAIAuthResultFailures_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiWAIAuthResultFailures_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiWAIAuthResultFailures_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiWAIAuthResultFailures data.
 * set (* wtpWapiWAIAuthResultFailures_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiWAIAuthResultFailures_val_ptr ) = rowreq_ctx->data.wtpWapiWAIAuthResultFailures;

    return MFD_SUCCESS;
} /* wtpWapiWAIAuthResultFailures_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIPerformanceStatsEntry.wtpWapiWAIDiscardCounters
 * wtpWapiWAIDiscardCounters is subid 11 of dot11WtpWAPIPerformanceStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.10.4.1.11
 * Description:
The number of WAI packets discarded.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiWAIDiscardCounters.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiWAIDiscardCounters_map(u_long *mib_wtpWapiWAIDiscardCounters_val_ptr, u_long raw_wtpWapiWAIDiscardCounters_val)
{
    netsnmp_assert(NULL != mib_wtpWapiWAIDiscardCounters_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiWAIDiscardCounters_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiWAIDiscardCounters mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWapiWAIDiscardCounters_val_ptr) = raw_wtpWapiWAIDiscardCounters_val;

    return MFD_SUCCESS;
} /* wtpWapiWAIDiscardCounters_map */

/**
 * Extract the current value of the wtpWapiWAIDiscardCounters data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiWAIDiscardCounters_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiWAIDiscardCounters_get( dot11WtpWAPIPerformanceStatsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiWAIDiscardCounters_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiWAIDiscardCounters_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiWAIDiscardCounters_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiWAIDiscardCounters data.
 * set (* wtpWapiWAIDiscardCounters_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiWAIDiscardCounters_val_ptr ) = rowreq_ctx->data.wtpWapiWAIDiscardCounters;

    return MFD_SUCCESS;
} /* wtpWapiWAIDiscardCounters_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIPerformanceStatsEntry.wtpWapiWAITimeoutCounters
 * wtpWapiWAITimeoutCounters is subid 12 of dot11WtpWAPIPerformanceStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.10.4.1.12
 * Description:
The number of WAI overtime packet.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiWAITimeoutCounters.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiWAITimeoutCounters_map(u_long *mib_wtpWapiWAITimeoutCounters_val_ptr, u_long raw_wtpWapiWAITimeoutCounters_val)
{
    netsnmp_assert(NULL != mib_wtpWapiWAITimeoutCounters_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiWAITimeoutCounters_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiWAITimeoutCounters mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWapiWAITimeoutCounters_val_ptr) = raw_wtpWapiWAITimeoutCounters_val;

    return MFD_SUCCESS;
} /* wtpWapiWAITimeoutCounters_map */

/**
 * Extract the current value of the wtpWapiWAITimeoutCounters data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiWAITimeoutCounters_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiWAITimeoutCounters_get( dot11WtpWAPIPerformanceStatsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiWAITimeoutCounters_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiWAITimeoutCounters_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiWAITimeoutCounters_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiWAITimeoutCounters data.
 * set (* wtpWapiWAITimeoutCounters_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiWAITimeoutCounters_val_ptr ) = rowreq_ctx->data.wtpWapiWAITimeoutCounters;

    return MFD_SUCCESS;
} /* wtpWapiWAITimeoutCounters_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIPerformanceStatsEntry.wtpWapiWAIFormatErrors
 * wtpWapiWAIFormatErrors is subid 13 of dot11WtpWAPIPerformanceStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.10.4.1.13
 * Description:
WAI malformed packet number.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiWAIFormatErrors.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiWAIFormatErrors_map(u_long *mib_wtpWapiWAIFormatErrors_val_ptr, u_long raw_wtpWapiWAIFormatErrors_val)
{
    netsnmp_assert(NULL != mib_wtpWapiWAIFormatErrors_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiWAIFormatErrors_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiWAIFormatErrors mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWapiWAIFormatErrors_val_ptr) = raw_wtpWapiWAIFormatErrors_val;

    return MFD_SUCCESS;
} /* wtpWapiWAIFormatErrors_map */

/**
 * Extract the current value of the wtpWapiWAIFormatErrors data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiWAIFormatErrors_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiWAIFormatErrors_get( dot11WtpWAPIPerformanceStatsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiWAIFormatErrors_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiWAIFormatErrors_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiWAIFormatErrors_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiWAIFormatErrors data.
 * set (* wtpWapiWAIFormatErrors_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiWAIFormatErrors_val_ptr ) = rowreq_ctx->data.wtpWapiWAIFormatErrors;

    return MFD_SUCCESS;
} /* wtpWapiWAIFormatErrors_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIPerformanceStatsEntry.wtpWapiWAICertificateHandshakeFailures
 * wtpWapiWAICertificateHandshakeFailures is subid 14 of dot11WtpWAPIPerformanceStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.10.4.1.14
 * Description:
WAI failed to shake hands with the number of certified.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiWAICertificateHandshakeFailures.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiWAICertificateHandshakeFailures_map(u_long *mib_wtpWapiWAICertificateHandshakeFailures_val_ptr, u_long raw_wtpWapiWAICertificateHandshakeFailures_val)
{
    netsnmp_assert(NULL != mib_wtpWapiWAICertificateHandshakeFailures_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiWAICertificateHandshakeFailures_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiWAICertificateHandshakeFailures mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWapiWAICertificateHandshakeFailures_val_ptr) = raw_wtpWapiWAICertificateHandshakeFailures_val;

    return MFD_SUCCESS;
} /* wtpWapiWAICertificateHandshakeFailures_map */

/**
 * Extract the current value of the wtpWapiWAICertificateHandshakeFailures data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiWAICertificateHandshakeFailures_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiWAICertificateHandshakeFailures_get( dot11WtpWAPIPerformanceStatsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiWAICertificateHandshakeFailures_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiWAICertificateHandshakeFailures_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiWAICertificateHandshakeFailures_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiWAICertificateHandshakeFailures data.
 * set (* wtpWapiWAICertificateHandshakeFailures_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiWAICertificateHandshakeFailures_val_ptr ) = rowreq_ctx->data.wtpWapiWAICertificateHandshakeFailures;

    return MFD_SUCCESS;
} /* wtpWapiWAICertificateHandshakeFailures_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIPerformanceStatsEntry.wtpWapiWAIUnicastHandshakeFailures
 * wtpWapiWAIUnicastHandshakeFailures is subid 15 of dot11WtpWAPIPerformanceStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.10.4.1.15
 * Description:
WAI unicast number of the failure of key agreement.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiWAIUnicastHandshakeFailures.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiWAIUnicastHandshakeFailures_map(u_long *mib_wtpWapiWAIUnicastHandshakeFailures_val_ptr, u_long raw_wtpWapiWAIUnicastHandshakeFailures_val)
{
    netsnmp_assert(NULL != mib_wtpWapiWAIUnicastHandshakeFailures_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiWAIUnicastHandshakeFailures_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiWAIUnicastHandshakeFailures mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWapiWAIUnicastHandshakeFailures_val_ptr) = raw_wtpWapiWAIUnicastHandshakeFailures_val;

    return MFD_SUCCESS;
} /* wtpWapiWAIUnicastHandshakeFailures_map */

/**
 * Extract the current value of the wtpWapiWAIUnicastHandshakeFailures data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiWAIUnicastHandshakeFailures_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiWAIUnicastHandshakeFailures_get( dot11WtpWAPIPerformanceStatsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiWAIUnicastHandshakeFailures_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiWAIUnicastHandshakeFailures_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiWAIUnicastHandshakeFailures_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiWAIUnicastHandshakeFailures data.
 * set (* wtpWapiWAIUnicastHandshakeFailures_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiWAIUnicastHandshakeFailures_val_ptr ) = rowreq_ctx->data.wtpWapiWAIUnicastHandshakeFailures;

    return MFD_SUCCESS;
} /* wtpWapiWAIUnicastHandshakeFailures_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWAPIPerformanceStatsEntry.wtpWapiWAIMulticastHandshakeFailures
 * wtpWapiWAIMulticastHandshakeFailures is subid 16 of dot11WtpWAPIPerformanceStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.33050.6.1.1.10.4.1.16
 * Description:
WAI multicast number of key failure.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWapiWAIMulticastHandshakeFailures.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWapiWAIMulticastHandshakeFailures_map(u_long *mib_wtpWapiWAIMulticastHandshakeFailures_val_ptr, u_long raw_wtpWapiWAIMulticastHandshakeFailures_val)
{
    netsnmp_assert(NULL != mib_wtpWapiWAIMulticastHandshakeFailures_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiWAIMulticastHandshakeFailures_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWapiWAIMulticastHandshakeFailures mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWapiWAIMulticastHandshakeFailures_val_ptr) = raw_wtpWapiWAIMulticastHandshakeFailures_val;

    return MFD_SUCCESS;
} /* wtpWapiWAIMulticastHandshakeFailures_map */

/**
 * Extract the current value of the wtpWapiWAIMulticastHandshakeFailures data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpWapiWAIMulticastHandshakeFailures_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpWapiWAIMulticastHandshakeFailures_get( dot11WtpWAPIPerformanceStatsTable_rowreq_ctx *rowreq_ctx, u_long * wtpWapiWAIMulticastHandshakeFailures_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpWapiWAIMulticastHandshakeFailures_val_ptr );


    DEBUGMSGTL(("verbose:dot11WtpWAPIPerformanceStatsTable:wtpWapiWAIMulticastHandshakeFailures_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpWapiWAIMulticastHandshakeFailures data.
 * set (* wtpWapiWAIMulticastHandshakeFailures_val_ptr ) from rowreq_ctx->data
 */
    (* wtpWapiWAIMulticastHandshakeFailures_val_ptr ) = rowreq_ctx->data.wtpWapiWAIMulticastHandshakeFailures;

    return MFD_SUCCESS;
} /* wtpWapiWAIMulticastHandshakeFailures_get */



/** @} */
