/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.18.2.1 $ of : mfd-data-get.m2c,v $ 
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "dot11ConfigWlanTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement dot11ConfigWlanTable get routines.
 * TODO:240:M: Implement dot11ConfigWlanTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table dot11ConfigWlanTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * dot11ConfigWlanTable is subid 2 of dot11wlanConfig.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.31656.6.1.2.13.2, length: 12
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement dot11ConfigWlanTable data context functions.
 */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11VlanConfigEntry.wlanID
 * wlanID is subid 1 of dot11VlanConfigEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.2.7.1.1
 * Description:
Vlan ID.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wlanID.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wlanID_dot11ConfigWlanTable_map(long *mib_wlanID_val_ptr, long raw_wlanID_val)
{
    netsnmp_assert(NULL != mib_wlanID_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanID_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wlanID mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wlanID_val_ptr) = raw_wlanID_val;

    return MFD_SUCCESS;
} /* wlanID_map */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
dot11ConfigWlanTable_indexes_set_tbl_idx(dot11ConfigWlanTable_mib_index *tbl_idx, long wlanID_val)
{
    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:dot11ConfigWlanTable_indexes_set_tbl_idx","called\n"));

    /* wlanID(1)/INTEGER/ASN_INTEGER/long(long)//l/A/W/e/r/d/h */
    tbl_idx->wlanID = wlanID_val;
    

    return MFD_SUCCESS;
} /* dot11ConfigWlanTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
dot11ConfigWlanTable_indexes_set(dot11ConfigWlanTable_rowreq_ctx *rowreq_ctx, long wlanID_val)
{
    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:dot11ConfigWlanTable_indexes_set","called\n"));

    if(MFD_SUCCESS != dot11ConfigWlanTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
                                   , wlanID_val
           ))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if(0 != dot11ConfigWlanTable_index_to_oid(&rowreq_ctx->oid_idx,
                                    &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* dot11ConfigWlanTable_indexes_set */


/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigWlanEntry.wlanBindSecurity
 * wlanBindSecurity is subid 1 of dot11ConfigWlanEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.2.13.2.1.1
 * Description:
Bind security.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wlanBindSecurity.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wlanBindSecurity_map(long *mib_wlanBindSecurity_val_ptr, long raw_wlanBindSecurity_val)
{
    netsnmp_assert(NULL != mib_wlanBindSecurity_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanBindSecurity_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wlanBindSecurity mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wlanBindSecurity_val_ptr) = raw_wlanBindSecurity_val;

    return MFD_SUCCESS;
} /* wlanBindSecurity_map */

/**
 * Extract the current value of the wlanBindSecurity data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wlanBindSecurity_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wlanBindSecurity_get( dot11ConfigWlanTable_rowreq_ctx *rowreq_ctx, long * wlanBindSecurity_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wlanBindSecurity_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanBindSecurity_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wlanBindSecurity data.
 * set (* wlanBindSecurity_val_ptr ) from rowreq_ctx->data
 */
    (* wlanBindSecurity_val_ptr ) = rowreq_ctx->data.wlanBindSecurity;

    return MFD_SUCCESS;
} /* wlanBindSecurity_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigWlanEntry.wlanBindIf
 * wlanBindIf is subid 2 of dot11ConfigWlanEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.2.13.2.1.2
 * Description:
Bind interface.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wlanBindIf.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wlanBindIf_map(char **mib_wlanBindIf_val_ptr_ptr, size_t *mib_wlanBindIf_val_ptr_len_ptr, char *raw_wlanBindIf_val_ptr, size_t raw_wlanBindIf_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wlanBindIf_val_ptr);
    netsnmp_assert((NULL != mib_wlanBindIf_val_ptr_ptr) && (NULL != mib_wlanBindIf_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanBindIf_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wlanBindIf non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wlanBindIf_val_ptr_len; /* assume equal */
    if((NULL == *mib_wlanBindIf_val_ptr_ptr) || (*mib_wlanBindIf_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wlanBindIf_val_ptr_ptr = realloc( *mib_wlanBindIf_val_ptr_ptr, converted_len * sizeof(**mib_wlanBindIf_val_ptr_ptr));
        if(NULL == *mib_wlanBindIf_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wlanBindIf_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wlanBindIf_val_ptr_ptr, raw_wlanBindIf_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wlanBindIf_map */

/**
 * Extract the current value of the wlanBindIf data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wlanBindIf_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wlanBindIf_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wlanBindIf.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wlanBindIf_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wlanBindIf_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wlanBindIf_get( dot11ConfigWlanTable_rowreq_ctx *rowreq_ctx, char **wlanBindIf_val_ptr_ptr, size_t *wlanBindIf_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != wlanBindIf_val_ptr_ptr) && (NULL != *wlanBindIf_val_ptr_ptr));
   netsnmp_assert( NULL != wlanBindIf_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanBindIf_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wlanBindIf data.
 * set (* wlanBindIf_val_ptr_ptr ) and (* wlanBindIf_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for wlanBindIf data
     */
    if ((NULL == (* wlanBindIf_val_ptr_ptr )) ||
        ((* wlanBindIf_val_ptr_len_ptr ) < (rowreq_ctx->data.wlanBindIf_len * sizeof((* wlanBindIf_val_ptr_ptr )[0])))) {
        /*
         * allocate space for wlanBindIf data
         */
        (* wlanBindIf_val_ptr_ptr ) = malloc(rowreq_ctx->data.wlanBindIf_len * sizeof((* wlanBindIf_val_ptr_ptr )[0]));
        if(NULL == (* wlanBindIf_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* wlanBindIf_val_ptr_len_ptr ) = rowreq_ctx->data.wlanBindIf_len * sizeof((* wlanBindIf_val_ptr_ptr )[0]);
    memcpy( (* wlanBindIf_val_ptr_ptr ), rowreq_ctx->data.wlanBindIf, (* wlanBindIf_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* wlanBindIf_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigWlanEntry.wlanHideEssid
 * wlanHideEssid is subid 3 of dot11ConfigWlanEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.2.13.2.1.3
 * Description:
Hide ESSID.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  no(0), yes(1)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wlanHideEssid.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wlanHideEssid_map(u_long *mib_wlanHideEssid_val_ptr, u_long raw_wlanHideEssid_val)
{
    netsnmp_assert(NULL != mib_wlanHideEssid_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanHideEssid_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wlanHideEssid enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wlanHideEssid_val) {
        case INTERNAL_WLANHIDEESSID_NO:
             *mib_wlanHideEssid_val_ptr = WLANHIDEESSID_NO;
             break;

        case INTERNAL_WLANHIDEESSID_YES:
             *mib_wlanHideEssid_val_ptr = WLANHIDEESSID_YES;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wlanHideEssid\n", raw_wlanHideEssid_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wlanHideEssid_map */

/**
 * Extract the current value of the wlanHideEssid data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wlanHideEssid_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wlanHideEssid_get( dot11ConfigWlanTable_rowreq_ctx *rowreq_ctx, u_long * wlanHideEssid_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wlanHideEssid_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanHideEssid_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wlanHideEssid data.
 * set (* wlanHideEssid_val_ptr ) from rowreq_ctx->data
 */
    (* wlanHideEssid_val_ptr ) = rowreq_ctx->data.wlanHideEssid;

    return MFD_SUCCESS;
} /* wlanHideEssid_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigWlanEntry.wlanServiceEnable
 * wlanServiceEnable is subid 4 of dot11ConfigWlanEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.2.13.2.1.4
 * Description:
Service enable.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  disable(0), enable(1)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wlanServiceEnable.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wlanServiceEnable_map(u_long *mib_wlanServiceEnable_val_ptr, u_long raw_wlanServiceEnable_val)
{
    netsnmp_assert(NULL != mib_wlanServiceEnable_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanServiceEnable_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wlanServiceEnable enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wlanServiceEnable_val) {
        case INTERNAL_WLANSERVICEENABLE_DISABLE:
             *mib_wlanServiceEnable_val_ptr = WLANSERVICEENABLE_DISABLE;
             break;

        case INTERNAL_WLANSERVICEENABLE_ENABLE:
             *mib_wlanServiceEnable_val_ptr = WLANSERVICEENABLE_ENABLE;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wlanServiceEnable\n", raw_wlanServiceEnable_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wlanServiceEnable_map */

/**
 * Extract the current value of the wlanServiceEnable data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wlanServiceEnable_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wlanServiceEnable_get( dot11ConfigWlanTable_rowreq_ctx *rowreq_ctx, u_long * wlanServiceEnable_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wlanServiceEnable_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanServiceEnable_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wlanServiceEnable data.
 * set (* wlanServiceEnable_val_ptr ) from rowreq_ctx->data
 */
    (* wlanServiceEnable_val_ptr ) = rowreq_ctx->data.wlanServiceEnable;

    return MFD_SUCCESS;
} /* wlanServiceEnable_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigWlanEntry.wlanMaxConnectUsr
 * wlanMaxConnectUsr is subid 5 of dot11ConfigWlanEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.2.13.2.1.5
 * Description:
Max connect user.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wlanMaxConnectUsr.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wlanMaxConnectUsr_map(long *mib_wlanMaxConnectUsr_val_ptr, long raw_wlanMaxConnectUsr_val)
{
    netsnmp_assert(NULL != mib_wlanMaxConnectUsr_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanMaxConnectUsr_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wlanMaxConnectUsr mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wlanMaxConnectUsr_val_ptr) = raw_wlanMaxConnectUsr_val;

    return MFD_SUCCESS;
} /* wlanMaxConnectUsr_map */

/**
 * Extract the current value of the wlanMaxConnectUsr data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wlanMaxConnectUsr_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wlanMaxConnectUsr_get( dot11ConfigWlanTable_rowreq_ctx *rowreq_ctx, long * wlanMaxConnectUsr_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wlanMaxConnectUsr_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanMaxConnectUsr_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wlanMaxConnectUsr data.
 * set (* wlanMaxConnectUsr_val_ptr ) from rowreq_ctx->data
 */
    (* wlanMaxConnectUsr_val_ptr ) = rowreq_ctx->data.wlanMaxConnectUsr;

    return MFD_SUCCESS;
} /* wlanMaxConnectUsr_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigWlanEntry.wlanLoadBalanceStatus
 * wlanLoadBalanceStatus is subid 6 of dot11ConfigWlanEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.2.13.2.1.6
 * Description:
Load balance status.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  no(0), number(1), flow(2)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wlanLoadBalanceStatus.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wlanLoadBalanceStatus_map(u_long *mib_wlanLoadBalanceStatus_val_ptr, u_long raw_wlanLoadBalanceStatus_val)
{
    netsnmp_assert(NULL != mib_wlanLoadBalanceStatus_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanLoadBalanceStatus_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wlanLoadBalanceStatus enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wlanLoadBalanceStatus_val) {
        case INTERNAL_WLANLOADBALANCESTATUS_NO:
             *mib_wlanLoadBalanceStatus_val_ptr = WLANLOADBALANCESTATUS_NO;
             break;

        case INTERNAL_WLANLOADBALANCESTATUS_NUMBER:
             *mib_wlanLoadBalanceStatus_val_ptr = WLANLOADBALANCESTATUS_NUMBER;
             break;

        case INTERNAL_WLANLOADBALANCESTATUS_FLOW:
             *mib_wlanLoadBalanceStatus_val_ptr = WLANLOADBALANCESTATUS_FLOW;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wlanLoadBalanceStatus\n", raw_wlanLoadBalanceStatus_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wlanLoadBalanceStatus_map */

/**
 * Extract the current value of the wlanLoadBalanceStatus data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wlanLoadBalanceStatus_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wlanLoadBalanceStatus_get( dot11ConfigWlanTable_rowreq_ctx *rowreq_ctx, u_long * wlanLoadBalanceStatus_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wlanLoadBalanceStatus_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanLoadBalanceStatus_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wlanLoadBalanceStatus data.
 * set (* wlanLoadBalanceStatus_val_ptr ) from rowreq_ctx->data
 */
    (* wlanLoadBalanceStatus_val_ptr ) = rowreq_ctx->data.wlanLoadBalanceStatus;

    return MFD_SUCCESS;
} /* wlanLoadBalanceStatus_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigWlanEntry.wlanLoadBalanceStatusBaseOnFlow
 * wlanLoadBalanceStatusBaseOnFlow is subid 7 of dot11ConfigWlanEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.2.13.2.1.7
 * Description:
Load balance status select.(Base on flow)
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  disable(0), enable(1)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wlanLoadBalanceStatusBaseOnFlow.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wlanLoadBalanceStatusBaseOnFlow_map(u_long *mib_wlanLoadBalanceStatusBaseOnFlow_val_ptr, u_long raw_wlanLoadBalanceStatusBaseOnFlow_val)
{
    netsnmp_assert(NULL != mib_wlanLoadBalanceStatusBaseOnFlow_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanLoadBalanceStatusBaseOnFlow_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wlanLoadBalanceStatusBaseOnFlow enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wlanLoadBalanceStatusBaseOnFlow_val) {
        case INTERNAL_WLANLOADBALANCESTATUSBASEONFLOW_DISABLE:
             *mib_wlanLoadBalanceStatusBaseOnFlow_val_ptr = WLANLOADBALANCESTATUSBASEONFLOW_DISABLE;
             break;

        case INTERNAL_WLANLOADBALANCESTATUSBASEONFLOW_ENABLE:
             *mib_wlanLoadBalanceStatusBaseOnFlow_val_ptr = WLANLOADBALANCESTATUSBASEONFLOW_ENABLE;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wlanLoadBalanceStatusBaseOnFlow\n", raw_wlanLoadBalanceStatusBaseOnFlow_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wlanLoadBalanceStatusBaseOnFlow_map */

/**
 * Extract the current value of the wlanLoadBalanceStatusBaseOnFlow data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wlanLoadBalanceStatusBaseOnFlow_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wlanLoadBalanceStatusBaseOnFlow_get( dot11ConfigWlanTable_rowreq_ctx *rowreq_ctx, u_long * wlanLoadBalanceStatusBaseOnFlow_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wlanLoadBalanceStatusBaseOnFlow_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanLoadBalanceStatusBaseOnFlow_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wlanLoadBalanceStatusBaseOnFlow data.
 * set (* wlanLoadBalanceStatusBaseOnFlow_val_ptr ) from rowreq_ctx->data
 */
    (* wlanLoadBalanceStatusBaseOnFlow_val_ptr ) = rowreq_ctx->data.wlanLoadBalanceStatusBaseOnFlow;

    return MFD_SUCCESS;
} /* wlanLoadBalanceStatusBaseOnFlow_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigWlanEntry.wlanLoadBalanceStatusBaseOnUsr
 * wlanLoadBalanceStatusBaseOnUsr is subid 8 of dot11ConfigWlanEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.2.13.2.1.8
 * Description:
Load balance status select.(Base on user)
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  disable(0), enable(1)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wlanLoadBalanceStatusBaseOnUsr.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wlanLoadBalanceStatusBaseOnUsr_map(u_long *mib_wlanLoadBalanceStatusBaseOnUsr_val_ptr, u_long raw_wlanLoadBalanceStatusBaseOnUsr_val)
{
    netsnmp_assert(NULL != mib_wlanLoadBalanceStatusBaseOnUsr_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanLoadBalanceStatusBaseOnUsr_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wlanLoadBalanceStatusBaseOnUsr enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wlanLoadBalanceStatusBaseOnUsr_val) {
        case INTERNAL_WLANLOADBALANCESTATUSBASEONUSR_DISABLE:
             *mib_wlanLoadBalanceStatusBaseOnUsr_val_ptr = WLANLOADBALANCESTATUSBASEONUSR_DISABLE;
             break;

        case INTERNAL_WLANLOADBALANCESTATUSBASEONUSR_ENABLE:
             *mib_wlanLoadBalanceStatusBaseOnUsr_val_ptr = WLANLOADBALANCESTATUSBASEONUSR_ENABLE;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wlanLoadBalanceStatusBaseOnUsr\n", raw_wlanLoadBalanceStatusBaseOnUsr_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wlanLoadBalanceStatusBaseOnUsr_map */

/**
 * Extract the current value of the wlanLoadBalanceStatusBaseOnUsr data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wlanLoadBalanceStatusBaseOnUsr_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wlanLoadBalanceStatusBaseOnUsr_get( dot11ConfigWlanTable_rowreq_ctx *rowreq_ctx, u_long * wlanLoadBalanceStatusBaseOnUsr_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wlanLoadBalanceStatusBaseOnUsr_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanLoadBalanceStatusBaseOnUsr_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wlanLoadBalanceStatusBaseOnUsr data.
 * set (* wlanLoadBalanceStatusBaseOnUsr_val_ptr ) from rowreq_ctx->data
 */
    (* wlanLoadBalanceStatusBaseOnUsr_val_ptr ) = rowreq_ctx->data.wlanLoadBalanceStatusBaseOnUsr;

    return MFD_SUCCESS;
} /* wlanLoadBalanceStatusBaseOnUsr_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigWlanEntry.wlanLoadBalanceTrafficDiffThreshhd
 * wlanLoadBalanceTrafficDiffThreshhd is subid 9 of dot11ConfigWlanEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.2.13.2.1.9
 * Description:
The threshold of flow difference.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wlanLoadBalanceTrafficDiffThreshhd.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wlanLoadBalanceTrafficDiffThreshhd_map(long *mib_wlanLoadBalanceTrafficDiffThreshhd_val_ptr, long raw_wlanLoadBalanceTrafficDiffThreshhd_val)
{
    netsnmp_assert(NULL != mib_wlanLoadBalanceTrafficDiffThreshhd_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanLoadBalanceTrafficDiffThreshhd_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wlanLoadBalanceTrafficDiffThreshhd mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wlanLoadBalanceTrafficDiffThreshhd_val_ptr) = raw_wlanLoadBalanceTrafficDiffThreshhd_val;

    return MFD_SUCCESS;
} /* wlanLoadBalanceTrafficDiffThreshhd_map */

/**
 * Extract the current value of the wlanLoadBalanceTrafficDiffThreshhd data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wlanLoadBalanceTrafficDiffThreshhd_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wlanLoadBalanceTrafficDiffThreshhd_get( dot11ConfigWlanTable_rowreq_ctx *rowreq_ctx, long * wlanLoadBalanceTrafficDiffThreshhd_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wlanLoadBalanceTrafficDiffThreshhd_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanLoadBalanceTrafficDiffThreshhd_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wlanLoadBalanceTrafficDiffThreshhd data.
 * set (* wlanLoadBalanceTrafficDiffThreshhd_val_ptr ) from rowreq_ctx->data
 */
    (* wlanLoadBalanceTrafficDiffThreshhd_val_ptr ) = rowreq_ctx->data.wlanLoadBalanceTrafficDiffThreshhd;

    return MFD_SUCCESS;
} /* wlanLoadBalanceTrafficDiffThreshhd_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigWlanEntry.wlanLoadBalanceUsersDiffThreshhd
 * wlanLoadBalanceUsersDiffThreshhd is subid 10 of dot11ConfigWlanEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.2.13.2.1.10
 * Description:
The threshold of user difference.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wlanLoadBalanceUsersDiffThreshhd.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wlanLoadBalanceUsersDiffThreshhd_map(long *mib_wlanLoadBalanceUsersDiffThreshhd_val_ptr, long raw_wlanLoadBalanceUsersDiffThreshhd_val)
{
    netsnmp_assert(NULL != mib_wlanLoadBalanceUsersDiffThreshhd_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanLoadBalanceUsersDiffThreshhd_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wlanLoadBalanceUsersDiffThreshhd mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wlanLoadBalanceUsersDiffThreshhd_val_ptr) = raw_wlanLoadBalanceUsersDiffThreshhd_val;

    return MFD_SUCCESS;
} /* wlanLoadBalanceUsersDiffThreshhd_map */

/**
 * Extract the current value of the wlanLoadBalanceUsersDiffThreshhd data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wlanLoadBalanceUsersDiffThreshhd_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wlanLoadBalanceUsersDiffThreshhd_get( dot11ConfigWlanTable_rowreq_ctx *rowreq_ctx, long * wlanLoadBalanceUsersDiffThreshhd_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wlanLoadBalanceUsersDiffThreshhd_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanLoadBalanceUsersDiffThreshhd_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wlanLoadBalanceUsersDiffThreshhd data.
 * set (* wlanLoadBalanceUsersDiffThreshhd_val_ptr ) from rowreq_ctx->data
 */
    (* wlanLoadBalanceUsersDiffThreshhd_val_ptr ) = rowreq_ctx->data.wlanLoadBalanceUsersDiffThreshhd;

    return MFD_SUCCESS;
} /* wlanLoadBalanceUsersDiffThreshhd_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigWlanEntry.wlanStaOnlineNum
 * wlanStaOnlineNum is subid 11 of dot11ConfigWlanEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.13.2.1.11
 * Description:
The num station on wlan.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wlanStaOnlineNum.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wlanStaOnlineNum_map(long *mib_wlanStaOnlineNum_val_ptr, long raw_wlanStaOnlineNum_val)
{
    netsnmp_assert(NULL != mib_wlanStaOnlineNum_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanStaOnlineNum_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wlanStaOnlineNum mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wlanStaOnlineNum_val_ptr) = raw_wlanStaOnlineNum_val;

    return MFD_SUCCESS;
} /* wlanStaOnlineNum_map */

/**
 * Extract the current value of the wlanStaOnlineNum data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wlanStaOnlineNum_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wlanStaOnlineNum_get( dot11ConfigWlanTable_rowreq_ctx *rowreq_ctx, long * wlanStaOnlineNum_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wlanStaOnlineNum_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanStaOnlineNum_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wlanStaOnlineNum data.
 * set (* wlanStaOnlineNum_val_ptr ) from rowreq_ctx->data
 */
    (* wlanStaOnlineNum_val_ptr ) = rowreq_ctx->data.wlanStaOnlineNum;

    return MFD_SUCCESS;
} /* wlanStaOnlineNum_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigWlanEntry.wlanUsrWirelessResoUseRate
 * wlanUsrWirelessResoUseRate is subid 12 of dot11ConfigWlanEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.13.2.1.12
 * Description:
The available rate of resources in the user side.(Wireless side)
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wlanUsrWirelessResoUseRate.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wlanUsrWirelessResoUseRate_map(char **mib_wlanUsrWirelessResoUseRate_val_ptr_ptr, size_t *mib_wlanUsrWirelessResoUseRate_val_ptr_len_ptr, char *raw_wlanUsrWirelessResoUseRate_val_ptr, size_t raw_wlanUsrWirelessResoUseRate_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wlanUsrWirelessResoUseRate_val_ptr);
    netsnmp_assert((NULL != mib_wlanUsrWirelessResoUseRate_val_ptr_ptr) && (NULL != mib_wlanUsrWirelessResoUseRate_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanUsrWirelessResoUseRate_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wlanUsrWirelessResoUseRate non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wlanUsrWirelessResoUseRate_val_ptr_len; /* assume equal */
    if((NULL == *mib_wlanUsrWirelessResoUseRate_val_ptr_ptr) || (*mib_wlanUsrWirelessResoUseRate_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wlanUsrWirelessResoUseRate_val_ptr_ptr = realloc( *mib_wlanUsrWirelessResoUseRate_val_ptr_ptr, converted_len * sizeof(**mib_wlanUsrWirelessResoUseRate_val_ptr_ptr));
        if(NULL == *mib_wlanUsrWirelessResoUseRate_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wlanUsrWirelessResoUseRate_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wlanUsrWirelessResoUseRate_val_ptr_ptr, raw_wlanUsrWirelessResoUseRate_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wlanUsrWirelessResoUseRate_map */

/**
 * Extract the current value of the wlanUsrWirelessResoUseRate data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wlanUsrWirelessResoUseRate_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param wlanUsrWirelessResoUseRate_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by wlanUsrWirelessResoUseRate.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*wlanUsrWirelessResoUseRate_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update wlanUsrWirelessResoUseRate_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
wlanUsrWirelessResoUseRate_get( dot11ConfigWlanTable_rowreq_ctx *rowreq_ctx, char **wlanUsrWirelessResoUseRate_val_ptr_ptr, size_t *wlanUsrWirelessResoUseRate_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != wlanUsrWirelessResoUseRate_val_ptr_ptr) && (NULL != *wlanUsrWirelessResoUseRate_val_ptr_ptr));
   netsnmp_assert( NULL != wlanUsrWirelessResoUseRate_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanUsrWirelessResoUseRate_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wlanUsrWirelessResoUseRate data.
 * set (* wlanUsrWirelessResoUseRate_val_ptr_ptr ) and (* wlanUsrWirelessResoUseRate_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for wlanUsrWirelessResoUseRate data
     */
    if ((NULL == (* wlanUsrWirelessResoUseRate_val_ptr_ptr )) ||
        ((* wlanUsrWirelessResoUseRate_val_ptr_len_ptr ) < (rowreq_ctx->data.wlanUsrWirelessResoUseRate_len * sizeof((* wlanUsrWirelessResoUseRate_val_ptr_ptr )[0])))) {
        /*
         * allocate space for wlanUsrWirelessResoUseRate data
         */
        (* wlanUsrWirelessResoUseRate_val_ptr_ptr ) = malloc(rowreq_ctx->data.wlanUsrWirelessResoUseRate_len * sizeof((* wlanUsrWirelessResoUseRate_val_ptr_ptr )[0]));
        if(NULL == (* wlanUsrWirelessResoUseRate_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* wlanUsrWirelessResoUseRate_val_ptr_len_ptr ) = rowreq_ctx->data.wlanUsrWirelessResoUseRate_len * sizeof((* wlanUsrWirelessResoUseRate_val_ptr_ptr )[0]);
    memcpy( (* wlanUsrWirelessResoUseRate_val_ptr_ptr ), rowreq_ctx->data.wlanUsrWirelessResoUseRate, (* wlanUsrWirelessResoUseRate_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* wlanUsrWirelessResoUseRate_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigWlanEntry.wlanBindSecType
 * wlanBindSecType is subid 13 of dot11ConfigWlanEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.13.2.1.13
 * Description:
The secyurity type of essid.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 6/16. Values:  openSystem(1), sharedKey(2), dot11x(3), WPA_P(4), WPA2_P(5), WPA_E(6), WPA2_E(7), MD5(8), WAPI_PSK(9), WAPI_AUTH(10)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wlanBindSecType.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wlanBindSecType_map(u_long *mib_wlanBindSecType_val_ptr, u_long raw_wlanBindSecType_val)
{
    netsnmp_assert(NULL != mib_wlanBindSecType_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanBindSecType_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wlanBindSecType enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wlanBindSecType_val) {
        case INTERNAL_WLANBINDSECTYPE_OPENSYSTEM:
             *mib_wlanBindSecType_val_ptr = WLANBINDSECTYPE_OPENSYSTEM;
             break;

        case INTERNAL_WLANBINDSECTYPE_SHAREDKEY:
             *mib_wlanBindSecType_val_ptr = WLANBINDSECTYPE_SHAREDKEY;
             break;

        case INTERNAL_WLANBINDSECTYPE_DOT11X:
             *mib_wlanBindSecType_val_ptr = WLANBINDSECTYPE_DOT11X;
             break;

        case INTERNAL_WLANBINDSECTYPE_WPA_P:
             *mib_wlanBindSecType_val_ptr = WLANBINDSECTYPE_WPA_P;
             break;

        case INTERNAL_WLANBINDSECTYPE_WPA2_P:
             *mib_wlanBindSecType_val_ptr = WLANBINDSECTYPE_WPA2_P;
             break;

        case INTERNAL_WLANBINDSECTYPE_WPA_E:
             *mib_wlanBindSecType_val_ptr = WLANBINDSECTYPE_WPA_E;
             break;

        case INTERNAL_WLANBINDSECTYPE_WPA2_E:
             *mib_wlanBindSecType_val_ptr = WLANBINDSECTYPE_WPA2_E;
             break;

        case INTERNAL_WLANBINDSECTYPE_MD5:
             *mib_wlanBindSecType_val_ptr = WLANBINDSECTYPE_MD5;
             break;

        case INTERNAL_WLANBINDSECTYPE_WAPI_PSK:
             *mib_wlanBindSecType_val_ptr = WLANBINDSECTYPE_WAPI_PSK;
             break;

        case INTERNAL_WLANBINDSECTYPE_WAPI_AUTH:
             *mib_wlanBindSecType_val_ptr = WLANBINDSECTYPE_WAPI_AUTH;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wlanBindSecType\n", raw_wlanBindSecType_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wlanBindSecType_map */

/**
 * Extract the current value of the wlanBindSecType data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wlanBindSecType_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wlanBindSecType_get( dot11ConfigWlanTable_rowreq_ctx *rowreq_ctx, u_long * wlanBindSecType_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wlanBindSecType_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanBindSecType_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wlanBindSecType data.
 * set (* wlanBindSecType_val_ptr ) from rowreq_ctx->data
 */
    (* wlanBindSecType_val_ptr ) = rowreq_ctx->data.wlanBindSecType;

    return MFD_SUCCESS;
} /* wlanBindSecType_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigWlanEntry.wlanBindEncryType
 * wlanBindEncryType is subid 14 of dot11ConfigWlanEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.13.2.1.14
 * Description:
The encryption type of essid.
						 Different security type support different encryption type:
						 openSystem:none,wep
						 sharedKey:wep
						 dot11x:wep
						 WPA-E:aes,tkip
						 WPA-P:aes,tkip
						 WPA2-E:aes,tkip
						 WPA2-P:aes,tkip
						 MD5:none
						 WAPI_PSK:sms4
						 WAPI_AUTH:sms4.
						 Security type must suit for encryption type,otherwise the value will not be set.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 4/8. Values:  none(1), wep(2), aes(3), tkip(4), sms4(5)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wlanBindEncryType.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wlanBindEncryType_map(u_long *mib_wlanBindEncryType_val_ptr, u_long raw_wlanBindEncryType_val)
{
    netsnmp_assert(NULL != mib_wlanBindEncryType_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanBindEncryType_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wlanBindEncryType enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_wlanBindEncryType_val) {
        case INTERNAL_WLANBINDENCRYTYPE_NONE:
             *mib_wlanBindEncryType_val_ptr = WLANBINDENCRYTYPE_NONE;
             break;

        case INTERNAL_WLANBINDENCRYTYPE_WEP:
             *mib_wlanBindEncryType_val_ptr = WLANBINDENCRYTYPE_WEP;
             break;

        case INTERNAL_WLANBINDENCRYTYPE_AES:
             *mib_wlanBindEncryType_val_ptr = WLANBINDENCRYTYPE_AES;
             break;

        case INTERNAL_WLANBINDENCRYTYPE_TKIP:
             *mib_wlanBindEncryType_val_ptr = WLANBINDENCRYTYPE_TKIP;
             break;

        case INTERNAL_WLANBINDENCRYTYPE_SMS4:
             *mib_wlanBindEncryType_val_ptr = WLANBINDENCRYTYPE_SMS4;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for wlanBindEncryType\n", raw_wlanBindEncryType_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* wlanBindEncryType_map */

/**
 * Extract the current value of the wlanBindEncryType data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wlanBindEncryType_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wlanBindEncryType_get( dot11ConfigWlanTable_rowreq_ctx *rowreq_ctx, u_long * wlanBindEncryType_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wlanBindEncryType_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanBindEncryType_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wlanBindEncryType data.
 * set (* wlanBindEncryType_val_ptr ) from rowreq_ctx->data
 */
    (* wlanBindEncryType_val_ptr ) = rowreq_ctx->data.wlanBindEncryType;

    return MFD_SUCCESS;
} /* wlanBindEncryType_get */


int
wlanInterfaceIPAddr_get( dot11ConfigWlanTable_rowreq_ctx *rowreq_ctx, char **wlanInterfaceIPAddr_val_ptr_ptr, size_t *wlanInterfaceIPAddr_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != wlanInterfaceIPAddr_val_ptr_ptr) && (NULL != *wlanInterfaceIPAddr_val_ptr_ptr));
   netsnmp_assert( NULL != wlanInterfaceIPAddr_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigWlanTable:wlanInterfaceIPAddr_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wlanBindIf data.
 * set (* wlanInterfaceIPAddr_val_ptr_ptr ) and (* wlanInterfaceIPAddr_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for wlanBindIf data
     */
    if ((NULL == (* wlanInterfaceIPAddr_val_ptr_ptr )) ||
        ((* wlanInterfaceIPAddr_val_ptr_len_ptr ) < (rowreq_ctx->data.wlanInterfaceIPAddr_len * sizeof((* wlanInterfaceIPAddr_val_ptr_ptr )[0])))) {
        /*
         * allocate space for wlanInterfaceIPAddr data
         */
        (* wlanInterfaceIPAddr_val_ptr_ptr ) = malloc(rowreq_ctx->data.wlanInterfaceIPAddr_len * sizeof((* wlanInterfaceIPAddr_val_ptr_ptr )[0]));
        if(NULL == (* wlanInterfaceIPAddr_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* wlanInterfaceIPAddr_val_ptr_len_ptr ) = rowreq_ctx->data.wlanInterfaceIPAddr_len * sizeof((* wlanInterfaceIPAddr_val_ptr_ptr )[0]);
    memcpy( (* wlanInterfaceIPAddr_val_ptr_ptr ), rowreq_ctx->data.wlanInterfaceIPAddr, (* wlanInterfaceIPAddr_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* wlanInterfaceIPAddr_get */


/** @} */
