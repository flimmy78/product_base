/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.8 2004/10/14 12:57:34 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "dot11TotalNasIDGroup.h"
#include "ws_sysinfo.h"
#include "ws_init_dbus.h"
#include "mibs_public.h"
#include "wcpss/wid/WID.h"
#include "dbus/wcpss/dcli_wid_wtp.h"
#include "dbus/wcpss/dcli_wid_wlan.h"
#include "nm/app/eag/eag_errcode.h"
#include "nm/app/eag/eag_conf.h"
#include "nm/app/eag/eag_interface.h"
#include "ws_dcli_wlans.h"
#include "ws_eag_conf.h"
#include "autelanWtpGroup.h"

dbus_parameter dot11TotalNasIDGroup_parameter = { 0 };

#define TOTALNASID "2.20.1"
#define DEFAULTNASID "2.20.2"
/** Initializes the dot11TotalNasIDGroup module */
void
init_dot11TotalNasIDGroup(void)
{   
    static oid TotalNasID_oid[128] = {0};
    static oid DefaultNasID_oid[128] = { 0 };

	size_t public_oid_len   = 0;
	mad_dev_oid(TotalNasID_oid,TOTALNASID,&public_oid_len,enterprise_pvivate_oid);
	mad_dev_oid(DefaultNasID_oid,DEFAULTNASID,&public_oid_len,enterprise_pvivate_oid);
    DEBUGMSGTL(("dot11TotalNasIDGroup", "Initializing\n"));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("TotalNasID", handle_TotalNasID,
                               TotalNasID_oid, public_oid_len,
                               HANDLER_CAN_RONLY
        ));
	
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("DefaultNasID", handle_DefaultNasID,
                               DefaultNasID_oid, public_oid_len,
                               HANDLER_CAN_RWRITE
        ));
}

int
handle_TotalNasID(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    snmp_log(LOG_DEBUG, "enter handle_TotalNasID\n");

    switch(reqinfo->mode) {

        case MODE_GET:
		{
			instance_parameter *paraHead = NULL;
			instance_parameter *pq = NULL;	
			int ret=0;
			struct api_nasid_conf nasidconf;
			memset (&nasidconf,0,sizeof(nasidconf));
			int num =0;

			list_instance_parameter(&paraHead, SNMPD_INSTANCE_MASTER); 
			for(pq = paraHead; (NULL != pq); pq = pq->next)
			{
				ret = eag_get_nasid( pq->connection,pq->parameter.local_id,pq->parameter.instance_id, &nasidconf);
				if(EAG_RETURN_OK == ret)
				{
					num += nasidconf.current_num;
				}
			}
			free_instance_parameter_list(&paraHead);
	        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
									(u_char *)&num,
									sizeof(long));
    	}
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_TotalNasID\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

	snmp_log(LOG_DEBUG, "exit handle_TotalNasID\n");
    return SNMP_ERR_NOERROR;
}

int
handle_DefaultNasID(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
	snmp_log(LOG_DEBUG, "enter handle_DefaultNasID\n");	

    switch(reqinfo->mode) {

        case MODE_GET:
		{			
			instance_parameter *paraHead = NULL;
			int ret=0;
			struct api_nasid_conf nasidconf;
			memset (&nasidconf,0,sizeof(nasidconf));			
			char nasidbuf[128] = { 0 };
			
			memset(nasidbuf,0,sizeof(nasidbuf));
			list_instance_parameter(&paraHead, SNMPD_INSTANCE_MASTER); 
			if(paraHead)
			{
				memcpy(&dot11TotalNasIDGroup_parameter,&(paraHead->parameter),sizeof(dot11TotalNasIDGroup_parameter));
				
				ret = eag_get_nasid( paraHead->connection,paraHead->parameter.local_id,paraHead->parameter.instance_id, &nasidconf);
				if((EAG_RETURN_OK == ret)&&(nasidconf.current_num>0))
				{
					strncpy(nasidbuf,nasidconf.nasid_map[0].nasid,sizeof(nasidbuf)-1);
				}
			}
			free_instance_parameter_list(&paraHead);

			snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
									 (u_char *)nasidbuf,
									 strlen(nasidbuf));
		}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
            //if (/* XXX: check incoming data in requests->requestvb->val.XXX for failures, like an incorrect type or an illegal value or ... */) {
            //    netsnmp_set_request_error(reqinfo, requests, /* XXX: set error code depending on problem (like SNMP_ERR_WRONGTYPE or SNMP_ERR_WRONGVALUE or ... */);
            //}
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            //if (/* XXX if malloc, or whatever, failed: */) {
            //    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            //}
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            //if (/* XXX: error? */) {
            //    netsnmp_set_request_error(reqinfo, requests, /* some error */);
            //}
        {
        	int result = SNMPD_DBUS_ERROR;
			void *connection = NULL;
			int ret1=0,ret2=0;
			struct api_nasid_conf nasidconf;
			memset (&nasidconf,0,sizeof(nasidconf));
			struct nasid_map_t nasidmap1;
			memset (&nasidmap1,0,sizeof(struct nasid_map_t));
			struct nasid_map_t nasidmap2;
			memset (&nasidmap2,0,sizeof(struct nasid_map_t));			
			char input_string[256] = {0};
			memset(input_string,0,sizeof(input_string));
			strncpy(input_string,requests->requestvb->val.string,sizeof(input_string)-1);

			result = get_instance_dbus_connection(dot11TotalNasIDGroup_parameter, &connection, SNMPD_INSTANCE_MASTER_V3);
			if(SNMPD_DBUS_SUCCESS == result)
			{
				ret1 = eag_get_nasid( connection,dot11TotalNasIDGroup_parameter.local_id,dot11TotalNasIDGroup_parameter.instance_id, &nasidconf);
				if((EAG_RETURN_OK == ret1)&&(nasidconf.current_num>0))
				{
					nasidmap1.key_type = nasidconf.nasid_map[0].key_type;
					nasidmap2.key_type = nasidconf.nasid_map[0].key_type;
					switch(nasidconf.nasid_map[0].key_type)
					{						
						case NASID_KEYTYPE_WLANID:
							{
								nasidmap1.key.wlanidrange.id_begin = nasidconf.nasid_map[0].keywd_1;
								nasidmap1.key.wlanidrange.id_end = nasidconf.nasid_map[0].keywd_2;
								nasidmap2.key.wlanidrange.id_begin = nasidconf.nasid_map[0].keywd_1;
								nasidmap2.key.wlanidrange.id_end = nasidconf.nasid_map[0].keywd_2;
							}
							break;
						case NASID_KEYTYPE_VLANID:
							{
								nasidmap1.key.vlanidrange.id_begin = nasidconf.nasid_map[0].keywd_1;
								nasidmap1.key.vlanidrange.id_end = nasidconf.nasid_map[0].keywd_2;
								nasidmap2.key.vlanidrange.id_begin = nasidconf.nasid_map[0].keywd_1;
								nasidmap2.key.vlanidrange.id_end = nasidconf.nasid_map[0].keywd_2;
							}
							break;
						case NASID_KEYTYPE_WTPID:
							{
								nasidmap1.key.wtpidrange.id_begin = nasidconf.nasid_map[0].keywd_1;
								nasidmap1.key.wtpidrange.id_end = nasidconf.nasid_map[0].keywd_2;
								nasidmap2.key.wtpidrange.id_begin = nasidconf.nasid_map[0].keywd_1;
								nasidmap2.key.wtpidrange.id_end = nasidconf.nasid_map[0].keywd_2;
							}
							break;
						case NASID_KEYTYPE_IPRANGE:
							{
								nasidmap1.key.iprange.ip_begin = nasidconf.nasid_map[0].keywd_1;
								nasidmap1.key.iprange.ip_end = nasidconf.nasid_map[0].keywd_2;
								nasidmap2.key.iprange.ip_begin = nasidconf.nasid_map[0].keywd_1;
								nasidmap2.key.iprange.ip_end = nasidconf.nasid_map[0].keywd_2;
							}
							break;
						case NASID_KEYTYPE_INTF:
							{
								strncpy(nasidmap1.key.intf,nasidconf.nasid_map[0].keystr,MAX_NASID_KEY_BUFF_LEN-1);
								strncpy(nasidmap2.key.intf,nasidconf.nasid_map[0].keystr,MAX_NASID_KEY_BUFF_LEN-1);
							}
							break;
						default:
							{
								netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
							}
							break;
					}
					strncpy(nasidmap2.nasid,input_string,MAX_NASID_LEN-1);
					nasidmap2.conid = nasidconf.nasid_map[0].conid;

					ret2 = eag_del_nasid( connection, dot11TotalNasIDGroup_parameter.local_id, dot11TotalNasIDGroup_parameter.instance_id, &nasidmap1);					
					ret2 = eag_add_nasid( connection, dot11TotalNasIDGroup_parameter.local_id, dot11TotalNasIDGroup_parameter.instance_id, &nasidmap2);
					if(EAG_RETURN_OK != ret2)
					{
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
					}
				}
				else
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
				}
			}
			else
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
			}
		}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            //if (/* XXX: error? */) {
            //    /* try _really_really_ hard to never get to this point */
            //    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            //}
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            //if (/* XXX: error? */) {
            //    /* try _really_really_ hard to never get to this point */
            //    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            //}
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_DefaultNasID\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }
	snmp_log(LOG_DEBUG, "exit handle_DefaultNasID\n");

    return SNMP_ERR_NOERROR;
}

