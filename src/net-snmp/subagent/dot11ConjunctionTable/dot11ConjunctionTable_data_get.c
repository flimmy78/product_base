/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.18.2.1 $ of : mfd-data-get.m2c,v $ 
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "dot11ConjunctionTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement dot11ConjunctionTable get routines.
 * TODO:240:M: Implement dot11ConjunctionTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table dot11ConjunctionTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * dot11ConjunctionTable is subid 2 of wtpLink.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.31656.6.1.1.6.2, length: 12
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement dot11ConjunctionTable data context functions.
 */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11ConfigTrapSwitchEntry.wtpMacAddr
 * wtpMacAddr is subid 1 of dot11ConfigTrapSwitchEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.18.2.1.1
 * Description:
AP Mac  Address Group.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpMacAddr.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpMacAddr_conjunction_map(char **mib_wtpMacAddr_val_ptr_ptr, size_t *mib_wtpMacAddr_val_ptr_len_ptr, char *raw_wtpMacAddr_val_ptr, size_t raw_wtpMacAddr_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpMacAddr_val_ptr);
    netsnmp_assert((NULL != mib_wtpMacAddr_val_ptr_ptr) && (NULL != mib_wtpMacAddr_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpMacAddr_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpMacAddr non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpMacAddr_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpMacAddr_val_ptr_ptr) || (*mib_wtpMacAddr_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpMacAddr_val_ptr_ptr = realloc( *mib_wtpMacAddr_val_ptr_ptr, converted_len * sizeof(**mib_wtpMacAddr_val_ptr_ptr));
        if(NULL == *mib_wtpMacAddr_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpMacAddr_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpMacAddr_val_ptr_ptr, raw_wtpMacAddr_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpMacAddr_map */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
dot11ConjunctionTable_indexes_set_tbl_idx(dot11ConjunctionTable_mib_index *tbl_idx, char *wtpMacAddr_val_ptr,  size_t wtpMacAddr_val_ptr_len)
{
    DEBUGMSGTL(("verbose:dot11ConjunctionTable:dot11ConjunctionTable_indexes_set_tbl_idx","called\n"));

    /* wtpMacAddr(1)/DisplayString/ASN_OCTET_STR/char(char)//L/A/w/e/R/d/H */
     tbl_idx->wtpMacAddr_len = sizeof(tbl_idx->wtpMacAddr);
    /*
     * make sure there is enough space for wtpMacAddr data
     */
    if ((NULL == tbl_idx->wtpMacAddr) ||
        (tbl_idx->wtpMacAddr_len < (wtpMacAddr_val_ptr_len * sizeof(tbl_idx->wtpMacAddr[0])))) {
        snmp_log(LOG_ERR,"not enough space for value\n");
        return MFD_ERROR;
    }
    tbl_idx->wtpMacAddr_len = wtpMacAddr_val_ptr_len * sizeof(tbl_idx->wtpMacAddr[0]);
    memcpy( tbl_idx->wtpMacAddr, wtpMacAddr_val_ptr, tbl_idx->wtpMacAddr_len );
    

    return MFD_SUCCESS;
} /* dot11ConjunctionTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
dot11ConjunctionTable_indexes_set(dot11ConjunctionTable_rowreq_ctx *rowreq_ctx, char *wtpMacAddr_val_ptr,  size_t wtpMacAddr_val_ptr_len)
{
    DEBUGMSGTL(("verbose:dot11ConjunctionTable:dot11ConjunctionTable_indexes_set","called\n"));

    if(MFD_SUCCESS != dot11ConjunctionTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
                                   , wtpMacAddr_val_ptr, wtpMacAddr_val_ptr_len
           ))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if(0 != dot11ConjunctionTable_index_to_oid(&rowreq_ctx->oid_idx,
                                    &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* dot11ConjunctionTable_indexes_set */


/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConjunctionEntry.wtpReasonInvalidFailConjunctTimes
 * wtpReasonInvalidFailConjunctTimes is subid 1 of dot11ConjunctionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.6.2.1.1
 * Description:
The total user conjunction failed times because of invalided.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpReasonInvalidFailConjunctTimes.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpReasonInvalidFailConjunctTimes_map(u_long *mib_wtpReasonInvalidFailConjunctTimes_val_ptr, u_long raw_wtpReasonInvalidFailConjunctTimes_val)
{
    netsnmp_assert(NULL != mib_wtpReasonInvalidFailConjunctTimes_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpReasonInvalidFailConjunctTimes_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpReasonInvalidFailConjunctTimes mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpReasonInvalidFailConjunctTimes_val_ptr) = raw_wtpReasonInvalidFailConjunctTimes_val;

    return MFD_SUCCESS;
} /* wtpReasonInvalidFailConjunctTimes_map */

/**
 * Extract the current value of the wtpReasonInvalidFailConjunctTimes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpReasonInvalidFailConjunctTimes_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpReasonInvalidFailConjunctTimes_get( dot11ConjunctionTable_rowreq_ctx *rowreq_ctx, u_long * wtpReasonInvalidFailConjunctTimes_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpReasonInvalidFailConjunctTimes_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpReasonInvalidFailConjunctTimes_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpReasonInvalidFailConjunctTimes data.
 * set (* wtpReasonInvalidFailConjunctTimes_val_ptr ) from rowreq_ctx->data
 */
    (* wtpReasonInvalidFailConjunctTimes_val_ptr ) = rowreq_ctx->data.wtpReasonInvalidFailConjunctTimes;

    return MFD_SUCCESS;
} /* wtpReasonInvalidFailConjunctTimes_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConjunctionEntry.wtpReasonTimeOutFailConjunctTimes
 * wtpReasonTimeOutFailConjunctTimes is subid 2 of dot11ConjunctionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.6.2.1.2
 * Description:
The total user conjunction failed times because of time out.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpReasonTimeOutFailConjunctTimes.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpReasonTimeOutFailConjunctTimes_map(u_long *mib_wtpReasonTimeOutFailConjunctTimes_val_ptr, u_long raw_wtpReasonTimeOutFailConjunctTimes_val)
{
    netsnmp_assert(NULL != mib_wtpReasonTimeOutFailConjunctTimes_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpReasonTimeOutFailConjunctTimes_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpReasonTimeOutFailConjunctTimes mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpReasonTimeOutFailConjunctTimes_val_ptr) = raw_wtpReasonTimeOutFailConjunctTimes_val;

    return MFD_SUCCESS;
} /* wtpReasonTimeOutFailConjunctTimes_map */

/**
 * Extract the current value of the wtpReasonTimeOutFailConjunctTimes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpReasonTimeOutFailConjunctTimes_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpReasonTimeOutFailConjunctTimes_get( dot11ConjunctionTable_rowreq_ctx *rowreq_ctx, u_long * wtpReasonTimeOutFailConjunctTimes_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpReasonTimeOutFailConjunctTimes_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpReasonTimeOutFailConjunctTimes_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpReasonTimeOutFailConjunctTimes data.
 * set (* wtpReasonTimeOutFailConjunctTimes_val_ptr ) from rowreq_ctx->data
 */
    (* wtpReasonTimeOutFailConjunctTimes_val_ptr ) = rowreq_ctx->data.wtpReasonTimeOutFailConjunctTimes;

    return MFD_SUCCESS;
} /* wtpReasonTimeOutFailConjunctTimes_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConjunctionEntry.wtpReasonRefuseFailConjunctTimes
 * wtpReasonRefuseFailConjunctTimes is subid 3 of dot11ConjunctionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.6.2.1.3
 * Description:
The total user conjunction failed times because of refusing.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpReasonRefuseFailConjunctTimes.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpReasonRefuseFailConjunctTimes_map(u_long *mib_wtpReasonRefuseFailConjunctTimes_val_ptr, u_long raw_wtpReasonRefuseFailConjunctTimes_val)
{
    netsnmp_assert(NULL != mib_wtpReasonRefuseFailConjunctTimes_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpReasonRefuseFailConjunctTimes_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpReasonRefuseFailConjunctTimes mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpReasonRefuseFailConjunctTimes_val_ptr) = raw_wtpReasonRefuseFailConjunctTimes_val;

    return MFD_SUCCESS;
} /* wtpReasonRefuseFailConjunctTimes_map */

/**
 * Extract the current value of the wtpReasonRefuseFailConjunctTimes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpReasonRefuseFailConjunctTimes_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpReasonRefuseFailConjunctTimes_get( dot11ConjunctionTable_rowreq_ctx *rowreq_ctx, u_long * wtpReasonRefuseFailConjunctTimes_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpReasonRefuseFailConjunctTimes_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpReasonRefuseFailConjunctTimes_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpReasonRefuseFailConjunctTimes data.
 * set (* wtpReasonRefuseFailConjunctTimes_val_ptr ) from rowreq_ctx->data
 */
    (* wtpReasonRefuseFailConjunctTimes_val_ptr ) = rowreq_ctx->data.wtpReasonRefuseFailConjunctTimes;

    return MFD_SUCCESS;
} /* wtpReasonRefuseFailConjunctTimes_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConjunctionEntry.wtpReasonOthersFailConjunctTimes
 * wtpReasonOthersFailConjunctTimes is subid 4 of dot11ConjunctionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.6.2.1.4
 * Description:
The total user conjunction failed times because of other reason.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpReasonOthersFailConjunctTimes.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpReasonOthersFailConjunctTimes_map(u_long *mib_wtpReasonOthersFailConjunctTimes_val_ptr, u_long raw_wtpReasonOthersFailConjunctTimes_val)
{
    netsnmp_assert(NULL != mib_wtpReasonOthersFailConjunctTimes_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpReasonOthersFailConjunctTimes_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpReasonOthersFailConjunctTimes mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpReasonOthersFailConjunctTimes_val_ptr) = raw_wtpReasonOthersFailConjunctTimes_val;

    return MFD_SUCCESS;
} /* wtpReasonOthersFailConjunctTimes_map */

/**
 * Extract the current value of the wtpReasonOthersFailConjunctTimes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpReasonOthersFailConjunctTimes_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpReasonOthersFailConjunctTimes_get( dot11ConjunctionTable_rowreq_ctx *rowreq_ctx, u_long * wtpReasonOthersFailConjunctTimes_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpReasonOthersFailConjunctTimes_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpReasonOthersFailConjunctTimes_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpReasonOthersFailConjunctTimes data.
 * set (* wtpReasonOthersFailConjunctTimes_val_ptr ) from rowreq_ctx->data
 */
    (* wtpReasonOthersFailConjunctTimes_val_ptr ) = rowreq_ctx->data.wtpReasonOthersFailConjunctTimes;

    return MFD_SUCCESS;
} /* wtpReasonOthersFailConjunctTimes_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConjunctionEntry.wtpTryReconjunctTimes
 * wtpTryReconjunctTimes is subid 5 of dot11ConjunctionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.6.2.1.5
 * Description:
The total times that try to reconjunction.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpTryReconjunctTimes.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpTryReconjunctTimes_map(u_long *mib_wtpTryReconjunctTimes_val_ptr, u_long raw_wtpTryReconjunctTimes_val)
{
    netsnmp_assert(NULL != mib_wtpTryReconjunctTimes_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpTryReconjunctTimes_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpTryReconjunctTimes mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpTryReconjunctTimes_val_ptr) = raw_wtpTryReconjunctTimes_val;

    return MFD_SUCCESS;
} /* wtpTryReconjunctTimes_map */

/**
 * Extract the current value of the wtpTryReconjunctTimes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpTryReconjunctTimes_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpTryReconjunctTimes_get( dot11ConjunctionTable_rowreq_ctx *rowreq_ctx, u_long * wtpTryReconjunctTimes_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpTryReconjunctTimes_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpTryReconjunctTimes_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpTryReconjunctTimes data.
 * set (* wtpTryReconjunctTimes_val_ptr ) from rowreq_ctx->data
 */
    (* wtpTryReconjunctTimes_val_ptr ) = rowreq_ctx->data.wtpTryReconjunctTimes;

    return MFD_SUCCESS;
} /* wtpTryReconjunctTimes_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConjunctionEntry.wtpReconjunctSuccessTimes
 * wtpReconjunctSuccessTimes is subid 6 of dot11ConjunctionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.6.2.1.6
 * Description:
The total successful times that reconjunction.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpReconjunctSuccessTimes.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpReconjunctSuccessTimes_map(u_long *mib_wtpReconjunctSuccessTimes_val_ptr, u_long raw_wtpReconjunctSuccessTimes_val)
{
    netsnmp_assert(NULL != mib_wtpReconjunctSuccessTimes_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpReconjunctSuccessTimes_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpReconjunctSuccessTimes mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpReconjunctSuccessTimes_val_ptr) = raw_wtpReconjunctSuccessTimes_val;

    return MFD_SUCCESS;
} /* wtpReconjunctSuccessTimes_map */

/**
 * Extract the current value of the wtpReconjunctSuccessTimes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpReconjunctSuccessTimes_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpReconjunctSuccessTimes_get( dot11ConjunctionTable_rowreq_ctx *rowreq_ctx, u_long * wtpReconjunctSuccessTimes_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpReconjunctSuccessTimes_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpReconjunctSuccessTimes_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpReconjunctSuccessTimes data.
 * set (* wtpReconjunctSuccessTimes_val_ptr ) from rowreq_ctx->data
 */
    (* wtpReconjunctSuccessTimes_val_ptr ) = rowreq_ctx->data.wtpReconjunctSuccessTimes;

    return MFD_SUCCESS;
} /* wtpReconjunctSuccessTimes_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConjunctionEntry.wtpReasonInvalidReconjunctTimes
 * wtpReasonInvalidReconjunctTimes is subid 7 of dot11ConjunctionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.6.2.1.7
 * Description:
The total user reconjunction failed times because of invalided.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpReasonInvalidReconjunctTimes.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpReasonInvalidReconjunctTimes_map(u_long *mib_wtpReasonInvalidReconjunctTimes_val_ptr, u_long raw_wtpReasonInvalidReconjunctTimes_val)
{
    netsnmp_assert(NULL != mib_wtpReasonInvalidReconjunctTimes_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpReasonInvalidReconjunctTimes_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpReasonInvalidReconjunctTimes mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpReasonInvalidReconjunctTimes_val_ptr) = raw_wtpReasonInvalidReconjunctTimes_val;

    return MFD_SUCCESS;
} /* wtpReasonInvalidReconjunctTimes_map */

/**
 * Extract the current value of the wtpReasonInvalidReconjunctTimes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpReasonInvalidReconjunctTimes_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpReasonInvalidReconjunctTimes_get( dot11ConjunctionTable_rowreq_ctx *rowreq_ctx, u_long * wtpReasonInvalidReconjunctTimes_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpReasonInvalidReconjunctTimes_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpReasonInvalidReconjunctTimes_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpReasonInvalidReconjunctTimes data.
 * set (* wtpReasonInvalidReconjunctTimes_val_ptr ) from rowreq_ctx->data
 */
    (* wtpReasonInvalidReconjunctTimes_val_ptr ) = rowreq_ctx->data.wtpReasonInvalidReconjunctTimes;

    return MFD_SUCCESS;
} /* wtpReasonInvalidReconjunctTimes_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConjunctionEntry.wtpReasonTimeOutReconjunctTimes
 * wtpReasonTimeOutReconjunctTimes is subid 8 of dot11ConjunctionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.6.2.1.8
 * Description:
The total user reconjunction failed times because of time out.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpReasonTimeOutReconjunctTimes.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpReasonTimeOutReconjunctTimes_map(u_long *mib_wtpReasonTimeOutReconjunctTimes_val_ptr, u_long raw_wtpReasonTimeOutReconjunctTimes_val)
{
    netsnmp_assert(NULL != mib_wtpReasonTimeOutReconjunctTimes_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpReasonTimeOutReconjunctTimes_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpReasonTimeOutReconjunctTimes mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpReasonTimeOutReconjunctTimes_val_ptr) = raw_wtpReasonTimeOutReconjunctTimes_val;

    return MFD_SUCCESS;
} /* wtpReasonTimeOutReconjunctTimes_map */

/**
 * Extract the current value of the wtpReasonTimeOutReconjunctTimes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpReasonTimeOutReconjunctTimes_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpReasonTimeOutReconjunctTimes_get( dot11ConjunctionTable_rowreq_ctx *rowreq_ctx, u_long * wtpReasonTimeOutReconjunctTimes_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpReasonTimeOutReconjunctTimes_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpReasonTimeOutReconjunctTimes_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpReasonTimeOutReconjunctTimes data.
 * set (* wtpReasonTimeOutReconjunctTimes_val_ptr ) from rowreq_ctx->data
 */
    (* wtpReasonTimeOutReconjunctTimes_val_ptr ) = rowreq_ctx->data.wtpReasonTimeOutReconjunctTimes;

    return MFD_SUCCESS;
} /* wtpReasonTimeOutReconjunctTimes_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConjunctionEntry.wtpReasonRefuseReconjunctTimes
 * wtpReasonRefuseReconjunctTimes is subid 9 of dot11ConjunctionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.6.2.1.9
 * Description:
The total user reconjunction failed times because of refusing.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpReasonRefuseReconjunctTimes.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpReasonRefuseReconjunctTimes_map(u_long *mib_wtpReasonRefuseReconjunctTimes_val_ptr, u_long raw_wtpReasonRefuseReconjunctTimes_val)
{
    netsnmp_assert(NULL != mib_wtpReasonRefuseReconjunctTimes_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpReasonRefuseReconjunctTimes_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpReasonRefuseReconjunctTimes mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpReasonRefuseReconjunctTimes_val_ptr) = raw_wtpReasonRefuseReconjunctTimes_val;

    return MFD_SUCCESS;
} /* wtpReasonRefuseReconjunctTimes_map */

/**
 * Extract the current value of the wtpReasonRefuseReconjunctTimes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpReasonRefuseReconjunctTimes_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpReasonRefuseReconjunctTimes_get( dot11ConjunctionTable_rowreq_ctx *rowreq_ctx, u_long * wtpReasonRefuseReconjunctTimes_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpReasonRefuseReconjunctTimes_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpReasonRefuseReconjunctTimes_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpReasonRefuseReconjunctTimes data.
 * set (* wtpReasonRefuseReconjunctTimes_val_ptr ) from rowreq_ctx->data
 */
    (* wtpReasonRefuseReconjunctTimes_val_ptr ) = rowreq_ctx->data.wtpReasonRefuseReconjunctTimes;

    return MFD_SUCCESS;
} /* wtpReasonRefuseReconjunctTimes_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConjunctionEntry.wtpReasonOtherReconjunctTimes
 * wtpReasonOtherReconjunctTimes is subid 10 of dot11ConjunctionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.6.2.1.10
 * Description:
The total user reconjunction failed times because of other reasons.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpReasonOtherReconjunctTimes.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpReasonOtherReconjunctTimes_map(u_long *mib_wtpReasonOtherReconjunctTimes_val_ptr, u_long raw_wtpReasonOtherReconjunctTimes_val)
{
    netsnmp_assert(NULL != mib_wtpReasonOtherReconjunctTimes_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpReasonOtherReconjunctTimes_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpReasonOtherReconjunctTimes mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpReasonOtherReconjunctTimes_val_ptr) = raw_wtpReasonOtherReconjunctTimes_val;

    return MFD_SUCCESS;
} /* wtpReasonOtherReconjunctTimes_map */

/**
 * Extract the current value of the wtpReasonOtherReconjunctTimes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpReasonOtherReconjunctTimes_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpReasonOtherReconjunctTimes_get( dot11ConjunctionTable_rowreq_ctx *rowreq_ctx, u_long * wtpReasonOtherReconjunctTimes_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpReasonOtherReconjunctTimes_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpReasonOtherReconjunctTimes_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpReasonOtherReconjunctTimes data.
 * set (* wtpReasonOtherReconjunctTimes_val_ptr ) from rowreq_ctx->data
 */
    (* wtpReasonOtherReconjunctTimes_val_ptr ) = rowreq_ctx->data.wtpReasonOtherReconjunctTimes;

    return MFD_SUCCESS;
} /* wtpReasonOtherReconjunctTimes_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConjunctionEntry.wtpSolutionConjunctTimes
 * wtpSolutionConjunctTimes is subid 11 of dot11ConjunctionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.6.2.1.11
 * Description:
The total times that solution Conjunct
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpSolutionConjunctTimes.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpSolutionConjunctTimes_map(u_long *mib_wtpSolutionConjunctTimes_val_ptr, u_long raw_wtpSolutionConjunctTimes_val)
{
    netsnmp_assert(NULL != mib_wtpSolutionConjunctTimes_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpSolutionConjunctTimes_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpSolutionConjunctTimes mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpSolutionConjunctTimes_val_ptr) = raw_wtpSolutionConjunctTimes_val;

    return MFD_SUCCESS;
} /* wtpSolutionConjunctTimes_map */

/**
 * Extract the current value of the wtpSolutionConjunctTimes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpSolutionConjunctTimes_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpSolutionConjunctTimes_get( dot11ConjunctionTable_rowreq_ctx *rowreq_ctx, u_long * wtpSolutionConjunctTimes_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpSolutionConjunctTimes_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpSolutionConjunctTimes_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpSolutionConjunctTimes data.
 * set (* wtpSolutionConjunctTimes_val_ptr ) from rowreq_ctx->data
 */
    (* wtpSolutionConjunctTimes_val_ptr ) = rowreq_ctx->data.wtpSolutionConjunctTimes;

    return MFD_SUCCESS;
} /* wtpSolutionConjunctTimes_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConjunctionEntry.wtpReasonUsrLeaveSolutionConjunctTimes
 * wtpReasonUsrLeaveSolutionConjunctTimes is subid 12 of dot11ConjunctionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.6.2.1.12
 * Description:
The total times that solution conjunction because of user leaving.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpReasonUsrLeaveSolutionConjunctTimes.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpReasonUsrLeaveSolutionConjunctTimes_map(u_long *mib_wtpReasonUsrLeaveSolutionConjunctTimes_val_ptr, u_long raw_wtpReasonUsrLeaveSolutionConjunctTimes_val)
{
    netsnmp_assert(NULL != mib_wtpReasonUsrLeaveSolutionConjunctTimes_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpReasonUsrLeaveSolutionConjunctTimes_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpReasonUsrLeaveSolutionConjunctTimes mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpReasonUsrLeaveSolutionConjunctTimes_val_ptr) = raw_wtpReasonUsrLeaveSolutionConjunctTimes_val;

    return MFD_SUCCESS;
} /* wtpReasonUsrLeaveSolutionConjunctTimes_map */

/**
 * Extract the current value of the wtpReasonUsrLeaveSolutionConjunctTimes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpReasonUsrLeaveSolutionConjunctTimes_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpReasonUsrLeaveSolutionConjunctTimes_get( dot11ConjunctionTable_rowreq_ctx *rowreq_ctx, u_long * wtpReasonUsrLeaveSolutionConjunctTimes_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpReasonUsrLeaveSolutionConjunctTimes_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpReasonUsrLeaveSolutionConjunctTimes_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpReasonUsrLeaveSolutionConjunctTimes data.
 * set (* wtpReasonUsrLeaveSolutionConjunctTimes_val_ptr ) from rowreq_ctx->data
 */
    (* wtpReasonUsrLeaveSolutionConjunctTimes_val_ptr ) = rowreq_ctx->data.wtpReasonUsrLeaveSolutionConjunctTimes;

    return MFD_SUCCESS;
} /* wtpReasonUsrLeaveSolutionConjunctTimes_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConjunctionEntry.wtpReasonLackAbilitySolutionConjunctTimes
 * wtpReasonLackAbilitySolutionConjunctTimes is subid 13 of dot11ConjunctionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.6.2.1.13
 * Description:
The total times that solution conjunction because of lack of ablility.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpReasonLackAbilitySolutionConjunctTimes.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpReasonLackAbilitySolutionConjunctTimes_map(u_long *mib_wtpReasonLackAbilitySolutionConjunctTimes_val_ptr, u_long raw_wtpReasonLackAbilitySolutionConjunctTimes_val)
{
    netsnmp_assert(NULL != mib_wtpReasonLackAbilitySolutionConjunctTimes_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpReasonLackAbilitySolutionConjunctTimes_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpReasonLackAbilitySolutionConjunctTimes mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpReasonLackAbilitySolutionConjunctTimes_val_ptr) = raw_wtpReasonLackAbilitySolutionConjunctTimes_val;

    return MFD_SUCCESS;
} /* wtpReasonLackAbilitySolutionConjunctTimes_map */

/**
 * Extract the current value of the wtpReasonLackAbilitySolutionConjunctTimes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpReasonLackAbilitySolutionConjunctTimes_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpReasonLackAbilitySolutionConjunctTimes_get( dot11ConjunctionTable_rowreq_ctx *rowreq_ctx, u_long * wtpReasonLackAbilitySolutionConjunctTimes_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpReasonLackAbilitySolutionConjunctTimes_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpReasonLackAbilitySolutionConjunctTimes_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpReasonLackAbilitySolutionConjunctTimes data.
 * set (* wtpReasonLackAbilitySolutionConjunctTimes_val_ptr ) from rowreq_ctx->data
 */
    (* wtpReasonLackAbilitySolutionConjunctTimes_val_ptr ) = rowreq_ctx->data.wtpReasonLackAbilitySolutionConjunctTimes;

    return MFD_SUCCESS;
} /* wtpReasonLackAbilitySolutionConjunctTimes_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConjunctionEntry.wtpReasonExceptionSolutionConjunctTimes
 * wtpReasonExceptionSolutionConjunctTimes is subid 14 of dot11ConjunctionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.6.2.1.14
 * Description:
The total times that solution conjunction because of excertion.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpReasonExceptionSolutionConjunctTimes.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpReasonExceptionSolutionConjunctTimes_map(u_long *mib_wtpReasonExceptionSolutionConjunctTimes_val_ptr, u_long raw_wtpReasonExceptionSolutionConjunctTimes_val)
{
    netsnmp_assert(NULL != mib_wtpReasonExceptionSolutionConjunctTimes_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpReasonExceptionSolutionConjunctTimes_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpReasonExceptionSolutionConjunctTimes mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpReasonExceptionSolutionConjunctTimes_val_ptr) = raw_wtpReasonExceptionSolutionConjunctTimes_val;

    return MFD_SUCCESS;
} /* wtpReasonExceptionSolutionConjunctTimes_map */

/**
 * Extract the current value of the wtpReasonExceptionSolutionConjunctTimes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpReasonExceptionSolutionConjunctTimes_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpReasonExceptionSolutionConjunctTimes_get( dot11ConjunctionTable_rowreq_ctx *rowreq_ctx, u_long * wtpReasonExceptionSolutionConjunctTimes_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpReasonExceptionSolutionConjunctTimes_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpReasonExceptionSolutionConjunctTimes_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpReasonExceptionSolutionConjunctTimes data.
 * set (* wtpReasonExceptionSolutionConjunctTimes_val_ptr ) from rowreq_ctx->data
 */
    (* wtpReasonExceptionSolutionConjunctTimes_val_ptr ) = rowreq_ctx->data.wtpReasonExceptionSolutionConjunctTimes;

    return MFD_SUCCESS;
} /* wtpReasonExceptionSolutionConjunctTimes_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConjunctionEntry.wtpReasonOtherSolutionConjunctTimes
 * wtpReasonOtherSolutionConjunctTimes is subid 15 of dot11ConjunctionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.6.2.1.15
 * Description:
The total times that solution conjunction because of other reasons.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpReasonOtherSolutionConjunctTimes.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpReasonOtherSolutionConjunctTimes_map(u_long *mib_wtpReasonOtherSolutionConjunctTimes_val_ptr, u_long raw_wtpReasonOtherSolutionConjunctTimes_val)
{
    netsnmp_assert(NULL != mib_wtpReasonOtherSolutionConjunctTimes_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpReasonOtherSolutionConjunctTimes_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpReasonOtherSolutionConjunctTimes mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpReasonOtherSolutionConjunctTimes_val_ptr) = raw_wtpReasonOtherSolutionConjunctTimes_val;

    return MFD_SUCCESS;
} /* wtpReasonOtherSolutionConjunctTimes_map */

/**
 * Extract the current value of the wtpReasonOtherSolutionConjunctTimes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpReasonOtherSolutionConjunctTimes_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpReasonOtherSolutionConjunctTimes_get( dot11ConjunctionTable_rowreq_ctx *rowreq_ctx, u_long * wtpReasonOtherSolutionConjunctTimes_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpReasonOtherSolutionConjunctTimes_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpReasonOtherSolutionConjunctTimes_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpReasonOtherSolutionConjunctTimes data.
 * set (* wtpReasonOtherSolutionConjunctTimes_val_ptr ) from rowreq_ctx->data
 */
    (* wtpReasonOtherSolutionConjunctTimes_val_ptr ) = rowreq_ctx->data.wtpReasonOtherSolutionConjunctTimes;

    return MFD_SUCCESS;
} /* wtpReasonOtherSolutionConjunctTimes_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConjunctionEntry.wtpReasonTerminalNotSupportAllSpeedFailConjunctionTimes
 * wtpReasonTerminalNotSupportAllSpeedFailConjunctionTimes is subid 16 of dot11ConjunctionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.6.2.1.16
 * Description:
The total times that fail conjunction because of not support all the speed.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpReasonTerminalNotSupportAllSpeedFailConjunctionTimes.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpReasonTerminalNotSupportAllSpeedFailConjunctionTimes_map(u_long *mib_wtpReasonTerminalNotSupportAllSpeedFailConjunctionTimes_val_ptr, u_long raw_wtpReasonTerminalNotSupportAllSpeedFailConjunctionTimes_val)
{
    netsnmp_assert(NULL != mib_wtpReasonTerminalNotSupportAllSpeedFailConjunctionTimes_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpReasonTerminalNotSupportAllSpeedFailConjunctionTimes_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpReasonTerminalNotSupportAllSpeedFailConjunctionTimes mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpReasonTerminalNotSupportAllSpeedFailConjunctionTimes_val_ptr) = raw_wtpReasonTerminalNotSupportAllSpeedFailConjunctionTimes_val;

    return MFD_SUCCESS;
} /* wtpReasonTerminalNotSupportAllSpeedFailConjunctionTimes_map */

/**
 * Extract the current value of the wtpReasonTerminalNotSupportAllSpeedFailConjunctionTimes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param wtpReasonTerminalNotSupportAllSpeedFailConjunctionTimes_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
wtpReasonTerminalNotSupportAllSpeedFailConjunctionTimes_get( dot11ConjunctionTable_rowreq_ctx *rowreq_ctx, u_long * wtpReasonTerminalNotSupportAllSpeedFailConjunctionTimes_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpReasonTerminalNotSupportAllSpeedFailConjunctionTimes_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpReasonTerminalNotSupportAllSpeedFailConjunctionTimes_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpReasonTerminalNotSupportAllSpeedFailConjunctionTimes data.
 * set (* wtpReasonTerminalNotSupportAllSpeedFailConjunctionTimes_val_ptr ) from rowreq_ctx->data
 */
    (* wtpReasonTerminalNotSupportAllSpeedFailConjunctionTimes_val_ptr ) = rowreq_ctx->data.wtpReasonTerminalNotSupportAllSpeedFailConjunctionTimes;

    return MFD_SUCCESS;
} /* wtpReasonTerminalNotSupportAllSpeedFailConjunctionTimes_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConjunctionEntry.wtpNotContainedInStdReasonAssocFailSum
 * wtpNotContainedInStdReasonAssocFailSum is subid 17 of dot11ConjunctionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.6.2.1.17
 * Description:
The total times that fail conjunction because of not support all the speed.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpNotContainedInStdReasonAssocFailSum.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpNotContainedInStdReasonAssocFailSum_map(u_long *mib_wtpNotContainedInStdReasonAssocFailSum_val_ptr, u_long raw_wtpNotContainedInStdReasonAssocFailSum_val)
{
    netsnmp_assert(NULL != mib_wtpNotContainedInStdReasonAssocFailSum_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpNotContainedInStdReasonAssocFailSum_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpNotContainedInStdReasonAssocFailSum mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpNotContainedInStdReasonAssocFailSum_val_ptr) = raw_wtpNotContainedInStdReasonAssocFailSum_val;

    return MFD_SUCCESS;
} /* wtpNotContainedInStdReasonAssocFailSum_map */

int
wtpNotContainedInStdReasonAssocFailSum_get( dot11ConjunctionTable_rowreq_ctx *rowreq_ctx, u_long * wtpNotContainedInStdReasonAssocFailSum_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpNotContainedInStdReasonAssocFailSum_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpNotContainedInStdReasonAssocFailSum_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpNotContainedInStdReasonAssocFailSum data.
 * set (* wtpNotContainedInStdReasonAssocFailSum_val_ptr ) from rowreq_ctx->data
 */
    (* wtpNotContainedInStdReasonAssocFailSum_val_ptr ) = rowreq_ctx->data.wtpNotContainedInStdReasonAssocFailSum;

    return MFD_SUCCESS;
} 

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConjunctionEntry.wtpUnknowReasonAssocFailSum
 * wtpUnknowReasonAssocFailSum is subid 18 of dot11ConjunctionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.6.2.1.18
 * Description:
The total times that fail conjunction because of not support all the speed.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpUnknowReasonAssocFailSum.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpUnknowReasonAssocFailSum_map(u_long *mib_wtpUnknowReasonAssocFailSum_val_ptr, u_long raw_wtpUnknowReasonAssocFailSum_val)
{
    netsnmp_assert(NULL != mib_wtpUnknowReasonAssocFailSum_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpUnknowReasonAssocFailSum_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpUnknowReasonAssocFailSum mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpUnknowReasonAssocFailSum_val_ptr) = raw_wtpUnknowReasonAssocFailSum_val;

    return MFD_SUCCESS;
} /* wtpUnknowReasonAssocFailSum_map */

int
wtpUnknowReasonAssocFailSum_get( dot11ConjunctionTable_rowreq_ctx *rowreq_ctx, u_long * wtpUnknowReasonAssocFailSum_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpUnknowReasonAssocFailSum_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpUnknowReasonAssocFailSum_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpUnknowReasonAssocFailSum data.
 * set (* wtpUnknowReasonAssocFailSum_val_ptr ) from rowreq_ctx->data
 */
    (* wtpUnknowReasonAssocFailSum_val_ptr ) = rowreq_ctx->data.wtpUnknowReasonAssocFailSum;

    return MFD_SUCCESS;
} 

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConjunctionEntry.wtpPreAssCannotShiftDeassocFailSum
 * wtpPreAssCannotShiftDeassocFailSum is subid 19 of dot11ConjunctionEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.6.2.1.19
 * Description:
The total times that fail conjunction because of not support all the speed.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpPreAssCannotShiftDeassocFailSum.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpPreAssCannotShiftDeassocFailSum_map(u_long *mib_wtpPreAssCannotShiftDeassocFailSum_val_ptr, u_long raw_wtpPreAssCannotShiftDeassocFailSum_val)
{
    netsnmp_assert(NULL != mib_wtpPreAssCannotShiftDeassocFailSum_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpPreAssCannotShiftDeassocFailSum_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpPreAssCannotShiftDeassocFailSum mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpPreAssCannotShiftDeassocFailSum_val_ptr) = raw_wtpPreAssCannotShiftDeassocFailSum_val;

    return MFD_SUCCESS;
} /* wtpPreAssCannotShiftDeassocFailSum_map */

int
wtpPreAssCannotShiftDeassocFailSum_get( dot11ConjunctionTable_rowreq_ctx *rowreq_ctx, u_long * wtpPreAssCannotShiftDeassocFailSum_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != wtpPreAssCannotShiftDeassocFailSum_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConjunctionTable:wtpPreAssCannotShiftDeassocFailSum_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the wtpPreAssCannotShiftDeassocFailSum data.
 * set (* wtpPreAssCannotShiftDeassocFailSum_val_ptr ) from rowreq_ctx->data
 */
    (* wtpPreAssCannotShiftDeassocFailSum_val_ptr ) = rowreq_ctx->data.wtpPreAssCannotShiftDeassocFailSum;

    return MFD_SUCCESS;
} /* wtpPreAssCannotShiftDeassocFailSum_get */





/** @} */
