/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.18.2.1 $ of : mfd-data-get.m2c,v $ 
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "dot11WlanRadioDataTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement dot11WlanRadioDataTable get routines.
 * TODO:240:M: Implement dot11WlanRadioDataTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table dot11WlanRadioDataTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * dot11WlanRadioDataTable is subid 2 of wlanData.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.31656.6.1.1.16.2, length: 12
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement dot11WlanRadioDataTable data context functions.
 */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWlanStatsEntry.wlanCurrID
 * wlanCurrID is subid 1 of dot11WtpWlanStatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.5.3.1.1
 * Description:
The wlan's ID.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wlanCurrID.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wlanCurrID_dot11WlanRadioDataTable_map(long *mib_wlanCurrID_val_ptr, long raw_wlanCurrID_val)
{
    netsnmp_assert(NULL != mib_wlanCurrID_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WlanRadioDataTable:wlanCurrID_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wlanCurrID mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wlanCurrID_val_ptr) = raw_wlanCurrID_val;

    return MFD_SUCCESS;
} /* wlanCurrID_map */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
dot11WlanRadioDataTable_indexes_set_tbl_idx(dot11WlanRadioDataTable_mib_index *tbl_idx, long wlanCurrID_val)
{
    DEBUGMSGTL(("verbose:dot11WlanRadioDataTable:dot11WlanRadioDataTable_indexes_set_tbl_idx","called\n"));

    /* wlanCurrID(1)/INTEGER/ASN_INTEGER/long(long)//l/A/w/e/r/d/h */
    tbl_idx->wlanCurrID = wlanCurrID_val;
    

    return MFD_SUCCESS;
} /* dot11WlanRadioDataTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
dot11WlanRadioDataTable_indexes_set(dot11WlanRadioDataTable_rowreq_ctx *rowreq_ctx, long wlanCurrID_val)
{
    DEBUGMSGTL(("verbose:dot11WlanRadioDataTable:dot11WlanRadioDataTable_indexes_set","called\n"));

    if(MFD_SUCCESS != dot11WlanRadioDataTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
                                   , wlanCurrID_val
           ))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if(0 != dot11WlanRadioDataTable_index_to_oid(&rowreq_ctx->oid_idx,
                                    &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* dot11WlanRadioDataTable_indexes_set */


/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WlanRadioDataEntry.WlanradioRecvFlow
 * WlanradioRecvFlow is subid 1 of dot11WlanRadioDataEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.16.2.1.1
 * Description:
The Wireless radioRecvFlow which received from terminal(Appointed SSID).
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-WlanradioRecvFlow.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
WlanradioRecvFlow_map(unsigned long long *mib_WlanradioRecvFlow_val_ptr, unsigned long long raw_WlanradioRecvFlow_val)
{
    netsnmp_assert(NULL != mib_WlanradioRecvFlow_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WlanRadioDataTable:WlanradioRecvFlow_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement WlanradioRecvFlow mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_WlanradioRecvFlow_val_ptr) = raw_WlanradioRecvFlow_val;

    return MFD_SUCCESS;
} /* WlanradioRecvFlow_map */

/**
 * Extract the current value of the WlanradioRecvFlow data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param WlanradioRecvFlow_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
WlanradioRecvFlow_get( dot11WlanRadioDataTable_rowreq_ctx *rowreq_ctx, unsigned long long * WlanradioRecvFlow_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != WlanradioRecvFlow_val_ptr );

/*
 * TODO:231:o: |-> copy WlanradioRecvFlow data.
 * get (* WlanradioRecvFlow_val_ptr ).low and (* WlanradioRecvFlow_val_ptr ).high from rowreq_ctx->data
 */
    //(* WlanradioRecvFlow_val_ptr ).high = rowreq_ctx->data.WlanradioRecvFlow.high;
    (* WlanradioRecvFlow_val_ptr ) = rowreq_ctx->data.WlanradioRecvFlow;


    return MFD_SUCCESS;
} /* WlanradioRecvFlow_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WlanRadioDataEntry.WlanradioSendFlow
 * WlanradioSendFlow is subid 2 of dot11WlanRadioDataEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.16.2.1.2
 * Description:
The Wireless radioSendFlow which received from terminal(Appointed SSID).(bts)
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-WlanradioSendFlow.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
WlanradioSendFlow_map(unsigned long long *mib_WlanradioSendFlow_val_ptr, unsigned long long raw_WlanradioSendFlow_val)
{
    netsnmp_assert(NULL != mib_WlanradioSendFlow_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WlanRadioDataTable:WlanradioSendFlow_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement WlanradioSendFlow mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_WlanradioSendFlow_val_ptr) = raw_WlanradioSendFlow_val;

    return MFD_SUCCESS;
} /* WlanradioSendFlow_map */

/**
 * Extract the current value of the WlanradioSendFlow data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param WlanradioSendFlow_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
WlanradioSendFlow_get( dot11WlanRadioDataTable_rowreq_ctx *rowreq_ctx, unsigned long long * WlanradioSendFlow_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != WlanradioSendFlow_val_ptr );

/*
 * TODO:231:o: |-> copy WlanradioSendFlow data.
 * get (* WlanradioSendFlow_val_ptr ).low and (* WlanradioSendFlow_val_ptr ).high from rowreq_ctx->data
 */
    //(* WlanradioSendFlow_val_ptr ).high = rowreq_ctx->data.WlanradioSendFlow.high;
    (* WlanradioSendFlow_val_ptr ) = rowreq_ctx->data.WlanradioSendFlow;


    return MFD_SUCCESS;
} /* WlanradioSendFlow_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WlanRadioDataEntry.WlanradioReSendFrames
 * WlanradioReSendFrames is subid 3 of dot11WlanRadioDataEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.16.2.1.3
 * Description:
The Wireless radioReSendFrames which received from terminal(Appointed SSID).(bts)
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-WlanradioReSendFrames.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
WlanradioReSendFrames_map(unsigned long long *mib_WlanradioReSendFrames_val_ptr, unsigned long long raw_WlanradioReSendFrames_val)
{
    netsnmp_assert(NULL != mib_WlanradioReSendFrames_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WlanRadioDataTable:WlanradioReSendFrames_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement WlanradioReSendFrames mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_WlanradioReSendFrames_val_ptr) = raw_WlanradioReSendFrames_val;

    return MFD_SUCCESS;
} /* WlanradioReSendFrames_map */

/**
 * Extract the current value of the WlanradioReSendFrames data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param WlanradioReSendFrames_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
WlanradioReSendFrames_get( dot11WlanRadioDataTable_rowreq_ctx *rowreq_ctx, unsigned long long * WlanradioReSendFrames_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != WlanradioReSendFrames_val_ptr );

/*
 * TODO:231:o: |-> copy WlanradioReSendFrames data.
 * get (* WlanradioReSendFrames_val_ptr ).low and (* WlanradioReSendFrames_val_ptr ).high from rowreq_ctx->data
 */
    //(* WlanradioReSendFrames_val_ptr ).high = rowreq_ctx->data.WlanradioReSendFrames.high;
    (* WlanradioReSendFrames_val_ptr ) = rowreq_ctx->data.WlanradioReSendFrames;


    return MFD_SUCCESS;
} /* WlanradioReSendFrames_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WlanRadioDataEntry.WlanradioSendDiscardFrames
 * WlanradioSendDiscardFrames is subid 4 of dot11WlanRadioDataEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.16.2.1.4
 * Description:
The Wireless radioSendDiscardFrames which received from terminal(Appointed SSID).(bts)
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-WlanradioSendDiscardFrames.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
WlanradioSendDiscardFrames_map(unsigned long long *mib_WlanradioSendDiscardFrames_val_ptr, unsigned long long raw_WlanradioSendDiscardFrames_val)
{
    netsnmp_assert(NULL != mib_WlanradioSendDiscardFrames_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WlanRadioDataTable:WlanradioSendDiscardFrames_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement WlanradioSendDiscardFrames mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_WlanradioSendDiscardFrames_val_ptr) = raw_WlanradioSendDiscardFrames_val;

    return MFD_SUCCESS;
} /* WlanradioSendDiscardFrames_map */

/**
 * Extract the current value of the WlanradioSendDiscardFrames data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param WlanradioSendDiscardFrames_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
WlanradioSendDiscardFrames_get( dot11WlanRadioDataTable_rowreq_ctx *rowreq_ctx, unsigned long long * WlanradioSendDiscardFrames_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != WlanradioSendDiscardFrames_val_ptr );

/*
 * TODO:231:o: |-> copy WlanradioSendDiscardFrames data.
 * get (* WlanradioSendDiscardFrames_val_ptr ).low and (* WlanradioSendDiscardFrames_val_ptr ).high from rowreq_ctx->data
 */
    //(* WlanradioSendDiscardFrames_val_ptr ).high = rowreq_ctx->data.WlanradioSendDiscardFrames.high;
    (* WlanradioSendDiscardFrames_val_ptr ) = rowreq_ctx->data.WlanradioSendDiscardFrames;


    return MFD_SUCCESS;
} /* WlanradioSendDiscardFrames_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WlanRadioDataEntry.WlanradioSendErrFrames
 * WlanradioSendErrFrames is subid 5 of dot11WlanRadioDataEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.16.2.1.5
 * Description:
The Wireless radioSendErrFrames which received from terminal(Appointed SSID).(bts)
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-WlanradioSendErrFrames.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
WlanradioSendErrFrames_map(unsigned long long *mib_WlanradioSendErrFrames_val_ptr, unsigned long long raw_WlanradioSendErrFrames_val)
{
    netsnmp_assert(NULL != mib_WlanradioSendErrFrames_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WlanRadioDataTable:WlanradioSendErrFrames_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement WlanradioSendErrFrames mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_WlanradioSendErrFrames_val_ptr) = raw_WlanradioSendErrFrames_val;

    return MFD_SUCCESS;
} /* WlanradioSendErrFrames_map */

/**
 * Extract the current value of the WlanradioSendErrFrames data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param WlanradioSendErrFrames_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
WlanradioSendErrFrames_get( dot11WlanRadioDataTable_rowreq_ctx *rowreq_ctx, unsigned long long * WlanradioSendErrFrames_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != WlanradioSendErrFrames_val_ptr );

/*
 * TODO:231:o: |-> copy WlanradioSendErrFrames data.
 * get (* WlanradioSendErrFrames_val_ptr ).low and (* WlanradioSendErrFrames_val_ptr ).high from rowreq_ctx->data
 */
    //(* WlanradioSendErrFrames_val_ptr ).high = rowreq_ctx->data.WlanradioSendErrFrames.high;
    (* WlanradioSendErrFrames_val_ptr ) = rowreq_ctx->data.WlanradioSendErrFrames;


    return MFD_SUCCESS;
} /* WlanradioSendErrFrames_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WlanRadioDataEntry.WlanradioRecvDiscardFrames
 * WlanradioRecvDiscardFrames is subid 6 of dot11WlanRadioDataEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.16.2.1.6
 * Description:
The Wireless radioRecvDiscardFrames which received from terminal(Appointed SSID).(bts)
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-WlanradioRecvDiscardFrames.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
WlanradioRecvDiscardFrames_map(unsigned long long *mib_WlanradioRecvDiscardFrames_val_ptr, unsigned long long raw_WlanradioRecvDiscardFrames_val)
{
    netsnmp_assert(NULL != mib_WlanradioRecvDiscardFrames_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WlanRadioDataTable:WlanradioRecvDiscardFrames_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement WlanradioRecvDiscardFrames mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_WlanradioRecvDiscardFrames_val_ptr) = raw_WlanradioRecvDiscardFrames_val;

    return MFD_SUCCESS;
} /* WlanradioRecvDiscardFrames_map */

/**
 * Extract the current value of the WlanradioRecvDiscardFrames data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param WlanradioRecvDiscardFrames_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
WlanradioRecvDiscardFrames_get( dot11WlanRadioDataTable_rowreq_ctx *rowreq_ctx, unsigned long long * WlanradioRecvDiscardFrames_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != WlanradioRecvDiscardFrames_val_ptr );

/*
 * TODO:231:o: |-> copy WlanradioRecvDiscardFrames data.
 * get (* WlanradioRecvDiscardFrames_val_ptr ).low and (* WlanradioRecvDiscardFrames_val_ptr ).high from rowreq_ctx->data
 */
    //(* WlanradioRecvDiscardFrames_val_ptr ).high = rowreq_ctx->data.WlanradioRecvDiscardFrames.high;
    (* WlanradioRecvDiscardFrames_val_ptr ) = rowreq_ctx->data.WlanradioRecvDiscardFrames;


    return MFD_SUCCESS;
} /* WlanradioRecvDiscardFrames_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WlanRadioDataEntry.WlanradioReRecvFrames
 * WlanradioReRecvFrames is subid 7 of dot11WlanRadioDataEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.16.2.1.7
 * Description:
The Wireless radioReRecvFrames which received from terminal(Appointed SSID).(bts)
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-WlanradioReRecvFrames.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
WlanradioReRecvFrames_map(unsigned long long *mib_WlanradioReRecvFrames_val_ptr, unsigned long long raw_WlanradioReRecvFrames_val)
{
    netsnmp_assert(NULL != mib_WlanradioReRecvFrames_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WlanRadioDataTable:WlanradioReRecvFrames_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement WlanradioReRecvFrames mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_WlanradioReRecvFrames_val_ptr) = raw_WlanradioReRecvFrames_val;

    return MFD_SUCCESS;
} /* WlanradioReRecvFrames_map */

/**
 * Extract the current value of the WlanradioReRecvFrames data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param WlanradioReRecvFrames_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
WlanradioReRecvFrames_get( dot11WlanRadioDataTable_rowreq_ctx *rowreq_ctx, unsigned long long * WlanradioReRecvFrames_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != WlanradioReRecvFrames_val_ptr );

/*
 * TODO:231:o: |-> copy WlanradioReRecvFrames data.
 * get (* WlanradioReRecvFrames_val_ptr ).low and (* WlanradioReRecvFrames_val_ptr ).high from rowreq_ctx->data
 */
    //(* WlanradioReRecvFrames_val_ptr ).high = rowreq_ctx->data.WlanradioReRecvFrames.high;
    (* WlanradioReRecvFrames_val_ptr ) = rowreq_ctx->data.WlanradioReRecvFrames;


    return MFD_SUCCESS;
} /* WlanradioReRecvFrames_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WlanRadioDataEntry.WlanradioRecvSpeed
 * WlanradioRecvSpeed is subid 8 of dot11WlanRadioDataEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.16.2.1.8
 * Description:
The Wireless radioRecvSpeed which received from terminal(Appointed SSID).
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-WlanradioRecvSpeed.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
WlanradioRecvSpeed_map(long *mib_WlanradioRecvSpeed_val_ptr, long raw_WlanradioRecvSpeed_val)
{
    netsnmp_assert(NULL != mib_WlanradioRecvSpeed_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WlanRadioDataTable:WlanradioRecvSpeed_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement WlanradioRecvSpeed mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_WlanradioRecvSpeed_val_ptr) = raw_WlanradioRecvSpeed_val;

    return MFD_SUCCESS;
} /* WlanradioRecvSpeed_map */

/**
 * Extract the current value of the WlanradioRecvSpeed data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param WlanradioRecvSpeed_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
WlanradioRecvSpeed_get( dot11WlanRadioDataTable_rowreq_ctx *rowreq_ctx, long * WlanradioRecvSpeed_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != WlanradioRecvSpeed_val_ptr );


    DEBUGMSGTL(("verbose:dot11WlanRadioDataTable:WlanradioRecvSpeed_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the WlanradioRecvSpeed data.
 * set (* WlanradioRecvSpeed_val_ptr ) from rowreq_ctx->data
 */
    (* WlanradioRecvSpeed_val_ptr ) = rowreq_ctx->data.WlanradioRecvSpeed;

    return MFD_SUCCESS;
} /* WlanradioRecvSpeed_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WlanRadioDataEntry.WlanradioSendSpeed
 * WlanradioSendSpeed is subid 9 of dot11WlanRadioDataEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.16.2.1.9
 * Description:
The Wireless radioSendSpeed which received from terminal(Appointed SSID).(bts)
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-WlanradioSendSpeed.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
WlanradioSendSpeed_map(long *mib_WlanradioSendSpeed_val_ptr, long raw_WlanradioSendSpeed_val)
{
    netsnmp_assert(NULL != mib_WlanradioSendSpeed_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11WlanRadioDataTable:WlanradioSendSpeed_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement WlanradioSendSpeed mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_WlanradioSendSpeed_val_ptr) = raw_WlanradioSendSpeed_val;

    return MFD_SUCCESS;
} /* WlanradioSendSpeed_map */

/**
 * Extract the current value of the WlanradioSendSpeed data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param WlanradioSendSpeed_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
WlanradioSendSpeed_get( dot11WlanRadioDataTable_rowreq_ctx *rowreq_ctx, long * WlanradioSendSpeed_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != WlanradioSendSpeed_val_ptr );


    DEBUGMSGTL(("verbose:dot11WlanRadioDataTable:WlanradioSendSpeed_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the WlanradioSendSpeed data.
 * set (* WlanradioSendSpeed_val_ptr ) from rowreq_ctx->data
 */
    (* WlanradioSendSpeed_val_ptr ) = rowreq_ctx->data.WlanradioSendSpeed;

    return MFD_SUCCESS;
} /* WlanradioSendSpeed_get */



/** @} */
