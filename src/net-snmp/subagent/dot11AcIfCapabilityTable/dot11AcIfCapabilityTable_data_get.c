/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.18.2.1 $ of : mfd-data-get.m2c,v $ 
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "dot11AcIfCapabilityTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement dot11AcIfCapabilityTable get routines.
 * TODO:240:M: Implement dot11AcIfCapabilityTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table dot11AcIfCapabilityTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * dot11AcIfCapabilityTable is subid 3 of dot11AcInterface.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3, length: 12
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement dot11AcIfCapabilityTable data context functions.
 */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfEntry.ifIndex
 * ifIndex is subid 1 of dot11AcIfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.2.1.1
 * Description:
Interface index.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-ifIndex.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
ifIndex_map(long *mib_ifIndex_val_ptr, long raw_ifIndex_val)
{
    netsnmp_assert(NULL != mib_ifIndex_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:ifIndex_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement ifIndex mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_ifIndex_val_ptr) = raw_ifIndex_val;

    return MFD_SUCCESS;
} /* ifIndex_map */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
dot11AcIfCapabilityTable_indexes_set_tbl_idx(dot11AcIfCapabilityTable_mib_index *tbl_idx, long ifIndex_val)
{
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:dot11AcIfCapabilityTable_indexes_set_tbl_idx","called\n"));

    /* ifIndex(1)/INTEGER/ASN_INTEGER/long(long)//l/A/w/e/r/d/h */
    tbl_idx->ifIndex = ifIndex_val;
    

    return MFD_SUCCESS;
} /* dot11AcIfCapabilityTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
dot11AcIfCapabilityTable_indexes_set(dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, long ifIndex_val)
{
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:dot11AcIfCapabilityTable_indexes_set","called\n"));

    if(MFD_SUCCESS != dot11AcIfCapabilityTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
                                   , ifIndex_val
           ))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if(0 != dot11AcIfCapabilityTable_index_to_oid(&rowreq_ctx->oid_idx,
                                    &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* dot11AcIfCapabilityTable_indexes_set */


/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acIfInUcastPkts
 * acIfInUcastPkts is subid 1 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.1
 * Description:
The total number of unicast packets the interface received.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acIfInUcastPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acIfInUcastPkts_map(unsigned long long *mib_acIfInUcastPkts_val_ptr, unsigned long long raw_acIfInUcastPkts_val)
{
    netsnmp_assert(NULL != mib_acIfInUcastPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfInUcastPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acIfInUcastPkts_val_ptr) = raw_acIfInUcastPkts_val;

    return MFD_SUCCESS;
} /* acIfInUcastPkts_map */

/**
 * Extract the current value of the acIfInUcastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acIfInUcastPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acIfInUcastPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acIfInUcastPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acIfInUcastPkts_val_ptr );
   
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfInUcastPkts_get","called\n"));
   
   netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> copy acIfInUcastPkts data.
 * get (* acIfInUcastPkts_val_ptr ).low and (* acIfInUcastPkts_val_ptr ).high from rowreq_ctx->data
 */
    (* acIfInUcastPkts_val_ptr ) = rowreq_ctx->data.acIfInUcastPkts;


    return MFD_SUCCESS;
} /* acIfInUcastPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acIfInNUcastPkts
 * acIfInNUcastPkts is subid 2 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.2
 * Description:
The total number of non-unicast packets the interface received.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acIfInNUcastPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acIfInNUcastPkts_map(unsigned long long *mib_acIfInNUcastPkts_val_ptr, unsigned long long raw_acIfInNUcastPkts_val)
{
    netsnmp_assert(NULL != mib_acIfInNUcastPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfInNUcastPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInNUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acIfInNUcastPkts_val_ptr) = raw_acIfInNUcastPkts_val;

    return MFD_SUCCESS;
} /* acIfInNUcastPkts_map */

/**
 * Extract the current value of the acIfInNUcastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acIfInNUcastPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acIfInNUcastPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acIfInNUcastPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acIfInNUcastPkts_val_ptr );
   
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfInNUcastPkts_get","called\n"));
   
   netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> copy acIfInNUcastPkts data.
 * get (* acIfInNUcastPkts_val_ptr ).low and (* acIfInNUcastPkts_val_ptr ).high from rowreq_ctx->data
 */
    (* acIfInNUcastPkts_val_ptr ) = rowreq_ctx->data.acIfInNUcastPkts;


    return MFD_SUCCESS;
} /* acIfInNUcastPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acIfInOctets
 * acIfInOctets is subid 3 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.3
 * Description:
The total number of bytes the interface received.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acIfInOctets.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acIfInOctets_map(unsigned long long *mib_acIfInOctets_val_ptr, unsigned long long raw_acIfInOctets_val)
{
    netsnmp_assert(NULL != mib_acIfInOctets_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfInOctets_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInOctets mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acIfInOctets_val_ptr) = raw_acIfInOctets_val;

    return MFD_SUCCESS;
} /* acIfInOctets_map */

/**
 * Extract the current value of the acIfInOctets data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acIfInOctets_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acIfInOctets_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acIfInOctets_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acIfInOctets_val_ptr );
   
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfInOctets_get","called\n"));
   
   netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> copy acIfInOctets data.
 * get (* acIfInOctets_val_ptr ).low and (* acIfInOctets_val_ptr ).high from rowreq_ctx->data
 */
    (* acIfInOctets_val_ptr ) = rowreq_ctx->data.acIfInOctets;


    return MFD_SUCCESS;
} /* acIfInOctets_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acIfInDiscardPkts
 * acIfInDiscardPkts is subid 4 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.4
 * Description:
The total number of  packets the interface received and discarded.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acIfInDiscardPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acIfInDiscardPkts_map(u_long *mib_acIfInDiscardPkts_val_ptr, u_long raw_acIfInDiscardPkts_val)
{
    netsnmp_assert(NULL != mib_acIfInDiscardPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfInDiscardPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInDiscardPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acIfInDiscardPkts_val_ptr) = raw_acIfInDiscardPkts_val;

    return MFD_SUCCESS;
} /* acIfInDiscardPkts_map */

/**
 * Extract the current value of the acIfInDiscardPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acIfInDiscardPkts_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acIfInDiscardPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, u_long * acIfInDiscardPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acIfInDiscardPkts_val_ptr );


    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfInDiscardPkts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the acIfInDiscardPkts data.
 * set (* acIfInDiscardPkts_val_ptr ) from rowreq_ctx->data
 */
    (* acIfInDiscardPkts_val_ptr ) = rowreq_ctx->data.acIfInDiscardPkts;

    return MFD_SUCCESS;
} /* acIfInDiscardPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acIfInErrors
 * acIfInErrors is subid 5 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.5
 * Description:
The total number of error packets the interface received.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acIfInErrors.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acIfInErrors_map(u_long *mib_acIfInErrors_val_ptr, u_long raw_acIfInErrors_val)
{
    netsnmp_assert(NULL != mib_acIfInErrors_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfInErrors_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInErrors mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acIfInErrors_val_ptr) = raw_acIfInErrors_val;

    return MFD_SUCCESS;
} /* acIfInErrors_map */

/**
 * Extract the current value of the acIfInErrors data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acIfInErrors_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acIfInErrors_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, u_long * acIfInErrors_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acIfInErrors_val_ptr );


    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfInErrors_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the acIfInErrors data.
 * set (* acIfInErrors_val_ptr ) from rowreq_ctx->data
 */
    (* acIfInErrors_val_ptr ) = rowreq_ctx->data.acIfInErrors;

    return MFD_SUCCESS;
} /* acIfInErrors_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acIfOutUcastPkts
 * acIfOutUcastPkts is subid 6 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.6
 * Description:
The total number of unicast packets the interface transmited.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acIfOutUcastPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acIfOutUcastPkts_map(unsigned long long *mib_acIfOutUcastPkts_val_ptr, unsigned long long raw_acIfOutUcastPkts_val)
{
    netsnmp_assert(NULL != mib_acIfOutUcastPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfOutUcastPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfOutUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acIfOutUcastPkts_val_ptr) = raw_acIfOutUcastPkts_val;

    return MFD_SUCCESS;
} /* acIfOutUcastPkts_map */

/**
 * Extract the current value of the acIfOutUcastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acIfOutUcastPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acIfOutUcastPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acIfOutUcastPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acIfOutUcastPkts_val_ptr );
   
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfOutUcastPkts_get","called\n"));
   
   netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> copy acIfOutUcastPkts data.
 * get (* acIfOutUcastPkts_val_ptr ).low and (* acIfOutUcastPkts_val_ptr ).high from rowreq_ctx->data
 */
    (* acIfOutUcastPkts_val_ptr ) = rowreq_ctx->data.acIfOutUcastPkts;


    return MFD_SUCCESS;
} /* acIfOutUcastPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acIfOutNUcastPkts
 * acIfOutNUcastPkts is subid 7 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.7
 * Description:
The total number of non-unicast packets the interface transmited.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acIfOutNUcastPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acIfOutNUcastPkts_map(unsigned long long *mib_acIfOutNUcastPkts_val_ptr, unsigned long long raw_acIfOutNUcastPkts_val)
{
    netsnmp_assert(NULL != mib_acIfOutNUcastPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfOutNUcastPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfOutNUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acIfOutNUcastPkts_val_ptr) = raw_acIfOutNUcastPkts_val;

    return MFD_SUCCESS;
} /* acIfOutNUcastPkts_map */

/**
 * Extract the current value of the acIfOutNUcastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acIfOutNUcastPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acIfOutNUcastPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acIfOutNUcastPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acIfOutNUcastPkts_val_ptr );
   
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfOutNUcastPkts_get","called\n"));
   
   netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> copy acIfOutNUcastPkts data.
 * get (* acIfOutNUcastPkts_val_ptr ).low and (* acIfOutNUcastPkts_val_ptr ).high from rowreq_ctx->data
 */
    (* acIfOutNUcastPkts_val_ptr ) = rowreq_ctx->data.acIfOutNUcastPkts;


    return MFD_SUCCESS;
} /* acIfOutNUcastPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acIfOutOctets
 * acIfOutOctets is subid 8 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.8
 * Description:
The total number of bytes the interface transmited.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acIfOutOctets.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acIfOutOctets_map(unsigned long long *mib_acIfOutOctets_val_ptr, unsigned long long raw_acIfOutOctets_val)
{
    netsnmp_assert(NULL != mib_acIfOutOctets_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfOutOctets_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfOutOctets mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acIfOutOctets_val_ptr) = raw_acIfOutOctets_val;

    return MFD_SUCCESS;
} /* acIfOutOctets_map */

/**
 * Extract the current value of the acIfOutOctets data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acIfOutOctets_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acIfOutOctets_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acIfOutOctets_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acIfOutOctets_val_ptr );
   
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfOutOctets_get","called\n"));
   
   netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> copy acIfOutOctets data.
 * get (* acIfOutOctets_val_ptr ).low and (* acIfOutOctets_val_ptr ).high from rowreq_ctx->data
 */
    (* acIfOutOctets_val_ptr ) = rowreq_ctx->data.acIfOutOctets;


    return MFD_SUCCESS;
} /* acIfOutOctets_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acIfOutDiscardPkts
 * acIfOutDiscardPkts is subid 9 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.9
 * Description:
The total number of  packets the interface transmited and discarded.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acIfOutDiscardPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acIfOutDiscardPkts_map(u_long *mib_acIfOutDiscardPkts_val_ptr, u_long raw_acIfOutDiscardPkts_val)
{
    netsnmp_assert(NULL != mib_acIfOutDiscardPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfOutDiscardPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfOutDiscardPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acIfOutDiscardPkts_val_ptr) = raw_acIfOutDiscardPkts_val;

    return MFD_SUCCESS;
} /* acIfOutDiscardPkts_map */

/**
 * Extract the current value of the acIfOutDiscardPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acIfOutDiscardPkts_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acIfOutDiscardPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, u_long * acIfOutDiscardPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acIfOutDiscardPkts_val_ptr );


    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfOutDiscardPkts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the acIfOutDiscardPkts data.
 * set (* acIfOutDiscardPkts_val_ptr ) from rowreq_ctx->data
 */
    (* acIfOutDiscardPkts_val_ptr ) = rowreq_ctx->data.acIfOutDiscardPkts;

    return MFD_SUCCESS;
} /* acIfOutDiscardPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acIfOutErrors
 * acIfOutErrors is subid 10 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.10
 * Description:
The total number of error packets the interface transmited.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acIfOutErrors.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acIfOutErrors_map(u_long *mib_acIfOutErrors_val_ptr, u_long raw_acIfOutErrors_val)
{
    netsnmp_assert(NULL != mib_acIfOutErrors_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfOutErrors_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfOutErrors mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acIfOutErrors_val_ptr) = raw_acIfOutErrors_val;

    return MFD_SUCCESS;
} /* acIfOutErrors_map */

/**
 * Extract the current value of the acIfOutErrors data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acIfOutErrors_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acIfOutErrors_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, u_long * acIfOutErrors_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acIfOutErrors_val_ptr );


    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfOutErrors_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the acIfOutErrors data.
 * set (* acIfOutErrors_val_ptr ) from rowreq_ctx->data
 */
    (* acIfOutErrors_val_ptr ) = rowreq_ctx->data.acIfOutErrors;

    return MFD_SUCCESS;
} /* acIfOutErrors_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acIfUpDwnTimes
 * acIfUpDwnTimes is subid 11 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.11
 * Description:
The interface up-down times.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acIfUpDwnTimes.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acIfUpDwnTimes_map(u_long *mib_acIfUpDwnTimes_val_ptr, u_long raw_acIfUpDwnTimes_val)
{
    netsnmp_assert(NULL != mib_acIfUpDwnTimes_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfUpDwnTimes_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfUpDwnTimes mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acIfUpDwnTimes_val_ptr) = raw_acIfUpDwnTimes_val;

    return MFD_SUCCESS;
} /* acIfUpDwnTimes_map */

/**
 * Extract the current value of the acIfUpDwnTimes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acIfUpDwnTimes_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acIfUpDwnTimes_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, u_long * acIfUpDwnTimes_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acIfUpDwnTimes_val_ptr );


    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfUpDwnTimes_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the acIfUpDwnTimes data.
 * set (* acIfUpDwnTimes_val_ptr ) from rowreq_ctx->data
 */
    (* acIfUpDwnTimes_val_ptr ) = rowreq_ctx->data.acIfUpDwnTimes;

    return MFD_SUCCESS;
} /* acIfUpDwnTimes_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acIfInMulticastPkts
 * acIfInMulticastPkts is subid 12 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.12
 * Description:
Multicast packets received.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acIfInMulticastPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acIfInMulticastPkts_map(u_long *mib_acIfInMulticastPkts_val_ptr, u_long raw_acIfInMulticastPkts_val)
{
    netsnmp_assert(NULL != mib_acIfInMulticastPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfInMulticastPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInMulticastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acIfInMulticastPkts_val_ptr) = raw_acIfInMulticastPkts_val;

    return MFD_SUCCESS;
} /* acIfInMulticastPkts_map */

/**
 * Extract the current value of the acIfInMulticastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acIfInMulticastPkts_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acIfInMulticastPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, u_long * acIfInMulticastPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acIfInMulticastPkts_val_ptr );


    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfInMulticastPkts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the acIfInMulticastPkts data.
 * set (* acIfInMulticastPkts_val_ptr ) from rowreq_ctx->data
 */
    (* acIfInMulticastPkts_val_ptr ) = rowreq_ctx->data.acIfInMulticastPkts;

    return MFD_SUCCESS;
} /* acIfInMulticastPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acIfOutMulticastPkts
 * acIfOutMulticastPkts is subid 13 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.13
 * Description:
Multicast packets sent.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acIfOutMulticastPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acIfOutMulticastPkts_map(u_long *mib_acIfOutMulticastPkts_val_ptr, u_long raw_acIfOutMulticastPkts_val)
{
    netsnmp_assert(NULL != mib_acIfOutMulticastPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfOutMulticastPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfOutMulticastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acIfOutMulticastPkts_val_ptr) = raw_acIfOutMulticastPkts_val;

    return MFD_SUCCESS;
} /* acIfOutMulticastPkts_map */

/**
 * Extract the current value of the acIfOutMulticastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acIfOutMulticastPkts_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acIfOutMulticastPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, u_long * acIfOutMulticastPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acIfOutMulticastPkts_val_ptr );


    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfOutMulticastPkts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the acIfOutMulticastPkts data.
 * set (* acIfOutMulticastPkts_val_ptr ) from rowreq_ctx->data
 */
    (* acIfOutMulticastPkts_val_ptr ) = rowreq_ctx->data.acIfOutMulticastPkts;

    return MFD_SUCCESS;
} /* acIfOutMulticastPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acUplinkRate
 * acUplinkRate is subid 14 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.14
 * Description:
The  ac uplink rate.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acUplinkRate.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acUplinkRate_map(unsigned long long *mib_acUplinkRate_val_ptr, unsigned long long raw_acUplinkRate_val)
{
    netsnmp_assert(NULL != mib_acUplinkRate_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acUplinkRate_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acUplinkRate mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acUplinkRate_val_ptr) = raw_acUplinkRate_val;

    return MFD_SUCCESS;
} /* acUplinkRate_map */

/**
 * Extract the current value of the acUplinkRate data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acUplinkRate_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acUplinkRate_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acUplinkRate_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acUplinkRate_val_ptr );
   
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acUplinkRate_get","called\n"));
   
   netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> copy acUplinkRate data.
 * get (* acUplinkRate_val_ptr ).low and (* acUplinkRate_val_ptr ).high from rowreq_ctx->data
 */
    (* acUplinkRate_val_ptr ) = rowreq_ctx->data.acUplinkRate;


    return MFD_SUCCESS;
} /* acUplinkRate_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acDownlinkRate
 * acDownlinkRate is subid 15 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.15
 * Description:
The  ac downlink rate.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acDownlinkRate.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acDownlinkRate_map(unsigned long long *mib_acDownlinkRate_val_ptr, unsigned long long raw_acDownlinkRate_val)
{
    netsnmp_assert(NULL != mib_acDownlinkRate_val_ptr);
    
    /*
     * TODO:241:o: |-> Implement acDownlinkRate mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acDownlinkRate_val_ptr) = raw_acDownlinkRate_val;

    return MFD_SUCCESS;
} /* acDownlinkRate_map */

/**
 * Extract the current value of the acDownlinkRate data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acDownlinkRate_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acDownlinkRate_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acDownlinkRate_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acDownlinkRate_val_ptr );
   
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acDownlinkRate_get","called\n"));
   
   netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> copy acDownlinkRate data.
 * get (* acDownlinkRate_val_ptr ).low and (* acDownlinkRate_val_ptr ).high from rowreq_ctx->data
 */
    (* acDownlinkRate_val_ptr ) = rowreq_ctx->data.acDownlinkRate;


    return MFD_SUCCESS;
} /* acDownlinkRate_get */





int
acBandwidthUsage_map(u_long *mib_acBandwidthUsage_val_ptr, u_long raw_acBandwidthUsage_val)
{
    netsnmp_assert(NULL != mib_acBandwidthUsage_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acBandwidthUsage_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInDiscardPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acBandwidthUsage_val_ptr) = raw_acBandwidthUsage_val;

    return MFD_SUCCESS;
} /* acIfInDiscardPkts_map */

int
acBandwidthUsage_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, u_long * acBandwidthUsage_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acBandwidthUsage_val_ptr );


    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acBandwidthUsage_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the acIfInDiscardPkts data.
 * set (* acIfInDiscardPkts_val_ptr ) from rowreq_ctx->data
 */
    (* acBandwidthUsage_val_ptr ) = rowreq_ctx->data.acBandwidthUsage;

    return MFD_SUCCESS;
} /* acIfInDiscardPkts_get */



int
acDropUsage_map(u_long *mib_acDropUsage_val_ptr, u_long raw_acDropUsage_val)
{
    netsnmp_assert(NULL != mib_acDropUsage_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acDropUsage_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInDiscardPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acDropUsage_val_ptr) = raw_acDropUsage_val;

    return MFD_SUCCESS;
} /* acIfInDiscardPkts_map */

int
acDropUsage_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, u_long * acDropUsage_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acDropUsage_val_ptr );


    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acDropUsage_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the acIfInDiscardPkts data.
 * set (* acIfInDiscardPkts_val_ptr ) from rowreq_ctx->data
 */
    (* acDropUsage_val_ptr ) = rowreq_ctx->data.acDropUsage;

    return MFD_SUCCESS;
} /* acIfInDiscardPkts_get */

int
acIfOutBroadcastPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, u_long * acIfOutBroadcastPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acIfOutBroadcastPkts_val_ptr );


    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfOutBroadcastPkts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the acIfInDiscardPkts data.
 * set (* acIfOutBroadcastPkts_val_ptr ) from rowreq_ctx->data
 */
    (* acIfOutBroadcastPkts_val_ptr ) = rowreq_ctx->data.acIfOutBroadcastPkts;

    return MFD_SUCCESS;
} /* acIfOutBroadcastPkts_get */

int
acUplinkKbyteRate_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, u_long * acUplinkKbyteRate_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acUplinkKbyteRate_val_ptr );


    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acUplinkKbyteRate_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the acIfInDiscardPkts data.
 * set (* acUplinkKbyteRate_val_ptr ) from rowreq_ctx->data
 */
    (* acUplinkKbyteRate_val_ptr ) = rowreq_ctx->data.acUplinkKbyteRate;

    return MFD_SUCCESS;
} /* acUplinkKbyteRate_get */

int
acDownlinkKbyteRate_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, u_long * acDownlinkKbyteRate_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acDownlinkKbyteRate_val_ptr );


    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acDownlinkKbyteRate_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the acIfInDiscardPkts data.
 * set (* acDownlinkKbyteRate_val_ptr ) from rowreq_ctx->data
 */
    (* acDownlinkKbyteRate_val_ptr ) = rowreq_ctx->data.acDownlinkKbyteRate;

    return MFD_SUCCESS;
} /* acDownlinkKbyteRate_get */


/** @} */
