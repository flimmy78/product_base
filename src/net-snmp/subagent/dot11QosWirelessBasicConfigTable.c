/*
 * Note: this file originally auto-generated by mib2c using
 *  : mib2c.iterate.conf,v 5.14.2.2 2005/05/09 08:13:01 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "dot11QosWirelessBasicConfigTable.h"
#include "wcpss/asd/asd.h"
#include "wcpss/wid/WID.h"
#include "dbus/wcpss/dcli_wid_wtp.h"
#include "dbus/wcpss/dcli_wid_wlan.h"
#include "ws_dcli_wlans.h"
#include "ws_sysinfo.h"
#include "ws_init_dbus.h"
#include <stdlib.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include "ws_init_dbus.h"
#include <dbus/dbus.h>
#include "sysdef/npd_sysdef.h"
#include "dbus/npd/npd_dbus_def.h"
#include "autelanWtpGroup.h"
#include "ws_dbus_list_interface.h"
//#include "autelanWtpGroup.h"

#define QOSWIRELESSBASICCONFIG "3.4.2"

#define __DEBUG	1


struct dot11QosWirelessBasicConfigTable_entry {
    /* Index values */
	dbus_parameter parameter;
	long globalBcWtpID;
    long BcWtpID;
    long BcRadioLocalID;
    long BcQosType;
	long BcQosID;
	char *BcQosname;
    /* Column values */
    long NewQoSTrafficClass;
    long NewQoSEnabled;
    long NewQoSBW;
    long NewQoSResPercent;
    long NewQoSsharedBW;
    long NewQoSsharedBWPercent;
    char *NewSchedAlgName;
    long NewResPolicyEnabled;
    char *NewResPolicyName;
    long NewBackgroundSvcAvgSpeed;
    long NewBackgroundSvcMaxBurst;
    long NewBackgroundSvcPriority;
    long NewBackgroundSvcResPriority;
    long NewBestEffortSvcAvgSpeed;
    long NewBestEffortSvcMaxBurst;
    long NewBestEffortSvcPriority;
    long NewBestEffortSvcResPriority;
    long NewVoiceSvcAvgSpeed;
    long NewVoiceSvcMaxBurst;
    long NewVoiceSvcPriority;
    long NewVoiceSvcResPriority;
    long NewVideoSvcAvgSpeed;
    long NewVideoSvcMaxBurst;
    long NewVideoSvcPriority;
    long NewVideoSvcResPriority;

    /* Illustrate using a simple linked list */
    int   valid;
    struct dot11QosWirelessBasicConfigTable_entry *next;
};

void dot11QosWirelessBasicConfigTable_load(void);
void dot11QosWirelessBasicConfigTable_removeEntry( struct dot11QosWirelessBasicConfigTable_entry *entry );

/** Initializes the dot11QosWirelessBasicConfigTable module */
void
init_dot11QosWirelessBasicConfigTable(void)
{
  /* here we initialize all the tables we're planning on supporting */
    initialize_table_dot11QosWirelessBasicConfigTable();
}

/** Initialize the dot11QosWirelessBasicConfigTable table by defining its contents and how it's structured */
void
initialize_table_dot11QosWirelessBasicConfigTable(void)
{
    static oid dot11QosWirelessBasicConfigTable_oid[128] = {0};
    size_t dot11QosWirelessBasicConfigTable_oid_len   = 0;
	mad_dev_oid(dot11QosWirelessBasicConfigTable_oid,QOSWIRELESSBASICCONFIG,&dot11QosWirelessBasicConfigTable_oid_len,enterprise_pvivate_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    reg = netsnmp_create_handler_registration(
              "dot11QosWirelessBasicConfigTable",     dot11QosWirelessBasicConfigTable_handler,
              dot11QosWirelessBasicConfigTable_oid, dot11QosWirelessBasicConfigTable_oid_len,
              HANDLER_CAN_RWRITE
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: globalBcWtpID */
                           ASN_INTEGER,  /* index: BcRadioLocalID */
                           ASN_INTEGER,  /* index: BcQosType */
                           0);
    table_info->min_column = NEWWIRELESSQOSMIN;
    table_info->max_column = NEWWIRELESSQOSMAX;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = dot11QosWirelessBasicConfigTable_get_first_data_point;
    iinfo->get_next_data_point  = dot11QosWirelessBasicConfigTable_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );

	netsnmp_inject_handler(reg,netsnmp_get_cache_handler(DOT1DTPFDBTABLE_CACHE_TIMEOUT,dot11QosWirelessBasicConfigTable_load, dot11QosWirelessBasicConfigTable_removeEntry,dot11QosWirelessBasicConfigTable_oid, dot11QosWirelessBasicConfigTable_oid_len));
    /* Initialise the contents of the table here */
}

    /* Typical data structure for a row entry */

struct dot11QosWirelessBasicConfigTable_entry  *dot11QosWirelessBasicConfigTable_head = NULL;

/* create a new row in the (unsorted) table */
struct dot11QosWirelessBasicConfigTable_entry *
dot11QosWirelessBasicConfigTable_createEntry(
				 dbus_parameter parameter,
				 long globalBcWtpID,
                 long  BcWtpID,
                 long  BcRadioLocalID,
                 long  BcQosType,
                 long BcQosID,
                 char *BcQosname,
                 long NewQoSTrafficClass,
			     long NewQoSEnabled,
			     long NewQoSBW,
			     long NewQoSResPercent,
			     long NewQoSsharedBW,
			     long NewQoSsharedBWPercent,
			     char *NewSchedAlgName,
			     long NewResPolicyEnabled,
			     char *NewResPolicyName,
			     long NewBackgroundSvcAvgSpeed,
			     long NewBackgroundSvcMaxBurst,
			     long NewBackgroundSvcPriority,
			     long NewBackgroundSvcResPriority,
			     long NewBestEffortSvcAvgSpeed,
			     long NewBestEffortSvcMaxBurst,
			     long NewBestEffortSvcPriority,
			     long NewBestEffortSvcResPriority,
			     long NewVoiceSvcAvgSpeed,
			     long NewVoiceSvcMaxBurst,
			     long NewVoiceSvcPriority,
			     long NewVoiceSvcResPriority,
			     long NewVideoSvcAvgSpeed,
			     long NewVideoSvcMaxBurst,
			     long NewVideoSvcPriority,
			     long NewVideoSvcResPriority
                ) {
    struct dot11QosWirelessBasicConfigTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct dot11QosWirelessBasicConfigTable_entry);
    if (!entry)
        return NULL;

	memcpy(&entry->parameter, &parameter, sizeof(dbus_parameter));
	entry->globalBcWtpID = globalBcWtpID;
    entry->BcWtpID = BcWtpID;
    entry->BcRadioLocalID = BcRadioLocalID;
    entry->BcQosType = BcQosType;
	entry->BcQosID = BcQosID;
	entry->BcQosname = strdup(BcQosname);
	entry->NewQoSTrafficClass = NewQoSTrafficClass;
	entry->NewQoSEnabled = NewQoSEnabled;
	entry->NewQoSBW = NewQoSBW;
	entry->NewQoSResPercent = NewQoSResPercent;
	entry->NewQoSsharedBW = NewQoSsharedBW;
	entry->NewQoSsharedBWPercent = NewQoSsharedBWPercent;
	entry->NewSchedAlgName = strdup(NewSchedAlgName);
	entry->NewResPolicyEnabled = NewResPolicyEnabled;
	entry->NewResPolicyName = strdup(NewResPolicyName);
	entry->NewBackgroundSvcAvgSpeed = NewBackgroundSvcAvgSpeed;
	entry->NewBackgroundSvcMaxBurst = NewBackgroundSvcMaxBurst;
	entry->NewBackgroundSvcPriority = NewBackgroundSvcPriority;
	entry->NewBestEffortSvcAvgSpeed = NewBestEffortSvcAvgSpeed;
	entry->NewBestEffortSvcMaxBurst = NewBestEffortSvcMaxBurst;
	entry->NewBestEffortSvcPriority = NewBestEffortSvcPriority;
	entry->NewVoiceSvcAvgSpeed = NewVoiceSvcAvgSpeed;
	entry->NewVoiceSvcMaxBurst = NewVoiceSvcMaxBurst;
	entry->NewVoiceSvcPriority = NewVoiceSvcPriority;
	entry->NewVoiceSvcResPriority = NewVoiceSvcResPriority;
	entry->NewVideoSvcAvgSpeed = NewVideoSvcAvgSpeed;
	entry->NewVideoSvcMaxBurst = NewVideoSvcMaxBurst;
	entry->NewVideoSvcPriority = NewVideoSvcPriority;
	entry->NewVideoSvcResPriority = NewVideoSvcResPriority;
    entry->next = dot11QosWirelessBasicConfigTable_head;
    dot11QosWirelessBasicConfigTable_head = entry;
    return entry;
}

/* remove a row from the table */
void
dot11QosWirelessBasicConfigTable_removeEntry( struct dot11QosWirelessBasicConfigTable_entry *entry ) {
    struct dot11QosWirelessBasicConfigTable_entry *ptr, *prev;

    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = dot11QosWirelessBasicConfigTable_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        dot11QosWirelessBasicConfigTable_head = ptr->next;
    else
        prev->next = ptr->next;

	if(NULL != entry->BcQosname)
	{
		free(entry->BcQosname);
	}
	if(NULL != entry->NewResPolicyName)
	{
		free(entry->NewResPolicyName);
	}
	if(NULL != entry->NewSchedAlgName)
	{
		free(entry->NewSchedAlgName);
	}
    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}

void dot11QosWirelessBasicConfigTable_load()
{
	
	snmp_log(LOG_DEBUG, "enter dot11QosWirelessBasicConfigTable_load\n");
	
	struct dot11QosWirelessBasicConfigTable_entry *temp; 
	while( dot11QosWirelessBasicConfigTable_head ){
		temp=dot11QosWirelessBasicConfigTable_head->next;
		dot11QosWirelessBasicConfigTable_removeEntry(dot11QosWirelessBasicConfigTable_head);
		dot11QosWirelessBasicConfigTable_head=temp;
	}
	
    snmpd_dbus_message *messageHead = NULL, *messageNode = NULL;
    
    snmp_log(LOG_DEBUG, "enter list_connection_call_dbus_method:show_wtp_list_by_mac_cmd_func\n");
    messageHead = list_connection_call_dbus_method(show_wtp_list_by_mac_cmd_func, SHOW_ALL_WTP_TABLE_METHOD);
	snmp_log(LOG_DEBUG, "exit list_connection_call_dbus_method:show_wtp_list_by_mac_cmd_func,messageHead=%p\n", messageHead);

	
	if(messageHead)
	{
		for(messageNode = messageHead; NULL != messageNode; messageNode = messageNode->next)
		{
		    DCLI_WTP_API_GROUP_ONE *head = messageNode->message;  
	        if((head)&&(head->WTP_INFO))
    		{
    		    void *connection = NULL;
                if(SNMPD_DBUS_ERROR == get_slot_dbus_connection(messageNode->parameter.slot_id, &connection, SNMPD_INSTANCE_MASTER_V3))
                    continue;
                    
    		    int i=0;
    		    WID_WTP *q = NULL;
				int j=0,k=0;
				int ret1 = 0;
				int ret2 = 0;
				char type[20] = { 0 };
				memset(type,0,20);
				DCLI_WQOS *WQOS = NULL;
				char wtpID[10] = { 0 };
				char radioID[10] = { 0 };
				int QodId = 0;
				char qos_id[10] = { 0 };
				memset(qos_id,0,10);
				char QosName[20] = { 0 };
				DCLI_WQOS *wqos = NULL;
				int NewQoSBW = 0;
				int NewQoSResPercent = 0;
				int NewQoSsharedBW = 0;
				int NewQoSsharedBWPercent = 0;
				char NewSchedAlgName[20] = { 0 };
				int NewResPolicyEnabled = 0;
				char NewResPolicyName[20]= { 0 };
				int NewBackgroundSvcAvgSpeed = 0;
				int NewBackgroundSvcMaxBurst = 0;
				int NewBackgroundSvcPriority = 0;
				int NewBackgroundSvcResPriority = 0;
				int NewBestEffortSvcAvgSpeed = 0;
				int NewBestEffortSvcMaxBurst = 0;
				int NewBestEffortSvcPriority = 0;
				int NewBestEffortSvcResPriority = 0;
				int NewVoiceSvcAvgSpeed = 0;
				int NewVoiceSvcMaxBurst = 0;
				int NewVoiceSvcPriority = 0;
				int NewVoiceSvcResPriority = 0;
				int NewVideoSvcAvgSpeed = 0;
				int NewVideoSvcMaxBurst = 0;
				int NewVideoSvcPriority = 0;
				int NewVideoSvcResPriority = 0;
    		    for(i = 0,q = head->WTP_INFO->WTP_LIST; (i < head->WTP_INFO->list_len)&&(NULL != q); i++,q=q->next)
        		{	
                    unsigned long globalBcWtpID = local_to_global_ID(messageNode->parameter, 
                                                                     q->WTPID, 
                                                                     WIRELESS_MAX_NUM);
                                                                     
        			for(j=0;j<q->RadioCount;j++)
        			{   
        			    for(k=1;k<5;k++)
        				{   	
							memset(type,0,20);
        					if(k == 1) 
							{
								strncpy(type,"BESTEFFORT",sizeof(type)-1);
        					}
        					else if(k == 2) 
							{
				                strncpy(type,"BACKGROUND",sizeof(type)-1);
        					}
        					else if(k == 3) 
							{
				                strncpy(type,"VIDEO",sizeof(type)-1);
        					}	
        					else if(k == 4) 
							{
				                strncpy(type,"VOICE",sizeof(type)-1);
        					}				
        				   
						    memset(wtpID,0,10);		
		                    memset(radioID,0,10);							
							snprintf(wtpID,sizeof(wtpID)-1,"%d",q->WTPID);
			                snprintf(radioID,sizeof(radioID)-1,"%d",j);
							memset(QosName,0,20);
        					ret1 = wid_show_qos_radio_cmd(messageNode->parameter, connection,wtpID,radioID,type,&WQOS);
							if((ret1 == 1)&&(WQOS->qos[0]))
    						{
    							QodId = WQOS->qos[0]->QosID;
								if(WQOS->qos[0]->name)
								{
									strncpy(QosName,WQOS->qos[0]->name,sizeof(QosName)-1);
								}
    						}
							memset(NewSchedAlgName,0,20);
        					memset(qos_id,0,10);
							snprintf(qos_id,sizeof(qos_id)-1,"%d",QodId);

        					ret2=show_qos_extension_info(messageNode->parameter, connection,qos_id,&wqos);
							if((ret2 == 1)&&(wqos->qos[0]))
                            {   
                                NewQoSBW = wqos->qos[0]->qos_total_bandwidth;
                                NewQoSResPercent = wqos->qos[0]->qos_res_scale;
                                NewQoSsharedBW = wqos->qos[0]->qos_share_bandwidth;
                                NewQoSsharedBWPercent = wqos->qos[0]->qos_res_share_scale;
								strncpy(NewSchedAlgName,wqos->qos[0]->qos_manage_arithmetic,sizeof(NewSchedAlgName)-1);
                                if(wqos->qos[0]->qos_use_res_grab == 1)
                                {
                                    NewResPolicyEnabled = 1;
                                }
                                else if(wqos->qos[0]->qos_use_res_grab == 0 )
                                {
                                    NewResPolicyEnabled = 2;
                                }

							 	strncpy(NewResPolicyName,wqos->qos[0]->qos_res_grab_arithmetic,sizeof(NewResPolicyName)-1);

								if(wqos->qos[0]->radio_qos[1])
								{
									NewBackgroundSvcAvgSpeed = wqos->qos[0]->radio_qos[1]->qos_average_rate;
									NewBackgroundSvcMaxBurst = wqos->qos[0]->radio_qos[1]->qos_max_degree;
									NewBackgroundSvcPriority = wqos->qos[0]->radio_qos[1]->qos_policy_pri;
									NewBackgroundSvcResPriority = wqos->qos[0]->radio_qos[1]->qos_res_grab_pri;
								}
								if(wqos->qos[0]->radio_qos[0])
								{
									NewBestEffortSvcAvgSpeed = wqos->qos[0]->radio_qos[0]->qos_average_rate;
									NewBestEffortSvcMaxBurst = wqos->qos[0]->radio_qos[0]->qos_max_degree;
									NewBestEffortSvcPriority = wqos->qos[0]->radio_qos[0]->qos_policy_pri;
									NewBestEffortSvcResPriority = wqos->qos[0]->radio_qos[0]->qos_res_grab_pri;
								}
								if(wqos->qos[0]->radio_qos[3])
								{
									NewVoiceSvcAvgSpeed = wqos->qos[0]->radio_qos[3]->qos_average_rate;
									NewVoiceSvcMaxBurst = wqos->qos[0]->radio_qos[3]->qos_max_degree;
									NewVoiceSvcPriority = wqos->qos[0]->radio_qos[3]->qos_policy_pri;
									NewVoiceSvcResPriority = wqos->qos[0]->radio_qos[3]->qos_res_grab_pri;
								}
								if(wqos->qos[0]->radio_qos[2])
								{
									NewVideoSvcAvgSpeed = wqos->qos[0]->radio_qos[2]->qos_average_rate;
									NewVideoSvcMaxBurst = wqos->qos[0]->radio_qos[2]->qos_max_degree;
									NewVideoSvcPriority = wqos->qos[0]->radio_qos[2]->qos_policy_pri;
									NewVideoSvcResPriority = wqos->qos[0]->radio_qos[2]->qos_res_grab_pri;
								}
                            }
        					   
        					dot11QosWirelessBasicConfigTable_createEntry(messageNode->parameter,
        					                                              globalBcWtpID,
                    													  q->WTPID,
                    													  j,
                    													  k,
                    													  QodId,
                    													  QosName,
                    													  0,
                    													  0,
                    													  NewQoSBW,
                    													  NewQoSResPercent,
                    													  NewQoSsharedBW,
                    													  NewQoSsharedBWPercent,
                    													  NewSchedAlgName,
                    													  NewResPolicyEnabled,
                    													  NewResPolicyName,
                    													  NewBackgroundSvcAvgSpeed,
                    													  NewBackgroundSvcMaxBurst,
                    													  NewBackgroundSvcPriority,
                    													  NewBackgroundSvcResPriority,
                    													  NewBestEffortSvcAvgSpeed,
                    													  NewBestEffortSvcMaxBurst,
                    													  NewBestEffortSvcPriority,
                    													  NewBestEffortSvcResPriority,
                    													  NewVoiceSvcAvgSpeed,
                    													  NewVoiceSvcMaxBurst,
                    													  NewVoiceSvcPriority,
                    													  NewVoiceSvcResPriority,
                    													  NewVideoSvcAvgSpeed,
                    													  NewVideoSvcMaxBurst,
                    													  NewVideoSvcPriority,
                    													  NewVideoSvcResPriority); 	
							if(ret1 == 1)
							{
								Free_qos_one(WQOS);
							}
							if(ret2 == 1)
							{
								Free_qos_extension_info(wqos);
							}				 
        				}
        			}
					FREE_OBJECT(q->WTPMAC);
        		}
    		}
    	}
    	free_dbus_message_list(&messageHead, Free_wtp_list_by_mac_head);
	}

	snmp_log(LOG_DEBUG, "exit dot11QosWirelessBasicConfigTable_load\n");
}		


/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
dot11QosWirelessBasicConfigTable_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{   
    if(dot11QosWirelessBasicConfigTable_head == NULL)
		{
			return NULL;
		}
    *my_loop_context = dot11QosWirelessBasicConfigTable_head;
    return dot11QosWirelessBasicConfigTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
dot11QosWirelessBasicConfigTable_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct dot11QosWirelessBasicConfigTable_entry *entry = (struct dot11QosWirelessBasicConfigTable_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if ( entry ) {
        snmp_set_var_value( idx, (u_char*)&entry->globalBcWtpID, sizeof(entry->globalBcWtpID) );
        idx = idx->next_variable;
        snmp_set_var_value( idx, (u_char*)&entry->BcRadioLocalID, sizeof(entry->BcRadioLocalID) );
        idx = idx->next_variable;
        snmp_set_var_value( idx, (u_char*)&entry->BcQosType, sizeof(entry->BcQosType) );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
    } else {
        return NULL;
    }
	return put_index_data; 
}


/** handles requests for the dot11QosWirelessBasicConfigTable table */
int
dot11QosWirelessBasicConfigTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct dot11QosWirelessBasicConfigTable_entry          *table_entry;

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            table_entry = (struct dot11QosWirelessBasicConfigTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
            if( !table_entry )
			{
					netsnmp_set_request_error(reqinfo,request,SNMP_NOSUCHINSTANCE);
					continue;
				}	  
            switch (table_info->colnum) {
            case COLUMN_BCWTPID:
                snmp_set_var_typed_value( request->requestvb, ASN_INTEGER,
                                          (u_char*)&table_entry->globalBcWtpID,
                                          sizeof(table_entry->globalBcWtpID));
                break;
            case COLUMN_BCRADIOLOCALID:
                snmp_set_var_typed_value( request->requestvb, ASN_INTEGER,
                                          (u_char*)&table_entry->BcRadioLocalID,
                                          sizeof(table_entry->BcRadioLocalID));
                break;
            case COLUMN_BCQOSTYPE:
                snmp_set_var_typed_value( request->requestvb, ASN_INTEGER,
                                          (u_char*)&table_entry->BcQosType,
                                          sizeof(table_entry->BcQosType));
                break;
            case COLUMN_NEWQOSTRAFFICCLASS:
                snmp_set_var_typed_value( request->requestvb, ASN_INTEGER,
                                          (u_char*)&table_entry->NewQoSTrafficClass,
                                          sizeof(table_entry->NewQoSTrafficClass));
			
                break;
            case COLUMN_NEWQOSENABLED:
                snmp_set_var_typed_value( request->requestvb, ASN_INTEGER,
                                          (u_char*)&table_entry->NewQoSEnabled,
                                          sizeof(table_entry->NewQoSEnabled));
                break;
            case COLUMN_NEWQOSBW:
			{   
                snmp_set_var_typed_value( request->requestvb, ASN_INTEGER,
                                          (u_char*)&table_entry->NewQoSBW,
                                          sizeof(table_entry->NewQoSBW));
            }
                break;
            case COLUMN_NEWQOSRESPERCENT:
			{   
                snmp_set_var_typed_value( request->requestvb, ASN_INTEGER,
                                          (u_char*)&table_entry->NewQoSResPercent,
                                          sizeof(table_entry->NewQoSResPercent));
            }
                break;
            case COLUMN_NEWQOSSHAREDBW:
			{   
                snmp_set_var_typed_value( request->requestvb, ASN_INTEGER,
                                          (u_char*)&table_entry->NewQoSsharedBW,
                                          sizeof(table_entry->NewQoSsharedBW));
            }
                break;
            case COLUMN_NEWQOSSHAREDBWPERCENT:
			{   
                snmp_set_var_typed_value( request->requestvb, ASN_INTEGER,
                                          (u_char*)&table_entry->NewQoSsharedBWPercent,
                                          sizeof(table_entry->NewQoSsharedBWPercent));
            }
                break;
            case COLUMN_NEWSCHEDALGNAME:
			{   
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          (u_char*)table_entry->NewSchedAlgName,
                                          strlen(table_entry->NewSchedAlgName));
            }
                break;
            case COLUMN_NEWRESPOLICYENABLED:
			{   
                snmp_set_var_typed_value( request->requestvb, ASN_INTEGER,
                                          (u_char*)&table_entry->NewResPolicyEnabled,
                                          sizeof(table_entry->NewResPolicyEnabled));
            }
                break;
            case COLUMN_NEWRESPOLICYNAME:
			{   
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          (u_char*)table_entry->NewResPolicyName,
                                          strlen(table_entry->NewResPolicyName));
            }
                break;
            case COLUMN_NEWBACKGROUNDSVCAVGSPEED:
			{   
                snmp_set_var_typed_value( request->requestvb, ASN_INTEGER,
                                          (u_char*)&table_entry->NewBackgroundSvcAvgSpeed,
                                          sizeof(table_entry->NewBackgroundSvcAvgSpeed));
            }
                break;
            case COLUMN_NEWBACKGROUNDSVCMAXBURST:
			{   
                snmp_set_var_typed_value( request->requestvb, ASN_INTEGER,
                                          (u_char*)&table_entry->NewBackgroundSvcMaxBurst,
                                          sizeof(table_entry->NewBackgroundSvcMaxBurst));
            }
                break;
            case COLUMN_NEWBACKGROUNDSVCPRIORITY:
			{   
                snmp_set_var_typed_value( request->requestvb, ASN_INTEGER,
                                          (u_char*)&table_entry->NewBackgroundSvcPriority,
                                          sizeof(table_entry->NewBackgroundSvcPriority));
            }
                break;
            case COLUMN_NEWBACKGROUNDSVCRESPRIORITY:
			{   
                snmp_set_var_typed_value( request->requestvb, ASN_INTEGER,
                                          (u_char*)&table_entry->NewBackgroundSvcResPriority,
                                          sizeof(table_entry->NewBackgroundSvcResPriority));
            }
                break;
            case COLUMN_NEWBESTEFFORTSVCAVGSPEED:
			{   
                snmp_set_var_typed_value( request->requestvb, ASN_INTEGER,
                                          (u_char*)&table_entry->NewBestEffortSvcAvgSpeed,
                                          sizeof(table_entry->NewBestEffortSvcAvgSpeed));
            }
                break;
            case COLUMN_NEWBESTEFFORTSVCMAXBURST:
			{   
                snmp_set_var_typed_value( request->requestvb, ASN_INTEGER,
                                          (u_char*)&table_entry->NewBestEffortSvcMaxBurst,
                                          sizeof(table_entry->NewBestEffortSvcMaxBurst));
            }
                break;
            case COLUMN_NEWBESTEFFORTSVCPRIORITY:
			{   
                snmp_set_var_typed_value( request->requestvb, ASN_INTEGER,
                                          (u_char*)&table_entry->NewBestEffortSvcPriority,
                                          sizeof(table_entry->NewBestEffortSvcPriority));
            }
                break;
            case COLUMN_NEWBESTEFFORTSVCRESPRIORITY:
			{   
                snmp_set_var_typed_value( request->requestvb, ASN_INTEGER,
                                          (u_char*)&table_entry->NewBestEffortSvcResPriority,
                                          sizeof(table_entry->NewBestEffortSvcResPriority));
            }
                break;
            case COLUMN_NEWVOICESVCAVGSPEED:
			{   
                snmp_set_var_typed_value( request->requestvb, ASN_INTEGER,
                                          (u_char*)&table_entry->NewVoiceSvcAvgSpeed,
                                          sizeof(table_entry->NewVoiceSvcAvgSpeed));
            }
                break;
            case COLUMN_NEWVOICESVCMAXBURST:
			{   
                snmp_set_var_typed_value( request->requestvb, ASN_INTEGER,
                                          (u_char*)&table_entry->NewVoiceSvcMaxBurst,
                                          sizeof(table_entry->NewVoiceSvcMaxBurst));
            }
                break;
            case COLUMN_NEWVOICESVCPRIORITY:
			{   
                snmp_set_var_typed_value( request->requestvb, ASN_INTEGER,
                                          (u_char*)&table_entry->NewVoiceSvcPriority,
                                          sizeof(table_entry->NewVoiceSvcPriority));
            }
                break;
            case COLUMN_NEWVOICESVCRESPRIORITY:
			{   				
                snmp_set_var_typed_value( request->requestvb, ASN_INTEGER,
                                          (u_char*)&table_entry->NewVoiceSvcResPriority,
                                          sizeof(table_entry->NewVoiceSvcResPriority));
            }
                break;
            case COLUMN_NEWVIDEOSVCAVGSPEED:
			{   
                snmp_set_var_typed_value( request->requestvb, ASN_INTEGER,
                                          (u_char*)&table_entry->NewVideoSvcAvgSpeed,
                                          sizeof(table_entry->NewVideoSvcAvgSpeed));
            }
                break;
            case COLUMN_NEWVIDEOSVCMAXBURST:
			{   
                snmp_set_var_typed_value( request->requestvb, ASN_INTEGER,
                                          (u_char*)&table_entry->NewVideoSvcMaxBurst,
                                          sizeof(table_entry->NewVideoSvcMaxBurst));
            }
                break;
            case COLUMN_NEWVIDEOSVCPRIORITY:
			{   
                snmp_set_var_typed_value( request->requestvb, ASN_INTEGER,
                                          (u_char*)&table_entry->NewVideoSvcPriority,
                                          sizeof(table_entry->NewVideoSvcPriority));
            }
                break;
            case COLUMN_NEWVIDEOSVCRESPRIORITY:
			{   
                snmp_set_var_typed_value( request->requestvb, ASN_INTEGER,
                                          (u_char*)&table_entry->NewVideoSvcResPriority,
                                          sizeof(table_entry->NewVideoSvcResPriority));
            }
            break;
            }
        }
        break;

        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
        for (request=requests; request; request=request->next) {
            table_entry = (struct dot11QosWirelessBasicConfigTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_NEWQOSTRAFFICCLASS:
                if ( request->requestvb->type != ASN_INTEGER ) {
                    netsnmp_set_request_error( reqinfo, request,
                                               SNMP_ERR_WRONGTYPE );
                    return SNMP_ERR_NOERROR;
                }
                /* Also may need to check size/value */
                break;
            case COLUMN_NEWQOSENABLED:
                if ( request->requestvb->type != ASN_INTEGER ) {
                    netsnmp_set_request_error( reqinfo, request,
                                               SNMP_ERR_WRONGTYPE );
                    return SNMP_ERR_NOERROR;
                }
                /* Also may need to check size/value */
                break;
            case COLUMN_NEWQOSBW:
                if ( request->requestvb->type != ASN_INTEGER ) {
                    netsnmp_set_request_error( reqinfo, request,
                                               SNMP_ERR_WRONGTYPE );
                    return SNMP_ERR_NOERROR;
                }
                /* Also may need to check size/value */
                break;
            case COLUMN_NEWQOSRESPERCENT:
                if ( request->requestvb->type != ASN_INTEGER ) {
                    netsnmp_set_request_error( reqinfo, request,
                                               SNMP_ERR_WRONGTYPE );
                    return SNMP_ERR_NOERROR;
                }
                /* Also may need to check size/value */
                break;
            case COLUMN_NEWQOSSHAREDBW:
                if ( request->requestvb->type != ASN_INTEGER ) {
                    netsnmp_set_request_error( reqinfo, request,
                                               SNMP_ERR_WRONGTYPE );
                    return SNMP_ERR_NOERROR;
                }
                /* Also may need to check size/value */
                break;
            case COLUMN_NEWQOSSHAREDBWPERCENT:
                if ( request->requestvb->type != ASN_INTEGER ) {
                    netsnmp_set_request_error( reqinfo, request,
                                               SNMP_ERR_WRONGTYPE );
                    return SNMP_ERR_NOERROR;
                }
                /* Also may need to check size/value */
                break;
            case COLUMN_NEWSCHEDALGNAME:
                if ( request->requestvb->type != ASN_OCTET_STR ) {
                    netsnmp_set_request_error( reqinfo, request,
                                               SNMP_ERR_WRONGTYPE );
                    return SNMP_ERR_NOERROR;
                }
                /* Also may need to check size/value */
                break;
            case COLUMN_NEWRESPOLICYENABLED:
                if ( request->requestvb->type != ASN_INTEGER ) {
                    netsnmp_set_request_error( reqinfo, request,
                                               SNMP_ERR_WRONGTYPE );
                    return SNMP_ERR_NOERROR;
                }
                /* Also may need to check size/value */
                break;
            case COLUMN_NEWRESPOLICYNAME:
                if ( request->requestvb->type != ASN_OCTET_STR ) {
                    netsnmp_set_request_error( reqinfo, request,
                                               SNMP_ERR_WRONGTYPE );
                    return SNMP_ERR_NOERROR;
                }
                /* Also may need to check size/value */
                break;
            case COLUMN_NEWBACKGROUNDSVCAVGSPEED:
                if ( request->requestvb->type != ASN_INTEGER ) {
                    netsnmp_set_request_error( reqinfo, request,
                                               SNMP_ERR_WRONGTYPE );
                    return SNMP_ERR_NOERROR;
                }
                /* Also may need to check size/value */
                break;
            case COLUMN_NEWBACKGROUNDSVCMAXBURST:
                if ( request->requestvb->type != ASN_INTEGER ) {
                    netsnmp_set_request_error( reqinfo, request,
                                               SNMP_ERR_WRONGTYPE );
                    return SNMP_ERR_NOERROR;
                }
                /* Also may need to check size/value */
                break;
            case COLUMN_NEWBACKGROUNDSVCPRIORITY:
                if ( request->requestvb->type != ASN_INTEGER ) {
                    netsnmp_set_request_error( reqinfo, request,
                                               SNMP_ERR_WRONGTYPE );
                    return SNMP_ERR_NOERROR;
                }
                /* Also may need to check size/value */
                break;
            case COLUMN_NEWBACKGROUNDSVCRESPRIORITY:
                if ( request->requestvb->type != ASN_INTEGER ) {
                    netsnmp_set_request_error( reqinfo, request,
                                               SNMP_ERR_WRONGTYPE );
                    return SNMP_ERR_NOERROR;
                }
                /* Also may need to check size/value */
                break;
            case COLUMN_NEWBESTEFFORTSVCAVGSPEED:
                if ( request->requestvb->type != ASN_INTEGER ) {
                    netsnmp_set_request_error( reqinfo, request,
                                               SNMP_ERR_WRONGTYPE );
                    return SNMP_ERR_NOERROR;
                }
                /* Also may need to check size/value */
                break;
            case COLUMN_NEWBESTEFFORTSVCMAXBURST:
                if ( request->requestvb->type != ASN_INTEGER ) {
                    netsnmp_set_request_error( reqinfo, request,
                                               SNMP_ERR_WRONGTYPE );
                    return SNMP_ERR_NOERROR;
                }
                /* Also may need to check size/value */
                break;
            case COLUMN_NEWBESTEFFORTSVCPRIORITY:
                if ( request->requestvb->type != ASN_INTEGER ) {
                    netsnmp_set_request_error( reqinfo, request,
                                               SNMP_ERR_WRONGTYPE );
                    return SNMP_ERR_NOERROR;
                }
                /* Also may need to check size/value */
                break;
            case COLUMN_NEWBESTEFFORTSVCRESPRIORITY:
                if ( request->requestvb->type != ASN_INTEGER ) {
                    netsnmp_set_request_error( reqinfo, request,
                                               SNMP_ERR_WRONGTYPE );
                    return SNMP_ERR_NOERROR;
                }
                /* Also may need to check size/value */
                break;
            case COLUMN_NEWVOICESVCAVGSPEED:
                if ( request->requestvb->type != ASN_INTEGER ) {
                    netsnmp_set_request_error( reqinfo, request,
                                               SNMP_ERR_WRONGTYPE );
                    return SNMP_ERR_NOERROR;
                }
                /* Also may need to check size/value */
                break;
            case COLUMN_NEWVOICESVCMAXBURST:
                if ( request->requestvb->type != ASN_INTEGER ) {
                    netsnmp_set_request_error( reqinfo, request,
                                               SNMP_ERR_WRONGTYPE );
                    return SNMP_ERR_NOERROR;
                }
                /* Also may need to check size/value */
                break;
            case COLUMN_NEWVOICESVCPRIORITY:
                if ( request->requestvb->type != ASN_INTEGER ) {
                    netsnmp_set_request_error( reqinfo, request,
                                               SNMP_ERR_WRONGTYPE );
                    return SNMP_ERR_NOERROR;
                }
                /* Also may need to check size/value */
                break;
            case COLUMN_NEWVOICESVCRESPRIORITY:
                if ( request->requestvb->type != ASN_INTEGER ) {
                    netsnmp_set_request_error( reqinfo, request,
                                               SNMP_ERR_WRONGTYPE );
                    return SNMP_ERR_NOERROR;
                }
                /* Also may need to check size/value */
                break;
            case COLUMN_NEWVIDEOSVCAVGSPEED:
                if ( request->requestvb->type != ASN_INTEGER ) {
                    netsnmp_set_request_error( reqinfo, request,
                                               SNMP_ERR_WRONGTYPE );
                    return SNMP_ERR_NOERROR;
                }
                /* Also may need to check size/value */
                break;
            case COLUMN_NEWVIDEOSVCMAXBURST:
                if ( request->requestvb->type != ASN_INTEGER ) {
                    netsnmp_set_request_error( reqinfo, request,
                                               SNMP_ERR_WRONGTYPE );
                    return SNMP_ERR_NOERROR;
                }
                /* Also may need to check size/value */
                break;
            case COLUMN_NEWVIDEOSVCPRIORITY:
                if ( request->requestvb->type != ASN_INTEGER ) {
                    netsnmp_set_request_error( reqinfo, request,
                                               SNMP_ERR_WRONGTYPE );
                    return SNMP_ERR_NOERROR;
                }
                /* Also may need to check size/value */
                break;
            case COLUMN_NEWVIDEOSVCRESPRIORITY:
                if ( request->requestvb->type != ASN_INTEGER ) {
                    netsnmp_set_request_error( reqinfo, request,
                                               SNMP_ERR_WRONGTYPE );
                    return SNMP_ERR_NOERROR;
                }
                /* Also may need to check size/value */
                break;
            default:
                netsnmp_set_request_error( reqinfo, request,
                                           SNMP_ERR_NOTWRITABLE );
                return SNMP_ERR_NOERROR;
            }
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        for (request=requests; request; request=request->next) {
            table_entry = (struct dot11QosWirelessBasicConfigTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_NEWQOSTRAFFICCLASS:
                /* Need to save old 'table_entry->NewQoSTrafficClass' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWQOSENABLED:
                /* Need to save old 'table_entry->NewQoSEnabled' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWQOSBW:
                /* Need to save old 'table_entry->NewQoSBW' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWQOSRESPERCENT:
                /* Need to save old 'table_entry->NewQoSResPercent' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWQOSSHAREDBW:
                /* Need to save old 'table_entry->NewQoSsharedBW' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWQOSSHAREDBWPERCENT:
                /* Need to save old 'table_entry->NewQoSsharedBWPercent' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWSCHEDALGNAME:
                /* Need to save old 'table_entry->NewSchedAlgName' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWRESPOLICYENABLED:
                /* Need to save old 'table_entry->NewResPolicyEnabled' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWRESPOLICYNAME:
                /* Need to save old 'table_entry->NewResPolicyName' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWBACKGROUNDSVCAVGSPEED:
                /* Need to save old 'table_entry->NewBackgroundSvcAvgSpeed' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWBACKGROUNDSVCMAXBURST:
                /* Need to save old 'table_entry->NewBackgroundSvcMaxBurst' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWBACKGROUNDSVCPRIORITY:
                /* Need to save old 'table_entry->NewBackgroundSvcPriority' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWBACKGROUNDSVCRESPRIORITY:
                /* Need to save old 'table_entry->NewBackgroundSvcResPriority' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWBESTEFFORTSVCAVGSPEED:
                /* Need to save old 'table_entry->NewBestEffortSvcAvgSpeed' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWBESTEFFORTSVCMAXBURST:
                /* Need to save old 'table_entry->NewBestEffortSvcMaxBurst' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWBESTEFFORTSVCPRIORITY:
                /* Need to save old 'table_entry->NewBestEffortSvcPriority' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWBESTEFFORTSVCRESPRIORITY:
                /* Need to save old 'table_entry->NewBestEffortSvcResPriority' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWVOICESVCAVGSPEED:
                /* Need to save old 'table_entry->NewVoiceSvcAvgSpeed' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWVOICESVCMAXBURST:
                /* Need to save old 'table_entry->NewVoiceSvcMaxBurst' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWVOICESVCPRIORITY:
                /* Need to save old 'table_entry->NewVoiceSvcPriority' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWVOICESVCRESPRIORITY:
                /* Need to save old 'table_entry->NewVoiceSvcResPriority' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWVIDEOSVCAVGSPEED:
                /* Need to save old 'table_entry->NewVideoSvcAvgSpeed' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWVIDEOSVCMAXBURST:
                /* Need to save old 'table_entry->NewVideoSvcMaxBurst' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWVIDEOSVCPRIORITY:
                /* Need to save old 'table_entry->NewVideoSvcPriority' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWVIDEOSVCRESPRIORITY:
                /* Need to save old 'table_entry->NewVideoSvcResPriority' value.
                   May need to use 'memcpy' */
                break;
            }
        }
        break;

    case MODE_SET_UNDO:
        for (request=requests; request; request=request->next) {
            table_entry = (struct dot11QosWirelessBasicConfigTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_NEWQOSTRAFFICCLASS:
                /* Need to restore old 'table_entry->NewQoSTrafficClass' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWQOSENABLED:
                /* Need to restore old 'table_entry->NewQoSEnabled' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWQOSBW:
                /* Need to restore old 'table_entry->NewQoSBW' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWQOSRESPERCENT:
                /* Need to restore old 'table_entry->NewQoSResPercent' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWQOSSHAREDBW:
                /* Need to restore old 'table_entry->NewQoSsharedBW' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWQOSSHAREDBWPERCENT:
                /* Need to restore old 'table_entry->NewQoSsharedBWPercent' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWSCHEDALGNAME:
                /* Need to restore old 'table_entry->NewSchedAlgName' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWRESPOLICYENABLED:
                /* Need to restore old 'table_entry->NewResPolicyEnabled' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWRESPOLICYNAME:
                /* Need to restore old 'table_entry->NewResPolicyName' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWBACKGROUNDSVCAVGSPEED:
                /* Need to restore old 'table_entry->NewBackgroundSvcAvgSpeed' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWBACKGROUNDSVCMAXBURST:
                /* Need to restore old 'table_entry->NewBackgroundSvcMaxBurst' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWBACKGROUNDSVCPRIORITY:
                /* Need to restore old 'table_entry->NewBackgroundSvcPriority' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWBACKGROUNDSVCRESPRIORITY:
                /* Need to restore old 'table_entry->NewBackgroundSvcResPriority' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWBESTEFFORTSVCAVGSPEED:
                /* Need to restore old 'table_entry->NewBestEffortSvcAvgSpeed' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWBESTEFFORTSVCMAXBURST:
                /* Need to restore old 'table_entry->NewBestEffortSvcMaxBurst' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWBESTEFFORTSVCPRIORITY:
                /* Need to restore old 'table_entry->NewBestEffortSvcPriority' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWBESTEFFORTSVCRESPRIORITY:
                /* Need to restore old 'table_entry->NewBestEffortSvcResPriority' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWVOICESVCAVGSPEED:
                /* Need to restore old 'table_entry->NewVoiceSvcAvgSpeed' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWVOICESVCMAXBURST:
                /* Need to restore old 'table_entry->NewVoiceSvcMaxBurst' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWVOICESVCPRIORITY:
                /* Need to restore old 'table_entry->NewVoiceSvcPriority' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWVOICESVCRESPRIORITY:
                /* Need to restore old 'table_entry->NewVoiceSvcResPriority' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWVIDEOSVCAVGSPEED:
                /* Need to restore old 'table_entry->NewVideoSvcAvgSpeed' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWVIDEOSVCMAXBURST:
                /* Need to restore old 'table_entry->NewVideoSvcMaxBurst' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWVIDEOSVCPRIORITY:
                /* Need to restore old 'table_entry->NewVideoSvcPriority' value.
                   May need to use 'memcpy' */
                break;
            case COLUMN_NEWVIDEOSVCRESPRIORITY:
                /* Need to restore old 'table_entry->NewVideoSvcResPriority' value.
                   May need to use 'memcpy' */
                break;
            }
        }
        break;

    case MODE_SET_COMMIT:
        break;
    }
    return SNMP_ERR_NOERROR;
}
